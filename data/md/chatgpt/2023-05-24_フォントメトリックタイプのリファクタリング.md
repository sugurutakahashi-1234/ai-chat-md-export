# フォントメトリックタイプのリファクタリング

Date: 2023-05-24

---

## 👤 User
*2023-05-24 12:54:47*

リファクタリングしてほしい

```swift
public enum LineHeightType {
    case fixed(CGFloat)
    case fontSizeMultiple(CGFloat)

    func value(for fontSize: CGFloat) -> CGFloat {
        switch self {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return fontSize * multiple
        }
    }
}

public enum KerningType {
    case fixed(CGFloat)
    case fontSizeMultiple(CGFloat)

    func value(for fontSize: CGFloat) -> CGFloat {
        switch self {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return fontSize * multiple
        }
    }
}
```

---

## 🤖 Assistant
*2023-05-24 12:55:20*

あなたが共有したSwiftコードについて考えると、LineHeightTypeとKerningTypeは非常に似ています。これらの型は同じプロパティとメソッドを持っているため、プロトコルを用いて一般化することができます。

以下に、プロトコルを使用してこのコードをリファクタリングする方法を示します。

```swift
public protocol FontMetricType {
    var value: CGFloat { get }
    func value(for fontSize: CGFloat) -> CGFloat
}

extension FontMetricType {
    public func value(for fontSize: CGFloat) -> CGFloat {
        switch self {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return fontSize * multiple
        }
    }
}

public enum LineHeightType: FontMetricType {
    case fixed(CGFloat)
    case fontSizeMultiple(CGFloat)
    
    public var value: CGFloat {
        switch self {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return multiple
        }
    }
}

public enum KerningType: FontMetricType {
    case fixed(CGFloat)
    case fontSizeMultiple(CGFloat)
    
    public var value: CGFloat {
        switch self {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return multiple
        }
    }
}
```

このリファクタリングにより、FontMetricTypeプロトコルを満たすすべての型（この場合、LineHeightTypeとKerningType）で共有される動作が一元化されます。これにより、将来的に同様の振る舞いを持つ新しい型を追加する際の作業が少なくなります。

---

## 👤 User
*2023-05-24 12:56:07*

むしろ、記述量が増えている気がするのだけれども、、、

---

## 🤖 Assistant
*2023-05-24 12:56:44*

すみません、あなたの気持ちは理解できます。確かに、この場合のリファクタリングはコードの行数を増やしています。しかしながら、リファクタリングの目的は常にコードの行数を減らすことではなく、コードの可読性、メンテナンス性、再利用性を向上させることです。

しかし、もしご要望があれば、適切にカプセル化した上で、より簡潔な記述にすることも可能です。

ここでは、共通の動作をカプセル化した`FontMetric`型を作成し、それを`LineHeight`型と`Kerning`型で利用します。

```swift
public struct FontMetric {
    public enum MetricType {
        case fixed(CGFloat)
        case fontSizeMultiple(CGFloat)
    }

    let metricType: MetricType

    public func value(for fontSize: CGFloat) -> CGFloat {
        switch metricType {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return fontSize * multiple
        }
    }
}

public typealias LineHeight = FontMetric
public typealias Kerning = FontMetric
```

この例では、`FontMetric`が共通の動作をカプセル化し、`LineHeight`と`Kerning`はそれを直接利用しています。この形式では、`LineHeight`と`Kerning`が全く同じ動作をすることが明示的に示されています。これにより、この2つの型に対する操作を一箇所で管理することができます。

しかし、これには譲れないトレードオフが存在します。`LineHeight`と`Kerning`は単なる型エイリアスであるため、将来的にこれらの型が異なる動作を必要とした場合、`FontMetric`の分離が必要になる可能性があります。

---

## 👤 User
*2023-05-24 12:57:33*

なるほど、ちなみに public var value: CGFloat の記述は両方とも使われていないので削除できたりしないの？

---

## 🤖 Assistant
*2023-05-24 12:58:11*

申し訳ありません、その点については誤りがありました。実際にはそのプロパティは不要で、削除することができます。`FontMetricType`プロトコルからそのプロパティを削除し、各型の定義からも削除します。修正後のコードは次のようになります。

```swift
public protocol FontMetricType {
    func value(for fontSize: CGFloat) -> CGFloat
}

extension FontMetricType {
    public func value(for fontSize: CGFloat) -> CGFloat {
        switch self {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return fontSize * multiple
        }
    }
}

public enum LineHeightType: FontMetricType {
    case fixed(CGFloat)
    case fontSizeMultiple(CGFloat)
}

public enum KerningType: FontMetricType {
    case fixed(CGFloat)
    case fontSizeMultiple(CGFloat)
}
```

なお、`FontMetricType`プロトコルは現在利用されていないため、それも削除可能です。したがって、次のようにさらにシンプルにすることもできます。

```swift
public enum LineHeightType {
    case fixed(CGFloat)
    case fontSizeMultiple(CGFloat)

    func value(for fontSize: CGFloat) -> CGFloat {
        switch self {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return fontSize * multiple
        }
    }
}

public enum KerningType {
    case fixed(CGFloat)
    case fontSizeMultiple(CGFloat)

    func value(for fontSize: CGFloat) -> CGFloat {
        switch self {
        case .fixed(let fixedValue):
            return fixedValue
        case .fontSizeMultiple(let multiple):
            return fontSize * multiple
        }
    }
}
```

ただし、この形式ではLineHeightTypeとKerningTypeの間に共通の振る舞いがあることが明示的に示されていません。これらの型が似ている理由がコードからは明らかでない場合、または将来的に他の類似の型を追加する可能性がある場合、最初のプロトコルを用いたアプローチを検討することをお勧めします。

---
