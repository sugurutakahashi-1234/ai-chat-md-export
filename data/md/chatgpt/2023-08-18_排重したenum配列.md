# 排重したenum配列

日付: 2023-08-18

---

## 👤 ユーザー
*2023/8/18 10:43:27*

Swiftで連想値を持つenumの配列をもっているとする。
この配列は同じcaseの配列を複数受け入れるようにしているが、その重複を排除した配列を取得したい場合はどうすればいいか。

---

## 🤖 アシスタント
*2023/8/18 10:44:11*

Swiftの`enum`を用いて連想値を持つ場合、その連想値に基づいてenumのインスタンスを一意にすることは、直接的な方法では難しいです。しかし、カスタムの比較ロジックを実装することで、連想値に基づいて重複を排除することができます。

以下の例を考えてみましょう：

```swift
enum ItemType: Equatable {
    case book(title: String, author: String)
    case music(title: String, artist: String)

    static func == (lhs: ItemType, rhs: ItemType) -> Bool {
        switch (lhs, rhs) {
        case let (.book(lhsTitle, lhsAuthor), .book(rhsTitle, rhsAuthor)):
            return lhsTitle == rhsTitle && lhsAuthor == rhsAuthor
        case let (.music(lhsTitle, lhsArtist), .music(rhsTitle, rhsArtist)):
            return lhsTitle == rhsTitle && lhsArtist == rhsArtist
        default:
            return false
        }
    }
}

let items: [ItemType] = [
    .book(title: "1984", author: "George Orwell"),
    .music(title: "Imagine", artist: "John Lennon"),
    .book(title: "1984", author: "George Orwell")
]

let uniqueItems = Array(Set(items))
print(uniqueItems)
```

ここで、`ItemType` enumは`Equatable`プロトコルを採用しています。これにより、連想値を基に等価性を判定できるようになります。

そして、`Set`を使用することで、配列の中から重複するアイテムを排除することができます。

ただし、注意点として、この方法で`uniqueItems`を取得した場合、元の配列の順序が保持されないことがあります。順序を保持しながら重複を排除したい場合、より複雑な方法をとる必要があります。

---

## 👤 ユーザー
*2023/8/18 10:44:19*

順番を維持したいのでSetは使って欲しくない

---

## 🤖 アシスタント
*2023/8/18 10:44:41*

順序を維持したまま重複を排除するには、手動でチェックする必要があります。

以下はそのための方法を示す例です：

```swift
enum ItemType: Equatable {
    case book(title: String, author: String)
    case music(title: String, artist: String)

    static func == (lhs: ItemType, rhs: ItemType) -> Bool {
        switch (lhs, rhs) {
        case let (.book(lhsTitle, lhsAuthor), .book(rhsTitle, rhsAuthor)):
            return lhsTitle == rhsTitle && lhsAuthor == rhsAuthor
        case let (.music(lhsTitle, lhsArtist), .music(rhsTitle, rhsArtist)):
            return lhsTitle == rhsTitle && lhsArtist == rhsArtist
        default:
            return false
        }
    }
}

let items: [ItemType] = [
    .book(title: "1984", author: "George Orwell"),
    .music(title: "Imagine", artist: "John Lennon"),
    .book(title: "1984", author: "George Orwell")
]

var uniqueItems: [ItemType] = []
for item in items {
    if !uniqueItems.contains(item) {
        uniqueItems.append(item)
    }
}

print(uniqueItems)
```

この方法で、`items`配列の中から重複を排除し、`uniqueItems`配列に順序を保持したまま保存します。

---

## 👤 ユーザー
*2023/8/18 10:44:56*

for文はあまり使いたくない

---

## 🤖 アシスタント
*2023/8/18 10:45:24*

了解しました。`reduce(into:_:)`を使って関数型のアプローチで順序を維持したまま重複を排除する方法を示します。

```swift
enum ItemType: Equatable {
    case book(title: String, author: String)
    case music(title: String, artist: String)

    static func == (lhs: ItemType, rhs: ItemType) -> Bool {
        switch (lhs, rhs) {
        case let (.book(lhsTitle, lhsAuthor), .book(rhsTitle, rhsAuthor)):
            return lhsTitle == rhsTitle && lhsAuthor == rhsAuthor
        case let (.music(lhsTitle, lhsArtist), .music(rhsTitle, rhsArtist)):
            return lhsTitle == rhsTitle && lhsArtist == rhsArtist
        default:
            return false
        }
    }
}

let items: [ItemType] = [
    .book(title: "1984", author: "George Orwell"),
    .music(title: "Imagine", artist: "John Lennon"),
    .book(title: "1984", author: "George Orwell")
]

let uniqueItems = items.reduce(into: [ItemType]()) { (result, item) in
    if !result.contains(item) {
        result.append(item)
    }
}

print(uniqueItems)
```

この方法では、`reduce(into:_:)`メソッドを使って`items`配列を一度だけトラバースします。このメソッドは、新しい配列`result`を作成し、それを更新していく形で動作します。この方法で、`for`ループを避け、より宣言的な方法で同じ結果を得ることができます。

---

## 👤 ユーザー
*2023/8/18 10:45:45*

Equatable をつけたくない場合はどうすればいいか？

---

## 🤖 アシスタント
*2023/8/18 10:46:19*

`Equatable` プロトコルを採用しない場合でも、カスタムの比較ロジックを使って重複を排除できます。具体的には、高階関数を活用して配列の要素をチェックし、重複しないものだけを新しい配列に追加する方法が考えられます。

以下にその一例を示します：

```swift
enum ItemType {
    case book(title: String, author: String)
    case music(title: String, artist: String)

    func isEqual(to other: ItemType) -> Bool {
        switch (self, other) {
        case let (.book(title1, author1), .book(title2, author2)):
            return title1 == title2 && author1 == author2
        case let (.music(title1, artist1), .music(title2, artist2)):
            return title1 == title2 && artist1 == artist2
        default:
            return false
        }
    }
}

let items: [ItemType] = [
    .book(title: "1984", author: "George Orwell"),
    .music(title: "Imagine", artist: "John Lennon"),
    .book(title: "1984", author: "George Orwell")
]

let uniqueItems = items.reduce(into: [ItemType]()) { (result, item) in
    if !result.contains(where: { $0.isEqual(to: item) }) {
        result.append(item)
    }
}

print(uniqueItems)
```

ここで`isEqual(to:)`というカスタムメソッドを`ItemType`に追加しました。このメソッドは`Equatable`の代わりに、enumの連想値の比較を行います。

そして、`reduce(into:_:)`メソッドの中で`contains(where:)`を使い、既存のアイテムが重複しているかどうかを確認します。もし重複していなければ、新しいアイテムを結果の配列に追加します。

---

## 👤 ユーザー
*2023/8/18 10:47:59*

以下でcaseが同じならtrueを返す関数を書いて欲しい

public enum MeasurementType {
    case video(measurement: VideoMeasurement?)
    case website(measurement: WebsiteMeasurement?)
    case questionnaire(measurement: QuestionnaireMeasurement?)
    case interview(measurement: InterviewMeasurement?)
    
    public func isEqualMeasurementType() -&gt; Bool {
        
    }
}

---

## 🤖 アシスタント
*2023/8/18 10:48:29*

`MeasurementType` enumの各ケースが他の`MeasurementType`のケースと同じであるかを確認するための関数を作成します。そのため、関数は2つの`MeasurementType`の間での比較をサポートする必要があります。また、連想値は無視し、enumのケースのみを比較します。

以下のコードは、`isEqualMeasurementType(to:)`関数を追加してその動作を実装したものです：

```swift
public enum MeasurementType {
    case video(measurement: VideoMeasurement?)
    case website(measurement: WebsiteMeasurement?)
    case questionnaire(measurement: QuestionnaireMeasurement?)
    case interview(measurement: InterviewMeasurement?)
    
    public func isEqualMeasurementType(to other: MeasurementType) -> Bool {
        switch (self, other) {
        case (.video, .video),
             (.website, .website),
             (.questionnaire, .questionnaire),
             (.interview, .interview):
            return true
        default:
            return false
        }
    }
}
```

使用方法：

```swift
let type1 = MeasurementType.video(measurement: nil)
let type2 = MeasurementType.video(measurement: VideoMeasurement())
let type3 = MeasurementType.website(measurement: nil)

print(type1.isEqualMeasurementType(to: type2))  // true
print(type1.isEqualMeasurementType(to: type3))  // false
```

この関数は、2つの`MeasurementType`が同じケースを持っているかどうかをチェックします。連想値は比較には関与しません。

---

## 👤 ユーザー
*2023/8/18 10:48:59*

これを使って、uniqueMeasurementTypesを記述してほし。

---

## 🤖 アシスタント
*2023/8/18 10:49:36*

了解しました。以下は`uniqueMeasurementTypes`を計算するコードを示します。

まず、`MeasurementType` enumで提供される`isEqualMeasurementType(to:)`関数を使用して、配列内の`MeasurementType`の項目が他の項目と同じケースを持っているかどうかをチェックします。

そして、`reduce(into:_:)`メソッドを使用して、新しい配列に重複しない`MeasurementType`の項目のみを追加します。

```swift
// 既存のMeasurementTypeの定義
public enum MeasurementType {
    case video(measurement: VideoMeasurement?)
    case website(measurement: WebsiteMeasurement?)
    case questionnaire(measurement: QuestionnaireMeasurement?)
    case interview(measurement: InterviewMeasurement?)
    
    public func isEqualMeasurementType(to other: MeasurementType) -> Bool {
        switch (self, other) {
        case (.video, .video),
             (.website, .website),
             (.questionnaire, .questionnaire),
             (.interview, .interview):
            return true
        default:
            return false
        }
    }
}

// 重複を排除するロジック
let measurementTypes: [MeasurementType] = [
    .video(measurement: nil),
    .website(measurement: nil),
    .video(measurement: nil),  // 重複している
    .questionnaire(measurement: nil)
]

let uniqueMeasurementTypes = measurementTypes.reduce(into: [MeasurementType]()) { (result, type) in
    if !result.contains(where: { $0.isEqualMeasurementType(to: type) }) {
        result.append(type)
    }
}

print(uniqueMeasurementTypes)
```

このロジックでは、`measurementTypes`配列の各項目を確認し、`result`という新しい配列に追加される前に、その項目が既に存在するかどうかを`isEqualMeasurementType(to:)`関数を使用してチェックします。この方法で、重複する`MeasurementType`の項目が`uniqueMeasurementTypes`に追加されないようになっています。

---

## 👤 ユーザー
*2023/8/18 10:50:11*

isEqualMeasurementType(to other: MeasurementType) の関数名の候補を考えてほしい。otherは一般的なのかも気になる。

---

## 🤖 アシスタント
*2023/8/18 10:50:36*

関数の名前は、関数の目的や振る舞いを明確に伝えることが重要です。`isEqualMeasurementType(to:)` は十分に明確である一方、より簡潔または異なる名前を考慮することも可能です。以下はいくつかの提案です：

1. `isSameType(as:)`
2. `matchesType(with:)`
3. `hasSameType(as:)`
4. `typeEquals(\_:)`
5. `isEqualToType(\_:)`
6. `correspondsTo(\_: )`
7. `isOfType(\_: )`

`other` を引数名として使うことは一般的ですが、関数のコンテキストに応じてもっと具体的な名前を使用することもできます。例えば、`otherType` または `comparisonType` といった名前を使うことで、引数の意味をもう少し明確にすることができます。

最終的な選択は、コードベースの他の部分やチームの命名慣習、および関数の目的や使用法に応じて行うことをおすすめします。

---

## 👤 ユーザー
*2023/8/18 10:51:49*

isSameType(as:) がいい。書き直して欲しい。

---

## 🤖 アシスタント
*2023/8/18 10:52:13*

了解しました。以下に、`isSameType(as:)` という関数名を使って`MeasurementType` enumと重複を排除するロジックを再記述します。

```swift
// 既存のMeasurementTypeの定義
public enum MeasurementType {
    case video(measurement: VideoMeasurement?)
    case website(measurement: WebsiteMeasurement?)
    case questionnaire(measurement: QuestionnaireMeasurement?)
    case interview(measurement: InterviewMeasurement?)
    
    public func isSameType(as other: MeasurementType) -> Bool {
        switch (self, other) {
        case (.video, .video),
             (.website, .website),
             (.questionnaire, .questionnaire),
             (.interview, .interview):
            return true
        default:
            return false
        }
    }
}

// 重複を排除するロジック
let measurementTypes: [MeasurementType] = [
    .video(measurement: nil),
    .website(measurement: nil),
    .video(measurement: nil),  // 重複している
    .questionnaire(measurement: nil)
]

let uniqueMeasurementTypes = measurementTypes.reduce(into: [MeasurementType]()) { (result, type) in
    if !result.contains(where: { $0.isSameType(as: type) }) {
        result.append(type)
    }
}

print(uniqueMeasurementTypes)
```

関数名を`isSameType(as:)`に変更し、重複を排除するロジックの部分もそれに合わせて更新しました。

---

## 👤 ユーザー
*2023/8/18 11:01:53*

こういうデータ構造になっていて、ResearchのextensionでuniqueMeasurementTypesを追加するようにしたんだ。

public struct Research: Identifiable {
    public let measurements: \[Measurement\]
}

public struct Measurement: Identifiable {
    public typealias ID = String
    
    public let id: Measurement.ID
    public let order: Int
    public let type: MeasurementType

    public init(id: Measurement.ID, order: Int, type: MeasurementType) {
        self.id = id
        self.order = order
        self.type = type
    }
}

---

## 🤖 アシスタント
*2023/8/18 11:02:20*

わかりました。`Research` の `extension` に `uniqueMeasurementTypes` を追加する場合のコードを以下に示します。

まず、`MeasurementType` に `isSameType(as:)` メソッドを追加します：

```swift
public enum MeasurementType {
    case video(measurement: VideoMeasurement?)
    case website(measurement: WebsiteMeasurement?)
    case questionnaire(measurement: QuestionnaireMeasurement?)
    case interview(measurement: InterviewMeasurement?)
    
    public func isSameType(as other: MeasurementType) -> Bool {
        switch (self, other) {
        case (.video, .video),
             (.website, .website),
             (.questionnaire, .questionnaire),
             (.interview, .interview):
            return true
        default:
            return false
        }
    }
}
```

そして、`Research` の `extension` で `uniqueMeasurementTypes` を計算するプロパティを追加します：

```swift
extension Research {
    public var uniqueMeasurementTypes: [MeasurementType] {
        return measurements.reduce(into: [MeasurementType]()) { (result, measurement) in
            let type = measurement.type
            if !result.contains(where: { $0.isSameType(as: type) }) {
                result.append(type)
            }
        }
    }
}
```

これで、`Research` インスタンスから直接 `uniqueMeasurementTypes` を呼び出して、その研究に関連するユニークな測定タイプの配列を取得することができます。

---

## 👤 ユーザー
*2023/8/18 11:02:51*

contains の否定系を使いたくないんだ。どうすればいい？

---

## 🤖 アシスタント
*2023/8/18 11:03:09*

`contains` の否定系を使用しない方法として、`first(where:)` や `firstIndex(where:)` などを使用して該当する要素が存在するかどうかをチェックすることができます。もし該当する要素がない場合は、`nil` が返されるので、その結果を元に条件判断を行います。

以下に、`contains` を使用しない方法で `uniqueMeasurementTypes` を計算する方法を示します：

```swift
extension Research {
    public var uniqueMeasurementTypes: [MeasurementType] {
        return measurements.reduce(into: [MeasurementType]()) { (result, measurement) in
            let type = measurement.type
            if result.first(where: { $0.isSameType(as: type) }) == nil {
                result.append(type)
            }
        }
    }
}
```

このコードでは、`first(where:)` が `nil` を返す場合（つまり、同じタイプの `MeasurementType` がまだ `result` 配列に存在しない場合）、新しいタイプを `result` 配列に追加します。

---

## 👤 ユーザー
*2023/8/18 11:06:21*

var isVideoOrWebsite : Bool と

---

## 🤖 アシスタント
*2023/8/18 11:06:49*

了解しました。`MeasurementType` enumのインスタンスが `video` または `website` の場合に `true` を返す、`isVideoOrWebsite` という計算プロパティを追加したいとのことです。

以下のように `MeasurementType` enumにこの計算プロパティを追加できます：

```swift
public enum MeasurementType {
    case video(measurement: VideoMeasurement?)
    case website(measurement: WebsiteMeasurement?)
    case questionnaire(measurement: QuestionnaireMeasurement?)
    case interview(measurement: InterviewMeasurement?)
    
    public func isSameType(as other: MeasurementType) -> Bool {
        switch (self, other) {
        case (.video, .video),
             (.website, .website),
             (.questionnaire, .questionnaire),
             (.interview, .interview):
            return true
        default:
            return false
        }
    }

    public var isVideoOrWebsite: Bool {
        switch self {
        case .video, .website:
            return true
        default:
            return false
        }
    }
}
```

この `isVideoOrWebsite` プロパティを使うと、`MeasurementType` enumのインスタンスが `video` または `website` の場合に簡単に確認できます：

```swift
let type = MeasurementType.video(measurement: nil)
print(type.isVideoOrWebsite)  // true
```

---

## 👤 ユーザー
*2023/8/18 11:07:32*

ResearchのextensionでVideoまたはWebsiteを含んでいるかどうかのBoolがほしい

---

## 🤖 アシスタント
*2023/8/18 11:07:50*

了解しました。`Research`の`extension`に`containsVideoOrWebsite`という計算プロパティを追加します。このプロパティは、`Research`内の`measurements`配列に`video`または`website`タイプの`Measurement`が含まれている場合に`true`を返します。

以下がその実装です：

```swift
extension Research {
    public var containsVideoOrWebsite: Bool {
        return measurements.contains { $0.type.isVideoOrWebsite }
    }
}
```

これで、`Research`のインスタンスから`containsVideoOrWebsite`プロパティを直接呼び出して、それが`video`または`website`タイプの`Measurement`を含むかどうかを簡単に確認できます。

---

## 👤 ユーザー
*2023/8/18 11:08:22*

isVideoOrWebsiteを使わないで記述して欲しい

---

## 🤖 アシスタント
*2023/8/18 11:08:33*

了解しました。`isVideoOrWebsite` を使用せずに `containsVideoOrWebsite` を定義する方法を以下に示します。

```swift
extension Research {
    public var containsVideoOrWebsite: Bool {
        return measurements.contains { measurement in
            switch measurement.type {
            case .video, .website:
                return true
            default:
                return false
            }
        }
    }
}
```

この方法では、`contains` メソッドを使用して、`measurements` 配列の各 `Measurement` の `type` が `video` または `website` であるかどうかを直接チェックしています。

---
