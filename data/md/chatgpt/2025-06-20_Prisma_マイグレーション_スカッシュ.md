# Prisma マイグレーション スカッシュ

日付: 2025-06-20

---

## 👤 ユーザー
*2025/6/20 14:53:24*

もう少し具体的なケースで教えて欲しい、v0.1.0やv0.2.0やv0.3.0など、継続して開発を進めているとする。

カッシュマイグレーションプリズマ 
https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#how-to-migrate-cleanly-from-a-development-environment

---

## 🤖 アシスタント
*2025/6/20 14:53:39*

以下では **“初期版 v0.1.0 → 機能追加 v0.2.0 → 次期 v0.3.0”** と段階的に開発を重ねるチームを想定し、  
本番 DB にはまだ適用していない**開発用マイグレーションを 1 つにスカッシュ**してからリリースする ― という具体例で手順を整理します。  

---

## 0. 前提のリポジトリ構成と命名

```
my-app/
├─ prisma/
│  ├─ schema.prisma          # ドメイン定義の真実のソース
│  └─ migrations/            # prisma migrate dev が生成
│     ├─ 20240610_000000_init                # v0.1.0 時点
│     ├─ 20240705_120000_add_tasks_table     # ← feature/add-tasks で dev
│     └─ 20240708_094500_add_due_date_column # ← 同上
└─ package.json
```

- **v0.1.0** : `init` だけが本番に適用済み。  
- **v0.2.0 ブランチ** : 2 個の開発用マイグレーション（`add_tasks_table`, `add_due_date_column`）が増えた。  
- **目的** : これら 2 個を **「1 ファイルの “v0.2.0.sql”」** にまとめて本番へ deploy したい。  

---

## 1. スカッシュ手順（開発ブランチ → ↓ main 統合前）

> Prisma 公式が示す **「Migrating cleanly from a development environment」** のフローをそのまま当てはめる形です。citeturn1view0

### 1-1. migrations フォルダを “本番と同じ状態” に戻す
```bash
# feature/add-tasks ブランチ内
git checkout main -- prisma/migrations
# これで ./prisma/migrations には init だけが残る
```

### 1-2. schema.prisma は **機能追加後** の最新形のまま

- tasks テーブル・dueDate カラムを **残したまま** にしておく。  

### 1-3. 1 ファイルにまとめたマイグレーションを生成
```bash
npx prisma migrate dev --name v0_2_0
# ./prisma/migrations/20240709_110000_v0_2_0/migration.sql が生成
#  この 1 本で init → 最新 (tasks+dueDate) まで上げられる
```
これで **v0.2.0 リリース用の “クリーン履歴”** が完成。  
ブランチを `main` にマージ & Git タグ **v0.2.0** を付け、本番では

```bash
npx prisma migrate deploy   # CI などで実行
```
を回すだけで OK です（中間 2 ステップは一切流れません）。citeturn1view0  

---

## 2. 次期リリース v0.3.0 でも同じサイクル

1. **feature/xxx** ブランチで `migrate dev` を繰り返しながら開発  
2. リリース直前に **再び「1-1 → 1-3」** を実施し  
   `npx prisma migrate dev --name v0_3_0` で 1 ファイル化  
3. `main` へマージしてタグ **v0.3.0**、本番では `migrate deploy`

こうすると **タグごとに “1 ファイルだけ”** が本番へ順番に適用されるため、

- DB 履歴が散らからず初期化時間も短縮  
- 中間マイグレーションで発生し得る **不要な書き込み・ロック・データ移動** を回避  
- ローカル開発では好きに `migrate dev` を叩いても最後にリセットできる

というメリットがあります。

---

## 3. より安全に回すための CI / Git 運用 Tips

| フェーズ | 推奨チェックポイント |
|---------|--------------------|
| **PR 作成時** | `prisma migrate status` で<br>「本番用テーブルに未適用が無いか」CI で検証 |
| **スカッシュ直後** | `git diff main -- prisma/migrations` が<br>「新ディレクトリ 1 件のみ」であることを確認 |
| **main マージ後** | GitHub Actions の deploy ジョブで<br>`npx prisma migrate deploy --preview-feature`<br>→ 成功したら `--skip-generate` なし deploy 本番 |

---

## 4. プロダクション側を**一度だけ**フルスカッシュしたいとき

すでに本番に何十本も履歴があり、新規環境の初期化が遅い場合は  
公式ガイド **「Creating a clean history in a production environment」** の手順で  
**`000000000000_squashed_migrations`** を作り、本番側で `migrate resolve --applied` することで  
**履歴テーブルだけをすげ替え** られます。citeturn1view0  

---

### まとめ

- **開発ブランチでは好きに `migrate dev`** → リリース前に **1 コにスカッシュ**  
- 手順は公式フロー（reset → `migrate dev --name`）をそのまま採用  
- タグ単位でマイグレーションが整理されるため、DB 管理も CI もシンプルになる  

このサイクルを固定化すると、バージョンが進むごとに「中間履歴によるメンテ負債」を残さず、  
オンボーディングや新規環境構築も高速に保てます。

---
