# iOSアプリ遷移方法

日付: 2024-10-08

---

## 👤 ユーザー
*2024/10/08 17:30:07*

iOSアプリ内で好きな箇所に遷移させる方法

---

## 🤖 アシスタント
*2024/10/08 17:30:43*

iOSアプリ内で任意の箇所に遷移させる方法はいくつかあります。SwiftUIとUIKitではアプローチが異なりますが、ここではそれぞれの方法について説明します。

### SwiftUIで任意の場所に遷移させる方法

1. **NavigationLinkを使う方法**
   - `NavigationLink`を使えば、あるViewから別のViewに遷移できます。任意の条件で遷移したい場合は、`isActive`や`tag`を使って条件に応じて自動的に遷移させることができます。

   ```swift
   struct ContentView: View {
       @State private var isLinkActive = false

       var body: some View {
           NavigationView {
               VStack {
                   Button("次の画面へ") {
                       isLinkActive = true
                   }
                   NavigationLink(destination: NextView(), isActive: $isLinkActive) {
                       EmptyView()
                   }
               }
           }
       }
   }
   ```

2. **プログラム的に遷移させる方法**
   - `NavigationStack`を使うことで、プログラムでナビゲーション履歴を管理し、任意のViewに遷移させることができます。

   ```swift
   struct ContentView: View {
       @State private var navigationPath = NavigationPath()

       var body: some View {
           NavigationStack(path: $navigationPath) {
               VStack {
                   Button("次の画面へ") {
                       navigationPath.append(NextView())
                   }
               }
               .navigationDestination(for: NextView.self) { view in
                   view
               }
           }
       }
   }
   ```

3. **プログラムでの深いリンク (Deeplink)**
   - URLを通じてアプリ内の特定の画面に遷移させるためには、DeeplinkやUniversal Linksを使います。SwiftUIでもこれに対応した処理を行うことができます。`onOpenURL`モディファイアを使ってURLハンドリングを行います。

   ```swift
   @main
   struct MyApp: App {
       var body: some Scene {
           WindowGroup {
               ContentView()
                   .onOpenURL { url in
                       // URLに基づいて適切な画面に遷移させる処理
                   }
           }
       }
   }
   ```

### UIKitでの任意の場所に遷移させる方法

1. **StoryboardsまたはXIBsでの遷移**
   - Storyboardを使っている場合、`performSegue(withIdentifier:)`で特定の画面に遷移することができます。

   ```swift
   self.performSegue(withIdentifier: "showNextScreen", sender: nil)
   ```

2. **プログラム的にViewControllerを遷移させる**
   - ViewControllerをコード上でプッシュしたりモーダル表示することで、プログラム的に任意の場所に遷移できます。

   ```swift
   let nextViewController = NextViewController()
   navigationController?.pushViewController(nextViewController, animated: true)
   ```

3. **DeeplinkやURL Schemeによる遷移**
   - DeeplinkやURL Schemeを使って、アプリがどこからでも特定のViewControllerに遷移するように設定できます。`UIApplicationDelegate`の`application(_:open:options:)`でURLを処理し、該当する画面に遷移します。

   ```swift
   func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
       if url.host == "openNextScreen" {
           let nextViewController = NextViewController()
           navigationController?.pushViewController(nextViewController, animated: true)
       }
       return true
   }
   ```

### まとめ
- **SwiftUI**では、`NavigationLink`や`NavigationStack`を使って条件付きでの遷移が可能です。特定のURLからの遷移は`onOpenURL`で実現します。
- **UIKit**では、`performSegue`や`pushViewController`で任意の箇所に遷移させることができます。また、DeeplinkやURL Schemeを使って任意の画面に直接アクセスできます。

用途に応じて最適な方法を選択してください。

---

## 👤 ユーザー
*2024/10/08 17:30:47*

内部WebViewを開いて、そこのリダイレクトURLを使って移動させたい

---

## 🤖 アシスタント
*2024/10/08 17:31:29*

内部WebViewでリダイレクトURLをキャッチし、そのURLを使って別の画面に遷移するには、`WKWebView`を使ってWebページを表示し、`WKNavigationDelegate`でリダイレクトされたURLを監視する方法が一般的です。以下にその実装例を示します。

### SwiftUIとWKWebViewの組み合わせでの実装

1. **WKWebViewの設定**
   `UIViewRepresentable`を使って、SwiftUIで`WKWebView`をラップします。

2. **WKNavigationDelegateでリダイレクトURLをキャッチ**
   `WKNavigationDelegate`を使って、リダイレクト先のURLをキャッチし、それを使って任意の画面に遷移させます。

#### コード例

```swift
import SwiftUI
import WebKit

// SwiftUIでWKWebViewを表示するためのラッパー
struct WebView: UIViewRepresentable {
    let url: URL
    @Binding var redirectURL: URL? // リダイレクト先のURLをキャッチするためのBinding

    func makeUIView(context: Context) -> WKWebView {
        let webView = WKWebView()
        webView.navigationDelegate = context.coordinator // WKNavigationDelegateの設定
        let request = URLRequest(url: url)
        webView.load(request)
        return webView
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        // 必要に応じて更新
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, WKNavigationDelegate {
        var parent: WebView

        init(_ parent: WebView) {
            self.parent = parent
        }

        func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
            if let url = navigationAction.request.url {
                // ここでリダイレクトURLを監視
                if url.absoluteString.contains("target_redirect_url") {
                    // リダイレクト先のURLをキャッチしてBindingで親Viewに伝える
                    parent.redirectURL = url
                }
            }
            decisionHandler(.allow)
        }
    }
}

// WebViewを表示し、リダイレクトURLを使って次の画面に遷移するSwiftUIのView
struct ContentView: View {
    @State private var redirectURL: URL? // リダイレクトURLをキャッチ
    @State private var shouldNavigate = false // 遷移フラグ

    var body: some View {
        NavigationView {
            VStack {
                WebView(url: URL(string: "https://example.com")!, redirectURL: $redirectURL)
                    .frame(height: 400)

                if shouldNavigate, let url = redirectURL {
                    // リダイレクトURLを使って次の画面に遷移
                    NavigationLink(destination: NextView(url: url), isActive: $shouldNavigate) {
                        EmptyView()
                    }
                }
            }
            .onChange(of: redirectURL) { newValue in
                // リダイレクトURLがキャッチされたら遷移フラグを立てる
                if newValue != nil {
                    shouldNavigate = true
                }
            }
        }
    }
}

// 遷移先のView
struct NextView: View {
    let url: URL

    var body: some View {
        Text("Redirected to: \(url.absoluteString)")
    }
}
```

### 実装のポイント

1. **`WebView`構造体**: `UIViewRepresentable`を使って`WKWebView`をSwiftUIに統合します。リダイレクト先のURLを監視するため、`@Binding var redirectURL`を定義しています。
2. **`WKNavigationDelegate`**: `Coordinator`クラス内で、`decidePolicyFor`メソッドを使って、ページのリダイレクトをキャッチしています。リダイレクト先のURLを見つけたら、`redirectURL`に設定します。
3. **`NavigationLink`による遷移**: `redirectURL`が更新されたら、それに応じて`NavigationLink`で次の画面に遷移します。

### その他のポイント

- リダイレクト先のURLのチェックロジック（例: `"target_redirect_url"`を含むかどうか）はアプリの要件に応じてカスタマイズします。
- 必要であれば、リダイレクトされたURLに基づいてさらなる処理を実行したり、他の画面に遷移したりすることができます。

この方法を使うことで、アプリ内で内部WebViewのリダイレクトURLをキャッチし、適切な遷移を実現できます。

---

## 👤 ユーザー
*2024/10/08 19:06:49*

didReceiveServerRedirectForProvisionalNavigation を使用するのはどうだろうか？

---

## 🤖 アシスタント
*2024/10/08 19:07:29*

`WKNavigationDelegate`のメソッドの一つである `webView(_:didReceiveServerRedirectForProvisionalNavigation:)` を使用するのは、サーバーリダイレクトが発生した際に呼び出されるため、リダイレクトの処理に非常に適しています。このメソッドを使うことで、サーバーからのリダイレクトを検知し、そのURLに基づいて遷移させる処理を簡単に実装できます。

### `didReceiveServerRedirectForProvisionalNavigation`の使用例

#### コード例

```swift
import SwiftUI
import WebKit

// SwiftUIでWKWebViewを表示するためのラッパー
struct WebView: UIViewRepresentable {
    let url: URL
    @Binding var redirectURL: URL? // リダイレクト先のURLをキャッチするためのBinding

    func makeUIView(context: Context) -> WKWebView {
        let webView = WKWebView()
        webView.navigationDelegate = context.coordinator // WKNavigationDelegateの設定
        let request = URLRequest(url: url)
        webView.load(request)
        return webView
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        // 必要に応じて更新
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, WKNavigationDelegate {
        var parent: WebView

        init(_ parent: WebView) {
            self.parent = parent
        }

        // サーバーリダイレクトが発生したときに呼ばれる
        func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
            // リダイレクトURLをキャッチ
            if let redirectURL = webView.url {
                parent.redirectURL = redirectURL
            }
        }

        func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
            decisionHandler(.allow)
        }
    }
}

// WebViewを表示し、リダイレクトURLを使って次の画面に遷移するSwiftUIのView
struct ContentView: View {
    @State private var redirectURL: URL? // リダイレクトURLをキャッチ
    @State private var shouldNavigate = false // 遷移フラグ

    var body: some View {
        NavigationView {
            VStack {
                WebView(url: URL(string: "https://example.com")!, redirectURL: $redirectURL)
                    .frame(height: 400)

                if shouldNavigate, let url = redirectURL {
                    // リダイレクトURLを使って次の画面に遷移
                    NavigationLink(destination: NextView(url: url), isActive: $shouldNavigate) {
                        EmptyView()
                    }
                }
            }
            .onChange(of: redirectURL) { newValue in
                // リダイレクトURLがキャッチされたら遷移フラグを立てる
                if newValue != nil {
                    shouldNavigate = true
                }
            }
        }
    }
}

// 遷移先のView
struct NextView: View {
    let url: URL

    var body: some View {
        Text("Redirected to: \(url.absoluteString)")
    }
}
```

### 実装の流れ

1. **`WKWebView`の設定**:
   `UIViewRepresentable`を使って`WKWebView`をSwiftUIにラップします。リダイレクトURLをキャッチするため、`@Binding var redirectURL`を定義しています。

2. **`didReceiveServerRedirectForProvisionalNavigation`でリダイレクトURLをキャッチ**:
   `Coordinator`クラスで`WKNavigationDelegate`を実装し、`webView(_:didReceiveServerRedirectForProvisionalNavigation:)`メソッドでサーバーリダイレクトを検知します。リダイレクト先のURLを`parent.redirectURL`に渡します。

3. **`NavigationLink`による遷移**:
   リダイレクトURLがキャッチされたら、`NavigationLink`を使って次の画面に遷移します。`onChange(of:)`を使って`redirectURL`の変化を監視し、リダイレクトが発生したら遷移フラグを立てます。

### メリット
- **`didReceiveServerRedirectForProvisionalNavigation`の使用**: サーバーリダイレクトが発生した時に確実にキャッチできるので、`decidePolicyFor`を使ってURLを手動で判断する必要がなく、簡潔にリダイレクト処理が可能です。
  
### 注意点
- `didReceiveServerRedirectForProvisionalNavigation`はサーバー側で行われるリダイレクトのみを対象にしているため、JavaScriptによるクライアント側リダイレクトなど、他の方法でリダイレクトが行われる場合には検知できない可能性があります。この場合は他の方法も併用する必要があります。

サーバーリダイレクトをキャッチしたい場合、この方法はシンプルかつ効果的です。

---

## 👤 ユーザー
*2024/10/08 19:09:09*

これはどういうこと？
具体的にtypeformというサービスを使ってリダイレクトURLを設定してそれを検知して、アプリ内WebViewを閉じようと思っている

---

## 🤖 アシスタント
*2024/10/08 19:09:48*

上記の内容は、`didReceiveServerRedirectForProvisionalNavigation`が**サーバー側リダイレクト**のみを検知することを指しています。具体的には、サーバー側でHTTPリダイレクト（例えば、HTTP 3xxステータスコード）が発生した場合にこのメソッドが呼び出されるという意味です。しかし、**クライアント側リダイレクト**（例えば、JavaScriptによるリダイレクトなど）はこのメソッドでは検知できない場合がある、ということを説明しています。

### TypeformのリダイレクトURLの検知とWebViewの閉鎖

Typeformを使って、フォーム送信後に特定のURLにリダイレクトする場合、以下のようなシナリオが考えられます。

1. **サーバー側リダイレクト**: Typeformがフォーム送信後にサーバーからリダイレクトを返す場合。この場合、`didReceiveServerRedirectForProvisionalNavigation`でリダイレクトURLをキャッチできます。
2. **クライアント側リダイレクト**: TypeformがJavaScriptを使ってリダイレクトする場合。この場合、`didReceiveServerRedirectForProvisionalNavigation`ではリダイレクトを検知できない可能性があるため、他の方法を使う必要があります。

#### サーバー側リダイレクトの処理
サーバー側リダイレクトが設定されている場合、`didReceiveServerRedirectForProvisionalNavigation`を使ってリダイレクトURLを検知し、アプリ内のWebViewを閉じることができます。

```swift
import SwiftUI
import WebKit

struct WebView: UIViewRepresentable {
    let url: URL
    @Binding var redirectURL: URL? // リダイレクトURLをキャッチ
    let onClose: () -> Void // WebViewを閉じるためのクロージャ

    func makeUIView(context: Context) -> WKWebView {
        let webView = WKWebView()
        webView.navigationDelegate = context.coordinator
        let request = URLRequest(url: url)
        webView.load(request)
        return webView
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        // 更新時に特にすることがなければそのまま
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, WKNavigationDelegate {
        var parent: WebView

        init(_ parent: WebView) {
            self.parent = parent
        }

        func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
            if let redirectURL = webView.url {
                // リダイレクトURLが検知されたらWebViewを閉じる処理を実行
                parent.redirectURL = redirectURL
                if redirectURL.absoluteString.contains("success") { // ここでリダイレクト先のURLをチェック
                    parent.onClose() // WebViewを閉じる
                }
            }
        }
    }
}

// WebViewを表示し、リダイレクトURLに基づいてWebViewを閉じるSwiftUIのView
struct ContentView: View {
    @State private var redirectURL: URL?

    var body: some View {
        WebView(url: URL(string: "https://your-typeform-url.com")!, redirectURL: $redirectURL) {
            // WebViewが閉じられる時の処理
            print("WebViewが閉じられました")
        }
        .frame(height: 400) // WebViewのサイズ
    }
}
```

#### クライアント側リダイレクトの処理

TypeformがJavaScriptを使ってリダイレクトしている場合は、`didReceiveServerRedirectForProvisionalNavigation`では検知できません。この場合は、`WKNavigationDelegate`の他のメソッドや、例えば`webView(_:didFinish:)`などでリダイレクト先URLをチェックする方法も検討できます。

```swift
class Coordinator: NSObject, WKNavigationDelegate {
    var parent: WebView

    init(_ parent: WebView) {
        self.parent = parent
    }

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        // ページの読み込みが完了したタイミングでURLを確認
        if let currentURL = webView.url {
            if currentURL.absoluteString.contains("success") { // リダイレクト先URLに特定のキーワードを含む場合
                parent.onClose() // WebViewを閉じる
            }
        }
    }
}
```

### 結論

- **サーバー側リダイレクト**: `didReceiveServerRedirectForProvisionalNavigation`が適しており、Typeformがサーバーからのリダイレクトを行っている場合にこれを使うと簡単にリダイレクトを検知して処理が可能です。
- **クライアント側リダイレクト (JavaScript等)**: サーバーではなくクライアント側でリダイレクトが行われている場合は、`webView(_:didFinish:)`など他のデリゲートメソッドでURLを検知する必要があります。

Typeformでフォーム送信後のリダイレクトがサーバーサイドかクライアントサイドかを確認した上で、最適な方法を選んでください。

---

## 👤 ユーザー
*2024/10/08 19:38:17*

このHTMLだとどのリダイレクトになるのか？

&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="refresh" content="0; url=sample-app://subscription/delete"&gt;
    &lt;title&gt;Redirecting...&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;If you are not redirected, &lt;a href="sample-app://subscription/delete"&gt;click here&lt;/a&gt;.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

---

## 🤖 アシスタント
*2024/10/08 19:38:47*

提供していただいたHTMLでは、`meta`タグの`http-equiv="refresh"`属性を使ってリダイレクトを行っています。この場合、**クライアント側のリダイレクト**になります。具体的には、ページが読み込まれた際にブラウザが`meta`タグを解釈し、指定されたURL（ここでは`sample-app://subscription/delete`）にクライアント側でリダイレクトを行います。

### リダイレクトのタイプ

このリダイレクトは、HTTPレスポンスに含まれるサーバーからのリダイレクト（HTTPステータスコード3xxによるリダイレクト）ではなく、HTML内の`meta`タグによりクライアント側で実行されるリダイレクトです。そのため、`WKNavigationDelegate`の`didReceiveServerRedirectForProvisionalNavigation`では検知できません。

### クライアント側リダイレクトの処理

クライアント側リダイレクトの場合、`webView(_:didFinish:)`のようなページ読み込み完了後にURLを確認するデリゲートメソッドで検知する方法が一般的です。以下のようにして、ページのロードが完了した時点でリダイレクトURLをキャッチし、処理を行うことができます。

#### `webView(_:didFinish:)`でリダイレクトURLをキャッチする例

```swift
import SwiftUI
import WebKit

struct WebView: UIViewRepresentable {
    let url: URL
    let onRedirect: (URL) -> Void // リダイレクトを検知した際のクロージャ

    func makeUIView(context: Context) -> WKWebView {
        let webView = WKWebView()
        webView.navigationDelegate = context.coordinator // WKNavigationDelegateの設定
        let request = URLRequest(url: url)
        webView.load(request)
        return webView
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        // 必要に応じて更新
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, WKNavigationDelegate {
        var parent: WebView

        init(_ parent: WebView) {
            self.parent = parent
        }

        // ページの読み込みが完了したタイミングでリダイレクト先URLをチェック
        func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
            if let currentURL = webView.url {
                if currentURL.scheme == "sample-app" {
                    // リダイレクト先がアプリスキームの場合、処理を行う
                    parent.onRedirect(currentURL)
                }
            }
        }
    }
}

// WebViewを表示し、リダイレクトURLを検知してWebViewを閉じるSwiftUIのView
struct ContentView: View {
    var body: some View {
        WebView(url: URL(string: "https://your-redirect-page.com")!) { redirectURL in
            // リダイレクトURLが "sample-app://" の場合にWebViewを閉じる
            if redirectURL.absoluteString.contains("sample-app://subscription/delete") {
                // WebViewを閉じる処理や、リダイレクト後の処理をここに記述
                print("リダイレクト先: \(redirectURL)")
            }
        }
        .frame(height: 400) // WebViewのサイズ
    }
}
```

### まとめ

- このHTMLでは、`meta`タグを使用して**クライアント側リダイレクト**が行われています。
- この場合、`didReceiveServerRedirectForProvisionalNavigation`ではリダイレクトを検知できませんが、`webView(_:didFinish:)`などのメソッドでページ読み込み後にリダイレクト先URLをキャッチできます。
- リダイレクト先がアプリスキーム（`sample-app://`）の場合、リダイレクトを検知してWebViewを閉じたり、他の処理を実行することが可能です。

この方法を使えば、Typeformなどで設定されたクライアント側リダイレクトも正確に検知し、次のアクションに進むことができます。

---

## 👤 ユーザー
*2024/10/08 19:39:30*

サファリとかだとこのリダイレクトをさせた時にエラーのアラートがでるので、リダイレクトURLがわかった時点で閉じるような処理をしたい

---

## 🤖 アシスタント
*2024/10/08 19:40:06*

サファリやiOSの他のWebブラウザでは、カスタムURLスキーム（`sample-app://`など）を使ったリダイレクトを行うと、**"このページを開けません"** のようなアラートが表示されることがあります。これを防ぐために、`WKWebView`でリダイレクトURL（カスタムスキーム）が検知された時点で、WebViewを閉じて、そのアラートが表示される前に処理を終了させることができます。

これを実現するためには、`WKNavigationDelegate`の `decidePolicyFor` メソッドを使って、リダイレクトURLがカスタムスキームであることを確認し、その時点でWebViewを閉じる処理を実行します。

### 解決方法：`decidePolicyFor`を使ってカスタムスキームを検知してWebViewを閉じる

以下のコードでは、`sample-app://`のようなカスタムスキームのリダイレクトURLが検知された時点でWebViewを閉じる処理を行っています。

#### コード例

```swift
import SwiftUI
import WebKit

// WebViewを表示するSwiftUIラッパー
struct WebView: UIViewRepresentable {
    let url: URL
    let onRedirect: (URL) -> Void // カスタムスキームが検知された時に呼ばれるクロージャ

    func makeUIView(context: Context) -> WKWebView {
        let webView = WKWebView()
        webView.navigationDelegate = context.coordinator
        let request = URLRequest(url: url)
        webView.load(request)
        return webView
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        // 必要に応じて更新
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, WKNavigationDelegate {
        var parent: WebView

        init(_ parent: WebView) {
            self.parent = parent
        }

        // WebView内のリクエストが発生するたびに呼ばれる
        func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
            if let url = navigationAction.request.url {
                if url.scheme == "sample-app" {
                    // カスタムスキーム（例: "sample-app://"）が検知されたら、WebViewを閉じる
                    parent.onRedirect(url)
                    decisionHandler(.cancel) // WebViewでのリダイレクト処理をキャンセルして、アラート表示を防ぐ
                    return
                }
            }
            decisionHandler(.allow) // 他の通常のリクエストは許可する
        }
    }
}

// WebViewを表示し、リダイレクトURLを検知してWebViewを閉じるSwiftUIのView
struct ContentView: View {
    @State private var isWebViewVisible = true

    var body: some View {
        if isWebViewVisible {
            WebView(url: URL(string: "https://your-redirect-page.com")!) { redirectURL in
                // カスタムスキームのリダイレクトが検知されたらWebViewを閉じる処理
                print("リダイレクト先: \(redirectURL)")
                isWebViewVisible = false // WebViewを非表示にして閉じる
            }
            .frame(height: 400) // WebViewのサイズ
        } else {
            Text("WebViewが閉じられました")
        }
    }
}
```

### このコードのポイント

1. **`decidePolicyFor`を使ったURLの検知**: `WKNavigationDelegate`の`webView(_:decidePolicyFor:decisionHandler:)`メソッドは、WebView内でナビゲーションアクション（ページ遷移やリクエスト）を制御できるメソッドです。ここでカスタムURLスキーム（`sample-app://`）を検知し、リダイレクト先のURLに一致した場合に処理を停止してWebViewを閉じます。

2. **`decisionHandler(.cancel)`を使ったアラート防止**: カスタムスキームが検知されたら`decisionHandler(.cancel)`を呼び出し、WebView内でそのリクエストを処理しないようにすることで、iOSやSafariで表示される「このページを開けません」というアラートを防ぎます。

3. **SwiftUIでのWebViewの閉鎖**: カスタムスキームが検知されたら、`isWebViewVisible`を`false`にしてWebViewを非表示にしています。これにより、ユーザーに自然な流れでWebViewが閉じられるように見せることができます。

### まとめ

- `meta`タグによるクライアント側のリダイレクトでは、`decidePolicyFor`を使ってリダイレクトURLを検知することができます。
- カスタムURLスキーム（`sample-app://`）が検知された時点で、WebViewのリダイレクト処理をキャンセルし、WebViewを閉じることでアラートを防ぐことができます。
- アプリケーション内で自然にWebViewを閉じる処理を実装でき、リダイレクトURLに基づいたアクションを起こすことが可能です。

この実装によって、TypeformなどでのリダイレクトURLを検知してアプリ内のWebViewを閉じることが簡単にできます。

---

## 👤 ユーザー
*2024/10/08 19:40:34*

optional func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction) async -&gt; WKNavigationActionPolicy　を使いたい

---

## 🤖 アシスタント
*2024/10/08 19:41:13*

`async/await`を利用して、非同期でWebViewのナビゲーションポリシーを決定するために、`optional func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction) async -> WKNavigationActionPolicy`を使いたいという場合、`iOS 16`からサポートされた非同期バージョンの`WKNavigationDelegate`メソッドを利用することができます。

これにより、非同期な処理を簡単に取り入れることができ、例えばカスタムスキームを使ったリダイレクトを処理し、必要なタイミングで`WKNavigationActionPolicy`を決定できます。

### 実装例

#### SwiftUI + 非同期版 `decidePolicyFor`

1. **非同期でナビゲーションポリシーを決定**: `async`対応の`decidePolicyFor`メソッドを使い、ナビゲーションアクションを非同期で決定します。
2. **カスタムスキームを検知しWebViewを閉じる**: カスタムスキームを検知したらWebViewを閉じ、通常のリクエストは許可します。

#### コード例

```swift
import SwiftUI
import WebKit

// SwiftUIでWKWebViewを表示するためのラッパー
struct WebView: UIViewRepresentable {
    let url: URL
    let onRedirect: (URL) -> Void // カスタムスキームが検知された時に呼ばれるクロージャ

    func makeUIView(context: Context) -> WKWebView {
        let webView = WKWebView()
        webView.navigationDelegate = context.coordinator
        let request = URLRequest(url: url)
        webView.load(request)
        return webView
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        // 必要に応じて更新
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, WKNavigationDelegate {
        var parent: WebView

        init(_ parent: WebView) {
            self.parent = parent
        }

        // 非同期版のナビゲーションポリシー決定メソッド
        func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction) async -> WKNavigationActionPolicy {
            if let url = navigationAction.request.url {
                if url.scheme == "sample-app" {
                    // カスタムスキームが検知された場合、WebViewを閉じる処理
                    await MainActor.run {
                        parent.onRedirect(url)
                    }
                    return .cancel // アラート表示を防ぐためリダイレクトをキャンセル
                }
            }
            return .allow // 通常のリクエストは許可
        }
    }
}

// WebViewを表示し、リダイレクトURLを検知してWebViewを閉じるSwiftUIのView
struct ContentView: View {
    @State private var isWebViewVisible = true

    var body: some View {
        if isWebViewVisible {
            WebView(url: URL(string: "https://your-redirect-page.com")!) { redirectURL in
                // カスタムスキームのリダイレクトが検知されたらWebViewを閉じる処理
                print("リダイレクト先: \(redirectURL)")
                isWebViewVisible = false // WebViewを非表示にして閉じる
            }
            .frame(height: 400) // WebViewのサイズ
        } else {
            Text("WebViewが閉じられました")
        }
    }
}
```

### 説明

1. **`decidePolicyFor`の非同期バージョン**:
   - この非同期バージョンのメソッドは、`iOS 16`以上で利用可能です。非同期で処理を実行した後に、`WKNavigationActionPolicy`を返します。
   - 非同期処理を行うために、メソッドの中で`await`を使用して、必要なタイミングでポリシーを決定できます。

2. **カスタムスキームの検知と非同期処理**:
   - URLのスキームをチェックして、`sample-app://`のようなカスタムスキームを検知します。検知したら`MainActor.run`を使ってメインスレッド上でWebViewを閉じる処理を実行し、ナビゲーションをキャンセルします。
   - 通常のWebリクエスト（`http`や`https`）の場合は、`return .allow`でリクエストを許可します。

3. **SwiftUIと非同期処理の統合**:
   - SwiftUIの中で非同期処理を使うことで、WebViewを動的に表示・非表示にできます。例えば、カスタムスキームが検知されたらWebViewを閉じるといった処理がスムーズに行えます。

### この実装の利点

- **非同期処理**: `async/await`を使うことで、非同期処理を容易に実装でき、例えばバックグラウンドで行う必要がある処理を待つことができる。
- **UIのスムーズな更新**: `MainActor.run`を使ってUIを非同期に安全に更新し、ユーザー体験を損なわずにWebViewを閉じることができる。
- **カスタムスキームの柔軟な処理**: カスタムURLスキームを使ったリダイレクトやディープリンク処理に対しても柔軟に対応でき、Safariなどで出現するアラートを防ぐことができる。

この方法で、`sample-app://`のようなカスタムスキームが検知された時点で、非同期処理を使用してWebViewを閉じることができます。

---

## 👤 ユーザー
*2024/10/08 19:41:37*

WebViewModel というものを作ってなるべくそちら側で処理を持ちたい

---

## 🤖 アシスタント
*2024/10/08 19:42:12*

User prefers to use a WebViewModel to handle processing related to WKWebView.

---

## 🔧 ツール
*2024/10/08 19:42:12*

Model set context updated.

---

## 🤖 アシスタント
*2024/10/08 19:42:12*

`WebViewModel`を使って処理をモデルに移すことで、`View`とロジックを分離し、コードの保守性を高めることができます。以下では、`WebViewModel`を作成し、その中で`WKWebView`の処理を管理する方法を紹介します。

### 実装例: `WebViewModel`を使用したWebViewの管理

1. **`WebViewModel`にWebView関連の処理を集約**: 非同期処理やリダイレクトの検知を`WebViewModel`に移動し、UIに関する処理は`View`側に残します。
2. **Viewは`WebViewModel`を参照するだけ**: SwiftUIのViewは、`WebViewModel`が提供するデータやロジックを利用して動作します。

#### WebViewModelの作成

```swift
import SwiftUI
import WebKit
import Combine

class WebViewModel: NSObject, ObservableObject, WKNavigationDelegate {
    @Published var isWebViewVisible = true
    @Published var redirectURL: URL?
    
    private var webView: WKWebView!
    
    override init() {
        super.init()
        webView = WKWebView()
        webView.navigationDelegate = self
    }
    
    // WebViewのインスタンスを返す
    func getWebView() -> WKWebView {
        return webView
    }
    
    // 非同期版のナビゲーションポリシー決定メソッド
    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction) async -> WKNavigationActionPolicy {
        if let url = navigationAction.request.url {
            if url.scheme == "sample-app" {
                await MainActor.run {
                    self.redirectURL = url
                    self.isWebViewVisible = false // WebViewを非表示にする
                }
                return .cancel // リダイレクトをキャンセル
            }
        }
        return .allow // 通常のリクエストは許可
    }
}
```

### SwiftUIのViewで`WebViewModel`を使用

`WebViewModel`を利用して、SwiftUIのView側ではWebViewの表示や非表示などの処理を簡潔に行います。

```swift
struct ContentView: View {
    @StateObject private var viewModel = WebViewModel()

    var body: some View {
        if viewModel.isWebViewVisible {
            WebView(viewModel: viewModel)
                .frame(height: 400) // WebViewの高さを指定
        } else {
            Text("WebViewが閉じられました")
        }
    }
}

// SwiftUIでWKWebViewを表示するためのラッパー
struct WebView: UIViewRepresentable {
    @ObservedObject var viewModel: WebViewModel

    func makeUIView(context: Context) -> WKWebView {
        return viewModel.getWebView() // WebViewModelからWebViewを取得
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        // 必要に応じて更新
    }
}
```

### 仕組み

1. **`WebViewModel`**:
   - `WKWebView`のナビゲーションポリシーやリダイレクト処理、非同期処理をモデル側に集約します。
   - WebViewの可視性を管理する`@Published var isWebViewVisible`と、リダイレクトURLを管理する`@Published var redirectURL`を定義し、これらの状態が変化したときにView側が自動的に更新されます。

2. **`ContentView`**:
   - `@StateObject`として`WebViewModel`を管理し、モデルの状態に基づいてWebViewを表示または非表示にします。
   - WebView自体の構成は`WebViewModel`に依存しており、ViewはWebViewの表示・非表示やモデルの更新をトリガーする役割に限定されています。

### メリット

- **責務の分離**: `WebViewModel`にWebView関連の処理を集約することで、Viewとビジネスロジックが明確に分離され、テストや保守がしやすくなります。
- **リアクティブなUI更新**: `@Published`プロパティにより、モデルの状態が変更されると自動的にUIが更新されます。これにより、UIのコードがシンプルになります。
- **非同期処理の利用**: `decidePolicyFor`メソッド内で非同期処理を利用することで、複雑な操作（例えば、リダイレクトの処理）を効率的に実装できます。

このアプローチにより、`WebViewModel`に処理を集約しつつ、リダイレクト検知や非同期処理も簡潔に実装できます。

---
