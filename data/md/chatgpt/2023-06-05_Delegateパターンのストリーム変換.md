# Delegateパターンのストリーム変換

日付: 2023-06-05

---

## 👤 ユーザー
*2023/6/5 15:57:35*

swiftでのアプリ開発で、外部SDKを使う関係でdelegate経由で呼ばれる関数があって、その関数では文字列が引数で設定されている。これをパススルーサブジェクトとして、ハンドリングしたいのだけれどもサンプルの実装をしてほしい

---

## 🤖 アシスタント
*2023/6/5 15:58:15*

SwiftではCombineフレームワークを利用してDelegateパターンの情報をReactiveなストリームに変換することが可能です。そのためには、まずSDKのdelegateメソッドをラップするクラスを作成し、その中でSubjectを用意します。

以下にその実装例を示します。サンプルでは、ある`ExternalSDKDelegate`というdelegateが`receivedMessage(_ message: String)`というメソッドを持つと仮定します。

まずはDelegateのラッパークラスを作ります：

```swift
import Combine

class SDKDelegateWrapper: ExternalSDKDelegate {
    let messageSubject = PassthroughSubject<String, Never>()

    func receivedMessage(_ message: String) {
        messageSubject.send(message)
    }
}
```

上記の`SDKDelegateWrapper`クラスは`ExternalSDKDelegate`プロトコルを準拠しています。そして、`receivedMessage(_:)`メソッドが呼ばれる度に、引数のメッセージを`messageSubject`に送信します。

このラッパーを使用すると、以下のようにあるクラスからDelegateメソッドの呼び出しをSubscribeすることができます：

```swift
class SomeClass {
    private var cancellables = Set<AnyCancellable>()
    private let sdkDelegateWrapper = SDKDelegateWrapper()

    init() {
        setupSDK()
        observeMessages()
    }

    private func setupSDK() {
        let sdk = ExternalSDK()  // これはあなたが使っているSDKの初期化方法による
        sdk.delegate = sdkDelegateWrapper
    }

    private func observeMessages() {
        sdkDelegateWrapper.messageSubject
            .sink { message in
                print("Received message: \(message)")
            }
            .store(in: &cancellables)
    }
}
```

`SomeClass`は`messageSubject`をSubscribeしています。その結果、Delegateメソッド`receivedMessage(_:)`が呼び出される度に、そのメッセージがprintされます。

これはサンプルのコードなので、あなたが使っているSDKやその利用方法によって適宜修正してください。

---

## 👤 ユーザー
*2023/6/5 15:59:00*

さらにSomeClassをViewModelとして、Viewにその値を反映させたい。

---

## 🤖 アシスタント
*2023/6/5 15:59:41*

SwiftUIを使っていると仮定すると、ViewModelは`@Published`プロパティラッパーを使って変更を公開することができます。そして、SwiftUIのViewはこの`@Published`プロパティにバインドして自動的に更新することができます。

まずViewModelを更新しましょう：

```swift
class SomeViewModel: ObservableObject {
    private var cancellables = Set<AnyCancellable>()
    private let sdkDelegateWrapper = SDKDelegateWrapper()

    @Published var latestMessage: String?

    init() {
        setupSDK()
        observeMessages()
    }

    private func setupSDK() {
        let sdk = ExternalSDK()  // これはあなたが使っているSDKの初期化方法による
        sdk.delegate = sdkDelegateWrapper
    }

    private func observeMessages() {
        sdkDelegateWrapper.messageSubject
            .sink { [weak self] message in
                self?.latestMessage = message
            }
            .store(in: &cancellables)
    }
}
```

ここで新しく`latestMessage`という`@Published`プロパティを追加しました。そして、`receivedMessage(_:)`メソッドが呼ばれる度に、そのメッセージを`latestMessage`に設定しています。

そして、以下のようにSwiftUIのViewを作成します：

```swift
import SwiftUI

struct ContentView: View {
    @ObservedObject var viewModel: SomeViewModel

    var body: some View {
        Text(viewModel.latestMessage ?? "No message yet")
            .padding()
    }
}
```

ここで`ContentView`は`viewModel.latestMessage`にバインドしています。そのため、`latestMessage`が変更されると、Viewは自動的に更新されます。

このViewを作成する時には、以下のようにViewModelを渡す必要があります：

```swift
let viewModel = SomeViewModel()
let contentView = ContentView(viewModel: viewModel)
```

これで、Delegateメソッドの呼び出しに基づいてViewが自動的に更新されるようになりました。

---

## 👤 ユーザー
*2023/6/5 16:01:32*

setupSDK と observeMessages を privateな関数としてのはなぜか？ init でぜんぶやってもよかったのでははてな

---

## 🤖 アシスタント
*2023/6/5 16:01:56*

あなたの指摘は正確で、`setupSDK`と`observeMessages`を`init`の中に直接記述することも完全に可能です。しかし、ここでこれらのメソッドを分けているのは主に以下の2つの理由によります：

1. **可読性**：`init`メソッドが長くなりすぎると、その中で何が行われているのかを理解するのが難しくなることがあります。それぞれの機能を個別のメソッドに分けることで、コードはより読みやすく、理解しやすくなります。

2. **再利用性**：将来的に、同じクラス内で何度かSDKを設定したり、メッセージを観察したりする必要が生じた場合、それぞれの機能を個別のメソッドに分けておくと再利用が容易になります。

つまり、これは主にコードの組織化と管理のためのプラクティスであり、実際の機能には直接影響を与えません。このようなアプローチを取るかどうかは、個々の開発者やチームによる設計決定に大きく依存します。

---

## 👤 ユーザー
*2023/6/5 16:04:27*

ViewModel で ExternalSDK での使用する機能だけ protocol 化 して、ViewModelでは ExternalSDKProtocol を引数で渡して、デフォルトをExternalSDK() とするように変更したい。

---

## 🤖 アシスタント
*2023/6/5 16:05:15*

あなたが述べたように、protocolを利用することはテストや依存性の分離に役立ちます。以下に、`ExternalSDK`の一部の機能を`ExternalSDKProtocol`というprotocolに抽出し、`SomeViewModel`がこのprotocolを使うように修正したサンプルコードを示します。

まずは`ExternalSDKProtocol`を作成します：

```swift
protocol ExternalSDKProtocol: AnyObject {
    var delegate: ExternalSDKDelegate? { get set }
    
    // ...他の必要なメソッドやプロパティ...
}
```

次に、実際の`ExternalSDK`がこのprotocolを準拠するようにします：

```swift
extension ExternalSDK: ExternalSDKProtocol {
    // delegateはすでに定義されているはずなので、他の必要なメソッドやプロパティをここに追加します。
}
```

最後に、`SomeViewModel`を更新して`ExternalSDKProtocol`に依存するようにします：

```swift
class SomeViewModel: ObservableObject {
    private var cancellables = Set<AnyCancellable>()
    private let sdkDelegateWrapper = SDKDelegateWrapper()

    @Published var latestMessage: String?

    private let sdk: ExternalSDKProtocol

    init(sdk: ExternalSDKProtocol = ExternalSDK()) {
        self.sdk = sdk
        setupSDK()
        observeMessages()
    }

    private func setupSDK() {
        sdk.delegate = sdkDelegateWrapper
    }

    private func observeMessages() {
        sdkDelegateWrapper.messageSubject
            .sink { [weak self] message in
                self?.latestMessage = message
            }
            .store(in: &cancellables)
    }
}
```

ここでは`SomeViewModel`の`init`メソッドが`ExternalSDKProtocol`を引数に取り、デフォルトの値として`ExternalSDK()`を設定しています。これにより、このViewModelは外部から別の`ExternalSDKProtocol`の実装を注入できるようになり（これはモックオブジェクトをテスト時に使用するのに便利です）、デフォルトでは実際の`ExternalSDK`を使用します。

このようにprotocolを使用することで、依存性の注入が可能になり、テストしやすさやモジュールの分離が向上します。

---

## 👤 ユーザー
*2023/6/5 16:07:16*

クリーンアーキテクチャーの観点から、ExternalSDKProtocol に おそらく外部SDKフレームワーク層であるExternalSDKDelegateを使ってしまっているが、それをうまく回避する方法（ExternalSDKProtocolは外部SDKに依存しないクリーンな状態にする方法）をおしえてほしい

---

## 🤖 アシスタント
*2023/6/5 16:08:16*

クリーンアーキテクチャに従うと、各レイヤーはそれ自体の関心事だけを処理すべきであり、外部の詳細（この場合、`ExternalSDK`）に依存すべきではありません。これに対処する一つの方法は、外部からの入力（この場合、`ExternalSDKDelegate`からのコールバック）を内部のドメインモデルに変換するアダプターレイヤーを設けることです。

以下に、このアプローチを実装する一例を示します。まず、`ExternalSDKProtocol`はデリゲートを設定する代わりに、クロージャを使用してメッセージの通知を受け取ります：

```swift
protocol ExternalSDKProtocol: AnyObject {
    var onMessageReceived: ((String) -> Void)? { get set }
    
    // ...他の必要なメソッドやプロパティ...
}
```

次に、`ExternalSDK`と`ExternalSDKDelegate`の実装を更新して、このクロージャを呼び出します：

```swift
class SDKDelegateWrapper: ExternalSDKDelegate {
    var onMessageReceived: ((String) -> Void)?

    func receivedMessage(_ message: String) {
        onMessageReceived?(message)
    }
}

extension ExternalSDK: ExternalSDKProtocol {
    var onMessageReceived: ((String) -> Void)? {
        get {
            (delegate as? SDKDelegateWrapper)?.onMessageReceived
        }
        set {
            let wrapper = (delegate as? SDKDelegateWrapper) ?? SDKDelegateWrapper()
            wrapper.onMessageReceived = newValue
            delegate = wrapper
        }
    }
}
```

そして、`SomeViewModel`は次のように更新します：

```swift
class SomeViewModel: ObservableObject {
    private var cancellables = Set<AnyCancellable>()
    private let sdk: ExternalSDKProtocol

    @Published var latestMessage: String?

    init(sdk: ExternalSDKProtocol = ExternalSDK()) {
        self.sdk = sdk
        setupSDK()
    }

    private func setupSDK() {
        sdk.onMessageReceived = { [weak self] message in
            self?.latestMessage = message
        }
    }
}
```

このアプローチでは、`ExternalSDKProtocol`は`ExternalSDKDelegate`に直接依存しなくなり、それぞれのレイヤーが自身の関心事だけを処理するようになります。これにより、`ExternalSDK`と`ExternalSDKDelegate`の具体的な実装が変わった場合でも、それらの変更が`SomeViewModel`に影響を及ぼすことはありません。

ただし、注意点として、このアプローチでは`ExternalSDK`のデリゲートが一つしか設定できないと仮定しています。複数のデリゲートを設定する必要がある場合は、それぞれのデリゲートに対してアダプターを設けるか、またはデリゲートのセットを管理する

---

## 👤 ユーザー
*2023/6/5 16:08:26*

つづき

---

## 🤖 アシスタント
*2023/6/5 16:10:15*

デリゲートのセットを管理するような機能が必要になる可能性があります。ただし、そのようなケースは比較的まれであり、実際のシナリオによります。

また、クリーンアーキテクチャの観点からすると、具体的な技術（この場合、`ExternalSDK`）に依存しないようにインターフェースを設計することが重要です。この例では`ExternalSDKProtocol`がその役割を果たしており、実装（`ExternalSDK`）が変わったとしてもそれが`SomeViewModel`に影響を与えないようにしています。

さらに、各レイヤーの依存関係を最小限に保つことも重要です。この例では、ViewModelはUI（View）とSDK（`ExternalSDKProtocol`を通じて）に

---
