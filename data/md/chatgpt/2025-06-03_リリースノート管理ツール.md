# リリースノート管理ツール

日付: 2025-06-03

---

## 👤 ユーザー
*2025/6/3 17:34:05*

GitHub の リリースノートとtagの管理をしたい。
リリースノートの生成はPRにラベルをつけてグルーピングする管理もあるが、Conventional Commits での管理でもよい。
また、完全自動化というよりは、特定のコマンドを実行するであったり、GitHub Actions の workflow\_dispatch で実行するのでもよい。
また、モノレポを採用していて、リリースノートとは別にChangelogを残していきたい。
リリースノートは本当にリリース単位での差分をのしたいが、Changelogは細々のしていきたいイメージです。
リリースノートを見るのはPMとかのイメージで、Changelogはエンジニアが見るイメージです。
なにかいいツールはあったりするだろうか？
ちなみにモノレポにしているのは分離したモジュールを公にリリースするわけではないです。
いいツールや運用方法があれば教えて欲しい。
Conventional Commits での管理はすでに導入している。

---

## 🤖 アシスタント
*2025/6/3 17:34:28*

### 目的の整理
| ドキュメント | 想定読者 | 粒度 |
|--------------|----------|------|
| **Release Notes** | PM／非エンジニア | “今回のリリースで何が変わったか” に絞ったハイライト |
| **CHANGELOG.md** | 開発者 | すべての feat / fix / refactor などを時系列に残す |

モノレポでも **タグは 1 つ、バージョンも全パッケージ横並び** でよいとの前提でツールを選びます。

---

## 主要ツールの比較（モノレポ前提）

| ツール | モノレポ対応 | Release Notes (GitHub Releases) | CHANGELOG.md | トリガ | 特徴 |
|--------|-------------|---------------------------------|--------------|--------|------|
| **release-please** | ◎（manifest 方式） | ◎ カスタムセクション・ラベル分け可 | ◎ 自動更新 | workflow_dispatch / push など | Google 製。Release PR を作り、マージでタグ＋リリースを発行。citeturn0search1 |
| **Changesets** | ◎ | △ (β版 plugin あり) | ◎ 変更ファイル⇒詳細 changelog 生成 | `pnpm changeset version` 等 | 変更内容を `.changeset/*.md` に“手書き”するので粒度を自分で調整しやすい。citeturn0search0 |
| **semantic-release** | ○ (community plugin) | ◎ `@semantic-release/github` | ◎ `@semantic-release/changelog` | push / workflow_dispatch | 100 % 自動化。設定が増えがち。citeturn0search7turn0search2 |
| **release-it** | ○ (同一バージョン運用が楽) | ◎ `@release-it/github` | ◎ `@release-it/conventional-changelog` | CLI / workflow_dispatch | 手動・自動を最も柔軟に切替可。設定 1 ファイルで完結。citeturn0search3turn0search8 |

> **ポイント**  
> ラベル／Conventional Commits のどちらでグループ化するかは  
> ▸ _release-please_：`release-notes-sections` と `pull_request_title_pattern` で両対応  
> ▸ _semantic-release / release-it_：Conventional Commits が前提、ラベルは補助的

---

## おすすめ運用 2 パターン

### 1. release-please だけで完結（最小構成）

1. **GitHub Action** `.github/workflows/release.yml`
   ```yaml
   name: Release
   on:
     workflow_dispatch:
     push:
       branches: [main]

   jobs:
     release:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
         - uses: google-github-actions/release-please-action@v4
           with:
             command: manifest
             config-file: .release-please-config.json
   ```
2. **`.release-please-config.json`**（抜粋）
   ```jsonc
   {
     "manifest": {
       "include-v-in-tag": false
     },
     "plugins": {
       "release-notes": {
         "config": {
           "sections": [
             { "type": "feat", "section": "✨ Features", "hidden": false },
             { "type": "fix",  "section": "🐛 Fixes",    "hidden": false },
             { "type": "chore","section": "🔧 Chores",   "hidden": true }
           ]
         }
       }
     }
   }
   ```
   *GitHub Release* には **hidden=false** の feat/fix だけ → PM 向けハイライト  
   `CHANGELOG.md` には hidden を無視して全件出力 → エンジニア向け詳細

### 2. Changesets ✚ release-please（“手書きサマリ＋自動”）

| 役割 | ツール | 説明 |
|------|--------|------|
| **詳細 CHANGELOG** | Changesets | 開発者が PR 内で `.changeset/*.md` を書く。マージ前に Bot がバージョンと CHANGELOG.md を更新する PR を生成 |
| **タグ & Release Notes** | release-please | 上記 PR が main に入った時点で manifest リリース。`.changeset` の最初の行だけをリリースノートに利用すればハイライトになる |

> **利点**  
> * PM 向け文章を `.changeset` の 1 行目に “人間が推敲” できる  
> * 同じ Conventional Commits を再利用できるので二度手間にならない

---

## よくある質問

| 疑問 | 回答 |
|------|------|
| **完全自動だと誤ったバージョンが付くのでは？** | `workflow_dispatch` や Release PR 承認フローを入れれば人間の確認を必須にできる |
| **複数パッケージを個別公開しない場合でも monorepo ツールを使う意味は？** | 依存解決や CHANGELOG 世代の都合で「パッケージ管理ツール＝バージョン管理ツール」として使えるため便利 |
| **ラベル管理に切り替えたくなったら？** | release-please は `labels` → `sections` で PR ラベルをそのままセクション名にマッピングできる |

---

## まとめ

1. **最短で始める**なら → **release-please** だけ  
   * 1 ファイルで粒度を切り替えられ、手動実行も簡単
2. **ハイライトを文章で微調整したい**なら → **Changesets ＋ release-please**  
   * `.changeset` の冒頭を Release Notes にし、残りを詳細 CHANGELOG に流用
3. どの構成でも **Conventional Commits** が下支えになるため、既存コミット規約は無駄にならない。

このどちらかをベースに、まずは `workflow_dispatch` で手動トリガにして運用してみる → 慣れたら push 自動化へ移行、という段階的な導入が失敗しにくいです。

---

## 👤 ユーザー
*2025/6/3 17:44:32*

タグを生成する機能についてはどうだろうか？

---

## 🤖 アシスタント
*2025/6/3 17:46:03*

### 主要ツールの “タグ生成” 機能だけを抜き出して比較

| ツール | どのコミットにタグ付け？ | 既定のタグ名 | カスタマイズ方法 | モノレポ時の挙動 | 備考 |
|--------|------------------------|--------------|-----------------|------------------|------|
| **release-please** | Release PR を **マージしたコミット** | `v1.2.3` | `include-v-in-tag`（v の有無）`include-component-in-tag`（パッケージ名を前置）などを `config.json` で設定 citeturn6search8 | manifest 方式の場合は **1 つのタグ** を付与（全パッケージ横並び）。個別モードでは `pkg-name-v1.2.3` | `major`/`minor` の **エイリアスタグ**も同時に更新できる citeturn6search2 |
| **Changesets** | `changeset publish`（または `changeset tag`）直後 | `pkg-name@1.2.3` | ―（CLI 引数のみ：`--no-git-tag` で抑止） | 変更があった **各パッケージごとにタグ**。全体タグは作らない | `changeset tag` は **署名タグ**もサポート（`--sign`）。GitHub Actions の公式 Action が push を自動化 citeturn5search7 |
| **release-it** | バージョンコミットを自動作成 → その **同じコミット** にタグ | `v${version}` | `git.tagName` テンプレート（例 `git.tagName="rel-${version}"`）で自由に変更 citeturn4search0turn4search1 | ルートのみタグ／パッケージごとタグの両パターンを設定 1 ファイルで切替 | `--no-git.tag`／`--no-github.release` 等で粒度を手動化 |
| **semantic-release** | CI 内で解析した **最新コミット** | `v${version}` | `tagFormat` オプション（例 `"${version}"` で v を除去） citeturn7search0 | `semantic-release-monorepo` プラグインで `pkg-name@1.2.3` 方式 | 完全自動。タグ push 失敗＝リリース失敗になるのでブランチ保護設定に注意 citeturn0search7 |

---

## モノレポ-タグ設計のヒント

| 目的 | 推奨パターン |
|------|--------------|
| **「全体で 1 つのバージョン」を付けたい**<br>（例：デプロイ単位でタグを使う） | **release-please manifest** — Release PR 1 本 → `v1.2.3` のみ。<br>大タグ 1 本なので CI/CD の `git describe --tags` がシンプル |
| **パッケージ単位の公開はしないが履歴は残したい** | **Changesets** — `version` で CHANGELOG をまとめ、`tag` で各パッケージに `pkg@ver` を打つ。<br>ルートにはタグを付けず、Deploy 用タグは `release-it` で別ワークフローにする、などハイブリッドも可 |
| **完全自動化＋単一タグ** | **semantic-release** — `tagFormat: "deploy-${version}"` などで命名統一。CI 成功時点で自動 push |

---

## カスタム例

<details>
<summary>release-please (ルートに <code>v1.2.3</code>、各パッケージに <code>pkg@1.2.3</code>)</summary>

```jsonc
{
  "include-v-in-tag": true,
  "manifest": { "include-component-in-tag": false },
  "packages": {
    "packages/foo": { "tag-separator": "@" },
    "packages/bar": { "tag-separator": "@" }
  }
}
```
</details>

<details>
<summary>release-it (<code>rel-${version}</code> 形式に変更・軽量タグを使用)</summary>

```json
{
  "git": {
    "tag": true,
    "tagName": "rel-${version}",
    "annotated": false
  }
}
```
</details>

<details>
<summary>semantic-release (「v」を付けずにタグ／Monorepo プラグイン使用)</summary>

```js
module.exports = {
  tagFormat: '${version}',
  plugins: [
    ['@semantic-release/commit-analyzer'],
    ['@semantic-release/release-notes-generator'],
    ['semantic-release-monorepo']
  ]
};
```
</details>

---

## まとめ — タグ生成だけで選ぶなら？

1. **「Release PR を確認してからタグ」派**  
   → **release-please**（マージ承認＝タグ確定）

2. **「publish が終わったらタグを押したい」派**  
   → **Changesets**（`changeset tag` を publish 後に実行）

3. **「手動 or 自動を都度選びたい」派**  
   → **release-it**（CLI 1 行で `--no-git.tag` など柔軟に切替）

4. **「フル自動で夜間に流す CI」派**  
   → **semantic-release**（コミット解析→タグ→GitHub Release までワンショット）

既存の Conventional Commits ルールはどのツールも利用できるので、**リリースフロー全体で誰が “タグを押す責任者” になるのか** を基準に選ぶと運用がブレません。

---

## 👤 ユーザー
*2025/6/3 17:59:54*

もしかして、https://github.com/unjs/changelogenも結構有効だったするのか？

---

## 🤖 アシスタント
*2025/6/3 18:00:50*

### changelogen は「CHANGELOG 特化」の軽量 CLI  
結論から言うと **“開発者向け CHANGELOG を高速に作りたい”** という用途にはかなり相性が良く、  
**リリースノート（PM 向けまとめ）だけを自動で GitHub Releases に流す**ことも最小構成で可能です。  

---

## どんなことが出来る？

| 機能 | 使い方（CLI） | 補足 |
|------|---------------|------|
| **CHANGELOG.md の生成／更新** | `npx changelogen` | Conventional Commits を解析して Markdown を生成|
| **バージョンの自動算出 & `package.json` 書き換え** | `--bump` | `feat` があれば minor、`fix` があれば patch…を自動判定 |
| **Commit + Tag (+ Push) まで自動** | `--release` <br>└ `--no-commit / --no-tag / --push` で粒度調整 | “タグだけ欲しい” も `--release --no-commit` で可 citeturn1search0 |
| **GitHub Releases との同期** | `changelogen gh release` | 既存 CHANGELOG から **feat / fix だけ**を抜粋してリリースノート生成可 citeturn0search0 |
| **テンプレート完全カスタム** | `.changelogrc`, `changelog.config.ts` | ✅ セクション名変更、❌ commit タイプごとに “GitHub では非表示” の指定も可 |

---

## モノレポでの使い勝手

| 目的 | changelogen での実現方法 | 備考 |
|------|-------------------------|------|
| **リポジトリ全体で 1 本の CHANGELOG** | ルートで `npx changelogen --release` | 全パッケージを横並びで version bump（`pnpm -r version` 的運用と相性○） |
| **パッケージごとに個別 CHANGELOG** | `packages/*` でスクリプトを回す<br>例）`pnpm -r --filter ./packages/* changelogen --release` | `--dir` オプションで対象を切り替えられるのでラッパースクリプトは簡単 |
| **PM 向け「ハイライトだけ」リリースノート** | ① `.changelogrc` で `hidden: true` を付ける<br>② `changelogen gh release` を workflow_dispatch で実行 | `feat` / `fix` 以外（refactor, chore など）は GitHub には載せない…といった設定が数行 |

> 💡 **タグは自前で打つ？**  
> `--release` を使えば “バージョン commit & タグ” を同じコミットに生成。  
> `--no-commit` を併用すれば「タグだけ」打つモードにも出来るので、 **タグ生成専用ツールとしても差し替え不要** です。

---

## 他ツールとの住み分け

| シナリオ | ベストチョイス |
|----------|----------------|
| **CHANGELOG を手書きせず、とにかく綺麗に出したい** | **changelogen**（最小依存・高速） |
| **Release PR→承認→タグ** のワークフローで<br>リリースノートも自動化したい | **release-please** |
| **パッケージ個別バージョン**＋**手書きサマリ** | **Changesets**（`.changeset/*.md` で自由度） |
| **CI だけで完全自動化**（push ＝即タグ） | **semantic-release** |

実際には **changelogen × GitHub Actions** を “CHANGELOG 生成＋タグ＋リリースノート同期” に使い、  
パッケージ公開や Canary 版配布だけ `release-it` で補うハイブリッド構成もよく採用されます。

---

## サンプル `.changelogrc`（PM 向けノイズを非表示）

```ts
import { defineConfig } from 'changelogen'

export default defineConfig({
  gitRemote: 'origin',     // for mono-repo on GitHub
  types: {
    feat:  { title: '✨ Features' },
    fix:   { title: '🐛 Fixes' },
    chore: { title: '🔧 Internals', hidden: true },   // ← GitHub Releases には載せない
    refactor: { title: '🧹 Refactor', hidden: true }
  }
})
```

1. `pnpm run changelog` → `CHANGELOG.md` は **全セクション** 出力  
2. `gh release` ワークフローで `feat / fix` だけを拾って**PM 向けリリースノート**完成  

---

### 結論

- **「タグ生成＋CHANGELOG 更新＋GitHub Release 反映」を 1 コマンドで完結**  
  → **changelogen** は十分有力。  
- モノレポでも `--dir` や `pnpm -r` で簡単にスケールする。  
- Conventional Commits が既に入っているなら **セットアップは 5 分**：  
  1. `pnpm add -D changelogen`  
  2. `.changelogrc` を置く  
  3. `workflow_dispatch` 用の Action を 10 行書くだけ  

これで **開発者の詳細履歴と PM 向けハイライトを分離**したリリース運用が実現できます。

---

## 👤 ユーザー
*2025/6/3 18:04:27*

changelogen を使うタイミングは基本的にローカルPCということか？

---

## 🤖 アシスタント
*2025/6/3 18:05:03*

いいえ、**ローカル実行に限定されるわけではありません**。  
`changelogen` はただの Node CLI なので、  

* **ローカル PC で対話的に叩く**  
* **GitHub Actions など CI ランナー内で自動実行する**  

──どちらのパターンでも動きます。実際には次の 3 通りの運用がよく使われます。

| 運用フェーズ | 実行場所 | 代表コマンド例 | 典型的な使い分け |
|-------------|----------|---------------|------------------|
| **プレビュー／ドラフト作成** | 開発者ローカル | `npx changelogen` | feat/fix が正しく分類されるか確認してから PR を出したい |
| **バージョン確定＋タグ付け** | CI（manual dispatch ／ main への push） | `npx changelogen --bump --release --push` | 人間の承認後に “1 コミット＋タグ” を自動生成して GitHub に push |
| **リリースノート同期** | CI（軽量ジョブ） | `npx changelogen gh release` | 生成済み `CHANGELOG.md` を読み取り、GitHub Releases にハイライトだけ投稿 citeturn1search0 |

---

## GitHub Actions 例（手動トリガでタグ＋リリースノートまで）

```yaml
name: Release with changelogen
on:
  workflow_dispatch:      # 必要なら push: [main] も追加可

permissions:
  contents: write         # タグ／コミット／Release の作成に必要

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0   # 全履歴がないと changelogen が差分を計算できない
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: |
          npx changelogen --bump --release --push   # ① CHANGELOG + version + タグ
          npx changelogen gh release                # ② 最新タグを GitHub Releases に同期
```

> ポイント  
> * **`--release --push`** が “タグ生成” を担当。`--no-commit` や `--no-tag` で粒度を調整できます。  
> * **`changelogen gh release`** を分けて呼ぶと、`hidden: true` にしたセクションを除外して PM 向けハイライトだけがリリースノートになります。 citeturn2search9  

---

## ローカル実行が向いているケース

| ケース | 理由 |
|--------|------|
| **小規模チームでリリース責任者が決まっている** | 「手元で確認してから push」の方が安心 |
| **Monorepo 内パッケージを選択的に bump したい** | `pnpm --filter ... exec changelogen --release` など柔軟に回せる |
| **リリース作業と同時にブログ用の全文 CHANGELOG を整形したい** | CLI オプション（`--dir` や `--output`）を対話的に変えやすい |

---

## CI 実行が向いているケース

| ケース | 理由 |
|--------|------|
| **複数人が頻繁にデプロイ** | “誰がリリースしても手順が同じ”＝事故防止 |
| **bot が nightly / canary 版を自動発行** | `schedule` イベントでも動かせるため人手ゼロ |
| **プロテクトブランチを使い、リリースコミットだけ例外にしたい** | ワークフロー側で `GITHUB_TOKEN` を用意すれば安全にタグ push できる |

---

### まとめ

* **ローカル専用ツールではない。**  
  CLI なので **ローカル／CI どちらでも実行可**。  
* **最小手順でタグ生成だけ欲しい**なら `--release --no-commit --push`。  
* **CHANGELOG とタグを確定 → GitHub Releases へ同期**まで 1 Workflow にまとめると、  
  *PM 向けリリースノート* と *開発者向け CHANGELOG* を自動分離したまま運用できます。

---

## 👤 ユーザー
*2025/6/3 18:06:57*

ちなみにパッケージのバージョン管理ツールとしての使い勝手ではどうか？

---

## 🤖 アシスタント
*2025/6/3 18:08:14*

### “パッケージの **バージョン管理ツール**” として changelogen を見たときの評価

| 観点 | changelogen | Changesets | release-it | 備考 |
|------|-------------|------------|------------|------|
| **バージョンの自動判定** | `--bump` が Conventional Commits を解析して `major/minor/patch` を決定し `package.json` を書き換え citeturn8search0 | 変更ファイル (`.changeset/*.md`) に bump 種別を明示。自動判定はしない citeturn9search0 | Commit 解析 or 手動入力 (`npm version` 相当) |
| **コミット & タグ生成** | `--release` でバージョン commit + 軽量/署名タグを同じコミットに作成。`--no-commit` `--no-tag` で粒度変更可 citeturn8search0 | `changeset version` が “Version PR” を生成 → マージでタグ | CLI フラグ／hooks で自由にオンオフ |
| **npm publish** | `--publish` あり。`--publishTag` で dist-tag も指定可 citeturn8search0 | `changeset publish` で multi-package に対応 | `npm`／`pnpm`／`yarn` ほか任意コマンドを hooks に |
| **Monorepo** | `--dir` (または `pnpm -r exec`) で **各パッケージ単発実行**。内部依存 bump はしない。Issue #85 で公式も“割り切り設計”と表明 citeturn8search7 | **依存グラフを解析して一括 bump**。内部 peerDeps も追従 citeturn9search0 | ルート一括かパッケージごとかを config 1 行で切替 |
| **プリ/カナリー リリース** | なし（タグ名を工夫して手動で運用） | 公式 plugin あり | `preRelease` オプションで標準対応 |
| **CI/CD での利用** | Node だけで動く → GitHub Actions に 2 行で組込める | Version PR + publish ジョブの 2 段構成が一般的 | 単一ジョブで完結する一方、設定が多め |
| **速度 / 依存数** | 依存 13 個・実行が速い (NJS エコシステム準拠) citeturn0search3 | 50 + 個、publish 時に git 操作が多い | 40 + 個、プラグインを入れるほど増える |

---

## 使い勝手を **3 行でまとめる** と…

1. **単一バージョン or 小規模モノレポ**なら  
   `npx changelogen --bump --release --push` **だけで**  
   “次バージョン算出 → package.json 更新 → commit → tag → push” が 1 コマンドで完結。  
2. **多パッケージ依存を自動で追従**させたい場合や  
   **canary／prerelease を流したい**場合は機能が足りない。  
3. その場合は、「バージョン管理＝Changesets / release-it」「CHANGELOG＋リリースノート＝changelogen」の **ハイブリッド**が実務で安定。

---

### 推奨パターン別ロードマップ

| チーム規模 / 要件 | 最小構成 | 拡張ポイント |
|-------------------|----------|--------------|
| **1 〜 5 人・全パッケージ同一バージョン**<br>（依存バンプは不要） | changelogen 単体 | `--push` で自動化 → 慣れたら nightly 用に cron を追加 |
| **10 + 人・内部依存を安全に保ちたい** | Changesets で Version PR → changelogen でタグとリリースノート | `changeset publish` を npm 2FA などと組み合わせ |
| **リリースフローを毎回手動確認したい** | release-it + changelogen | `release-it --no-git.tag` でタグだけ抑止してレビュー可 |
| **Canary / pre.1 / next-tag が必要** | release-it (preRelease) 又は Changesets (pre mode) | changelogen は “正式版” の CHANGELOG 生成に専念 |

---

## サンプル GitHub Actions（全パッケージ共通バージョン）

```yaml
name: Release
on:
  workflow_dispatch:

permissions:
  contents: write   # タグとコミットを push するのに必要

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: |
          npx changelogen --bump --release --push   # バージョン + タグ
          npx changelogen gh release                # feat/fix だけで GitHub Release
```

*`hidden: true` を `.changelogrc` に付けたセクションは GitHub Releases へは流れず、開発者向け CHANGELOG だけに残る構成です。*

---

## 結論

- **バージョンが 1 つ**で済む or **モノレポだけど内部依存の自動同期が不要**なら  
  **changelogen 1 本で完結できるシンプルさと速さ**が魅力。  
- 逆に **依存グラフ更新・pre-release・複雑な hook** が必要なら  
  **Changesets / release-it を “バージョン係”、changelogen を “CHANGELOG 書記係”** にするとストレスが少ない。

---

## 👤 ユーザー
*2025/6/3 19:07:03*

changelogen とは別のツールはないか？

---

## 🤖 アシスタント
*2025/6/3 19:07:27*

### changelogen 以外に検討できる代表的ツール

| ツール | 主目的 | モノレポ対応 | バージョン判定 | タグ／リリース | CHANGELOG 生成 | 特徴的な運用ポイント |
|--------|--------|--------------|----------------|----------------|----------------|----------------------|
| **auto (Intuit)** | リリース自動化 (ラベル駆動) | ◎ (workspaces/lerna 対応) | PR ラベルで semver を決定 | `auto shipit` がタグ＋GitHub Release | あり | “feat” などのラベルを付けてマージ→CI が全自動で shipit citeturn1search0 |
| **beachball (Microsoft)** | バージョン & 依存同期 | ◎ (大規模モノレポ向け) | `change/*` ファイルに手書き | `beachball bump` がタグ／CHANGELOG も生成 | あり | “change file” 方式は Changesets に近いが Office/Fluent UI で実績大 citeturn0search2turn0search6 |
| **git-cliff** | 超高速 CHANGELOG | △ (パッケージ分割無し) | なし（タグ差分ベース） | なし（任意で `git tag`） | ◎ テンプレート完全カスタム | Rust 製で 1 MB 以下。CI 1 ジョブで Markdown 出力可 citeturn0search0turn0search4 |
| **git-chglog** | CHANGELOG + 次タグ予告 | △ | `--next-tag` を CLI 指定 | 手動 (`git tag ...`) | ◎ | Go 製単体バイナリ。`pre-commit` でプレビュー → release job で確定 citeturn0search3 |
| **conventional-changelog / standard-version** | 最小構成 | ○ (ルートのみ) | コミット解析 | `standard-version` がタグ | ◎ | 依存 0 の純 JS。npm scripts 1 行で導入可能 citeturn0search7 |
| **conventional-release (GitHub Action)** | Action 専用 | △ | コミット解析 | Action がタグ & Release | CHANGELOG も upload | ワークフロー yaml 5 行で“とりあえず自動化” citeturn0search1 |

---

## あなたの要件に当てはめると

| 要件 | 合うツール | 理由 |
|------|-----------|------|
| **① モノレポで “全体１バージョン” だが内部依存は自動で追従したい** | **beachball** | `bump` 時に `package.json` の相互依存を一括更新し、CHANGELOG も生成 |
| **② PR ラベルでリリース粒度を完全自動化したい** | **auto** | “minor” “patch” ラベル運用だけで shipit。pre-release (`auto next`) も標準対応 |
| **③ とにかく速くて軽い CHANGELOG だけ欲しい** | **git-cliff** or **git-chglog** | 依存 1 ファイル／バイナリ。CI で Markdown を artifacts に添付するだけでも使える |
| **④ Node の標準ツールチェーンで最小構成** | **standard-version** | `npm run release` 1 行でタグ＋CHANGELOG。設定ゼロで Conventional Commits を解釈 |

---

## サンプル運用フロー（auto を採用する場合）

```yaml
# .github/workflows/release.yml
name: Auto Release
on:
  push:
    branches: [main]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: npx auto shipit --github-token ${{ secrets.GITHUB_TOKEN }}
```

* **開発者**: PR に `minor`, `patch`, `docs` などのラベルを付けてマージ  
* **CI**: `auto shipit` が  
  1. 次バージョンを決定  
  2. `CHANGELOG.md` とタグを生成  
  3. GitHub Release を作成  
  4. （必要なら）`npm publish` まで実行

---

## 選定の目安

1. **“リリース作業をボタン 1 つにしたい”**  
   → **auto** が最短。PR ラベル運用と親和。  
2. **“依存グラフが複雑”**  
   → **beachball** または **Changesets** で change file 方式。  
3. **“CHANGELOG は開発者だけ／リリースノートは別途”**  
   → **git-cliff + release-please** の二刀流（CHANGELOG は cliff、タグ＆リリースは release-please）。  
4. **“今はシンプルでいいが後で拡張したい”**  
   → **standard-version** で始めて、将来 beachball や auto へ移行しても Conventional Commits は流用できる。

---

### まとめ

- **changelogen** 以外にも  
  *運用自動化寄り（auto / beachball）* と  
  *CHANGELOG 出力特化（git-cliff / git-chglog）* の２系統がある。  
- 既に **Conventional Commits** を導入済みなら *どのツールも即利用可能*。  
- 選択基準は **①内部依存の自動追従が要るか ②PR ラベル or コミット解析どちらが運用に合うか ③リリース粒度の自動化レベル**。  
- 小さく始めるなら **standard-version**、ラベル運用を本格化するなら **auto**、大規模モノレポなら **beachball** が失敗しにくいラインナップです。

---

## 👤 ユーザー
*2025/6/3 19:09:34*

auto についてもっと知りたい。 Conventional Commits は適応されているのか？

---

## 🤖 アシスタント
*2025/6/3 19:10:08*

## 「auto」（Intuit 製）とは？

| 役割 | 一言で |
|------|--------|
| **release-bot** | **PR 単位**でバージョン計算・タグ付け・CHANGELOG・GitHub Release・npm publish まで全自動化する CLI／GitHub Action |

デフォルトは **PR ラベル駆動**ですが、**プラグインで振る舞いを差し替え**られます。  
その１つが **`conventional-commits` プラグイン**で、**コミットメッセージだけを解析**して SemVer を決定できます。 citeturn0search4

---

### 1. auto のワークフロー（最小構成）

```mermaid
graph TD
  subgraph 開発者
    A[feat/fix commit] -->|push| B(PR)
    B -- merge / squash --> C[main]
  end
  subgraph CI (GitHub Actions)
    C -->|auto version| D[バージョン算出]
    D -->|auto changelog| E[CHANGELOG更新]
    E -->|auto release| F[タグ+GitHub Release]
    F -->|auto publish| G[npm publish(optional)]
  end
```

* **`auto version`** – 変更から `major / minor / patch` を決定  
* **`auto changelog`** – 最新エントリを先頭に追加  
* **`auto release` / `shipit`** – タグ作成・GitHub Release投稿  
* **`auto publish`** – `npm publish`（オプション。pnpm/yarn も対応）

---

### 2. Conventional Commits を使うときの設定例

<details>
<summary><code>.autorc</code>（JSON でも JS でも可）</summary>

```jsonc
{
  "baseBranch": "main",
  "plugins": [
    // 既存の label 流儀を止める
    ["omit-label", { "omitReleaseNotes": true }],

    // コミット解析で semver を決定
    "conventional-commits",

    // GitHub Release 用の定型文を生成
    ["release-notes", {
      "sections": {
        "feat":  "✨ Features",
        "fix":   "🐛 Fixes",
        "chore": false        // CHANGELOG には残すが Release には載せない
      }
    }]
  ]
}
```
</details>

| コミットメッセージ | auto が付けるバージョン |
|-------------------|-------------------------|
| `feat: カメラ撮影機能を追加` | **MINOR** |
| `fix: ログイン画面のクラッシュ` | **PATCH** |
| `refactor!: API v2 に移行` または <br>`BREAKING CHANGE:` フッター | **MAJOR** |

citeturn0search4

---

### 3. GitHub Actions スニペット

```yaml
name: Release with auto + CC
on:
  workflow_dispatch:          # 手動実行
  push:                       # 任意で main push にも
    branches: [main]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: npx auto shipit --github-token "${{ secrets.GITHUB_TOKEN }}"
```

*`auto shipit` は **version → changelog → tag → GitHub Release → publish** をワンショットで実行。  
CI 実行／ローカル実行のいずれも同じコマンドなのでテストもしやすい。* citeturn0search0turn0search9

---

### 4. モノレポでのポイント

| シナリオ | 設定のコツ |
|----------|-----------|
| **全パッケージを同一バージョンでリリース** | そのまま root で使う（`auto shipit` が単一タグ `v1.2.3`） |
| **ワークスペースごとに独立リリース** | `--workspaces` フラグか <br>`import '@auto-it/workspaces'` プラグインで<br>**`packages/foo@1.2.3`** タグが個別に発行される |
| **Conventional Commits + モノレポ** | `conventional-commits` と `workspaces` を併用すると、各パッケージ配下のコミットだけをスコープに含めて判定 |

※ PR ラベル運用と Conventional Commits を **同時に有効**にすることも可能。  
`label` が優先 → 無ければ Conventional Commits を解析、という二段階判定がデフォルト動作です。 citeturn0search4

---

### 5. 実運用で感じる “良い点・気をつける点”

| 👍 便利 | ⚠️ 注意 |
|--------|--------|
| * プラグイン追加だけで Conventional Commits に切替可能（既存ラベル運用も壊れない） | * **squash merge** 時は “コミット 1 つ” になるため、PR で feat / fix が混在するとバージョン判定がブレることがある citeturn0search2 |
| * `auto pr create` で “Release PR” を作る手動確認フローも用意 | * プラグインが多機能なぶん、設定項目がやや多め |
| * `shipit --dry-run` が詳細シミュレーションを出力 → 想定外のメジャーアップを防げる | * 本番 CI と同一 Node バージョンを使わないと `auto` の plugin 解決が失敗することがある |

---

## まとめ — Conventional Commits × auto

1. **サポート状況**  
   *公式プラグイン `conventional-commits` が正式サポート*。  
   feat/fix/! のルールで SemVer を自動決定。 citeturn0search4  
2. **導入コスト**  
   `npm i -D auto @auto-it/conventional-commits` → `.autorc` で plugin 追加 → CI に `auto shipit` 1 行。  
3. **適しているケース**  
   - PR ラベル運用から **段階的に Conventional Commits へ移行**したい  
   - **Release PR で人間の目を入れつつ**、タグ＆GitHub Release は全自動  
   - **モノレポ**でも “全体 1 タグ”／“パッケージ個別” の両方を即切替したい  
4. **代替ツールとの棲み分け**  
   - **より軽量に CHANGELOG だけ欲しい** → `changelogen` / `git-cliff`  
   - **内部依存を厳密に追従** → `Changesets` / `beachball`  
   - **完全自動でコミット解析だけ** → `semantic-release`

> **結論**:  
> auto は **Conventional Commits 対応済み**。  
> “**ラベル駆動とコミット駆動のハイブリッド**” ができるため、既存運用を崩さずに  
> **バージョン判定の正確さ**と**リリース工程の全自動化**を両立できます。

---

## 👤 ユーザー
*2025/6/3 21:07:46*

そもそも自分の戦略が間違っていたかもしれない。

まず、workflow\_dispatchでGitHub側でリリースノートとtagをリモート上で作成して、諸々のリリースが終わった後に、changelogを更新する運用がいいように思える。

release-pleaseなどはバージョンアップのPRが発行されるがそれで更新すると、また、changelog更新のPRが生成されてしまい、無限ループに陥るためである。

そうなると、シンプルなchangelog更新ライブラリと、GitHub Actions で workflow\_dispatch でタグ名をinputで渡して、バリデーションして、リリースノートのurlを組み立てるような半自動スクリプトや、それをmainブランチで実行できるようなcliのライブラリを探せばいいことになる。

何か良い選択肢がないか？また、こう考えている運用についてどう思うか聞きたい。

name: Generate Tag & Release Note

on:
  workflow\_dispatch:
    inputs:
      tag:
        description: 'Tag name (e.g., 1.0.2, 1.0.2-rc.1)'
        required: true
        default: '0.0.0'

env:
  RELEASE\_NOTE\_URL: null
  SLACK\_USERNAME: DeployBot
  SLACK\_ICON: https://github.githubassets.com/images/modules/logos\_page/GitHub-Mark.png
  SLACK\_WEBHOOK: ${{ secrets.SLACK\_WEBHOOK\_URL }}

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:

    # Generate Tag & Release Note
    - name: Generate Release Note URL and Validate Tag
      run: |
        # Check tag format
        TAG\_FORMAT="^(\[0-9\]+\\.\[0-9\]+\\.\[0-9\]+(-rc\\.\[0-9\]+)?)$"
        if \[\[ ! "${{ github.event.inputs.tag }}" =~ $TAG\_FORMAT \]\]; then
          echo "Error: Invalid tag format!"
          exit 1
        fi
        
        # Extract branch name from github.ref
        BRANCH\_NAME=$(echo ${{ github.ref }} | sed 's/refs\\/heads\\///')
        
        # Print the release note URL
        RELEASE\_NOTE\_URL="https://github.com/suguruTakahashi-1234/fia-practical-sample/releases/new?tag=${{ github.event.inputs.tag }}&title=${{ github.event.inputs.tag }}&target=$BRANCH\_NAME&prerelease=1"
        echo "RELEASE\_NOTE\_URL=$RELEASE\_NOTE\_URL" &gt;&gt; $GITHUB\_ENV
        echo "Release note URL: $RELEASE\_NOTE\_URL"

    # Success
    - name: Slack Notification on Success
      uses: rtCamp/action-slack-notify@v2
      if: success()
      env:
        SLACK\_TITLE: Generate Tag & Release Note / Success
        SLACK\_COLOR: good
        SLACK\_MESSAGE: "${{ env.RELEASE\_NOTE\_URL }}"

    # Failure
    - name: Slack Notification on Failure
      uses: rtCamp/action-slack-notify@v2
      if: failure()
      env:
        SLACK\_TITLE: Generate Tag & Release Note / Failure
        SLACK\_COLOR: danger
        SLACK\_MESSAGE: Failure Generate Tag & Release Note

---

## 🤖 アシスタント
*2025/6/3 21:08:06*

### 個人的所感 — “**タグ → リリース → CHANGELOG**” の順は理にかなうか？

* **○ ループを回避**  
  *release-please* 型の “Version-PR → マージ → また PR…” 問題をきれいに断てます。  
* **○ ヒューマンチェックを残せる**  
  workflow_dispatch ならタグ名を人間が入力 → CI が最低限の検証だけ実施。  
* **○ CI が軽くなる**  
  CHANGELOG 生成は **タグで差分が確定してから 1 回だけ**走ればよい。  
* **△ 手動入力の負荷**  
  入力ミスやタグ名重複は追加チェック（`git tag --list "$tag"`）が必須。  
* **△ 「最新版の CHANGELOG が常に main にある」状態にはならない**  
  ただ PM/ユーザへは Release Note を使うので大抵のチームで実害は小。

> **結論:**  
> 「**タグ＆リリースを先に GitHub 上で確定し、あとから CHANGELOG を一括反映**」は十分アリ。  
> あとは *薄い* CLI を 2 つ揃えるだけで回ります。  

---

## 1️⃣ タグ＆リリースを作る超小型ツール

| 候補 | 方式 | 使い方 | メリット |
|------|------|-------|---------|
| **GitHub CLI (`gh`)** | API ラッパ | ```bash
git tag -a "$TAG" -m "chore(release): $TAG"
git push origin "$TAG"
gh release create "$TAG" --generate-notes
``` | *公式サポート*。`--generate-notes` で GitHub の **自動 Release Note** がそのまま出力 citeturn0search1turn0search4 |
| **gh-action-tag-release** (Marketplace) | Action | `uses: softprops/action-gh-release@v2`<br>`with: tag_name: ${{ inputs.tag }}` | YAML3行・保守不要。`draft: true` で社内レビューも可 |
| **semver-cli + gh** | Node script | `npx semver "$TAG"` で厳密検証 ➜ gh CLI | 既存 shell に *1 行* 足すだけ |

> **ポイント**  
> GitHub が 2024 年末に追加した “**自動生成 Release Note**” API を叩けば、  
> **CHANGELOG が無くても** feat / fix だけをまとめた Release Note が出来上がります。 citeturn0search7  

---

## 2️⃣ CHANGELOG を後から流し込む軽量ジェネレータ

| ツール | 1 コマンド例 | 特徴 |
|--------|-------------|------|
| **git-cliff** (Rust) | `git cliff -o CHANGELOG.md` | *超高速*・テンプレート自由・Conventional Commits 解析  citeturn0search0turn0search3 |
| **git-chglog** (Go) | `git-chglog --next-tag $TAG -o CHANGELOG.md` | バイナリ 3 MB・タグ差分ベース・既読性高 citeturn0search2 |
| **conventional-changelog CLI** (Node) | `conventional-changelog -p angular -i CHANGELOG.md -s` | 依存ゼロ JS・npm script に溶け込む |

どれも **“タグ間差分を取って Markdown を吐くだけ”** なので、  
Release 自体とは完全に分離できます。

---

## 3️⃣ 参考ワークフロー（2 つの Action に分離）

### A. `tag-release.yml`（手動 dispatch）

```yaml
name: Tag & Release
on:
  workflow_dispatch:
    inputs:
      tag: { description: 'e.g. 1.2.3', required: true }

jobs:
  release:
    runs-on: ubuntu-latest
    permissions: { contents: write }
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      # semver & 重複チェック
      - name: Validate tag
        run: |
          [[ "${{ github.event.inputs.tag }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-rc\.[0-9]+)?$ ]] || {
            echo "::error::Invalid semver"; exit 1; }
          git tag --list "${{ github.event.inputs.tag }}" | grep -q . && {
            echo "::error::Tag exists"; exit 1; }

      # タグ → GitHub Release （自動ノート）
      - run: |
          git tag -a "${{ github.event.inputs.tag }}" -m "chore(release): ${{ github.event.inputs.tag }}"
          git push origin "${{ github.event.inputs.tag }}"
          gh release create "${{ github.event.inputs.tag }}" \
            --generate-notes --verify-tag \
            --title "${{ github.event.inputs.tag }}"

      # Slack 通知など
```

### B. `update-changelog.yml`（`release` イベントで自動）

```yaml
name: Update CHANGELOG
on:
  release:
    types: [published]

jobs:
  changelog:
    if: github.event.release.prerelease == false   # 正式版のみ
    runs-on: ubuntu-latest
    permissions: { contents: write }
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - run: |
          git cliff -o CHANGELOG.md
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "docs(changelog): ${GITHUB_REF_NAME#refs/tags/}"
          git push origin HEAD:main
```

* **無限ループしない** -- Release がトリガ → CHANGELOG commit → **タグは打たない**。  
* draft/prerelease の場合はスキップできるので、正式公開だけ履歴に残ります。

---

## 4️⃣ 提案運用のメリット・デメリット

| | メリット | デメリット | 対策 |
|---|----------|-----------|-------|
| **タグ先行** | *バージョン衝突が起きにくい*／失敗しても CHANGELOG は未更新 | 入力ミスでタグ消しが面倒 | semver  + 重複タグ検査を CI に |
| **自動 Release Note** | PM 向けに十分／UI で追記も可 | テンプレ美観は GitHub 依存 | `gh release edit` で追記自動化も可 |
| **CHANGELOG 後追い** | git ベースなので高速・差分が明確 | “main に最新版がない瞬間” が数分生じる | small team なら許容範囲。大規模なら fast-forward 必須に |

---

## まとめ：この戦略で行くなら

1. **タグ & リリース**  
   *GitHub CLI*（`gh release create --generate-notes`）を **workflow_dispatch** で実行。  
   → PM へ即時共有可。  
2. **CHANGELOG**  
   Release 公開トリガで **git-cliff** などを 1 回回し、  
   `main` へ “docs(changelog): 1.2.3” を自動コミット。  
3. **ループは起きない**  
   タグを触るのは手動フローだけ／CHANGELOG 側はタグを打たない。  
4. **将来拡張**  
   prerelease, nightly なども **workflow_dispatch 入力**を増やすだけ。  

> **おすすめ最小セット**  
> *`gh` + `git-cliff`*  
> どちらも **単体バイナリ / 依存ゼロ**で速く、  
> `gh` は GitHub API の進化（自動リリースノート精度向上など）をそのまま享受できます。 citeturn0search0turn0search1turn0search4turn0search7

---

## 👤 ユーザー
*2025/6/3 21:15:24*

思ったのが、workflow\_dispatchで実行する必要はあるのか？ cli で実行の方が良かったりしないか？メリットデメリットを教えて欲しい。

CHANGELOG更新はPRがいいと思う。直プッシュは避けたい。

---

## 🤖 アシスタント
*2025/6/3 21:15:57*

### ❶ `workflow_dispatch` vs ローカル CLI—比較表

| 観点 | **workflow_dispatch (Actions)** | **ローカル CLI (`gh`, shell, npm-script… )** |
|------|---------------------------------|---------------------------------------------|
| **実行環境の一貫性** | GitHub が提供する Linux イメージで常に同じバージョンの Node／git／gh が使える。再現性・監査が高い。citeturn0search1turn0search7 | 開発者ごとのローカル環境に依存。`gh` やトークン設定漏れで失敗することがある。 |
| **UI/UX** | Actions タブの **Run workflow ボタン**で誰でも実行可。PM でもタグ入力だけでリリース可能。citeturn0search1 | ターミナル必須。操作に git 権限や CLI 知識が要る。 |
| **ログ／監査** | 実行ログが Actions に残る。タグや Release を誰がいつ作成したか一覧で追跡。 | git と Release の履歴は残るが「コマンド実行ログ」は個人 PC。事故調査が面倒。 |
| **セキュリティ** | PAT/GITHUB_TOKEN の権限を **最小**に設定できる。リポジトリ外にトークンが漏れにくい。 | 各開発者が PAT をローカル保存。社外 PC から操作すると漏えいリスク。 |
| **入力ミス防止** | YAML で入力検証 (`if` / 正規表現) を強制し易い。 | 手元スクリプトでも可能だが CI より統制が弱い。 |
| **速度／待ち時間** | キュー待ち・Runner 起動で 10–30 s 増える。Actions 分課金もかかる。 | push & `gh release create --generate-notes` まで数秒。速い。citeturn0search0 |
| **拡張性** | 後から Slack 通知・SNS 配信を **同じ Workflow** に追加しやすい。 | ローカルで複数 CLI を組むとスクリプト肥大化。 |
| **オフライン作業** | 不可 | 可能（VPN 接続で push 後に Release は後回しでも可） |

**まとめ**  
*小人数／高速優先*なら **CLI**、  
*監査・共有優先*＋*誰でも押せる* を重視するなら **workflow_dispatch** が安全。

---

### ❷ CHANGELOG を **PR 経由で更新**するワークフロー

1. **リリース確定**（CLI でも Actions でも OK）  
   ```bash
   git tag -a 1.2.3 -m "release: 1.2.3"
   git push origin 1.2.3
   gh release create 1.2.3 --generate-notes     # 自動 Release Noteciteturn0search0
   ```

2. **`release` イベントで CHANGELOG 生成 → PR**  
   ```yaml
   name: Changelog PR
   on:
     release:
       types: [published]

   jobs:
     changelog:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
           with: { fetch-depth: 0 }
         - uses: orhun/git-cliff@v2 # ✨Rust製・高速citeturn0search2turn0search11
           with:
             args: -o CHANGELOG.md
         - uses: peter-evans/create-pull-request@v7    # 変更を自動 PRciteturn1search0
           with:
             commit-message: "docs(changelog): ${GITHUB_REF##*/}"
             title: "docs: Update CHANGELOG for ${GITHUB_REF##*/}"
             branch: chore/update-changelog-${{ github.ref_name }}
   ```

* **メリット**  
  * main への直 push を避け、レビュー→マージで確定。  
  * `git-cliff` はタグ差分で生成するため **Release → CHANGELOG** の順でも破綻しない。  
* **デメリット対策**  
  * PR 待ちで CHANGELOG が少し遅れる → タイトルにバージョンを入れて検索しやすく。  

---

### ❸ どちらを採用するかの指針

| チーム状況 | 推奨パス |
|------------|----------|
| **社内に Release 専任者がいる / Actions 実行権限を限定したい** | ★ **workflow_dispatch** — UI で入力 → 全操作ログが CI に残る。 |
| **OSS や個人開発で頻繁にパッチを出す / 回線が細い** | ★ **ローカル CLI** — 手元で即タグ→Release。CI は CHANGELOG PR だけ。 |
| **どちらも併用したい** | タグ＆Release は CLI で実行可能にした上で、<br>「Run workflow ボタン」も残しておく（同じシェルを再利用） |

---

### ❹ 推奨ツールセット（どちらの場合でも共通）

| 役割 | ツール | 理由 |
|------|--------|------|
| タグ & Release | **GitHub CLI `gh`** | `--generate-notes` で GitHub の自動リリースノート API を活用 citeturn0search0 |
| セマンティック検証 | **semver-cli** or `grep -E` | 失敗前にフォーマットチェック |
| CHANGELOG 生成 | **git-cliff** | Conventional Commits & 高速テンプレート citeturn0search2 |
| PR 作成 | **peter-evans/create-pull-request** | 変更をブランチ化して自動 PR citeturn1search0 |

---

## ✅ まとめ

* **CLI 方式**は速くシンプル。開発者が完全に把握している環境では最小摩擦。  
* **workflow_dispatch** は UI・ログ・権限制御を GitHub に丸投げでき、  
  チーム規模が大きくなるほどトラブル対応が楽。  
* CHANGELOG は **タグ確定後に git-cliff で生成 → PR でレビュー** がループも避けて安全。  
* 迷うなら **両方同じシェルを呼ぶ**設計にし、CLI or Actions を自由に選べる形から始めると移行コストがほぼゼロです。

---

## 👤 ユーザー
*2025/6/3 21:30:36*

git-cliff は cliff.toml の編集があまり馴染みがなくて使うのが微妙である。

on:
  release:
    types: \[published\]

のトリガーでconfigファイルが簡単に設定できて、 公式のuses があってConventional Commitsに対応しているツールはないか？

---

## 🤖 アシスタント
*2025/6/3 21:32:17*

### “cliff.toml を書かずに済む” ＋ “公式 `uses:` がある” ＋ “Conventional Commits対応” の 2 強

| Action | 役割 | 典型的な設定 | 特徴 |
|--------|------|-------------|------|
| **requarks/changelog-action** | 最新タグと前タグの **コミット差分を Conventional Commits で解析**し、`CHANGELOG.md` またはリリース本文を生成 | ```yaml
- uses: requarks/changelog-action@v1
  with:
    token: ${{ secrets.GITHUB_TOKEN }}
    fromTag: ${{ github.event.release.previous_tag_name }}
    toTag:   ${{ github.event.release.tag_name }}
    outputFile: CHANGELOG.md          # 省けばSTDOUT
``` | *✔ コンフィグ不要*：`with:` に 3-4 行書くだけ  
*✔ 生成物を `stdout` にも出せる* ので PR でもコメントでも自由に流用可 citeturn0search3 |
| **TriPSs/conventional-changelog-action** | Conventional Commitsを基に **バージョン bump／タグ／CHANGELOG** まで一括生成 | ```yaml
- uses: TriPSs/conventional-changelog-action@v6
  with:
    git-message: 'docs(changelog): ${TAG}'
    skip-version-file: true          # ← version.json 等が無ければ必ず付ける
    skip-tag: true                   # ← 既にタグがある前提
    output-file: CHANGELOG.md
``` | *✔ `.autorc` 等の外部ファイルなし*  
*✔ bump/tag を **個別に無効化** できるので “CHANGELOG だけ” に絞れる citeturn0search0 |

> **どちらも**  
> *GitHub Marketplace に公式 Action があり*、`on: release: [published]` でそのまま動きます。  

---

## 推奨ワークフロー（CHANGELOG は PR、タグは既にある想定）

```yaml
# .github/workflows/changelog-pr.yml
name: Changelog PR
on:
  release:
    types: [published]

jobs:
  changelog:
    runs-on: ubuntu-latest
    permissions:
      contents: write      # create-pr が push するため
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      # ① CHANGELOG を Conventional Commits で生成 (toml 不要)
      - uses: requarks/changelog-action@v1        # ← or TriPSs/… に差し替え可
        id: changelog
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fromTag: ${{ github.event.release.previous_tag_name }}
          toTag:   ${{ github.event.release.tag_name }}
          outputFile: CHANGELOG.md

      # ② 自動 PR を作成
      - uses: peter-evans/create-pull-request@v7
        with:
          title: 'docs: Update CHANGELOG for ${{ github.event.release.tag_name }}'
          commit-message: 'docs(changelog): ${{ github.event.release.tag_name }}'
          branch: chore/update-changelog-${{ github.event.release.tag_name }}
          body: |
            🔖 **CHANGELOG** を ${{
              github.event.release.tag_name }} 向けに更新しました。
```

### ここがポイント
| | 説明 |
|---|------|
| **コンフィグ不要** | `requarks/changelog-action` は Conventional Commits の *プリセット*が既に入っているため `feat`,`fix`,`perf`,`refactor!` などを自動分類。 `CHANGELOG.md` テンプレもデフォルトで整っています。 |
| **PR 経由にしたい** | 生成した `CHANGELOG.md` をその場でコミットせず、`create-pull-request` へパイプ。 main ブランチは保護したまま。 |
| **無限ループしない** | トリガーは **release→PR** なので、PR マージが再度 `release` を起こすことはありません。 |
| **タグ検証は前段で済んでいる** | タグは手動 CLI / 別 workflow で作成済み → ここでは **差分生成だけ** に集中。 |

---

## CLI vs Actions（再掲の文脈で）

| 判断基準 | CLI 実行 | `on: release` Action |
|----------|----------|----------------------|
| **設定の簡単さ** | 手元で `npx changelog-action` の 1 行でも可 | YAML に `uses: requarks/changelog-action` を書くだけ（ほぼ同じ手間） |
| **統一環境 / ログ** | PC ごとに差が出る | **Actions に残るログ＋再実行** が利く |
| **保護ブランチ** | ローカル push 権が必要 | `create-pull-request` が PR を開くのでポリシーを崩さない |

今回「**CHANGELOG は必ず PR**」という条件なので、  
*CLI 手動 → git push* でも **PR を自分で開く手間** が増えます。  
**Release イベント → Action → PR 自動生成** の方がワンステップ少なく、事故も減るでしょう。

---

### まとめ

* **git-cliff が馴染まない**場合は  
  *公式 Action があり* *設定ファイル不要* な  
  **requarks/changelog-action**（最軽量）か  
  **TriPSs/conventional-changelog-action**（細かなスキップが利く）  
  が Conventional Commits ベースでは最もストレート。  
* トリガーは `on: release: [published]`、出力は `create-pull-request` に渡すだけで **PR 更新**フローが完成。  
* これにより **タグ → GitHub Release → CHANGELOG PR** の 1 方向パイプラインとなり、  
  ループも main 直 push も無く、メンテナンス性が高い運用になります。

---

## 👤 ユーザー
*2025/6/3 21:37:35*

どちらもあまり有名なツールではなかった。公式 uses: がなくても設定がある程度type safeで簡単にできて、Conventional Commits 
対応で、tag での自動生成が追加できるようなワンライナーで実行できるcliの選択肢はないか？

---

## 🤖 アシスタント
*2025/6/3 21:38:15*

### “設定ファイルを極力書かず 1 コマンドで動く” + **Conventional Commits 対応** + **タグも自動**  
──という条件なら、いま実戦投入しやすい CLI は **3 つ**に絞られます。

| CLI | インストール | “ワンライナー” 例 | 何が行われる？ | 設定ファイル | 補足 |
|-----|--------------|-------------------|----------------|--------------|------|
| **release-it ＋ @release-it/conventional-changelog** | `pnpm add -D release-it @release-it/conventional-changelog` | `npx release-it` | ① Conventional Commits を解析 → 推奨バージョン決定<br>② `CHANGELOG.md` 追記<br>③ **タグ**を `v1.2.3` で作成 & push | _optional_：`"release-it"` を `package.json` に書くだけ。JS/TOML/YAML も可（型定義あり） citeturn0search0 | *プラグイン方式*なので将来 `npm publish` 等も同じ1行に追加できる |
| **standard-version** | `pnpm add -D standard-version` | `npx standard-version` | ① Conventional Commits 解析<br>② `CHANGELOG.md` 追記<br>③ **タグ**を作成<br>④ 変更を _1 コミット_ にまとめて push | _不要_（デフォルトで “angular” プリセット）<br>オプションは全て CLI フラグで完結 citeturn0search1 | commit や tag メッセージを `-m` `--tag-prefix` で都度指定＝**完全コードレス** |
| **sv4git** (Go製・単体バイナリ) | `curl -L …/sv4git > /usr/local/bin/sv4git` | `sv4git release` | ① コミット lint (CC 準拠か確認)<br>② **バージョン計算 & タグ**<br>③ `CHANGELOG.md` 生成 | _不要_（YAML も書けるが省略可） citeturn1search1 | Git だけあれば動く — Node 依存ゼロ / クロスプラットフォーム |

---

## 最小セットアップ例（release-it）

1. **Install**  
   ```bash
   pnpm add -D release-it @release-it/conventional-changelog
   ```

2. **package.json に 3 行だけ**  
   ```json
   {
     "release-it": {
       "plugins": {
         "@release-it/conventional-changelog": { "preset": "angular" }
       }
     }
   }
   ```

3. **Run**  
   ```bash
   npx release-it          # 対話モードで next version を提案
   npx release-it --ci     # 対話なしで実行（CI 用）
   ```
   *タグ (`vX.Y.Z`)、CHANGELOG、GitHub Release* が一度に生成されます。  
   設定を JS/TS ファイルにすると **型補完**が効くので「type safe」。

---

## “タグ ⇒ リリース ⇒ CHANGELOG PR” パターンでの使い分け

| フェーズ | オススメワンライナー | 理由 |
|---------|---------------------|------|
| **手元でタグ & リリースを確定** | `npx standard-version --release-as minor --git-tag` | 最短：設定ゼロ／タグだけ押して止めるなら `--skip.changelog` |
| **CI で CHANGELOG を生成して PR** | `npx release-it --ci --no-git.tag --no-git.requireCleanWorkingDir`<br>*(もしくは)* `sv4git changelog` | タグは既にある前提で “差分だけ” 書き出せる；どちらも **config なし**で Conventional Commits を解析できます |

---

## メリット / デメリット早見

| | release-it | standard-version | sv4git |
|--|------------|-----------------|--------|
| **導入の容易さ** | ★★★☆（plugin 1 行） | ★★★★（本体だけ） | ★★★（バイナリコピー） |
| **設定の型安全** | JS/TS で完全補完 | CLI フラグのみ | YAML optional |
| **拡張性（npm publish など）** | 高 – plugin 追加 | 中 – postrelease script | 低 – release 固定 |
| **Node 依存ゼロ** | × | × | ○ |
| **メンテの継続性** | 8 k★ で活発 citeturn0search0 | 7 k★ で安定 citeturn0search1 | 0.5 k★ だが単体バイナリで気軽 citeturn1search1 |

---

### まとめ

* **「一番メジャーで、あとから publish や Slack 通知を足したい」**  
  → **release-it** ＋ `@release-it/conventional-changelog`
* **「設定ファイルすら書きたくない / package.json だけで完了させたい」**  
  → **standard-version**
* **「Node 依存を置きたくない・Go/Rust 環境に乗りたい」**  
  → **sv4git**

いずれも **タグ生成 ↔ CHANGELOG 生成を個別に ON/OFF** できるので、  
今の「タグとリリースは先に確定 → `release` イベントで CHANGELOG PR」という運用にぴったりフィットします。

---
