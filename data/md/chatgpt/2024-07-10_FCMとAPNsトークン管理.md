# FCMとAPNsトークン管理

日付: 2024-07-10

---

## 👤 ユーザー
*2024/07/10 16:19:28*

FCM Token と APNs Token のそれぞれの寿命

---

## 🤖 アシスタント
*2024/07/10 16:19:50*

FCM Token（Firebase Cloud Messaging Token）と APNs Token（Apple Push Notification Service Token）は、プッシュ通知を送信するために必要なデバイスの識別子です。それぞれの寿命について説明します。

### FCM Token
- **寿命**: 通常、FCM Token の寿命は無期限ですが、いくつかの理由で変更されることがあります。以下のような場合に新しいトークンが生成されます：
  - アプリがアンインストールされて再インストールされた場合
  - ユーザーがアプリのデータを消去した場合
  - ユーザーが新しいデバイスにアプリをインストールした場合
  - トークンの更新が明示的にリクエストされた場合
  - セキュリティ上の理由でトークンが無効化された場合

### APNs Token
- **寿命**: APNs Token の寿命も通常無期限ですが、以下の理由で変更されることがあります：
  - デバイスが iOS をアップデートした場合
  - ユーザーがデバイスの設定を変更した場合
  - アプリがアンインストールされて再インストールされた場合
  - APNs がトークンをリフレッシュすることを要求した場合

### トークンの管理
- いずれのトークンも無期限であることが多いですが、アプリケーションの実装においてはトークンの変更を常に監視し、必要に応じてサーバーに新しいトークンを送信するようにすることが重要です。
- FCM Token については、`onNewToken` コールバックを利用して、新しいトークンが生成された際に処理を行います。
- APNs Token については、`didRegisterForRemoteNotificationsWithDeviceToken` デリゲートメソッドで、新しいトークンが取得された際に処理を行います。

これにより、プッシュ通知が適切にデバイスに配信され続けるようにトークンを管理できます。

---

## 👤 ユーザー
*2024/07/10 16:20:34*

ユーザーがログアウトした際にはどのようにToken を登録すればよいか？

---

## 🤖 アシスタント
*2024/07/10 16:21:16*

ユーザーがログアウトした際のトークンの登録に関しては、セキュリティとプライバシーを考慮する必要があります。以下の手順でトークンを適切に処理する方法を説明します。

### FCM Token
1. **トークンの無効化**: ユーザーがログアウトした際に、サーバー側で該当する FCM Token を無効化または削除します。これにより、ログアウト後にそのトークンへの通知が送信されないようにします。
2. **トークンの再取得**: ユーザーが再度ログインした際に、新しい FCM Token を取得してサーバーに登録します。

#### iOS の例
```swift
import Firebase

func logoutUser() {
    // トークンの無効化処理（サーバー側にトークン無効化リクエストを送信）
    if let fcmToken = Messaging.messaging().fcmToken {
        // サーバーに無効化リクエストを送信する
        sendTokenToServer(token: fcmToken, action: "invalidate")
    }

    // ユーザーのログアウト処理
    Auth.auth().signOut()
}

func loginUser() {
    // ユーザーのログイン処理
    Auth.auth().signIn()

    // 新しいトークンの取得
    Messaging.messaging().token { token, error in
        if let error = error {
            print("Error fetching FCM registration token: \(error)")
        } else if let token = token {
            print("FCM registration token: \(token)")
            // サーバーに新しいトークンを登録
            sendTokenToServer(token: token, action: "register")
        }
    }
}

func sendTokenToServer(token: String, action: String) {
    // サーバーにトークンを送信する実装
}
```

### APNs Token
APNs トークンについても同様のアプローチが適用されます。ログアウト時にトークンをサーバーから削除し、ログイン時に新しいトークンを再登録します。

#### iOS の例
```swift
import UserNotifications

func logoutUser() {
    // APNs トークンの無効化処理（サーバー側にトークン無効化リクエストを送信）
    if let apnsToken = UserDefaults.standard.string(forKey: "apnsToken") {
        // サーバーに無効化リクエストを送信する
        sendTokenToServer(token: apnsToken, action: "invalidate")
    }

    // ユーザーのログアウト処理
    // ログアウト処理を実行
}

func loginUser() {
    // ユーザーのログイン処理
    // ログイン処理を実行

    // 新しい APNs トークンの取得
    UNUserNotificationCenter.current().getNotificationSettings { settings in
        if settings.authorizationStatus == .authorized {
            DispatchQueue.main.async {
                UIApplication.shared.registerForRemoteNotifications()
            }
        }
    }
}

func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    let tokenParts = deviceToken.map { data in String(format: "%02.2hhx", data) }
    let token = tokenParts.joined()
    print("Device Token: \(token)")

    // サーバーに新しいトークンを登録
    sendTokenToServer(token: token, action: "register")

    // トークンを保存（再ログアウト時の無効化のため）
    UserDefaults.standard.set(token, forKey: "apnsToken")
}

func sendTokenToServer(token: String, action: String) {
    // サーバーにトークンを送信する実装
}
```

### 注意点
- トークンの無効化と再取得の処理は、サーバー側で適切に実装する必要があります。
- トークンの登録・無効化リクエストはセキュアな通信（HTTPS）を使用して行います。
- ユーザーが再ログインするまでは通知を受け取らないようにするため、トークンの無効化は必須です。

これにより、ユーザーがログアウトした後に不要な通知を受け取ることを防ぐことができます。

---

## 👤 ユーザー
*2024/07/10 16:28:15*

サーバーサイドはどちらのトークンを保存するべき？

---

## 🤖 アシスタント
*2024/07/10 16:29:02*

サーバーサイドでは、どちらのトークンも保存することが一般的です。なぜなら、iOS デバイスにプッシュ通知を送信するためには APNs トークンが必要ですが、通知送信のための統一された管理を行うためには FCM トークンが必要です。以下に、どちらのトークンをどのように保存するかについての詳細を説明します。

### 1. APNs Token
- **用途**: Apple Push Notification Service を介して iOS デバイスに直接通知を送信するために使用します。
- **保存方法**: ユーザーごとに APNs トークンをデータベースに保存します。

### 2. FCM Token
- **用途**: Firebase Cloud Messaging を介してクロスプラットフォームでの通知を送信するために使用します。FCM は内部的に APNs を利用して iOS デバイスに通知を送信します。
- **保存方法**: ユーザーごとに FCM トークンをデータベースに保存します。

### 推奨される保存方法
#### データベースのスキーマ例
```sql
CREATE TABLE user_tokens (
    user_id VARCHAR(255) PRIMARY KEY,
    fcm_token VARCHAR(255) NOT NULL,
    apns_token VARCHAR(255) NOT NULL,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 保存の実装例（サーバーサイド）
以下は、サーバーサイドでトークンを保存する例です。この例では、Node.js と Express を使用していますが、他のサーバーサイド技術でも同様のアプローチが取れます。

```javascript
const express = require('express');
const bodyParser = require('body-parser');
const { Pool } = require('pg'); // PostgreSQL の場合

const app = express();
const pool = new Pool({
    connectionString: 'your_database_url'
});

app.use(bodyParser.json());

app.post('/register-token', async (req, res) => {
    const { userId, fcmToken, apnsToken } = req.body;

    if (!userId || !fcmToken || !apnsToken) {
        return res.status(400).send('Missing required fields');
    }

    try {
        const result = await pool.query(
            'INSERT INTO user_tokens (user_id, fcm_token, apns_token) VALUES ($1, $2, $3) ' +
            'ON CONFLICT (user_id) DO UPDATE SET fcm_token = $2, apns_token = $3, last_updated = CURRENT_TIMESTAMP',
            [userId, fcmToken, apnsToken]
        );

        res.status(200).send('Token registered successfully');
    } catch (err) {
        console.error('Error saving token:', err);
        res.status(500).send('Internal Server Error');
    }
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```

### トークンの更新
- **ユーザーがログインまたは再度トークンを取得した際に、最新のトークンをサーバーに送信して更新する必要があります**。前述の例では、`ON CONFLICT` SQL ステートメントを使用して既存のトークンを更新しています。

### トークンの無効化
- **ログアウト時には、トークンを無効化または削除することが推奨されます**。これにより、セキュリティとプライバシーが強化され、ユーザーが再ログインするまで通知が送信されないようにできます。

```javascript
app.post('/invalidate-token', async (req, res) => {
    const { userId } = req.body;

    if (!userId) {
        return res.status(400).send('Missing required fields');
    }

    try {
        const result = await pool.query(
            'UPDATE user_tokens SET fcm_token = NULL, apns_token = NULL WHERE user_id = $1',
            [userId]
        );

        res.status(200).send('Token invalidated successfully');
    } catch (err) {
        console.error('Error invalidating token:', err);
        res.status(500).send('Internal Server Error');
    }
});
```

### まとめ
サーバーサイドでは、APNs トークンと FCM トークンの両方を保存することで、プッシュ通知の送信に柔軟性を持たせることができます。ユーザーがログインおよびログアウトする際にこれらのトークンを適切に管理することで、セキュリティとユーザー体験の両方を向上させることができます。

---

## 👤 ユーザー
*2024/07/10 16:29:16*

FCMトークンだけで良くないのか？

---

## 🤖 アシスタント
*2024/07/10 16:30:06*

FCM トークンだけでプッシュ通知を管理することは多くの場合で十分です。実際、Firebase Cloud Messaging (FCM) は、APNs (Apple Push Notification Service) を介して iOS デバイスに通知を送信するための統合されたソリューションを提供します。

### FCM トークンのみを使用する利点
1. **統一された通知管理**: FCM を使用すると、iOS と Android デバイスの両方に対して統一されたインターフェースで通知を送信できます。これにより、サーバーサイドの実装がシンプルになります。
2. **自動ハンドリング**: FCM は APNs トークンを内部的に管理し、必要に応じて更新します。開発者は FCM トークンの管理に集中すれば良く、APNs トークンの個別管理は不要です。
3. **クロスプラットフォーム**: FCM を使用することで、複数のプラットフォームに対応する通知を一元的に管理できるため、マルチプラットフォームアプリケーションの開発が容易になります。

### 実装例
#### サーバーサイド
サーバーサイドでは、FCM トークンのみを保存し、管理することでプッシュ通知を送信できます。

##### データベースのスキーマ例
```sql
CREATE TABLE user_tokens (
    user_id VARCHAR(255) PRIMARY KEY,
    fcm_token VARCHAR(255) NOT NULL,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

##### 保存の実装例（Node.js と Express）
```javascript
const express = require('express');
const bodyParser = require('body-parser');
const { Pool } = require('pg'); // PostgreSQL の場合

const app = express();
const pool = new Pool({
    connectionString: 'your_database_url'
});

app.use(bodyParser.json());

app.post('/register-token', async (req, res) => {
    const { userId, fcmToken } = req.body;

    if (!userId || !fcmToken) {
        return res.status(400).send('Missing required fields');
    }

    try {
        const result = await pool.query(
            'INSERT INTO user_tokens (user_id, fcm_token) VALUES ($1, $2) ' +
            'ON CONFLICT (user_id) DO UPDATE SET fcm_token = $2, last_updated = CURRENT_TIMESTAMP',
            [userId, fcmToken]
        );

        res.status(200).send('Token registered successfully');
    } catch (err) {
        console.error('Error saving token:', err);
        res.status(500).send('Internal Server Error');
    }
});

app.post('/invalidate-token', async (req, res) => {
    const { userId } = req.body;

    if (!userId) {
        return res.status(400).send('Missing required fields');
    }

    try {
        const result = await pool.query(
            'UPDATE user_tokens SET fcm_token = NULL WHERE user_id = $1',
            [userId]
        );

        res.status(200).send('Token invalidated successfully');
    } catch (err) {
        console.error('Error invalidating token:', err);
        res.status(500).send('Internal Server Error');
    }
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```

### クライアントサイド
iOS デバイスでは、Firebase SDK を利用して FCM トークンを取得し、サーバーに登録します。

#### iOS の例
```swift
import Firebase

func registerForFCM() {
    Messaging.messaging().token { token, error in
        if let error = error {
            print("Error fetching FCM registration token: \(error)")
        } else if let token = token {
            print("FCM registration token: \(token)")
            // サーバーにトークンを登録
            sendTokenToServer(token: token)
        }
    }
}

func sendTokenToServer(token: String) {
    let url = URL(string: "https://your-server.com/register-token")!
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")

    let body: [String: Any] = ["userId": "your_user_id", "fcmToken": token]
    request.httpBody = try? JSONSerialization.data(withJSONObject: body, options: [])

    let task = URLSession.shared.dataTask(with: request) { data, response, error in
        if let error = error {
            print("Error sending token to server: \(error)")
        } else {
            print("Token successfully sent to server")
        }
    }
    task.resume()
}
```

### まとめ
FCM トークンのみを使用することで、プッシュ通知の管理がシンプルになり、クロスプラットフォーム対応の通知システムを容易に構築できます。APNs トークンを個別に管理する必要がないため、サーバーサイドのコードやデータベースの構造も簡素化されます。

---
