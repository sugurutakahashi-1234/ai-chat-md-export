# デリゲート変更: クロージャ, 通知, オブザーバー

日付: 2023-05-24

---

## 👤 ユーザー
*2023/5/24 9:14:53*

Swiftでのデリゲートパターンを他の実装に変えたいんだけど具体的にどうすればいいかおしえてほしい

---

## 🤖 アシスタント
*2023/5/24 9:15:41*

デリゲートパターンは非常に便利であり、iOS開発においては頻繁に用いられるパターンの一つです。しかしながら、時と場合によっては他のパターンの方がより適していることもあります。デリゲートパターンを他のパターンに変えるためには、実装したいパターンの特性を理解し、その適用方法を理解する必要があります。

以下に、デリゲートパターンから変えてみると良いパターンの一部を紹介します。

1. **クロージャ (Closure)**: Swiftでは、クロージャは実質的に「無名関数」です。デリゲートパターンを使用する代わりに、特定のタスクを実行するためのクロージャを受け取るメソッドを作成することができます。例えば、ボタンのクリックイベントを処理する代わりにクロージャを使用することができます。

```swift
class MyButton {
    var onClick: (() -> Void)?
    
    func click() {
        onClick?()
    }
}

let button = MyButton()
button.onClick = { 
    print("Button was clicked") 
}
button.click()
```

2. **通知パターン (Notification pattern)**: このパターンでは、あるオブジェクトが特定のイベントが発生したときに他のオブジェクトに通知します。これはデリゲートパターンと異なり、一つのイベントを多くのオブジェクトが監視することができます。これは NotificationCenter を使用して行うことができます。

```swift
let notificationName = Notification.Name("MyNotification")
NotificationCenter.default.addObserver(forName: notificationName, object: nil, queue: nil) { (notification) in
    print("Notification received")
}

NotificationCenter.default.post(name: notificationName, object: nil)
```

3. **オブザーバーパターン (Observer pattern)**: Swiftでは、Key-Value Observing (KVO) または Combine フレームワークを使用してオブザーバーパターンを実装することができます。このパターンでは、あるオブジェクトの状態の変更を他のオブジェクトが監視することができます。

デリゲートパターンは一対一のコミュニケーションを提供しますが、これらのパターンはより一般的なケースや多対多のコミュニケーションに適していることがあります。

---

## 👤 ユーザー
*2023/5/24 9:16:31*

await/asyncを使って書き直せないの？

---

## 🤖 アシスタント
*2023/5/24 9:17:07*

もちろんです、Swift 5.5以降では、非同期の処理を行うために `async`/`await` を使用することができます。デリゲートパターンを用いて非同期の処理を行っていた部分は、この新たな非同期APIを用いて書き換えることが可能です。

例えば、デリゲートパターンを使用した非同期のデータ取得を考えてみましょう。以下にそのデリゲートパターンによる実装を示します：

```swift
protocol DataFetcherDelegate {
    func dataFetched(_ data: Data)
    func dataFetchFailed(with error: Error)
}

class DataFetcher {
    var delegate: DataFetcherDelegate?

    func fetchData() {
        // Perform a network request or some other asynchronous operation
        // When the data is fetched, you call dataFetched(data:), and if there's an error, you call dataFetchFailed(with: error)
    }
}
```

そして、このコードを `async`/`await` を使った形に書き換えると次のようになります：

```swift
class DataFetcher {
    func fetchData() async throws -> Data {
        // Perform a network request or some other asynchronous operation
        // You can use `await` within this method to pause the execution until the data is fetched
        // If there's an error, you can simply `throw` it and handle it in the calling code
    }
}
```

ここで新たに導入された `async` キーワードはメソッドが非同期であることを示しています。このメソッドは `await` を使って呼び出す必要があり、呼び出し元はメソッドの完了を待つことになります。このような形で非同期の処理を行う場合、その処理が終了するまでの間、その他の処理をブロックすることなく進めることができます。

この `async`/`await` パターンを利用すると、デリゲートパターンを使うよりも直感的に非同期の処理を行うことができ、またエラーハンドリングもより簡単に行えます。

---

## 👤 ユーザー
*2023/5/24 9:17:13*

Combine でのobserveパターンをつかってほしい

---

## 🤖 アシスタント
*2023/5/24 9:17:38*

SwiftのCombineフレームワークを使って、オブザーバーパターンを実装することができます。ここでは、値の変化を監視し、その変化に応じて更新するシンプルな例を紹介します。

```swift
import Combine

class MyClass {
    // @Published はプロパティラッパーで、値が変更されたときにイベントを発行します。
    @Published var value: Int = 0
}

let myObject = MyClass()
var cancellables = Set<AnyCancellable>()

// myObject.value が変化するたびに、その変化を監視し、新しい値を印刷します。
myObject.$value
    .sink { newValue in
        print("Value changed to \(newValue)")
    }
    .store(in: &cancellables)

// 値を変更すると、その変更が印刷されます。
myObject.value = 10
myObject.value = 20
```

このコードでは、`@Published` プロパティラッパーを使って `value` プロパティの変更を監視します。その変更は `sink` オペレータを使って受け取り、その都度新しい値を印刷します。

Combineフレームワークは、データの変化を効率的に監視し、それに対応するアクションを実行する強力なツールです。これにより、デリゲートパターンや通知パターンに比べてより効率的かつ効果的なコードを書くことができます。

---
