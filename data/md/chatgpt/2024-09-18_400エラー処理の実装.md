# 400エラー処理の実装

日付: 2024-09-18

---

## 👤 ユーザー
*2024/9/18 15:00:27*

ここに 400 で"code": "content_filter", を検出してハンドリングしたい

    private func postMessage(
        threadId: Int,
        messageRequestDTO: MessageRequestDTO,
        isLastMessage: Bool = false
    ) async throws -&gt; Result&lt;Message, PostMessageError&gt; {
        do {
            let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
            return .success(message)
        } catch {
            guard let error = error as? OpenAPIClient.ErrorResponse else {
                throw APIError.unexpectedResponse
            }

            guard error.statusCode == 429,
                  let data = error.data,
                  let response429 = try? JSONDecoder().decode(ErrorDTO.self, from: data)
            else {
                throw APIError.unexpectedResponse
            }

            switch response429.code {
            case errorCodeRateLimit:
                return .failure(.rateLimit)
            default:
                throw APIError.unexpectedResponse
            }
        }
    }


extension ErrorResponse: LocalizedError, ErrorResponseProtocol {
    public var errorDescription: String? {
        if case .error(let code, let data, _, let error) = self {
            if let error = error as? URLError {
                // show NSURLErrorDomain code
                return "通信に失敗しました。通信状況をご確認いただき、もう一度お試しください。(\(error.errorCode))"
            }
            else if let data = data, let response = String(data: data, encoding: .utf8) {
                // show status code & response
                return "通信に失敗しました。通信状況をご確認いただき、もう一度お試しください。(\(code) - \(response))"
            }
            else {
                // got unknown error, show everything
                return "通信に失敗しました。通信状況をご確認いただき、もう一度お試しください。(\(self))"
            }
        }
        return nil
    }

    var statusCode: Int? {
        if case .error(let code, _, _, _) = self {
            return code
        }
        return nil
    }
    var data: Data? {
        if case .error(_, let data, _, _) = self {
            return data
        }
        return nil
    }
}

public enum ErrorResponse: Error {
    case error(Int, Data?, URLResponse?, Error)
}

{
  "code": "content_filter",
  "message": "The content was filtered. Please modify your prompt and retry."
}

---

## 🤖 アシスタント
*2024/9/18 15:00:37*

`400` エラーで `code: "content_filter"` を処理するためには、既存のエラーハンドリングに特定のロジックを追加して、"content_filter" エラーコードを検出し、それに応じた処理を行うようにします。以下のように、既存の `postMessage` メソッドにこのハンドリングを追加できます。

### 変更後のコード

```swift
private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch (error.statusCode, errorDTO.code) {
        case (400, "content_filter"):
            return .failure(.contentFilter) // 新たなエラーケースを追加
        case (429, _):
            return .failure(.rateLimit)
        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### `PostMessageError` に `contentFilter` を追加

`PostMessageError` の定義に新しいケースとして `contentFilter` を追加します。

```swift
enum PostMessageError: Error {
    case rateLimit
    case contentFilter // 新たなエラーケース
    // その他のエラーケース
}
```

### `ErrorDTO` の例

`ErrorDTO` が次のような構造であると仮定します:

```swift
struct ErrorDTO: Decodable {
    let code: String
    let message: String
}
```

これにより、`400` エラーが発生し、`"code": "content_filter"` を含むレスポンスが返ってきた場合、そのエラーを適切に処理し、`contentFilter` エラーとして失敗を返すことができます。

これで、"content_filter" に対応するエラーハンドリングが行えるようになります。

---

## 👤 ユーザー
*2024/9/18 15:01:32*

struct ErrorDTO: Codable {

    var code: String
    var message: String

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }
}

だった。

---

## 🤖 アシスタント
*2024/9/18 15:01:43*

`ErrorDTO` の定義が `Codable` 準拠で、`CodingKeys` を使用して `code` と `message` を定義していることを確認しました。この場合、先ほどの修正案にそのまま適用可能です。以下のコードは、`ErrorDTO` の定義をそのまま使用して、400 エラーで `content_filter` を検出するロジックを組み込んだものです。

### 修正版コード

```swift
private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch (error.statusCode, errorDTO.code) {
        case (400, "content_filter"):
            return .failure(.contentFilter) // 新たなエラーケース
        case (429, _):
            return .failure(.rateLimit)
        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### `ErrorDTO` の定義

`ErrorDTO` は以下の定義のままで問題ありません:

```swift
struct ErrorDTO: Codable {
    var code: String
    var message: String

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }
}
```

### `PostMessageError` に `contentFilter` を追加

`PostMessageError` に `contentFilter` を追加して、`content_filter` エラーに対応します。

```swift
enum PostMessageError: Error {
    case rateLimit
    case contentFilter // 新たなエラーケース
    // その他のエラーケース
}
```

これで、`400` エラーで `"code": "content_filter"` が返ってきた場合に、そのエラーを適切にハンドリングできるようになります。

---

## 👤 ユーザー
*2024/9/18 15:02:04*

enum PostMessageError: Error {
    case rateLimit
}
だった。

---

## 🤖 アシスタント
*2024/9/18 15:02:12*

User's `PostMessageError` enum previously only had a `rateLimit` case and is now being updated to include a `contentFilter` case.

---

## 🔧 ツール
*2024/9/18 15:02:12*

Model set context updated.

---

## 🤖 アシスタント
*2024/9/18 15:02:12*

`PostMessageError` に `contentFilter` ケースを追加する修正を適用します。既存の `PostMessageError` が `rateLimit` しか含んでいなかったため、`contentFilter` ケースを追加するだけです。以下のように修正できます。

### 修正後のコード

```swift
private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch (error.statusCode, errorDTO.code) {
        case (400, "content_filter"):
            return .failure(.contentFilter) // 新たなエラーケース
        case (429, _):
            return .failure(.rateLimit)
        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### `PostMessageError` の修正

`PostMessageError` に `contentFilter` を追加します。

```swift
enum PostMessageError: Error {
    case rateLimit
    case contentFilter // 新たなエラーケース
}
```

これにより、`400` エラーで `"content_filter"` が返ってきた場合、`contentFilter` エラーとして処理できるようになります。

---

## 👤 ユーザー
*2024/9/18 16:05:43*

こうしたい。enum PostMessageError: Error {
    /// 400
    enum BadRequest: String {
        case contentFilter = "content_filter"
    }
    /// 429
    case rateLimit
}

---

## 🤖 アシスタント
*2024/9/18 16:05:55*

以下のように `PostMessageError` をリファクタリングして、`BadRequest` という内部 `enum` を使って、`400` エラーに対する `contentFilter` を `BadRequest` 内で処理し、他のエラーケースも適切にハンドリングできるようにします。

### 修正後のコード

```swift
enum PostMessageError: Error {
    /// 400 Bad Request エラー
    enum BadRequest: String {
        case contentFilter = "content_filter"
    }
    
    /// 429 Rate Limit エラー
    case rateLimit
    
    /// 400 エラーを含むその他のエラー
    case badRequest(BadRequest)
}

private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch (error.statusCode, errorDTO.code) {
        case (400, "content_filter"):
            return .failure(.badRequest(.contentFilter)) // BadRequest enumを使用
        case (429, _):
            return .failure(.rateLimit)
        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### 変更点

1. `PostMessageError` 内に `BadRequest` という内部 `enum` を作成し、`contentFilter` のような特定の `400` エラーコードを扱うケースを追加。
2. `postMessage` メソッド内で `400` エラーが発生した場合は、`BadRequest` 内の適切なケース（ここでは `contentFilter`）を返すように変更。
3. `429` エラーは既存の `rateLimit` ケースでハンドリング。

これで `400` エラーに対する `content_filter` の処理と、`429` エラーに対するレートリミット処理が両方対応できるようになります。

---

## 👤 ユーザー
*2024/9/18 16:06:10*

case (400, "content_filter"): の判定をenum任せにいたい

---

## 🤖 アシスタント
*2024/9/18 16:06:39*

`400` エラーの判定を `PostMessageError.BadRequest` に委ねたい場合、`enum` 内でエラーコードのマッピングを処理できるようにします。これにより、`case (400, "content_filter")` のような判定を `BadRequest` の `rawValue` に依存させず、`BadRequest` enum にコードを移譲できます。

以下のように `PostMessageError.BadRequest` に `init` メソッドを追加し、`errorDTO.code` の判定を `BadRequest` の責任にすることができます。

### 修正後のコード

```swift
enum PostMessageError: Error {
    /// 400 Bad Request エラー
    enum BadRequest: String {
        case contentFilter = "content_filter"
        
        init?(code: String) {
            self.init(rawValue: code)
        }
    }
    
    /// 429 Rate Limit エラー
    case rateLimit
    
    /// 400 エラーを含むその他のエラー
    case badRequest(BadRequest)
}

private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        if let badRequest = PostMessageError.BadRequest(code: errorDTO.code), error.statusCode == 400 {
            return .failure(.badRequest(badRequest)) // 400 エラーをBadRequestに委ねる
        } else if error.statusCode == 429 {
            return .failure(.rateLimit)
        } else {
            throw APIError.unexpectedResponse
        }
    }
}
```

### 変更点

1. `BadRequest` enum に `init?(code: String)` を追加し、`errorDTO.code` をもとに `BadRequest` ケースを生成。
2. `postMessage` メソッド内で、`PostMessageError.BadRequest` の初期化を通じて `400` エラーの判定を実施。
   - これにより、`400` エラーコードの判定は `BadRequest` enum の初期化に委ねられます。
3. `429` エラーは従来どおり `rateLimit` ケースで処理。

これで、`400` エラーが発生した場合、`BadRequest` enum にエラーコードの処理を委ねることができ、コードの可読性と拡張性が向上します。

---

## 👤 ユーザー
*2024/9/18 16:07:06*

なるべくSwitch文にしたい

if let badRequest = PostMessageError.BadRequest(code: errorDTO.code), error.statusCode == 400 {
            return .failure(.badRequest(badRequest)) // 400 エラーをBadRequestに委ねる
        } else if error.statusCode == 429 {
            return .failure(.rateLimit)
        } else {
            throw APIError.unexpectedResponse
        }

---

## 🤖 アシスタント
*2024/9/18 16:07:28*

`switch` 文を使ってエラーハンドリングをシンプルにするために、`error.statusCode` と `errorDTO.code` を `switch` 文の中で処理することができます。`PostMessageError.BadRequest` の初期化ロジックを `switch` 文に組み込み、`400` や `429` などのステータスコードに応じて適切に処理します。

以下のようにリファクタリングできます：

### 修正後のコード

```swift
private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch error.statusCode {
        case 400:
            if let badRequest = PostMessageError.BadRequest(code: errorDTO.code) {
                return .failure(.badRequest(badRequest)) // 400 エラーを BadRequest に委ねる
            } else {
                throw APIError.unexpectedResponse
            }
        case 429:
            return .failure(.rateLimit) // 429 エラー処理
        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### 変更点

1. `switch` 文を `error.statusCode` に対して使用し、`400` や `429` などのステータスコードに応じたエラーハンドリングを実装。
2. `400` エラーの場合、`PostMessageError.BadRequest` の初期化を試み、適切なケースに分岐。
3. `400` で `BadRequest` にマッピングできない場合や、他のエラーの場合は `APIError.unexpectedResponse` を投げる。

このように `switch` 文でエラーハンドリングを行うことで、可読性とメンテナンス性が向上し、エラーコードに応じた処理がシンプルに整理されます。

---

## 👤 ユーザー
*2024/9/18 16:09:19*

init? ではなくスローしてほしい

enum APIError: Error {
    case unexpectedResponse
}

---

## 🤖 アシスタント
*2024/9/18 16:09:31*

User prefers to throw an error instead of using an optional initializer in their BadRequest error handling.

---

## 🔧 ツール
*2024/9/18 16:09:31*

Model set context updated.

---

## 🤖 アシスタント
*2024/9/18 16:09:31*

`PostMessageError.BadRequest` の初期化時にエラーをスローするように変更し、`init?` ではなく失敗時に `APIError.unexpectedResponse` をスローするようにリファクタリングします。これにより、エラーのハンドリングが明確になります。

以下がスローに対応した修正コードです。

### 修正後のコード

```swift
enum PostMessageError: Error {
    /// 400 Bad Request エラー
    enum BadRequest: String, Error {
        case contentFilter = "content_filter"
        
        init(code: String) throws {
            guard let badRequest = BadRequest(rawValue: code) else {
                throw APIError.unexpectedResponse // エラーが見つからなければスロー
            }
            self = badRequest
        }
    }
    
    /// 429 Rate Limit エラー
    case rateLimit
    
    /// 400 エラーを含むその他のエラー
    case badRequest(BadRequest)
}

private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch error.statusCode {
        case 400:
            do {
                let badRequest = try PostMessageError.BadRequest(code: errorDTO.code)
                return .failure(.badRequest(badRequest))
            } catch {
                throw APIError.unexpectedResponse // BadRequest の初期化に失敗した場合
            }
        case 429:
            return .failure(.rateLimit)
        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### 変更点

1. `PostMessageError.BadRequest` の初期化時に、該当するエラーコードが見つからなければエラーをスロー (`APIError.unexpectedResponse`) するように `init(code:)` メソッドを変更。
2. `switch` 文内で `BadRequest` の初期化が失敗した場合はエラーハンドリングでスロー。
3. これにより、エラーハンドリングがより厳密になり、`optional` を使用せずに明確に失敗をスローする形に変更。

この実装により、`init?` を使わずにエラーが発生した場合はスローされるため、コードの挙動が一貫性を持ちます。

---

## 👤 ユーザー
*2024/9/18 16:47:12*

こうした。直してほしい

enum PostMessageError: Error {
    enum BadRequestCode: String {
        case contentFilter = "content_filter"
        
        init(code: String) throws {
            guard let errorCode = BadRequestCode(rawValue: code) else {
                throw APIError.unexpectedResponse
            }
            self = errorCode
        }
    }
    
    enum TooManyRequestCode: String {
        case rateLimit = "rate_limit"
        
        init(code: String) throws {
            guard let errorCode = TooManyRequestCode(rawValue: code) else {
                throw APIError.unexpectedResponse
            }
            self = errorCode
        }
    }
    
    /// 400
    case badRequest(BadRequestCode)
    /// 429
    case tooManyRequest(TooManyRequestCode)
}

---

## 🤖 アシスタント
*2024/9/18 16:47:33*

以下のように修正します。`TooManyRequestCode` の部分も `BadRequestCode` と同様に扱い、エラーハンドリングの整合性を保ちつつ、`TooManyRequestCode` ではなく直接 `rateLimit` のエラーケースを使う方がよりシンプルになるかもしれません。

修正版の `enum` 定義は以下の通りです。

### 修正後のコード

```swift
enum PostMessageError: Error {
    
    /// 400 Bad Request エラーコード
    enum BadRequestCode: String {
        case contentFilter = "content_filter"
        
        init(code: String) throws {
            guard let errorCode = BadRequestCode(rawValue: code) else {
                throw APIError.unexpectedResponse
            }
            self = errorCode
        }
    }
    
    /// 429 Too Many Requests エラーコード
    enum TooManyRequestCode: String {
        case rateLimit = "rate_limit"
        
        init(code: String) throws {
            guard let errorCode = TooManyRequestCode(rawValue: code) else {
                throw APIError.unexpectedResponse
            }
            self = errorCode
        }
    }
    
    /// 400 Bad Request
    case badRequest(BadRequestCode)
    
    /// 429 Too Many Requests
    case tooManyRequest(TooManyRequestCode)
}
```

### 変更点

1. `PostMessageError.BadRequestCode` と `PostMessageError.TooManyRequestCode` の初期化メソッドで、コードが `rawValue` にマッチしない場合は `APIError.unexpectedResponse` をスローするようにしました。
2. `TooManyRequestCode` を `PostMessageError` の一部として維持していますが、もしコードの意味に応じて `rateLimit` を直接 `PostMessageError` 内に定義するなら、`TooManyRequestCode` は不要になるかもしれません（詳細なコードがあるなら残しても良い）。

このコードで、各 HTTP ステータスコードに応じた適切なエラー処理を実装できます。

---

## 👤 ユーザー
*2024/9/18 16:47:45*

private func postMessage( を修正してほしい

---

## 🤖 アシスタント
*2024/9/18 16:48:11*

`postMessage` 関数に対して、`PostMessageError.BadRequestCode` および `PostMessageError.TooManyRequestCode` を利用したエラーハンドリングを追加します。これにより、`400` エラー (`BadRequest`) と `429` エラー (`TooManyRequest`) の処理が `enum` を用いてスローされるように調整します。

### 修正後の `postMessage` 関数

```swift
private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch error.statusCode {
        case 400:
            do {
                let badRequestCode = try PostMessageError.BadRequestCode(code: errorDTO.code)
                return .failure(.badRequest(badRequestCode))
            } catch {
                throw APIError.unexpectedResponse // エラーコードが処理できなかった場合
            }
            
        case 429:
            do {
                let tooManyRequestCode = try PostMessageError.TooManyRequestCode(code: errorDTO.code)
                return .failure(.tooManyRequest(tooManyRequestCode))
            } catch {
                throw APIError.unexpectedResponse // エラーコードが処理できなかった場合
            }

        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### 変更点

1. `switch` 文で `error.statusCode` を確認し、`400` (`BadRequest`) と `429` (`TooManyRequest`) のステータスコードに基づいて、それぞれ `PostMessageError.BadRequestCode` および `PostMessageError.TooManyRequestCode` を初期化します。
2. 各ステータスコードに対して初期化が失敗した場合は、`APIError.unexpectedResponse` をスローします。

この修正により、`postMessage` メソッドは `400` や `429` ステータスコードに対して適切な `enum` をスローする構造になり、エラーハンドリングが明確かつ強化されています。

---

## 👤 ユーザー
*2024/9/18 18:32:19*

こうしたい

enum PostMessageError: Error {
    case contentFilter
    case rateLimit
}

enum APIError: Error {
    /// 400
    case badRequest(BadRequestCode)
    /// 429
    case tooManyRequest(TooManyRequestCode)
    /// unexpected
    case unexpectedResponse

    // MARK: - 400
    enum BadRequestCode: String {
        /// `重大度レベル` が `高` 以上で発生 Ref: https://learn.microsoft.com/ja-jp/azure/ai-services/openai/concepts/content-filter?tabs=definitions%2Cuser-prompt%2Cpython-new#risk-categories
        case contentFilter = "content_filter"
        
        init(code: String) throws {
            guard let errorCode = BadRequestCode(rawValue: code) else {
                throw APIError.unexpectedResponse
            }
            self = errorCode
        }
    }
    
    // MARK: - 429
    enum TooManyRequestCode: String {
        case rateLimit = "rate_limit"
        
        init(code: String) throws {
            guard let errorCode = TooManyRequestCode(rawValue: code) else {
                throw APIError.unexpectedResponse
            }
            self = errorCode
        }
    }
}

---

## 🤖 アシスタント
*2024/9/18 18:32:42*

ご提示いただいた `PostMessageError` と `APIError` の構造に基づいて、`postMessage` 関数を修正し、`PostMessageError` を適切にスローできるようにします。

`APIError` の中で `BadRequestCode` と `TooManyRequestCode` を定義し、`400` と `429` エラーをハンドリングしつつ、対応する `PostMessageError` を返すようにします。

### 修正後の `postMessage` 関数

```swift
private func postMessage(
    threadId: Int,
    messageRequestDTO: MessageRequestDTO,
    isLastMessage: Bool = false
) async throws -> Result<Message, PostMessageError> {
    do {
        let message = try await api.postMessage(threadId: threadId, request: messageRequestDTO).toDomain(isLastMessage: isLastMessage)
        return .success(message)
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch error.statusCode {
        case 400:
            do {
                let badRequestCode = try APIError.BadRequestCode(code: errorDTO.code)
                switch badRequestCode {
                case .contentFilter:
                    return .failure(.contentFilter)
                }
            } catch {
                throw APIError.unexpectedResponse // BadRequestCode が処理できなかった場合
            }
            
        case 429:
            do {
                let tooManyRequestCode = try APIError.TooManyRequestCode(code: errorDTO.code)
                switch tooManyRequestCode {
                case .rateLimit:
                    return .failure(.rateLimit)
                }
            } catch {
                throw APIError.unexpectedResponse // TooManyRequestCode が処理できなかった場合
            }

        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### 変更点

1. **400エラー処理 (`BadRequestCode`)**  
   `APIError.BadRequestCode` を初期化し、`switch` 文でエラーコード（例: `.contentFilter`）に対応する処理を行い、`PostMessageError.contentFilter` を返すようにしました。

2. **429エラー処理 (`TooManyRequestCode`)**  
   同様に `APIError.TooManyRequestCode` を初期化し、`rateLimit` の場合は `PostMessageError.rateLimit` を返すようにしました。

3. **`APIError.unexpectedResponse` のスロー**  
   `BadRequestCode` や `TooManyRequestCode` の初期化が失敗した場合、`APIError.unexpectedResponse` をスローします。

これで、`400` や `429` エラーに応じて `PostMessageError` が返され、`BadRequestCode` と `TooManyRequestCode` のハンドリングが整いました。

---

## 👤 ユーザー
*2024/9/18 18:34:40*

これもどうようの処理にしたい

    func finishConversation(threadId: Int) async throws -&gt; Result&lt;Void, PostMessageError&gt; {
        do {
            let _ = try await api.finishConversation(threadId: threadId)
            return .success(())
        } catch {
            guard let error = error as? OpenAPIClient.ErrorResponse else {
                throw APIError.unexpectedResponse
            }

            guard error.statusCode == 429,
                  let data = error.data,
                  let response429 = try? JSONDecoder().decode(ErrorDTO.self, from: data)
            else {
                throw APIError.unexpectedResponse
            }

            switch response429.code {
            case errorCodeRateLimit:
                return .failure(.rateLimit)
            default:
                throw APIError.unexpectedResponse
            }
        }
    }

---

## 🤖 アシスタント
*2024/9/18 18:35:05*

`finishConversation` 関数を、先ほどの `postMessage` 関数と同様のエラーハンドリング処理にリファクタリングします。これにより、`400` や `429` エラーが発生した際に、`APIError` と `PostMessageError` を適切に利用してエラー処理を行うようにできます。

### 修正後の `finishConversation` 関数

```swift
func finishConversation(threadId: Int) async throws -> Result<Void, PostMessageError> {
    do {
        let _ = try await api.finishConversation(threadId: threadId)
        return .success(())
    } catch {
        guard let error = error as? OpenAPIClient.ErrorResponse else {
            throw APIError.unexpectedResponse
        }

        guard let data = error.data,
              let errorDTO = try? JSONDecoder().decode(ErrorDTO.self, from: data)
        else {
            throw APIError.unexpectedResponse
        }

        switch error.statusCode {
        case 400:
            do {
                let badRequestCode = try APIError.BadRequestCode(code: errorDTO.code)
                switch badRequestCode {
                case .contentFilter:
                    return .failure(.contentFilter)
                }
            } catch {
                throw APIError.unexpectedResponse // BadRequestCode が処理できなかった場合
            }
            
        case 429:
            do {
                let tooManyRequestCode = try APIError.TooManyRequestCode(code: errorDTO.code)
                switch tooManyRequestCode {
                case .rateLimit:
                    return .failure(.rateLimit)
                }
            } catch {
                throw APIError.unexpectedResponse // TooManyRequestCode が処理できなかった場合
            }

        default:
            throw APIError.unexpectedResponse
        }
    }
}
```

### 変更点

1. **400エラー処理 (`BadRequestCode`)**  
   `APIError.BadRequestCode` を初期化し、`switch` 文でエラーコードを判定します。`400` エラーが `contentFilter` の場合、`PostMessageError.contentFilter` を返します。

2. **429エラー処理 (`TooManyRequestCode`)**  
   `APIError.TooManyRequestCode` を初期化し、`429` エラーが `rateLimit` の場合、`PostMessageError.rateLimit` を返します。

3. **`APIError.unexpectedResponse` のスロー**  
   `BadRequestCode` や `TooManyRequestCode` の初期化が失敗した場合、または未知のステータスコードが返された場合に `APIError.unexpectedResponse` をスローします。

これで、`finishConversation` 関数も `postMessage` と同様のエラーハンドリング構造を持ち、エラーの処理が統一されます。

---
