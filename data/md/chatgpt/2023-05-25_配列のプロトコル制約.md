# 配列のプロトコル制約

日付: 2023-05-25

---

## 👤 ユーザー
*2023/5/25 14:46:22*

Swiftって同じプロトコルが適応された異なるstructの配列を持つことはできないんだっけ？

---

## 🤖 アシスタント
*2023/5/25 14:47:02*

Swiftは型安全な言語で、そのため一つの配列は一つの型の要素しか持つことができません。ですが、それは明示的な型指定が必要であるということであり、それは特定のプロトコルに適合する全ての型を包括することはできません。

しかし、あるプロトコルに準拠するいくつかの異なる`struct`があり、それら全てを同じ配列に入れたい場合、プロトコル型を使用することができます。これにより、特定のプロトコルに準拠するすべてのオブジェクトを扱うことが可能となります。

以下に一つの例を示します：

```swift
protocol MyProtocol {
    var name: String { get }
    // 他の必要なメソッドやプロパティ
}

struct MyStruct1: MyProtocol {
    var name: String
    // 他のプロパティやメソッド
}

struct MyStruct2: MyProtocol {
    var name: String
    // 他のプロパティやメソッド
}

let array: [MyProtocol] = [MyStruct1(name: "struct1"), MyStruct2(name: "struct2")]
```

この例では、`MyStruct1`と`MyStruct2`という二つの`struct`は`MyProtocol`プロトコルに準拠しており、`MyProtocol`型の配列に格納することができます。

ただし、注意点として、この方法を使用すると、配列の要素はプロトコルの型として扱われ、その要素が実際にどの具体的な型であるかはランタイムまで分からないため、その要素に対して実行できる操作はプロトコルで定義されているものに限定されます。具体的な型のメソッドやプロパティにアクセスするためには、ダウンキャストが必要になるでしょう。

---

## 👤 ユーザー
*2023/5/25 14:47:28*

つまり、array\[1\].name とはできないということ？

---

## 🤖 アシスタント
*2023/5/25 14:47:53*

いえ、それは可能です。例で示した`MyProtocol`にはプロパティ`name`が定義されています。なので、`array[1].name`は実行可能です。これは、配列の要素が`MyProtocol`型として扱われ、その型で定義されたプロパティやメソッドへのアクセスが可能ということを示しています。

以下のコードを見てみましょう：

```swift
print(array[0].name)  // "struct1" を出力します。
print(array[1].name)  // "struct2" を出力します。
```

しかし、`MyStruct1`または`MyStruct2`で定義されていて、`MyProtocol`には存在しないメソッドやプロパティにアクセスしようとすると、その要素を適切な型にダウンキャストする必要があります。これは、要素が`MyProtocol`型として扱われるため、その型で定義されているメソッドやプロパティしか直接アクセスできないからです。

---
