# Swift プロパティリスト化

日付: 2024-05-29

---

## 👤 ユーザー
*2024/5/29 10:05:12*

Swift struct の型構造をListにするライブラリ

---

## 🤖 アシスタント
*2024/5/29 10:05:24*

Swiftで型構造をリストに変換するためのライブラリとして、一般的に以下のようなユースケースを考えることができます。例えば、Swiftで定義された構造体のプロパティを列挙したい場合や、JSONなどのデータ形式に変換する場合です。

このような目的を達成するために、自作のライブラリを作成するか、既存のライブラリを利用する方法があります。以下に、簡単なサンプルと既存のライブラリのいくつかを紹介します。

### 1. カスタムライブラリの作成

Swiftの`Mirror` APIを利用して、型構造をリストに変換するカスタムライブラリを作成できます。以下は簡単な例です。

```swift
import Foundation

struct Property {
    let name: String
    let type: Any.Type
}

func getProperties<T>(of type: T.Type) -> [Property] {
    let mirror = Mirror(reflecting: type.init())
    return mirror.children.compactMap { child in
        guard let label = child.label else { return nil }
        return Property(name: label, type: type(of: child.value))
    }
}

struct ExampleStruct {
    var id: Int
    var name: String
    var isActive: Bool
}

let properties = getProperties(of: ExampleStruct.self)
for property in properties {
    print("Property name: \(property.name), type: \(property.type)")
}
```

### 2. 既存のライブラリ

以下の既存ライブラリを利用することもできます。

#### **Runtime**
- `Runtime`は、Swiftの型情報をランタイムで取得するためのライブラリです。非常に強力で、複雑なリフレクション操作を簡単に行うことができます。
- [Runtime GitHub](https://github.com/wickwirew/Runtime)

#### **SwiftMirror**
- `SwiftMirror`は、Swiftのリフレクションを利用して型情報を操作するためのライブラリです。
- [SwiftMirror GitHub](https://github.com/yaslab/SwiftMirror)

### 例: Runtimeの使用例

```swift
import Runtime

struct ExampleStruct {
    var id: Int
    var name: String
    var isActive: Bool
}

do {
    let info = try typeInfo(of: ExampleStruct.self)
    for property in info.properties {
        print("Property name: \(property.name), type: \(property.type)")
    }
} catch {
    print("Error: \(error)")
}
```

上記のライブラリを使用することで、Swiftの型構造をリストに変換し、プロパティやその型情報を取得することが容易になります。用途に応じてカスタム実装やライブラリの利用を検討してください。

---

## 👤 ユーザー
*2024/5/29 10:06:02*

Swift mirror の使い方を教えて欲しい

---

## 🤖 アシスタント
*2024/5/29 10:06:17*

`Mirror` は Swift のリフレクションを利用してオブジェクトのプロパティやメソッドにアクセスするための機能です。以下に `Mirror` を使用して Swift の構造体やクラスのプロパティを取得する基本的な使い方を紹介します。

### 基本的な使い方

1. **構造体またはクラスを定義**
2. **`Mirror` を使ってプロパティを取得**
3. **取得したプロパティを操作**

以下は、簡単な構造体を定義し、`Mirror` を使ってそのプロパティを列挙する例です。

```swift
import Foundation

struct Person {
    var name: String
    var age: Int
    var isEmployed: Bool
}

let person = Person(name: "John Doe", age: 30, isEmployed: true)

func reflectProperties(of instance: Any) {
    let mirror = Mirror(reflecting: instance)
    for child in mirror.children {
        if let propertyName = child.label {
            print("Property name: \(propertyName), value: \(child.value)")
        }
    }
}

reflectProperties(of: person)
```

### 出力結果

上記のコードを実行すると、以下のように出力されます。

```
Property name: name, value: John Doe
Property name: age, value: 30
Property name: isEmployed, value: true
```

### 詳細な使用方法

#### クラスの場合

クラスも同様に `Mirror` を使ってプロパティを取得できます。クラスの継承階層も反映できます。

```swift
class Animal {
    var species: String
    init(species: String) {
        self.species = species
    }
}

class Dog: Animal {
    var name: String
    var age: Int
    init(name: String, age: Int, species: String = "Dog") {
        self.name = name
        self.age = age
        super.init(species: species)
    }
}

let dog = Dog(name: "Buddy", age: 5)

func reflectClassProperties(of instance: Any) {
    var mirror: Mirror? = Mirror(reflecting: instance)
    while let currentMirror = mirror {
        for child in currentMirror.children {
            if let propertyName = child.label {
                print("Property name: \(propertyName), value: \(child.value)")
            }
        }
        mirror = currentMirror.superclassMirror
    }
}

reflectClassProperties(of: dog)
```

### 出力結果

```
Property name: name, value: Buddy
Property name: age, value: 5
Property name: species, value: Dog
```

#### 詳細な型情報の取得

各プロパティの型情報も取得できます。

```swift
func reflectPropertiesWithTypes(of instance: Any) {
    let mirror = Mirror(reflecting: instance)
    for child in mirror.children {
        if let propertyName = child.label {
            let propertyType = type(of: child.value)
            print("Property name: \(propertyName), type: \(propertyType), value: \(child.value)")
        }
    }
}

reflectPropertiesWithTypes(of: person)
```

### 出力結果

```
Property name: name, type: String, value: John Doe
Property name: age, type: Int, value: 30
Property name: isEmployed, type: Bool, value: true
```

`Mirror` を利用することで、Swift のオブジェクトの内部構造を動的に検査し、プロパティ名や値、型情報などを取得することができます。これはデバッグや汎用的な処理を行う際に非常に有用です。

---

## 👤 ユーザー
*2024/5/29 10:07:16*

SwiftUIで型をビジュアル的に表現するようなコードをじっそうしてほしい

---

## 🤖 アシスタント
*2024/5/29 10:07:40*

SwiftUIを使って、構造体のプロパティとその値をビジュアル的に表示するコードの例を示します。ここでは、`Mirror`を利用してプロパティを取得し、それをリスト表示する方法を紹介します。

### 1. モデルの定義

まず、表示するためのサンプル構造体を定義します。

```swift
struct Person {
    var name: String
    var age: Int
    var isEmployed: Bool
}
```

### 2. プロパティをリフレクションする関数の作成

次に、`Mirror`を使ってプロパティを取得する関数を定義します。

```swift
func getProperties(of instance: Any) -> [(String, Any)] {
    let mirror = Mirror(reflecting: instance)
    return mirror.children.compactMap { child in
        guard let label = child.label else { return nil }
        return (label, child.value)
    }
}
```

### 3. SwiftUIビューの作成

SwiftUIを使って、取得したプロパティをリスト表示するビューを作成します。

```swift
import SwiftUI

struct ContentView: View {
    let person = Person(name: "John Doe", age: 30, isEmployed: true)
    let properties: [(String, Any)]
    
    init() {
        properties = getProperties(of: person)
    }

    var body: some View {
        NavigationView {
            List {
                ForEach(properties, id: \.0) { property in
                    HStack {
                        Text(property.0)
                            .fontWeight(.bold)
                        Spacer()
                        Text("\(property.1)")
                    }
                }
            }
            .navigationTitle("Person Properties")
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

### 解説

- **モデルの定義**: `Person`というサンプル構造体を定義しています。この構造体のプロパティを表示します。
- **プロパティをリフレクションする関数**: `getProperties(of:)`関数は、任意のインスタンスを受け取り、そのプロパティ名と値をタプルの配列として返します。
- **SwiftUIビューの作成**: `ContentView`は、`Person`インスタンスのプロパティをリスト表示するSwiftUIビューです。`properties`は、`getProperties(of:)`関数を使って取得したプロパティの配列です。

### 追加の改善

必要に応じて、プロパティの型情報を表示したり、プロパティの値に応じて表示スタイルを変更することもできます。以下は、型情報を表示する例です。

```swift
func getPropertiesWithTypes(of instance: Any) -> [(String, String, Any)] {
    let mirror = Mirror(reflecting: instance)
    return mirror.children.compactMap { child in
        guard let label = child.label else { return nil }
        return (label, "\(type(of: child.value))", child.value)
    }
}

struct ContentView: View {
    let person = Person(name: "John Doe", age: 30, isEmployed: true)
    let properties: [(String, String, Any)]
    
    init() {
        properties = getPropertiesWithTypes(of: person)
    }

    var body: some View {
        NavigationView {
            List {
                ForEach(properties, id: \.0) { property in
                    HStack {
                        VStack(alignment: .leading) {
                            Text(property.0)
                                .fontWeight(.bold)
                            Text(property.1)
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        Spacer()
                        Text("\(property.2)")
                    }
                }
            }
            .navigationTitle("Person Properties")
        }
    }
}
```

このようにすることで、プロパティ名、型情報、値を視覚的にわかりやすく表示できます。

---

## 👤 ユーザー
*2024/5/29 10:08:31*

structの中にstructがある場合は再起的にできないか？

---

## 🤖 アシスタント
*2024/5/29 10:08:52*

再帰的に構造体の中に構造体がある場合にもプロパティを取得して表示するためには、`Mirror` を再帰的に処理する必要があります。以下に、再帰的にプロパティを取得し、それをビジュアル的に表示する方法を示します。

### 1. サンプルモデルの定義

まず、ネストされた構造体を定義します。

```swift
struct Address {
    var city: String
    var postalCode: String
}

struct Person {
    var name: String
    var age: Int
    var isEmployed: Bool
    var address: Address
}
```

### 2. プロパティを再帰的に取得する関数の作成

次に、再帰的にプロパティを取得する関数を定義します。

```swift
func getPropertiesRecursively(of instance: Any, prefix: String = "") -> [(String, Any)] {
    let mirror = Mirror(reflecting: instance)
    var properties: [(String, Any)] = []

    for child in mirror.children {
        if let label = child.label {
            let propertyName = prefix.isEmpty ? label : "\(prefix).\(label)"
            properties.append((propertyName, child.value))
            let childMirror = Mirror(reflecting: child.value)
            if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                let nestedProperties = getPropertiesRecursively(of: child.value, prefix: propertyName)
                properties.append(contentsOf: nestedProperties)
            }
        }
    }
    return properties
}
```

### 3. SwiftUIビューの作成

SwiftUIを使って、再帰的に取得したプロパティをリスト表示するビューを作成します。

```swift
import SwiftUI

struct ContentView: View {
    let person = Person(name: "John Doe", age: 30, isEmployed: true, address: Address(city: "New York", postalCode: "10001"))
    let properties: [(String, Any)]
    
    init() {
        properties = getPropertiesRecursively(of: person)
    }

    var body: some View {
        NavigationView {
            List {
                ForEach(properties, id: \.0) { property in
                    HStack {
                        Text(property.0)
                            .fontWeight(.bold)
                        Spacer()
                        Text("\(property.1)")
                    }
                }
            }
            .navigationTitle("Person Properties")
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

### 解説

- **サンプルモデルの定義**: `Address` と `Person` という構造体を定義し、`Person` に `Address` をネストしています。
- **プロパティを再帰的に取得する関数**: `getPropertiesRecursively(of:prefix:)` 関数は、再帰的に構造体のプロパティを取得します。プロパティ名のプレフィックスを付けて、ネストされたプロパティを区別します。
- **SwiftUIビューの作成**: `ContentView` は、`Person` インスタンスのプロパティを再帰的にリスト表示するSwiftUIビューです。

### 出力例

実行すると、以下のようにネストされたプロパティも含めてリスト表示されます。

```
name, value: John Doe
age, value: 30
isEmployed, value: true
address.city, value: New York
address.postalCode, value: 10001
```

このようにすることで、ネストされた構造体のプロパティを再帰的に取得してビジュアル的に表示することができます。

---

## 👤 ユーザー
*2024/5/29 10:12:14*

SwiftUI の DisclosureやOutlineで表現してほしい

---

## 🤖 アシスタント
*2024/5/29 10:12:38*

`SwiftUI` で構造体のプロパティを `DisclosureGroup` を使って再帰的に表示する方法を紹介します。これにより、ネストされたプロパティを折りたたんだり展開したりできるインタラクティブなビューを作成できます。

### 1. モデルの定義

まず、ネストされた構造体を定義します。

```swift
struct Address {
    var city: String
    var postalCode: String
}

struct Person {
    var name: String
    var age: Int
    var isEmployed: Bool
    var address: Address
}
```

### 2. 再帰的にプロパティを取得する関数

`Mirror` を利用して再帰的にプロパティを取得する関数を定義します。

```swift
import SwiftUI

struct Property: Identifiable {
    let id = UUID()
    let name: String
    let value: Any
    let children: [Property]
}

func getPropertiesRecursively(of instance: Any, prefix: String = "") -> [Property] {
    let mirror = Mirror(reflecting: instance)
    var properties: [Property] = []

    for child in mirror.children {
        if let label = child.label {
            let propertyName = prefix.isEmpty ? label : "\(prefix).\(label)"
            let childMirror = Mirror(reflecting: child.value)
            let children = (childMirror.displayStyle == .struct || childMirror.displayStyle == .class) ? getPropertiesRecursively(of: child.value, prefix: propertyName) : []
            properties.append(Property(name: propertyName, value: child.value, children: children))
        }
    }
    return properties
}
```

### 3. SwiftUIビューの作成

次に、`DisclosureGroup` を使ってプロパティを表示する SwiftUI ビューを作成します。

```swift
struct ContentView: View {
    let person = Person(name: "John Doe", age: 30, isEmployed: true, address: Address(city: "New York", postalCode: "10001"))
    let properties: [Property]
    
    init() {
        properties = getPropertiesRecursively(of: person)
    }

    var body: some View {
        NavigationView {
            List(properties, children: \.children) { property in
                if property.children.isEmpty {
                    HStack {
                        Text(property.name)
                            .fontWeight(.bold)
                        Spacer()
                        Text("\(property.value)")
                    }
                } else {
                    DisclosureGroup(property.name) {
                        ForEach(property.children) { child in
                            HStack {
                                Text(child.name)
                                    .fontWeight(.bold)
                                Spacer()
                                Text("\(child.value)")
                            }
                        }
                    }
                }
            }
            .navigationTitle("Person Properties")
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

### 解説

- **モデルの定義**: `Address` と `Person` という構造体を定義し、`Person` に `Address` をネストしています。
- **プロパティを再帰的に取得する関数**: `getPropertiesRecursively(of:prefix:)` 関数は、再帰的に構造体のプロパティを取得し、`Property` 構造体として返します。
- **SwiftUIビューの作成**: `ContentView` は、`Person` インスタンスのプロパティを再帰的に `DisclosureGroup` を使ってリスト表示する SwiftUI ビューです。

### 出力例

このコードを実行すると、以下のようにネストされたプロパティを `DisclosureGroup` で表示できます。クリックするとプロパティが展開され、ネストされたプロパティも表示されます。

```
Person Properties
- name: John Doe
- age: 30
- isEmployed: true
- address
  - city: New York
  - postalCode: 10001
```

この方法で、構造体のプロパティをインタラクティブに表示し、必要に応じて展開して詳細を確認できるようになります。

---

## 👤 ユーザー
*2024/5/29 10:14:29*

以下を再起的にして、DisclosureGroupを使うようにしてほしい

extension Components.Schemas.User: Identifiable {}

public struct ContentView: View {
    @State var users: [Components.Schemas.User] = []
    let client: Client

    public init() {
        self.client = Client(
            serverURL: try! Servers.server1(),
            transport: URLSessionTransport()
        )
    }

    public var body: some View {
        VStack {
            ScrollView(.horizontal) {
                HStack {
                    Button {
                        Task {
                            await getUser()
                            await getUsers()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("All")
                        }
                        .padding()
                    }
                    
                    
                    Button {
                        Task {
                            await getUsers()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("getUsers")
                        }
                        .padding()
                    }
                    
                    Button {
                        Task {
                            await getUser()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("getUser")
                        }
                        .padding()
                    }
                }
            }

            List {
                ForEach(users) { user in
                    Section {
                        ForEach(getPropertiesAndValues(of: user), id: \.property) { property, value in
                            Button {
                                UIPasteboard.general.string = value
                            } label: {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text(property)
                                        .font(.headline)
                                    Text(value)
                                        .font(.subheadline)
                                }
                            }
                        }
                    } header: {
                        HStack {
                            Text("User \(user.id)")
                                .font(.headline)
                            
                            Spacer()
                            
                            Button {
                                UIPasteboard.general.string = "\(user)"
                            } label : {
                                Image(systemName: "doc.on.doc")
                            }
                            .buttonStyle(.borderless)
                        }
                    }
                }
            }
            .listStyle(.plain)
        }
    }

    func getUsers() async {
        let response = try! await client.getUsers()
        
        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let users):
                self.users = users
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
        }
    }

    func getUser() async {
        let response = try! await client.getUserById(path: .init(id: 1))

        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let user):
                self.users = [user]
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
        }
    }
    
    /// 変数名とその値のタプルの配列を返す関数
    private func getPropertiesAndValues(of object: Any) -&gt; [(property: String, value: String)] {
        let mirror = Mirror(reflecting: object)
        return mirror.children.compactMap { child in
            guard let label = child.label else {
                return nil
            }
            return (label, String(describing: child.value))
        }
    }
    
    /// オブジェクト全体を文字列としてコピーするための関数
    private func getCopyString(from object: Any) -&gt; String {
        let properties = getPropertiesAndValues(of: object)
        return properties.map { "\($0.property): \($0.value)" }.joined(separator: "\n")
    }
}

#Preview {
    ContentView()
}

---

## 🤖 アシスタント
*2024/5/29 10:14:53*

以下は、`DisclosureGroup` を使って再帰的に構造体のプロパティを表示する方法を取り入れた `ContentView` の実装です。この実装では、ネストされたプロパティを展開可能にしています。

### 改良された `ContentView` のコード

```swift
import SwiftUI

// Mock structures for demonstration
extension Components.Schemas.User: Identifiable {}

struct Components {
    struct Schemas {
        struct User: Identifiable {
            let id: Int
            let name: String
            let address: Address
        }
        
        struct Address {
            let city: String
            let postalCode: String
        }
    }
}

public struct ContentView: View {
    @State var users: [Components.Schemas.User] = []
    let client: Client

    public init() {
        self.client = Client(
            serverURL: try! Servers.server1(),
            transport: URLSessionTransport()
        )
    }

    public var body: some View {
        VStack {
            ScrollView(.horizontal) {
                HStack {
                    Button {
                        Task {
                            await getUser()
                            await getUsers()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("All")
                        }
                        .padding()
                    }
                    
                    Button {
                        Task {
                            await getUsers()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("getUsers")
                        }
                        .padding()
                    }
                    
                    Button {
                        Task {
                            await getUser()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("getUser")
                        }
                        .padding()
                    }
                }
            }

            List {
                ForEach(users) { user in
                    DisclosureGroup("User \(user.id)") {
                        propertyView(of: user)
                    }
                }
            }
            .listStyle(.plain)
        }
    }

    func getUsers() async {
        let response = try! await client.getUsers()
        
        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let users):
                self.users = users
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
        }
    }

    func getUser() async {
        let response = try! await client.getUserById(path: .init(id: 1))

        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let user):
                self.users = [user]
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
        }
    }
    
    /// 再帰的にプロパティを表示するビュー
    @ViewBuilder
    private func propertyView(of object: Any) -> some View {
        let properties = getPropertiesRecursively(of: object)
        
        ForEach(properties, id: \.id) { property in
            if property.children.isEmpty {
                HStack {
                    Text(property.name)
                        .fontWeight(.bold)
                    Spacer()
                    Text("\(property.value)")
                        .onTapGesture {
                            UIPasteboard.general.string = "\(property.value)"
                        }
                }
            } else {
                DisclosureGroup(property.name) {
                    propertyView(of: property.value)
                }
            }
        }
    }
    
    /// プロパティを再帰的に取得する関数
    private func getPropertiesRecursively(of instance: Any, prefix: String = "") -> [Property] {
        let mirror = Mirror(reflecting: instance)
        var properties: [Property] = []

        for child in mirror.children {
            if let label = child.label {
                let propertyName = prefix.isEmpty ? label : "\(prefix).\(label)"
                let childMirror = Mirror(reflecting: child.value)
                let children = (childMirror.displayStyle == .struct || childMirror.displayStyle == .class) ? getPropertiesRecursively(of: child.value, prefix: propertyName) : []
                properties.append(Property(name: propertyName, value: child.value, children: children))
            }
        }
        return properties
    }
    
    /// プロパティ構造体
    struct Property: Identifiable {
        let id = UUID()
        let name: String
        let value: Any
        let children: [Property]
    }
}

#Preview {
    ContentView()
}
```

### 解説

- **モデルの定義**: `User` と `Address` 構造体を定義しました。これらはネストされたプロパティを持つサンプルモデルです。
- **プロパティ構造体**: `Property` 構造体は、プロパティ名、値、および子プロパティを保持します。
- **プロパティを再帰的に取得する関数**: `getPropertiesRecursively(of:prefix:)` 関数は、再帰的にプロパティを取得し、`Property` 構造体の配列を返します。
- **プロパティビューの作成**: `propertyView(of:)` 関数は、再帰的にプロパティを表示する SwiftUI ビューを生成します。
- **`DisclosureGroup` を使用したビュー**: `ContentView` では、`DisclosureGroup` を使ってプロパティを表示しています。ユーザーはプロパティをクリックして展開できます。

この実装により、構造体のプロパティをインタラクティブに表示し、ネストされたプロパティを簡単に確認できます。

---

## 👤 ユーザー
*2024/5/29 10:15:38*

以下のような関数を使わずに書いてほしい

@ViewBuilder
    private func propertyView(of object: Any) -&gt; some View {

---

## 🤖 アシスタント
*2024/5/29 10:16:16*

関数を使用せずに、`DisclosureGroup` を使って再帰的にプロパティを表示するコードを直接 `body` に組み込む方法を示します。

### 1. モデルの定義

まず、ネストされた構造体を定義します。

```swift
struct Address {
    var city: String
    var postalCode: String
}

struct Person {
    var name: String
    var age: Int
    var isEmployed: Bool
    var address: Address
}
```

### 2. プロパティを再帰的に取得するコード

`Mirror` を利用して再帰的にプロパティを取得するための構造体を定義します。

```swift
struct Property: Identifiable {
    let id = UUID()
    let name: String
    let value: Any
    let children: [Property]
}

func getPropertiesRecursively(of instance: Any, prefix: String = "") -> [Property] {
    let mirror = Mirror(reflecting: instance)
    var properties: [Property] = []

    for child in mirror.children {
        if let label = child.label {
            let propertyName = prefix.isEmpty ? label : "\(prefix).\(label)"
            let childMirror = Mirror(reflecting: child.value)
            let children = (childMirror.displayStyle == .struct || childMirror.displayStyle == .class) ? getPropertiesRecursively(of: child.value, prefix: propertyName) : []
            properties.append(Property(name: propertyName, value: child.value, children: children))
        }
    }
    return properties
}
```

### 3. SwiftUIビューの作成

`body` の中で直接再帰的にプロパティを表示するコードを記述します。

```swift
import SwiftUI

struct ContentView: View {
    @State var users: [Components.Schemas.User] = []
    let client: Client

    public init() {
        self.client = Client(
            serverURL: try! Servers.server1(),
            transport: URLSessionTransport()
        )
    }

    public var body: some View {
        VStack {
            ScrollView(.horizontal) {
                HStack {
                    Button {
                        Task {
                            await getUser()
                            await getUsers()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("All")
                        }
                        .padding()
                    }
                    
                    Button {
                        Task {
                            await getUsers()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("getUsers")
                        }
                        .padding()
                    }
                    
                    Button {
                        Task {
                            await getUser()
                        }
                    } label: {
                        VStack {
                            Image(systemName: "globe")
                                .imageScale(.large)
                                .foregroundStyle(.tint)
                            Text("getUser")
                        }
                        .padding()
                    }
                }
            }

            List {
                ForEach(users) { user in
                    DisclosureGroup("User \(user.id)") {
                        let properties = getPropertiesRecursively(of: user)
                        ForEach(properties) { property in
                            if property.children.isEmpty {
                                HStack {
                                    Text(property.name)
                                        .fontWeight(.bold)
                                    Spacer()
                                    Text("\(property.value)")
                                        .onTapGesture {
                                            UIPasteboard.general.string = "\(property.value)"
                                        }
                                }
                            } else {
                                DisclosureGroup(property.name) {
                                    let subProperties = property.children
                                    ForEach(subProperties) { subProperty in
                                        if subProperty.children.isEmpty {
                                            HStack {
                                                Text(subProperty.name)
                                                    .fontWeight(.bold)
                                                Spacer()
                                                Text("\(subProperty.value)")
                                                    .onTapGesture {
                                                        UIPasteboard.general.string = "\(subProperty.value)"
                                                    }
                                            }
                                        } else {
                                            DisclosureGroup(subProperty.name) {
                                                let nestedProperties = subProperty.children
                                                ForEach(nestedProperties) { nestedProperty in
                                                    HStack {
                                                        Text(nestedProperty.name)
                                                            .fontWeight(.bold)
                                                        Spacer()
                                                        Text("\(nestedProperty.value)")
                                                            .onTapGesture {
                                                                UIPasteboard.general.string = "\(nestedProperty.value)"
                                                            }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            .listStyle(.plain)
        }
    }

    func getUsers() async {
        let response = try! await client.getUsers()
        
        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let users):
                self.users = users
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
        }
    }

    func getUser() async {
        let response = try! await client.getUserById(path: .init(id: 1))

        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let user):
                self.users = [user]
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
        }
    }
}

#Preview {
    ContentView()
}
```

### 解説

- **モデルの定義**: `User` と `Address` 構造体を定義しました。これらはネストされたプロパティを持つサンプルモデルです。
- **プロパティ構造体**: `Property` 構造体は、プロパティ名、値、および子プロパティを保持します。
- **プロパティを再帰的に取得する関数**: `getPropertiesRecursively(of:prefix:)` 関数は、再帰的にプロパティを取得し、`Property` 構造体の配列を返します。
- **`DisclosureGroup` を使用したビュー**: `body` 内で直接 `DisclosureGroup` を使ってプロパティを表示しています。ユーザーはプロパティをクリックして展開できます。

このように、関数を使わずに `body` の中で直接プロパティを再帰的に表示するコードを記述することで、ネストされた構造体のプロパティをインタラクティブに表示できます。

---

## 👤 ユーザー
*2024/5/29 10:17:20*

Property 構造体がないと表現が難しいのかな？

---

## 🤖 アシスタント
*2024/5/29 10:17:39*

`Property`構造体を使用せずに、`Mirror`を直接操作して再帰的にプロパティを表示する方法も可能です。ただし、`Property`構造体がないと、ネストされたプロパティを保持するためのデータ構造が不足するため、コードがやや複雑になります。それでも、以下のように実装できます。

### 1. モデルの定義

まず、ネストされた構造体を定義します。

```swift
struct Address {
    var city: String
    var postalCode: String
}

struct Person {
    var name: String
    var age: Int
    var isEmployed: Bool
    var address: Address
}
```

### 2. 再帰的にプロパティを取得するコード

`Mirror`を利用して再帰的にプロパティを取得し、それを表示するためのコードを直接`body`に組み込みます。

```swift
import SwiftUI

struct ContentView: View {
    @State var users: [Person] = [Person(name: "John Doe", age: 30, isEmployed: true, address: Address(city: "New York", postalCode: "10001"))]

    public var body: some View {
        VStack {
            List {
                ForEach(users) { user in
                    DisclosureGroup("User \(user.name)") {
                        propertyView(of: user)
                    }
                }
            }
            .listStyle(.plain)
        }
    }

    @ViewBuilder
    private func propertyView(of object: Any) -> some View {
        let mirror = Mirror(reflecting: object)

        ForEach(Array(mirror.children.enumerated()), id: \.offset) { index, child in
            if let label = child.label {
                let childMirror = Mirror(reflecting: child.value)
                if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                    DisclosureGroup(label) {
                        propertyView(of: child.value)
                    }
                } else {
                    HStack {
                        Text(label)
                            .fontWeight(.bold)
                        Spacer()
                        Text("\(child.value)")
                            .onTapGesture {
                                UIPasteboard.general.string = "\(child.value)"
                            }
                    }
                }
            }
        }
    }
}

extension Person: Identifiable {
    var id: String { name }
}

#Preview {
    ContentView()
}
```

### 解説

- **モデルの定義**: `Person` と `Address` という構造体を定義し、`Person` に `Address` をネストしています。
- **プロパティビューの作成**: `propertyView(of:)` メソッドは、`Mirror` を利用して再帰的にプロパティを表示します。このメソッドは、ラベルが付いている子プロパティに対して、さらに `DisclosureGroup` を生成します。
- **`body` 内の構造**: `body` の中で `DisclosureGroup` を使用し、ユーザーのプロパティを表示します。プロパティがネストされている場合は、さらに `DisclosureGroup` を生成します。

この方法により、再帰的にプロパティを取得して表示することができます。`Property` 構造体を使用せずに実装するため、コードは直接的ですが、少し複雑になります。

---

## 👤 ユーザー
*2024/5/29 10:22:49*

こういうエラーになった

Function opaque return type was inferred as 'ForEach&lt;Array&lt;EnumeratedSequence&lt;Mirror.Children&gt;.Element&gt;, Int, _ConditionalContent&lt;DisclosureGroup&lt;Text, some View&gt;, HStack&lt;TupleView&lt;(Text, Spacer, some View)&gt;&gt;&gt;?&gt;' (aka 'ForEach&lt;Array&lt;(offset: Int, element: (label: Optional&lt;String&gt;, value: Any))&gt;, Int, Optional&lt;_ConditionalContent&lt;DisclosureGroup&lt;Text, some View&gt;, HStack&lt;TupleView&lt;(Text, Spacer, some View)&gt;&gt;&gt;&gt;&gt;'), which defines the opaque type in terms of itself

---

## 🤖 アシスタント
*2024/5/29 10:23:10*

エラーの原因は、`@ViewBuilder` 内で返されるビューの型が一貫していないためです。この問題を解決するには、`@ViewBuilder` を使わずに `AnyView` を使って統一的に返すビューの型を指定します。

以下は修正されたコードです：

### 1. モデルの定義

まず、ネストされた構造体を定義します。

```swift
struct Address {
    var city: String
    var postalCode: String
}

struct Person: Identifiable {
    var id: UUID = UUID()
    var name: String
    var age: Int
    var isEmployed: Bool
    var address: Address
}
```

### 2. 再帰的にプロパティを取得するコード

`Mirror` を利用して再帰的にプロパティを取得し、それを表示するためのコードを直接 `body` に組み込みます。

```swift
import SwiftUI

struct ContentView: View {
    @State var users: [Person] = [
        Person(name: "John Doe", age: 30, isEmployed: true, address: Address(city: "New York", postalCode: "10001"))
    ]

    var body: some View {
        VStack {
            List {
                ForEach(users) { user in
                    DisclosureGroup("User \(user.name)") {
                        propertyView(of: user)
                    }
                }
            }
            .listStyle(.plain)
        }
    }

    private func propertyView(of object: Any) -> some View {
        let mirror = Mirror(reflecting: object)

        return ForEach(Array(mirror.children.enumerated()), id: \.offset) { index, child in
            if let label = child.label {
                let childMirror = Mirror(reflecting: child.value)
                if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                    return AnyView(
                        DisclosureGroup(label) {
                            propertyView(of: child.value)
                        }
                    )
                } else {
                    return AnyView(
                        HStack {
                            Text(label)
                                .fontWeight(.bold)
                            Spacer()
                            Text("\(child.value)")
                                .onTapGesture {
                                    UIPasteboard.general.string = "\(child.value)"
                                }
                        }
                    )
                }
            } else {
                return AnyView(EmptyView())
            }
        }
    }
}

#Preview {
    ContentView()
}
```

### 解説

- **モデルの定義**: `Person` と `Address` という構造体を定義し、`Person` に `Address` をネストしています。また、`Person` 構造体に `Identifiable` プロトコルを適用しています。
- **プロパティビューの作成**: `propertyView(of:)` メソッドは、`Mirror` を利用して再帰的にプロパティを表示します。このメソッドは、ラベルが付いている子プロパティに対して、さらに `DisclosureGroup` を生成します。ビューの型を統一するために `AnyView` を使用しています。
- **`body` 内の構造**: `body` の中で `DisclosureGroup` を使用し、ユーザーのプロパティを表示します。プロパティがネストされている場合は、さらに `DisclosureGroup` を生成します。

この方法により、再帰的にプロパティを取得して表示することができます。`AnyView` を使用することで、返されるビューの型が一貫しているため、エラーを回避できます。

---
