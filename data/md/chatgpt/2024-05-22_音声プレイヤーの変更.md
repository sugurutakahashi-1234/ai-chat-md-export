# éŸ³å£°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¤‰æ›´

æ—¥ä»˜: 2024-05-22

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/22 12:41:03*

private var player: AVPlayer? ã‚’ audioPlayer: AVAudioPlayer? ã«å¤‰æ›´ã—ã¦ã»ã—ã„ã€‚

ã¾ãŸå¤‰æ›´éƒ¨åˆ†ã‚’ã‚ã‹ã‚Šã‚„ã™ãã—ã¦ã»ã—ã„


import AVFoundation
import Combine
import Foundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isSeeking: Bool = false
    @Published var isLoading: Bool = false
    @Published var isPlaying: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
    @Published var shouldDismiss: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    private let fileManageDriver: FileManageDriver = FileManageDriver()

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }

    func onApper() {
        isLoading = true

        let item = AVPlayerItem(url: audioUrl)
        player = AVPlayer(playerItem: item)

        // 0.1 ç§’ã”ã¨ã«å†ç”Ÿæ™‚åˆ»ã¨ seek bar ã‚’åŒæœŸã•ã›ã‚‹
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest($isPlaying, $isSeeking)
            .filter { _, isPlaying, isSeeking in
                isPlaying && !isSeeking // å†ç”Ÿä¸­ã‹ã¤seekã—ã¦ã„ãªã„ã¨ãã®ã¿æ›´æ–°
            }
            .map { [weak self] _, _, _ in
                self?.player?.currentTime().seconds ?? 0
            }
            .assign(to: &$currentTime)

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else {
                    return
                }
                isPlaying = false
                currentTime = duration
                player?.seek(to: .zero)
            }
            .store(in: &cancellables)

        // å†ç”Ÿæº–å‚™ãŒå®Œäº†ã—ãŸã‚‰å†ç”Ÿæ™‚é–“ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                switch status {
                case .readyToPlay:
                    self?.isLoading = false
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                case .unknown, .failed:
                    break
                @unknown default:
                    break
                }
            }
            .store(in: &cancellables)

        // éŸ³å£°ã‚’å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapPlay() {
        player?.play()
        isPlaying = true
    }

    func onTapPause() {
        player?.pause()
        isPlaying = false
    }

    func onTapGoBackward() {
        let newTime = max(currentTime - 15, 0)
        seek(to: newTime)
    }

    func onTapGoForward() {
        let newTime = min(currentTime + 15, duration)
        seek(to: newTime)
    }

    func onTapTrash() {
        appError = .delete
        showAlert = true
    }

    func onTapOkDelete() {
        do {
            try fileManageDriver.removeItemIfExists(at: audioUrl)
            shouldDismiss = true
        } catch {
            OSLogger.errorLog("\(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime) { [weak self] completed in
            if completed {
                self?.currentTime = time
                self?.isSeeking = false
            } else {
                OSLogger.errorLog("seek failed")
                self?.appError = .customError("seek failed")
                self?.showAlert = true
            }
        }
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/22 12:41:31*

Here's the modified code where `AVPlayer` is replaced with `AVAudioPlayer`. The changes are highlighted with comments for clarity:

```swift
import AVFoundation
import Combine
import Foundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isSeeking: Bool = false
    @Published var isLoading: Bool = false
    @Published var isPlaying: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
    @Published var shouldDismiss: Bool = false

    let audioUrl: URL
    private var audioPlayer: AVAudioPlayer?  // Changed from AVPlayer to AVAudioPlayer
    private var cancellables: Set<AnyCancellable> = []
    private let fileManageDriver: FileManageDriver = FileManageDriver()

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }

    func onApper() {
        isLoading = true

        do {
            audioPlayer = try AVAudioPlayer(contentsOf: audioUrl)  // Updated to AVAudioPlayer initialization
            audioPlayer?.prepareToPlay()  // Prepare the player for playback
            duration = audioPlayer?.duration ?? 0  // Set the duration
            audioPlayer?.delegate = self  // Set the delegate to self
            isLoading = false
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }

        // 0.1 ç§’ã”ã¨ã«å†ç”Ÿæ™‚åˆ»ã¨ seek bar ã‚’åŒæœŸã•ã›ã‚‹
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest($isPlaying, $isSeeking)
            .filter { _, isPlaying, isSeeking in
                isPlaying && !isSeeking // å†ç”Ÿä¸­ã‹ã¤seekã—ã¦ã„ãªã„ã¨ãã®ã¿æ›´æ–°
            }
            .map { [weak self] _, _, _ in
                self?.audioPlayer?.currentTime ?? 0  // Updated to use audioPlayer
            }
            .assign(to: &$currentTime)

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        NotificationCenter.default.publisher(for: .AVAudioPlayerDidFinishPlaying, object: audioPlayer)  // Updated to use AVAudioPlayerDidFinishPlaying
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else {
                    return
                }
                isPlaying = false
                currentTime = duration
                audioPlayer?.currentTime = 0  // Reset the player to the beginning
            }
            .store(in: &cancellables)

        // éŸ³å£°ã‚’å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapPlay() {
        audioPlayer?.play()  // Updated to use audioPlayer
        isPlaying = true
    }

    func onTapPause() {
        audioPlayer?.pause()  // Updated to use audioPlayer
        isPlaying = false
    }

    func onTapGoBackward() {
        let newTime = max(currentTime - 15, 0)
        seek(to: newTime)
    }

    func onTapGoForward() {
        let newTime = min(currentTime + 15, duration)
        seek(to: newTime)
    }

    func onTapTrash() {
        appError = .delete
        showAlert = true
    }

    func onTapOkDelete() {
        do {
            try fileManageDriver.removeItemIfExists(at: audioUrl)
            shouldDismiss = true
        } catch {
            OSLogger.errorLog("\(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func seek(to time: TimeInterval) {
        audioPlayer?.currentTime = time  // Updated to use audioPlayer
        currentTime = time
        isSeeking = false
    }
}

extension AudioPlayerPresenter: AVAudioPlayerDelegate {
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        isPlaying = false
        currentTime = duration
        audioPlayer?.currentTime = 0
    }
}
```

Key changes:
1. Replaced `AVPlayer` with `AVAudioPlayer`.
2. Updated initialization of the player.
3. Added `AVAudioPlayerDelegate` conformance to handle completion events.
4. Updated playback control functions (`onTapPlay`, `onTapPause`, `seek`).
5. Adjusted time synchronization to use `audioPlayer?.currentTime`.

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/22 12:41:51*

AVAudioPlayerDelegate ã‚’ä½¿ã‚ãªã„æ–¹æ³•ã¯ã‚ã‚‹ã‹ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/22 12:42:14*

`AVAudioPlayerDelegate` ã‚’ä½¿ç”¨ã—ãªã„æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚`AVAudioPlayer`ã®å†ç”Ÿå®Œäº†ã‚’é€šçŸ¥ã™ã‚‹ãŸã‚ã«ã€`NotificationCenter`ã‚’åˆ©ç”¨ã—ã¦ä»£æ›¿æ‰‹æ®µã‚’æä¾›ã§ãã¾ã™ã€‚ä»¥ä¸‹ã«ç¤ºã™ã‚ˆã†ã«ã€`AVPlayer`ã‹ã‚‰`AVAudioPlayer`ã«å¤‰æ›´ã—ã€`AVAudioPlayerDelegate`ã‚’ä½¿ç”¨ã›ãšã«é€šçŸ¥ã‚’è¨­å®šã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
import AVFoundation
import Combine
import Foundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isSeeking: Bool = false
    @Published var isLoading: Bool = false
    @Published var isPlaying: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
    @Published var shouldDismiss: Bool = false

    let audioUrl: URL
    private var audioPlayer: AVAudioPlayer?  // Changed from AVPlayer to AVAudioPlayer
    private var cancellables: Set<AnyCancellable> = []
    private let fileManageDriver: FileManageDriver = FileManageDriver()

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }

    func onApper() {
        isLoading = true

        do {
            audioPlayer = try AVAudioPlayer(contentsOf: audioUrl)  // Updated to AVAudioPlayer initialization
            audioPlayer?.prepareToPlay()  // Prepare the player for playback
            duration = audioPlayer?.duration ?? 0  // Set the duration
            isLoading = false
            
            // Observe playback completion using NotificationCenter
            NotificationCenter.default.addObserver(self, selector: #selector(audioPlayerDidFinishPlaying), name: .AVPlayerItemDidPlayToEndTime, object: audioPlayer)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }

        // 0.1 ç§’ã”ã¨ã«å†ç”Ÿæ™‚åˆ»ã¨ seek bar ã‚’åŒæœŸã•ã›ã‚‹
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest($isPlaying, $isSeeking)
            .filter { _, isPlaying, isSeeking in
                isPlaying && !isSeeking // å†ç”Ÿä¸­ã‹ã¤seekã—ã¦ã„ãªã„ã¨ãã®ã¿æ›´æ–°
            }
            .map { [weak self] _, _, _ in
                self?.audioPlayer?.currentTime ?? 0  // Updated to use audioPlayer
            }
            .assign(to: &$currentTime)

        // éŸ³å£°ã‚’å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapPlay() {
        audioPlayer?.play()  // Updated to use audioPlayer
        isPlaying = true
    }

    func onTapPause() {
        audioPlayer?.pause()  // Updated to use audioPlayer
        isPlaying = false
    }

    func onTapGoBackward() {
        let newTime = max(currentTime - 15, 0)
        seek(to: newTime)
    }

    func onTapGoForward() {
        let newTime = min(currentTime + 15, duration)
        seek(to: newTime)
    }

    func onTapTrash() {
        appError = .delete
        showAlert = true
    }

    func onTapOkDelete() {
        do {
            try fileManageDriver.removeItemIfExists(at: audioUrl)
            shouldDismiss = true
        } catch {
            OSLogger.errorLog("\(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func seek(to time: TimeInterval) {
        audioPlayer?.currentTime = time  // Updated to use audioPlayer
        currentTime = time
        isSeeking = false
    }

    @objc func audioPlayerDidFinishPlaying() {
        isPlaying = false
        currentTime = duration
        audioPlayer?.currentTime = 0
    }
}
```

ã“ã®æ–¹æ³•ã§ã¯ã€`NotificationCenter`ã‚’ä½¿ç”¨ã—ã¦å†ç”Ÿå®Œäº†ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã€`audioPlayerDidFinishPlaying`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€`AVAudioPlayerDelegate`ã‚’ä½¿ç”¨ã›ãšã«å†ç”Ÿå®Œäº†ã®å‡¦ç†ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

---
