# Combineでの複数のパブリッシャーの完了を検出する

Date: 2023-07-01

---

## 👤 User
*2023-07-01 19:07:32*

SwiftのCombineで2つのパブリッシャーがあったときに2つが両方completionになったときに実行される処理を書きたい

---

## 🤖 Assistant
*2023-07-01 19:08:10*

SwiftのCombineフレームワークでは、パブリッシャー間の操作を制御するために、さまざまな演算子を利用できます。その中に、あなたが求めているような、複数のパブリッシャーが両方completionになったときに動作するものもあります。

その一つは`Zip`という演算子で、複数のパブリッシャーの出力を一緒にバンドルすることができます。ただし、この`Zip`は各パブリッシャーの出力が揃った時にのみデータを送出するため、パブリッシャー間の出力の頻度が異なる場合は注意が必要です。

あなたの要件を満たすためには、以下のようなコードを書くことができます。

```swift
import Combine

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

let cancellable = publisher1.zip(publisher2)
    .sink { _ in
        print("Both publishers have completed.")
    }

publisher1.send()
publisher2.send()
```

このコードでは、`publisher1`と`publisher2`の両方がcompletionになったとき（つまり、両方からデータが送出されたとき）に、`zip`が新たなイベントを生成します。これにより、`sink`に指定したクロージャ内の`print`関数が呼び出されます。

ただし、`zip`演算子はデータのペアを生成しますので、両方のパブリッシャーからデータが送出されたときだけ動作します。もし、両方のパブリッシャーが完成したことを検出したい場合は、少し異なるアプローチが必要となります。それぞれのパブリッシャーが完了したことを別々に検出し、全て完了したことを確認するという方法が考えられます。

---

## 👤 User
*2023-07-01 19:08:35*

outputを一緒にしたいのではなくて、両方completionになったことだけをトリガーに処理をしたいんだ

---

## 🤖 Assistant
*2023-07-01 19:09:07*

あなたの要望に基づいて、パブリッシャーが完了したことを検出し、両方が完了したときに処理を実行する以下のようなコードを考えてみます。

```swift
import Combine

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

var completions = 0
let totalPublishers = 2

let cancellable1 = publisher1
    .sink(receiveCompletion: { _ in
        completions += 1
        if completions == totalPublishers {
            print("Both publishers have completed.")
        }
    }, receiveValue: { _ in })

let cancellable2 = publisher2
    .sink(receiveCompletion: { _ in
        completions += 1
        if completions == totalPublishers {
            print("Both publishers have completed.")
        }
    }, receiveValue: { _ in })

publisher1.send()
publisher1.send(completion: .finished)

publisher2.send()
publisher2.send(completion: .finished)
```

このコードでは、各パブリッシャーに対して`sink`を使用し、それぞれのパブリッシャーが完了したときに`completions`というカウンタをインクリメントします。そして、そのカウンタがパブリッシャーの総数（この場合は2）に等しくなったとき、つまりすべてのパブリッシャーが完了したときに、あなたが実行したい処理（この例ではメッセージを出力する）を行います。

ただし、このコードは完了イベントを正確にカウントするためには、各パブリッシャーが完了するまで`cancellable1`と`cancellable2`が存続していることを確認する必要があります。これらのオブジェクトがスコープから外れると、パブリッシャーとの接続が切断され、完了イベントが検出されなくなる可能性がありますので注意が必要です。

---

## 👤 User
*2023-07-01 19:09:41*

combinelatestで一緒にしたらreceiveCompletionにはどういう条件で入るの？それでもおなじことができないの

---

## 🤖 Assistant
*2023-07-01 19:10:16*

`CombineLatest`演算子は2つ（またはそれ以上）のパブリッシャーの最新の出力を組み合わせます。各パブリッシャーが最初に値を送信した後、どちらかのパブリッシャーが新しい値を送信するたびに、`CombineLatest`パブリッシャーは新しい組み合わせを送信します。

`CombineLatest`パブリッシャーの`receiveCompletion`イベントは、すべての入力パブリッシャーが完了したときにのみ送信されます。つまり、パブリッシャーの一方がまだ完了していない場合、そのパブリッシャーからの新しい出力が他のすべての最新の出力と組み合わされて送信されます。それぞれのパブリッシャーが終了した場合にのみ、全体の`CombineLatest`パブリッシャーが終了します。

そのため、`CombineLatest`を使用して両方のパブリッシャーが終了したことを検出することは可能です。以下にその例を示します。

```swift
import Combine

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

let cancellable = publisher1
    .combineLatest(publisher2)
    .sink(receiveCompletion: { _ in
        print("Both publishers have completed.")
    }, receiveValue: { _, _ in })

publisher1.send()
publisher1.send(completion: .finished)

publisher2.send()
publisher2.send(completion: .finished)
```

このコードでは、両方のパブリッシャーが終了したときに、`CombineLatest`パブリッシャーから`receiveCompletion`イベントが発生します。これにより、`sink`内の`receiveCompletion`クロージャが呼び出され、`print`関数が実行されます。したがって、これはあなたが求めている「両方のパブリッシャーが終了したときに処理を実行する」ことを満たすものとなります。

---

## 👤 User
*2023-07-01 19:13:49*

別の話になるかもしれないけど、cancellablesにsetされているものが完了されたことってどうやって判定するの？それぞれをcancellablesにsetして、その状態を確認するとかはできないの？

---

## 🤖 Assistant
*2023-07-01 19:14:40*

Swift CombineのCancellableは、Publisherからのサブスクリプションを表し、購読をキャンセルすることができます。ただし、Cancellableには直接的な完了状態を確認するためのプロパティやメソッドは提供されていません。

それぞれのCancellableが終了したかどうかを判定するためには、各サブスクリプションの`receiveCompletion`を利用して自己管理する必要があります。そのためには、各Cancellableが終了したことをトラックするためのカウンターまたはフラグを設定し、それぞれの`receiveCompletion`イベントで更新するという方法があります。

ただし、この方法は少々手間がかかりますし、特に多数のCancellableを管理しなければならない場合には面倒な場合があります。代わりに、各Cancellableが終了したときに共通の処理を実行するために、共通の`receiveCompletion`ハンドラを使うことも考えられます。

以下に具体的なコード例を示します：

```swift
import Combine

var cancellables = Set<AnyCancellable>()
let totalCancellables = 2
var completions = 0

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

let completionHandling: ((Subscribers.Completion<Never>) -> Void) = { _ in
    completions += 1
    if completions == totalCancellables {
        print("All cancellables have completed.")
    }
}

publisher1
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

publisher2
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

publisher1.send(completion: .finished)
publisher2.send(completion: .finished)
```

このコードでは、すべてのCancellableが終了したことをトラックするために`completions`カウンターを使用しています。`receiveCompletion`ハンドラは`completionHandling`クロージャとして共有され、各サブスクリプションの完了時にこのハンドラが呼び出されてカウンターが増加します。全てのCancellableが完了した時点で、すなわち`completions`が`totalCancellables`と等しくなったときに、メッセージが出力されます。

ただし、ここでも注意すべきは、各Cancellableがスコープから消えないように保持することです。これがないと、Cancellableは即座に解除されてしまい、期待した挙動にならない可能性があります。この例では、`store(in: &cancellables)`を使ってCancellableを保持しています。

---

## 👤 User
*2023-07-01 19:15:45*

このカウンターが2以上になるのをawaitとするような処理ってどう書けばいいかな？

---

## 🤖 Assistant
*2023-07-01 19:16:29*

Swift 5.5以降、非同期処理を行うための新しい仕組みとして、`async/await`パターンが導入されました。これを使うと、非同期処理をまるで同期的に書くかのように直感的に記述することができます。

あなたの要望を満たすために、非同期タスクとカウンターの監視を組み合わせるための方法を考えてみます。以下に示すコードは、`DispatchSemaphore`を使用してカウンターが特定の値に達するのを待つ非同期関数`waitForCompletions`を示しています。

```swift
import Combine
import Foundation

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

let semaphore = DispatchSemaphore(value: 0)
var completions = 0
let totalCancellables = 2
var cancellables = Set<AnyCancellable>()

let completionHandling: ((Subscribers.Completion<Never>) -> Void) = { _ in
    completions += 1
    if completions == totalCancellables {
        semaphore.signal()
    }
}

publisher1
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

publisher2
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

func waitForCompletions() async {
    await withUnsafeContinuation { continuation in
        DispatchQueue.global().async {
            semaphore.wait()
            continuation.resume()
        }
    }
    print("All cancellables have completed.")
}

Task {
    await waitForCompletions()
}

publisher1.send(completion: .finished)
publisher2.send(completion: .finished)
```

このコードでは、`waitForCompletions`関数が非同期タスクであり、その中で`DispatchSemaphore`を使用して`completions`カウンターが`totalCancellables`と等しくなるまで待機します。これにより、すべてのCancellableが完了したことを非同期的に監視することが可能になります。

ただし、このコードは`DispatchSemaphore`を非同期コードの中で使用していますので、注意が必要です。`DispatchSemaphore.wait`は呼び出し元のスレッドをブロックしますので、これをメインスレッドで呼び出すとアプリケーション全体がブロックされる可能性があります。これを防ぐためには、`DispatchQueue.global().async`を使って非同期タスクをバックグラウンドスレッドで実行します。

---

## 👤 User
*2023-07-01 19:16:40*

semaphore は使いたくない。Swift Concurrencyっぽく記述したい

---

## 🤖 Assistant
*2023-07-01 19:17:11*

Swift 5.5以降では、Swift Concurrencyを利用して非同期のコードをよりシンプルに、かつ直感的に書くことが可能となりました。以下に示すコードは、Swift Concurrencyを利用して`AsyncSequence`と`Task`を組み合わせた非同期関数`waitForCompletions`を示しています。

```swift
import Combine
import Foundation

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

var completions = 0
let totalCancellables = 2
var cancellables = Set<AnyCancellable>()

let completionSubject = PassthroughSubject<Void, Never>()

let completionHandling: ((Subscribers.Completion<Never>) -> Void) = { _ in
    completions += 1
    if completions == totalCancellables {
        completionSubject.send(completion: .finished)
    }
}

publisher1
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

publisher2
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

func waitForCompletions() async {
    for await _ in AsyncStream(completionSubject) {}
    print("All cancellables have completed.")
}

Task {
    await waitForCompletions()
}

publisher1.send(completion: .finished)
publisher2.send(completion: .finished)
```

このコードでは、`waitForCompletions`関数が非同期タスクであり、その中で`AsyncStream`を使用して`completionSubject`パブリッシャーが完了するまで待機します。`completionSubject`は`completions`カウンターが`totalCancellables`と等しくなったときに完了するように設定されています。これにより、すべてのCancellableが完了したことをSwift Concurrencyを使って非同期的に監視することが可能になります。

---

## 👤 User
*2023-07-01 19:17:44*

for await _ in AsyncStream(completionSubject) {} ってできるんだ

---

## 🤖 Assistant
*2023-07-01 19:18:30*

すみません、私の誤りでした。Swift ConcurrencyとCombineを混同してしまい、誤った情報を提供しました。Swift 5.5以降では、Swift Concurrencyを使用して非同期タスクを簡易に記述できますが、CombineのPublisherを直接AsyncSequenceとして扱うことはできません。

しかし、PublisherをAsyncSequenceに変換するためのカスタム変換関数を作ることは可能です。以下に示すコードは、`publisherToAsyncSequence`関数を用いてPublisherをAsyncSequenceに変換し、そのAsyncSequenceが終了するまで待機する非同期関数`waitForCompletions`を示しています。

```swift
import Combine
import Foundation

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

var completions = 0
let totalCancellables = 2
var cancellables = Set<AnyCancellable>()

let completionSubject = PassthroughSubject<Void, Never>()

let completionHandling: ((Subscribers.Completion<Never>) -> Void) = { _ in
    completions += 1
    if completions == totalCancellables {
        completionSubject.send(completion: .finished)
    }
}

publisher1
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

publisher2
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

func publisherToAsyncSequence<T>(_ publisher: Publishers.Autoconnect<Timer.TimerPublisher>) -> AsyncStream<Date, Never> {
    return AsyncStream<Date, Never> { continuation in
        let cancellable = publisher
            .sink(receiveCompletion: { _ in
                continuation.finish()
            }, receiveValue: { value in
                continuation.yield(value)
            })
        continuation.onTermination = { @Sendable _ in
            cancellable.cancel()
        }
    }
}

func waitForCompletions() async {
    for await _ in publisherToAsyncSequence(completionSubject) {}
    print("All cancellables have completed.")
}

Task {
    await waitForCompletions()
}

publisher1.send(completion: .finished)
publisher2.send(completion: .finished)
```

このコードでは、`waitForCompletions`関数が非同期タスクであり、その中で`AsyncStream`を使用して`completionSubject`パブリッシャーが完了するまで待機します。`completionSubject`は`completions`カウンターが`totalCancellables`と等しくなったときに完了するように設定されています。これにより、すべてのCancellableが完了したことをSwift Concurrencyを使って非同期的に監視することが可能になります。

ただし、このコードは非常に複雑であるため、状況によっては、もっとシンプルな手段で目的を達成できるかもしれません。例えば、Swift Concurrencyの中には、非同期タスクを組織するための非常に強力なツ

---

## 🤖 Assistant
*2023-07-01 19:18:39*

ールが多く存在します。

---

## 👤 User
*2023-07-01 19:18:55*

publisherToAsyncSequence はつくらなくていいよ。その場でせんげんするだけで。

---

## 🤖 Assistant
*2023-07-01 19:19:19*

指摘の通り、その場でPublisherをAsyncSequenceに変換するクロージャを利用できます。その場合、`Task`と`for await`を使って特定の条件が満たされるまで待機することも可能です。以下のコードがその例となります。

```swift
import Combine
import Foundation

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

var completions = 0
let totalCancellables = 2
var cancellables = Set<AnyCancellable>()

let completionSubject = PassthroughSubject<Void, Never>()

let completionHandling: ((Subscribers.Completion<Never>) -> Void) = { _ in
    completions += 1
    if completions == totalCancellables {
        completionSubject.send(completion: .finished)
    }
}

publisher1
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

publisher2
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

Task {
    for await _ in AsyncStream<Void, Never>({ continuation in
        let cancellable = completionSubject
            .sink(receiveCompletion: { _ in
                continuation.finish()
            }, receiveValue: { value in
                continuation.yield(value)
            })
        continuation.onTermination = { @Sendable _ in
            cancellable.cancel()
        }
    }) {}
    print("All cancellables have completed.")
}

publisher1.send(completion: .finished)
publisher2.send(completion: .finished)
```

このコードでは、`AsyncStream`の初期化時に直接クロージャを提供しています。その中で`completionSubject`の購読を行い、各イベントが発生したときに`AsyncStream.Continuation`に対して適切な操作を実行しています。

---

## 👤 User
*2023-07-01 19:19:29*

withCheckedContinuation とか使ったほうがシンプルにならない？

---

## 🤖 Assistant
*2023-07-01 19:20:07*

ご指摘の通り、`withCheckedContinuation`や`withUnsafeContinuation`を使うことで、非同期タスクが完了するまで待機するコードをよりシンプルに書くことが可能です。以下に示すコードは、`withCheckedContinuation`を使用した例です。

```swift
import Combine
import Foundation

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

var completions = 0
let totalCancellables = 2
var cancellables = Set<AnyCancellable>()

let completionHandling: ((Subscribers.Completion<Never>) -> Void) = { _ in
    completions += 1
    if completions == totalCancellables {
        Task { 
            await continuationsLock.withLock {
                completionContinuation?.resume()
                completionContinuation = nil
            }
        }
    }
}

publisher1
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

publisher2
    .sink(receiveCompletion: completionHandling, receiveValue: { _ in })
    .store(in: &cancellables)

let continuationsLock = NSLock()
var completionContinuation: CheckedContinuation<Void, Never>?

func waitForCompletions() async {
    await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
        continuationsLock.lock()
        completionContinuation = continuation
        continuationsLock.unlock()
    }
    print("All cancellables have completed.")
}

Task {
    await waitForCompletions()
}

publisher1.send(completion: .finished)
publisher2.send(completion: .finished)
```

このコードでは、全ての非同期タスクが完了したら`completionContinuation?.resume()`を呼び出すことで非同期の待機を解除しています。`completionContinuation`は`waitForCompletions`関数内で設定され、`withCheckedContinuation`の引数で受け取った`CheckedContinuation`インスタンスを保持します。これにより、すべてのCancellableが完了したことをSwift Concurrencyを使って非同期的に監視することが可能になります。

このアプローチでは`DispatchSemaphore`や`AsyncStream`を使用する必要がないため、より直感的でシンプルなコードとなります。ただし、`continuationsLock`を使用して排他制御を行っています。これは`completionContinuation`が複数のスレッドからアクセスされる可能性があるためで、データ競合を防ぐためのものです。

---

## 👤 User
*2023-07-01 19:20:32*

排他制御やらなくいいからもっとシンプルに書いて欲しい

---

## 🤖 Assistant
*2023-07-01 19:20:58*

大変申し訳ありません、再度試してみます。`TaskGroup`を使って、タスクがすべて終了したときの処理を行うのがより簡単になります。以下がその例です：

```swift
import Combine
import Foundation

let publisher1 = PassthroughSubject<Void, Never>()
let publisher2 = PassthroughSubject<Void, Never>()

var cancellables = Set<AnyCancellable>()

func handlePublisherCompletion(_ publisher: PassthroughSubject<Void, Never>) async {
    await withCheckedContinuation { continuation in
        publisher
            .sink(receiveCompletion: { _ in
                continuation.resume()
            }, receiveValue: { _ in })
            .store(in: &cancellables)
    }
}

Task {
    async let task1 = handlePublisherCompletion(publisher1)
    async let task2 = handlePublisherCompletion(publisher2)

    await task1
    await task2
    print("All cancellables have completed.")
}

publisher1.send(completion: .finished)
publisher2.send(completion: .finished)
```

このコードでは、`handlePublisherCompletion`関数が非同期タスクで、各パブリッシャが完了するまで待機します。その後、`Task`内で`handlePublisherCompletion`関数を非同期で呼び出し、`await`を使用してその完了を待っています。全ての非同期タスクが完了すると、「All cancellables have completed.」と出力されます。

このアプローチは、`withCheckedContinuation`とSwift Concurrencyの一部である`async let`構文を使って、より簡潔に非同期タスクの完了を待つことができます。

---

## 👤 User
*2023-07-01 21:18:51*

```swift
public func endAnalysis() async {
        // 分析終了後に視線データが途中で流れないように止める
        gazeTrackManager.stopTracking()
        
        print("*********1************\(emotionDataModels.count)")
        
        async let analyzeFinishedCheckedTask = analyzeFinishedChecked()
        
        // 感情分析のストリームを完了させる
        sampleBufferAndTimestampSubject.send(completion: .finished)
        
        // 相対座標の計算のストリームを完了させる
        gazeInformationSubject.send(completion: .finished)
        
        // Wait for both tasks to complete
        await analyzeFinishedCheckedTask
        
        print("*********2************\(emotionDataModels.count)")
        cancellableSet.forEach { $0.cancel() }
        cancellableSet = []
    }
    
    private func analyzeFinishedChecked() async {
        await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
            analyzeEmotionFinishedPublisher
                .combineLatest(relativeCoordinateGazeInformationFinishedPublisher)
                .sink { _ in
                    print("*********analyzeFinishedChecked***********")
                    continuation.resume(returning: ())
                } receiveValue: { _, _ in }
                .store(in: &cancellableSet)
        }
    }
```

---

## 🤖 Assistant
*2023-07-01 21:19:22*

あなたが提供したコードは、`analyzeEmotionFinishedPublisher`と`relativeCoordinateGazeInformationFinishedPublisher`の両方が完了したら、非同期タスクが終了することを保証するように見えます。ここでは、Swift 5.5 の新機能である `async/await` と `withCheckedContinuation` を使用して、これらの Publisher が完了するまで非同期に待機します。

非同期タスク `analyzeFinishedCheckedTask` が開始され、その後で両方の Publisher へ `.finished` を送信することで完了をトリガーします。最後に、`await analyzeFinishedCheckedTask` で非同期タスクが完了するまで待機します。これにより、両方の Publisher が完了してから `cancellableSet.forEach { $0.cancel() }` と `cancellableSet = []` が実行されることが保証されます。

ただし、ここで注意すべき点が一つあります。現在のコードでは、`.sink`に渡されたクロージャ内で `continuation.resume(returning: ())` を呼び出していますが、これは一度しか呼び出すべきではなく、また後続の処理でエラーを起こさないように注意が必要です。そのため、この処理を実行する前に、既に `continuation` がリジュームされていないことを確認することをおすすめします。

以上の説明はコードの構造と挙動を説明したもので、特定の問題点や改善点があるわけではありません。何か具体的な問題や疑問があれば、お知らせいただければ幸いです。

---

## 👤 User
*2023-07-01 21:19:25*

Constant 'analyzeFinishedCheckedTask' inferred to have type '()', which may be unexpected というエラーになった

---

## 🤖 Assistant
*2023-07-01 21:20:01*

ご提示いただいたエラーメッセージは、Swiftの型推論システムが`analyzeFinishedCheckedTask`という定数の型を`()` (Void)と推論し、これが意図したものでない可能性があると警告しているものです。

`async let`を使うとき、非同期関数の戻り値が非同期タスクの結果として得られます。しかし、`analyzeFinishedChecked()`関数の戻り値は`Void`であり、そのため`analyzeFinishedCheckedTask`も`Void`型になります。これが警告の原因です。

この警告を回避するには、`analyzeFinishedCheckedTask`定数を削除し、`await analyzeFinishedChecked()`を直接呼び出すことができます。

以下に修正したコードを示します：

```swift
public func endAnalysis() async {
    // 分析終了後に視線データが途中で流れないように止める
    gazeTrackManager.stopTracking()
    
    print("*********1************\(emotionDataModels.count)")
    
    // 感情分析のストリームを完了させる
    sampleBufferAndTimestampSubject.send(completion: .finished)
    
    // 相対座標の計算のストリームを完了させる
    gazeInformationSubject.send(completion: .finished)
    
    // Wait for both tasks to complete
    await analyzeFinishedChecked()
    
    print("*********2************\(emotionDataModels.count)")
    cancellableSet.forEach { $0.cancel() }
    cancellableSet = []
}

private func analyzeFinishedChecked() async {
    await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
        analyzeEmotionFinishedPublisher
            .combineLatest(relativeCoordinateGazeInformationFinishedPublisher)
            .sink { _ in
                print("*********analyzeFinishedChecked***********")
                continuation.resume(returning: ())
            } receiveValue: { _, _ in }
            .store(in: &cancellableSet)
    }
}
```

この修正により、警告は消え、`analyzeFinishedChecked()`が非同期に完了するまで待つことが保証されます。

---

## 👤 User
*2023-07-01 21:20:29*

気にしているのはawait analyzeFinishedChecked()の実行前にcontinuation.resume(returning: ())されてしまうことのなんだ。

---

## 🤖 Assistant
*2023-07-01 21:21:05*

確かに、その懸念は理解できます。`analyzeFinishedChecked`関数の`await withCheckedContinuation`の内部で、状態を追跡するために新たなパブリッシャを作成しています。このパブリッシャが完了するのを待つため、`withCheckedContinuation`を使用しています。

ただし、あなたが`.send(completion: .finished)`を呼び出す前に`analyzeFinishedChecked`を呼び出すことを保証すれば、この問題は発生しないはずです。なぜなら、`analyzeFinishedChecked`が呼び出された後でなければパブリッシャが完了することはありえないからです。

以下にその手順を示しています：

```swift
public func endAnalysis() async {
    // 分析終了後に視線データが途中で流れないように止める
    gazeTrackManager.stopTracking()
    
    print("*********1************\(emotionDataModels.count)")
    
    // Start the task of waiting for the publishers to complete
    await analyzeFinishedChecked()
    
    // 感情分析のストリームを完了させる
    sampleBufferAndTimestampSubject.send(completion: .finished)
    
    // 相対座標の計算のストリームを完了させる
    gazeInformationSubject.send(completion: .finished)

    print("*********2************\(emotionDataModels.count)")
    cancellableSet.forEach { $0.cancel() }
    cancellableSet = []
}
```

この変更により、パブリッシャが完了する前に`analyzeFinishedChecked`が開始され、その完了を待つ非同期タスクが確実に開始されます。したがって、`analyzeFinishedChecked`の`await withCheckedContinuation`ブロックの中で`continuation.resume(returning: ())`が呼び出されるのは、`analyzeFinishedChecked`がすでに開始されてからであり、その結果、早すぎる`resume`が行われることはなくなります。

---

## 👤 User
*2023-07-01 21:21:39*

// 感情分析のストリームを完了させる
    sampleBufferAndTimestampSubject.send(completion: .finished)
    
    // 相対座標の計算のストリームを完了させる
    gazeInformationSubject.send(completion: .finished)

の処理が結果的に continuation.resume(returning: ()) ようになっているんだ。

---

## 🤖 Assistant
*2023-07-01 21:22:12*

なるほど、理解しました。`sampleBufferAndTimestampSubject.send(completion: .finished)` と `gazeInformationSubject.send(completion: .finished)` が呼び出された結果として、最終的に `continuation.resume(returning: ())` が実行されるわけですね。

その場合、一つの解決策として `Task` を利用することを提案します。以下のように、`analyzeFinishedChecked` 内で二つの Publisher の完了を別々に待機し、両方が完了したら `continuation.resume(returning: ())` を呼び出すという方法です。

```swift
private func analyzeFinishedChecked() async {
    await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
        var completions = 0
        let completionSink: ((Subscribers.Completion<Never>) -> Void) = { _ in
            completions += 1
            if completions >= 2 {
                continuation.resume(returning: ())
            }
        }
        
        analyzeEmotionFinishedPublisher
            .sink(receiveCompletion: completionSink, receiveValue: { _ in })
            .store(in: &cancellableSet)
            
        relativeCoordinateGazeInformationFinishedPublisher
            .sink(receiveCompletion: completionSink, receiveValue: { _, _ in })
            .store(in: &cancellableSet)
    }
}
```

このコードでは、`analyzeEmotionFinishedPublisher` と `relativeCoordinateGazeInformationFinishedPublisher` の両方の完了を待つための `Task` を作成しています。これらの Publisher が完了するたびに、`completions` カウンタがインクリメントされます。そして、`completions` が 2 になったとき、つまり両方の Publisher が完了したときに、`continuation.resume(returning: ())` が呼び出されます。これにより、`sampleBufferAndTimestampSubject.send(completion: .finished)` と `gazeInformationSubject.send(completion: .finished)` が呼び出された結果として `continuation.resume(returning: ())` が呼び出されることを保証することができます。

---

## 👤 User
*2023-07-01 21:35:33*

こんなふうにanalyzeEmotionFinishedPublisherをsinkすれば全て解決するような気がしてきた。

 private let analyzeEmotionFinishedSubject = PassthroughSubject&lt;Void, Never&gt;()
    private let relativeCoordinateGazeInformationFinishedSubject = PassthroughSubject&lt;Void, Never&gt;()
    
    private var analyzeEmotionFinishedPublisher: AnyPublisher&lt;Void, Never&gt; {
        analyzeEmotionFinishedSubject
            .combineLatest(relativeCoordinateGazeInformationFinishedSubject)
    }

---

## 🤖 Assistant
*2023-07-01 21:36:12*

ご指摘の通り、あなたのコードは`analyzeEmotionFinishedPublisher`が両方の`analyzeEmotionFinishedSubject`と`relativeCoordinateGazeInformationFinishedSubject`がデータを発行した時点で値を発行するように組み合わせています。このため、`analyzeEmotionFinishedPublisher`の`sink`のクロージャ内で`continuation.resume(returning: ())`を呼び出すことで、あなたが意図する動作が実現できそうです。

ただし、ご注意いただきたいのは、`combineLatest`はそれぞれのPublisherから少なくとも1回データが発行された時点で値を発行するため、`analyzeEmotionFinishedSubject`と`relativeCoordinateGazeInformationFinishedSubject`の両方から発行された後にのみ`continuation.resume(returning: ())`が呼び出されることを確認してください。

以下のように`endAnalysis`メソッドを変更することでこの目的を達成できます。

```swift
public func endAnalysis() async {
    // 分析終了後に視線データが途中で流れないように止める
    gazeTrackManager.stopTracking()

    print("*********1************\(emotionDataModels.count)")

    // Start the task of waiting for the publishers to complete
    await analyzeFinishedChecked()

    // 感情分析のストリームを完了させる
    analyzeEmotionFinishedSubject.send(())

    // 相対座標の計算のストリームを完了させる
    relativeCoordinateGazeInformationFinishedSubject.send(())

    print("*********2************\(emotionDataModels.count)")
    cancellableSet.forEach { $0.cancel() }
    cancellableSet = []
}

private func analyzeFinishedChecked() async {
    await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
        analyzeEmotionFinishedPublisher
            .sink { _ in
                print("*********analyzeFinishedChecked***********")
                continuation.resume(returning: ())
            } receiveValue: { _, _ in }
            .store(in: &cancellableSet)
    }
}
```

この変更により、`analyzeEmotionFinishedSubject`と`relativeCoordinateGazeInformationFinishedSubject`がデータを発行すると、`analyzeFinishedChecked`内で`continuation.resume(returning: ())`が呼び出され、非同期タスクが終了します。これにより、`endAnalysis`メソッドは全ての分析が終了した後に処理を進めることができます。

---

## 👤 User
*2023-07-01 21:37:18*

Cannot convert return expression of type 'Publishers.CombineLatest&lt;PassthroughSubject&lt;Void, Never&gt;, PassthroughSubject&lt;Void, Never&gt;&gt;' to return type 'AnyPublisher&lt;Void, Never&gt;'とエラーになった

---

## 🤖 Assistant
*2023-07-01 21:37:35*

`combineLatest`が返す `Publishers.CombineLatest` タイプは直接 `AnyPublisher` タイプに変換できないため、そのエラーが出ています。`.eraseToAnyPublisher()` メソッドを使用して、そのパブリッシャを `AnyPublisher` に変換する必要があります。

以下のように修正してみてください：

```swift
private var analyzeEmotionFinishedPublisher: AnyPublisher<Void, Never> {
    analyzeEmotionFinishedSubject
        .combineLatest(relativeCoordinateGazeInformationFinishedSubject)
        .map { _, _ in () }
        .eraseToAnyPublisher()
}
```

この修正により、`analyzeEmotionFinishedPublisher`の型は `AnyPublisher<Void, Never>` になり、`combineLatest`によって返される値は `Void` にマップされます。このようにすることで、このパブリッシャが発行する値を無視し、その完了イベントだけに興味があることを表現できます。

---

## 👤 User
*2023-07-01 21:37:51*

マージの方がいいってことはある？

---

## 🤖 Assistant
*2023-07-01 21:38:27*

パブリッシャーを結合するのに `merge` が適しているかどうかは、あなたの具体的な要件によります。

`combineLatest` を使うと、二つのパブリッシャーがそれぞれ最新の値を発行するたびに新たな値が発行されます。つまり、二つのパブリッシャーが新たな値を発行したときだけ反応するようにすることができます。

一方、`merge` を使うと、どちらかのパブリッシャーが値を発行するたびにその値が発行されます。つまり、どちらかのパブリッシャーが新たな値を発行したときに反応するようにすることができます。

あなたが `combineLatest` を選んだ理由が、両方のパブリッシャーが完成するまで待つためだとしたら、それは正しい選択です。これは、`combineLatest` の完了イベントが、両方のパブリッシャーが完了したときにのみ発行されるからです。

ただし、一方のパブリッシャーが完了したときに反応する必要があるなら、`merge` の方が適しているかもしれません。この場合、それぞれのパブリッシャーが独立して完了イベントを発行することになります。そのため、一方が完了しても他方がまだ完了していない場合でも、それぞれの完了イベントに反応することができます。

---
