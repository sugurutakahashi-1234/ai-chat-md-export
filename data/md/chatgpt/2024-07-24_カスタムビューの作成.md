# カスタムビューの作成

日付: 2024-07-24

---

## 👤 ユーザー
*2024/7/24 17:31:14*

このViewを以下のところをViewにできるようなものにしてほしい。

Button {} label: {
                Text("写真を登録")
            }

struct TestView: View {
    @State private var selectedImage: UIImage?
    @State private var selectedPhotosPickerItem: PhotosPickerItem? = nil

    @State private var showCameraShoot: Bool = false
    @State private var showPhotoPicker: Bool = false
    @State private var showPhotoCrop: Bool = false

    var body: some View {
        Menu {
            Button {
                showCameraShoot = true
            } label: {
                Label {
                    Text("カメラで撮る")
                } icon: {
                    SFSymbols.camera.image
                }
            }
            
            Button {
                showPhotoPicker = true
            } label: {
                Label {
                    Text("写真を選択する")
                } icon: {
                    SFSymbols.photoOnRectangle.image
                }
            }
        } label: {
            Button {} label: {
                Text("写真を登録")
            }
        }
        .fullScreenCover(isPresented: $showCameraShoot) {
            SimpleCameraShootView(image: $selectedImage)
                .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $showPhotoCrop) {
            PhotoCropView(selectedImage: $selectedImage)
                .navigationStacked()
        }
        .photosPicker(isPresented: $showPhotoPicker, selection: $selectedPhotosPickerItem, matching: .images)
        .onChange(of: selectedPhotosPickerItem) { newItem in
            if let newItem {
                Task {
                    if let data = try? await newItem.loadTransferable(type: Data.self), let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .onChange(of: selectedImage) { image in
            showPhotoCrop = image != nil
        }
        .onChange(of: showPhotoCrop) { showPhotoCrop in
            if showPhotoCrop {
                selectedPhotosPickerItem = nil
            }
        }
    }
}

---

## 🤖 アシスタント
*2024/7/24 17:31:39*

`"写真を登録"` ボタンをカスタムビューとして定義し、使いやすく再利用可能なコンポーネントに変換します。

以下に、カスタムビューとして定義した `PhotoRegisterButton` を示します。

```swift
import SwiftUI
import PhotosUI

struct PhotoRegisterButton: View {
    @Binding var selectedImage: UIImage?
    @State private var selectedPhotosPickerItem: PhotosPickerItem? = nil

    @State private var showCameraShoot: Bool = false
    @State private var showPhotoPicker: Bool = false
    @State private var showPhotoCrop: Bool = false

    var body: some View {
        Menu {
            Button {
                showCameraShoot = true
            } label: {
                Label {
                    Text("カメラで撮る")
                } icon: {
                    SFSymbols.camera.image
                }
            }
            
            Button {
                showPhotoPicker = true
            } label: {
                Label {
                    Text("写真を選択する")
                } icon: {
                    SFSymbols.photoOnRectangle.image
                }
            }
        } label: {
            Text("写真を登録")
        }
        .fullScreenCover(isPresented: $showCameraShoot) {
            SimpleCameraShootView(image: $selectedImage)
                .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $showPhotoCrop) {
            PhotoCropView(selectedImage: $selectedImage)
                .navigationStacked()
        }
        .photosPicker(isPresented: $showPhotoPicker, selection: $selectedPhotosPickerItem, matching: .images)
        .onChange(of: selectedPhotosPickerItem) { newItem in
            if let newItem {
                Task {
                    if let data = try? await newItem.loadTransferable(type: Data.self), let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .onChange(of: selectedImage) { image in
            showPhotoCrop = image != nil
        }
        .onChange(of: showPhotoCrop) { showPhotoCrop in
            if showPhotoCrop {
                selectedPhotosPickerItem = nil
            }
        }
    }
}

struct TestView: View {
    @State private var selectedImage: UIImage?

    var body: some View {
        VStack {
            // 他のビューコンポーネント
            PhotoRegisterButton(selectedImage: $selectedImage)
        }
    }
}
```

このコードでは、`PhotoRegisterButton` をカスタムコンポーネントとして定義し、`TestView` の一部として使用しています。これにより、`"写真を登録"` ボタンを他のビューでも簡単に再利用することができます。

---

## 👤 ユーザー
*2024/7/24 17:32:18*

Text("写真を登録") の部分を任意なViewを与えられるようにしてほしいんだ。

---

## 🤖 アシスタント
*2024/7/24 17:32:47*

`PhotoRegisterButton` に任意のラベルビューを渡せるように汎用化するためには、カスタムラベルを受け取るプロパティを追加します。以下はその実装です。

```swift
import SwiftUI
import PhotosUI

struct PhotoRegisterButton<Label: View>: View {
    @Binding var selectedImage: UIImage?
    @State private var selectedPhotosPickerItem: PhotosPickerItem? = nil

    @State private var showCameraShoot: Bool = false
    @State private var showPhotoPicker: Bool = false
    @State private var showPhotoCrop: Bool = false
    
    let label: () -> Label

    var body: some View {
        Menu {
            Button {
                showCameraShoot = true
            } label: {
                Label {
                    Text("カメラで撮る")
                } icon: {
                    SFSymbols.camera.image
                }
            }
            
            Button {
                showPhotoPicker = true
            } label: {
                Label {
                    Text("写真を選択する")
                } icon: {
                    SFSymbols.photoOnRectangle.image
                }
            }
        } label: {
            label()
        }
        .fullScreenCover(isPresented: $showCameraShoot) {
            SimpleCameraShootView(image: $selectedImage)
                .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $showPhotoCrop) {
            PhotoCropView(selectedImage: $selectedImage)
                .navigationStacked()
        }
        .photosPicker(isPresented: $showPhotoPicker, selection: $selectedPhotosPickerItem, matching: .images)
        .onChange(of: selectedPhotosPickerItem) { newItem in
            if let newItem {
                Task {
                    if let data = try? await newItem.loadTransferable(type: Data.self), let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .onChange(of: selectedImage) { image in
            showPhotoCrop = image != nil
        }
        .onChange(of: showPhotoCrop) { showPhotoCrop in
            if showPhotoCrop {
                selectedPhotosPickerItem = nil
            }
        }
    }
}

struct TestView: View {
    @State private var selectedImage: UIImage?

    var body: some View {
        VStack {
            // 他のビューコンポーネント
            PhotoRegisterButton(selectedImage: $selectedImage) {
                Text("カスタム写真登録")
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
        }
    }
}
```

この実装では、`PhotoRegisterButton` コンポーネントに `Label` の型パラメータを追加し、`label` クロージャを通じて任意のラベルビューを受け取れるようにしました。これにより、`TestView` 内で `PhotoRegisterButton` に任意のビューを渡すことができます。

---

## 👤 ユーザー
*2024/7/24 17:33:51*

ちなみに、PhotoCrop するかしないかを選択できるようなフラグを渡したい。

---

## 🤖 アシスタント
*2024/7/24 17:34:22*

`PhotoRegisterButton` コンポーネントに、PhotoCrop を有効にするかどうかを制御するためのフラグを追加します。このフラグを使用して、PhotoCrop の表示を制御できるようにします。

以下がその実装です。

```swift
import SwiftUI
import PhotosUI

struct PhotoRegisterButton<Label: View>: View {
    @Binding var selectedImage: UIImage?
    @State private var selectedPhotosPickerItem: PhotosPickerItem? = nil

    @State private var showCameraShoot: Bool = false
    @State private var showPhotoPicker: Bool = false
    @State private var showPhotoCrop: Bool = false
    
    let label: () -> Label
    let enablePhotoCrop: Bool

    var body: some View {
        Menu {
            Button {
                showCameraShoot = true
            } label: {
                Label {
                    Text("カメラで撮る")
                } icon: {
                    SFSymbols.camera.image
                }
            }
            
            Button {
                showPhotoPicker = true
            } label: {
                Label {
                    Text("写真を選択する")
                } icon: {
                    SFSymbols.photoOnRectangle.image
                }
            }
        } label: {
            label()
        }
        .fullScreenCover(isPresented: $showCameraShoot) {
            SimpleCameraShootView(image: $selectedImage)
                .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $showPhotoCrop) {
            if enablePhotoCrop {
                PhotoCropView(selectedImage: $selectedImage)
                    .navigationStacked()
            }
        }
        .photosPicker(isPresented: $showPhotoPicker, selection: $selectedPhotosPickerItem, matching: .images)
        .onChange(of: selectedPhotosPickerItem) { newItem in
            if let newItem {
                Task {
                    if let data = try? await newItem.loadTransferable(type: Data.self), let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .onChange(of: selectedImage) { image in
            if enablePhotoCrop {
                showPhotoCrop = image != nil
            } else {
                // ここで追加の処理を行うことも可能です
                showPhotoCrop = false
            }
        }
        .onChange(of: showPhotoCrop) { showPhotoCrop in
            if showPhotoCrop {
                selectedPhotosPickerItem = nil
            }
        }
    }
}

struct TestView: View {
    @State private var selectedImage: UIImage?

    var body: some View {
        VStack {
            // 他のビューコンポーネント
            PhotoRegisterButton(selectedImage: $selectedImage, enablePhotoCrop: true) {
                Text("カスタム写真登録")
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
        }
    }
}
```

この実装では、`PhotoRegisterButton` コンポーネントに `enablePhotoCrop` フラグを追加し、このフラグによって PhotoCrop の有効/無効を制御します。`TestView` で `PhotoRegisterButton` を使用する際に、`enablePhotoCrop` を `true` または `false` に設定することで、PhotoCrop を有効または無効にできます。

---

## 👤 ユーザー
*2024/7/24 17:35:54*

Label: View がLabelとかぶっている

---

## 🤖 アシスタント
*2024/7/24 17:36:24*

`Label` と名前が重複している問題を解決するために、型パラメータの名前を変更します。例えば、`Content` という名前に変更します。

以下はその修正です。

```swift
import SwiftUI
import PhotosUI

struct PhotoRegisterButton<Content: View>: View {
    @Binding var selectedImage: UIImage?
    @State private var selectedPhotosPickerItem: PhotosPickerItem? = nil

    @State private var showCameraShoot: Bool = false
    @State private var showPhotoPicker: Bool = false
    @State private var showPhotoCrop: Bool = false
    
    let label: () -> Content
    let enablePhotoCrop: Bool

    var body: some View {
        Menu {
            Button {
                showCameraShoot = true
            } label: {
                Label {
                    Text("カメラで撮る")
                } icon: {
                    SFSymbols.camera.image
                }
            }
            
            Button {
                showPhotoPicker = true
            } label: {
                Label {
                    Text("写真を選択する")
                } icon: {
                    SFSymbols.photoOnRectangle.image
                }
            }
        } label: {
            label()
        }
        .fullScreenCover(isPresented: $showCameraShoot) {
            SimpleCameraShootView(image: $selectedImage)
                .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $showPhotoCrop) {
            if enablePhotoCrop {
                PhotoCropView(selectedImage: $selectedImage)
                    .navigationStacked()
            }
        }
        .photosPicker(isPresented: $showPhotoPicker, selection: $selectedPhotosPickerItem, matching: .images)
        .onChange(of: selectedPhotosPickerItem) { newItem in
            if let newItem {
                Task {
                    if let data = try? await newItem.loadTransferable(type: Data.self), let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .onChange(of: selectedImage) { image in
            if enablePhotoCrop {
                showPhotoCrop = image != nil
            } else {
                // ここで追加の処理を行うことも可能です
                showPhotoCrop = false
            }
        }
        .onChange(of: showPhotoCrop) { showPhotoCrop in
            if showPhotoCrop {
                selectedPhotosPickerItem = nil
            }
        }
    }
}

struct TestView: View {
    @State private var selectedImage: UIImage?

    var body: some View {
        VStack {
            // 他のビューコンポーネント
            PhotoRegisterButton(selectedImage: $selectedImage, enablePhotoCrop: true) {
                Text("カスタム写真登録")
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
        }
    }
}
```

この修正により、`Content` という名前を使用することで、型パラメータの名前と `Label` との衝突を避けています。

---

## 👤 ユーザー
*2024/7/24 17:46:19*

これの2パターンのpreview画面を実装してほしい#Previewを使ってほしいiOS18以降である

struct PhotoRegisterButton&lt;Content: View&gt;: View {
    @Binding var selectedImage: UIImage?
    let enablePhotoCrop: Bool
    let label: () -&gt; Content

    @State private var selectedPhotosPickerItem: PhotosPickerItem? = nil
    @State private var showCameraShoot: Bool = false
    @State private var showPhotoPicker: Bool = false
    @State private var showPhotoCrop: Bool = false

    var body: some View {
        Menu {
            Button {
                showCameraShoot = true
            } label: {
                Label {
                    Text("カメラで撮る")
                } icon: {
                    SFSymbols.camera.image
                }
            }
            
            Button {
                showPhotoPicker = true
            } label: {
                Label {
                    Text("写真を選択する")
                } icon: {
                    SFSymbols.photoOnRectangle.image
                }
            }
        } label: {
            label()
        }
        .fullScreenCover(isPresented: $showCameraShoot) {
            SimpleCameraShootView(image: $selectedImage)
                .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $showPhotoCrop) {
            PhotoCropView(selectedImage: $selectedImage)
                .navigationStacked()
        }
        .photosPicker(isPresented: $showPhotoPicker, selection: $selectedPhotosPickerItem, matching: .images)
        .onChange(of: selectedPhotosPickerItem) { newItem in
            if let newItem {
                Task {
                    if let data = try? await newItem.loadTransferable(type: Data.self), let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .onChange(of: selectedImage) { image in
            if enablePhotoCrop {
                showPhotoCrop = image != nil
            } else {
                showPhotoCrop = false
            }
        }
        .onChange(of: showPhotoCrop) { showPhotoCrop in
            if showPhotoCrop {
                selectedPhotosPickerItem = nil
            }
        }
    }
}

---

## 🤖 アシスタント
*2024/7/24 17:46:47*

`PhotoRegisterButton` のプレビューを2パターン実装するために、iOS 18 以降で利用できる `#Preview` を使用して、異なる `enablePhotoCrop` 設定を持つプレビューを作成します。

以下はそのコードです：

```swift
import SwiftUI
import PhotosUI

struct PhotoRegisterButton<Content: View>: View {
    @Binding var selectedImage: UIImage?
    let enablePhotoCrop: Bool
    let label: () -> Content

    @State private var selectedPhotosPickerItem: PhotosPickerItem? = nil
    @State private var showCameraShoot: Bool = false
    @State private var showPhotoPicker: Bool = false
    @State private var showPhotoCrop: Bool = false

    var body: some View {
        Menu {
            Button {
                showCameraShoot = true
            } label: {
                Label {
                    Text("カメラで撮る")
                } icon: {
                    SFSymbols.camera.image
                }
            }
            
            Button {
                showPhotoPicker = true
            } label: {
                Label {
                    Text("写真を選択する")
                } icon: {
                    SFSymbols.photoOnRectangle.image
                }
            }
        } label: {
            label()
        }
        .fullScreenCover(isPresented: $showCameraShoot) {
            SimpleCameraShootView(image: $selectedImage)
                .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $showPhotoCrop) {
            if enablePhotoCrop {
                PhotoCropView(selectedImage: $selectedImage)
                    .navigationStacked()
            }
        }
        .photosPicker(isPresented: $showPhotoPicker, selection: $selectedPhotosPickerItem, matching: .images)
        .onChange(of: selectedPhotosPickerItem) { newItem in
            if let newItem {
                Task {
                    if let data = try? await newItem.loadTransferable(type: Data.self), let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .onChange(of: selectedImage) { image in
            if enablePhotoCrop {
                showPhotoCrop = image != nil
            } else {
                showPhotoCrop = false
            }
        }
        .onChange(of: showPhotoCrop) { showPhotoCrop in
            if showPhotoCrop {
                selectedPhotosPickerItem = nil
            }
        }
    }
}

#Preview("PhotoRegisterButton with PhotoCrop enabled") {
    @State var selectedImage: UIImage? = nil
    return PhotoRegisterButton(selectedImage: $selectedImage, enablePhotoCrop: true) {
        Text("写真を登録")
            .padding()
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(8)
    }
}

#Preview("PhotoRegisterButton with PhotoCrop disabled") {
    @State var selectedImage: UIImage? = nil
    return PhotoRegisterButton(selectedImage: $selectedImage, enablePhotoCrop: false) {
        Text("写真を登録")
            .padding()
            .background(Color.green)
            .foregroundColor(.white)
            .cornerRadius(8)
    }
}
```

このコードでは、`PhotoRegisterButton` のプレビューを `#Preview` アトリビュートを使用して2つ作成しています。1つは `enablePhotoCrop` が `true` の場合、もう1つは `enablePhotoCrop` が `false` の場合です。それぞれのプレビューでは、ラベルのスタイルを異なる色で示しています。

---

## 👤 ユーザー
*2024/7/24 17:49:15*

VStackで登録した画像を上に表示してほしい

@available(iOS 18.0, *)
#Preview("PhotoCrop enabled") {
    @Previewable @State var selectedImage: UIImage? = nil

    return PhotoRegisterButton(selectedImage: $selectedImage, enablePhotoCrop: true) {
        Text("写真を登録")
            .padding()
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(8)
    }
}

@available(iOS 18.0, *)
#Preview("PhotoCrop disabled") {
    @Previewable @State var selectedImage: UIImage? = nil

    return PhotoRegisterButton(selectedImage: $selectedImage, enablePhotoCrop: false) {
        Text("写真を登録")
            .padding()
            .background(Color.green)
            .foregroundColor(.white)
            .cornerRadius(8)
    }
}

---

## 🤖 アシスタント
*2024/7/24 17:49:52*

`VStack` を使用して、登録した画像を上部に表示するように `PhotoRegisterButton` をプレビューします。以下にその実装を示します。

```swift
import SwiftUI
import PhotosUI

struct PhotoRegisterButton<Content: View>: View {
    @Binding var selectedImage: UIImage?
    let enablePhotoCrop: Bool
    let label: () -> Content

    @State private var selectedPhotosPickerItem: PhotosPickerItem? = nil
    @State private var showCameraShoot: Bool = false
    @State private var showPhotoPicker: Bool = false
    @State private var showPhotoCrop: Bool = false

    var body: some View {
        Menu {
            Button {
                showCameraShoot = true
            } label: {
                Label {
                    Text("カメラで撮る")
                } icon: {
                    SFSymbols.camera.image
                }
            }
            
            Button {
                showPhotoPicker = true
            } label: {
                Label {
                    Text("写真を選択する")
                } icon: {
                    SFSymbols.photoOnRectangle.image
                }
            }
        } label: {
            label()
        }
        .fullScreenCover(isPresented: $showCameraShoot) {
            SimpleCameraShootView(image: $selectedImage)
                .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $showPhotoCrop) {
            if enablePhotoCrop {
                PhotoCropView(selectedImage: $selectedImage)
                    .navigationStacked()
            }
        }
        .photosPicker(isPresented: $showPhotoPicker, selection: $selectedPhotosPickerItem, matching: .images)
        .onChange(of: selectedPhotosPickerItem) { newItem in
            if let newItem {
                Task {
                    if let data = try? await newItem.loadTransferable(type: Data.self), let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .onChange(of: selectedImage) { image in
            if enablePhotoCrop {
                showPhotoCrop = image != nil
            } else {
                showPhotoCrop = false
            }
        }
        .onChange(of: showPhotoCrop) { showPhotoCrop in
            if showPhotoCrop {
                selectedPhotosPickerItem = nil
            }
        }
    }
}

@available(iOS 18.0, *)
#Preview("PhotoCrop enabled") {
    @Previewable @State var selectedImage: UIImage? = nil

    return VStack {
        if let selectedImage {
            Image(uiImage: selectedImage)
                .resizable()
                .scaledToFit()
                .frame(height: 200)
                .padding()
        }
        PhotoRegisterButton(selectedImage: $selectedImage, enablePhotoCrop: true) {
            Text("写真を登録")
                .padding()
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(8)
        }
    }
}

@available(iOS 18.0, *)
#Preview("PhotoCrop disabled") {
    @Previewable @State var selectedImage: UIImage? = nil

    return VStack {
        if let selectedImage {
            Image(uiImage: selectedImage)
                .resizable()
                .scaledToFit()
                .frame(height: 200)
                .padding()
        }
        PhotoRegisterButton(selectedImage: $selectedImage, enablePhotoCrop: false) {
            Text("写真を登録")
                .padding()
                .background(Color.green)
                .foregroundColor(.white)
                .cornerRadius(8)
        }
    }
}
```

この実装では、`VStack` を使用して、選択された画像が存在する場合にはその画像を上部に表示し、その下に `PhotoRegisterButton` を表示するようにしています。これにより、選択された画像が見やすくなります。

---

## 👤 ユーザー
*2024/7/24 17:53:43*

写真が横長の画面でも 円のサークルがはみ出ないようにしてほしい

struct PhotoCropView: View {
    @Binding var selectedImage: UIImage?
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack {
            if let selectedImage {
                GeometryReader { geometry in
                    let size = min(geometry.size.width, geometry.size.height)

                    ZStack {
                        Image(uiImage: selectedImage)
                            .resizable()
                            .scaledToFit()
                            .frame(width: geometry.size.width, height: geometry.size.height)
                            .clipped()
                        
                        // 半透明のオーバーレイ
                        Rectangle()
                            .fill(Color.black.opacity(0.5))
                            .mask(
                                ZStack {
                                    Rectangle()
                                        .fill(Color.white)
                                    Circle()
                                        .frame(width: size * 0.8, height: size * 0.8)
                                        .blendMode(.destinationOut)
                                }
                            )
                            .compositingGroup()
                            .frame(width: geometry.size.width, height: geometry.size.height)
                        
                        Text("TODO: クリップ機能や拡大縮小機能は未実装")
                            .foregroundColor(.white)
                    }
                }
            } else {
                Text("No Image Selected")
                    .foregroundColor(.white)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.black)
        .ignoresSafeArea()
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    selectedImage = nil
                    dismiss.callAsFunction()
                } label: {
                    Text("キャンセル")
                        .foregroundStyle(.white)
                }
            }

            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("適用")
                        .foregroundStyle(.white)
                }
            }
        }
    }
}

---

## 🤖 アシスタント
*2024/7/24 17:54:08*

`PhotoCropView` の円形サークルが画面からはみ出ないようにするために、`GeometryReader` のサイズに基づいてサークルのサイズを調整し、常に中央に配置されるようにします。また、円形サークルの外側のオーバーレイも適切に調整します。

以下に修正したコードを示します：

```swift
import SwiftUI

struct PhotoCropView: View {
    @Binding var selectedImage: UIImage?
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack {
            if let selectedImage {
                GeometryReader { geometry in
                    let size = min(geometry.size.width, geometry.size.height)
                    let circleSize = size * 0.8

                    ZStack {
                        Image(uiImage: selectedImage)
                            .resizable()
                            .scaledToFit()
                            .frame(width: geometry.size.width, height: geometry.size.height)
                            .clipped()
                        
                        // 半透明のオーバーレイ
                        Rectangle()
                            .fill(Color.black.opacity(0.5))
                            .mask(
                                ZStack {
                                    Rectangle()
                                        .fill(Color.white)
                                    Circle()
                                        .frame(width: circleSize, height: circleSize)
                                        .blendMode(.destinationOut)
                                        .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                                }
                            )
                            .compositingGroup()
                            .frame(width: geometry.size.width, height: geometry.size.height)
                        
                        Text("TODO: クリップ機能や拡大縮小機能は未実装")
                            .foregroundColor(.white)
                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                    }
                }
            } else {
                Text("No Image Selected")
                    .foregroundColor(.white)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.black)
        .ignoresSafeArea()
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    selectedImage = nil
                    dismiss.callAsFunction()
                } label: {
                    Text("キャンセル")
                        .foregroundStyle(.white)
                }
            }

            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("適用")
                        .foregroundStyle(.white)
                }
            }
        }
    }
}
```

この修正では、`Circle` を `GeometryReader` の中心に配置し、そのサイズを `geometry.size.width` または `geometry.size.height` の最小値の 80% に設定しています。これにより、円形サークルが常に画面内に収まり、はみ出すことがなくなります。また、`Text` 要素も中央に配置しています。

---

## 👤 ユーザー
*2024/7/24 17:59:06*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-XokltJVsxPh9zHbas0wuJxgw",
  "size_bytes": 369335,
  "width": 545,
  "height": 962,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
このようにちょっと円がはみ出しているんだよね

---

## 🤖 アシスタント
*2024/7/24 17:59:33*

円が画面からはみ出さないようにするために、`Circle` のサイズを調整し、画面の短辺に合わせるようにします。以下に修正したコードを示します：

```swift
import SwiftUI

struct PhotoCropView: View {
    @Binding var selectedImage: UIImage?
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack {
            if let selectedImage {
                GeometryReader { geometry in
                    let circleSize = min(geometry.size.width, geometry.size.height) * 0.8

                    ZStack {
                        Image(uiImage: selectedImage)
                            .resizable()
                            .scaledToFit()
                            .frame(width: geometry.size.width, height: geometry.size.height)
                            .clipped()
                        
                        // 半透明のオーバーレイ
                        Rectangle()
                            .fill(Color.black.opacity(0.5))
                            .mask(
                                ZStack {
                                    Rectangle()
                                        .fill(Color.white)
                                    Circle()
                                        .frame(width: circleSize, height: circleSize)
                                        .blendMode(.destinationOut)
                                        .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                                }
                            )
                            .compositingGroup()
                            .frame(width: geometry.size.width, height: geometry.size.height)
                        
                        Text("TODO: クリップ機能や拡大縮小機能は未実装")
                            .foregroundColor(.white)
                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                    }
                }
            } else {
                Text("No Image Selected")
                    .foregroundColor(.white)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.black)
        .ignoresSafeArea()
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    selectedImage = nil
                    dismiss.callAsFunction()
                } label: {
                    Text("キャンセル")
                        .foregroundStyle(.white)
                }
            }

            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("適用")
                        .foregroundStyle(.white)
                }
            }
        }
    }
}
```

この修正では、`circleSize` を `geometry.size.width` と `geometry.size.height` の最小値の 80% に設定しています。これにより、円が画面の短辺に合わせて縮小され、はみ出すことがなくなります。

---
