# Organize audio display.

Êó•‰ªò: 2024-05-17

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/5/17 11:46:45*

‰ªä„Åì„ÅÆ„Çà„ÅÜ„Å™ÂÆüË£Ö„Åß„Åô„ÄÇ
Êó•‰ªò„Åî„Å®„Å´„ÅÜ„Åæ„Åè„Çè„Åã„Çã„Çà„ÅÜ„Å´ÂàÜ„Åë„Å¶Ê¨≤„Åó„ÅÑ„ÅÆ„Å®„ÄÅDisclosureGroup „Çí„ÇÑ„ÇÅ„Å¶fileSize „Å®duration „Çí„ÅÑ„ÅÑÊÑü„Åò„Å´Ë°®Áèæ„Åó„Åü„ÅÑ„ÄÇ

public struct AudioData: Sendable {
    let audioUrl: URL
    let createdAt: Date
    let fileSize: Int
    let duration: TimeInterval
}

extension AudioData: Identifiable {
    public var id: String {
        audioUrl.absoluteString
    }
}


@MainActor
struct AudioListView: View {
    @StateObject private var presenter: AudioListPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            if presenter.audioDatas.isEmpty {
                Text("„Ç®„É©„ÉºÔºÅ Âè≥‰∏ä„Åã„ÇâÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                    .isHidden(presenter.appError.isNil, remove: true)
                Text("„Éá„Éº„Çø„Åå1‰ª∂„ÇÇ„ÅÇ„Åæ„Åõ„Çì")
                    .isHidden(presenter.appError.isNotNil, remove: true)
            } else {
                ForEach(presenter.searchedAudioDatas) { audioData in
                    DisclosureGroup {
                        HStack {
                            Text("Date")
                            Spacer()
                            Text(audioData.createdAt.asISO8601)
                        }
                        HStack {
                            Text("Time")
                            Spacer()
                            Text(audioData.duration.mmss)
                        }
                        HStack {
                            Text("Size")
                            Spacer()
                            Text(audioData.fileSize.formattedSize)
                        }
                        HStack {
                            Text("Extension")
                            Spacer()
                            Text(audioData.audioUrl.pathExtension)
                        }
                    } label: {
                        Button {
                            presenter.onTapAudio(audioData: audioData)
                        } label: {
                            Text(audioData.audioUrl.lastPathComponent)
                        }
                    }
                }
            }
        }
        .searchable(text: $presenter.searchText) {}
        .toolbar {
            ToolbarItemGroup(placement: .topBarTrailing) {
                Button {
                    presenter.onTapTrash()
                } label: {
                    SFSymbols.trash.image
                        .foregroundStyle(.red)
                }
            }
        }
        .navigationTitle("Audio List")
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: false)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError, onOk: { _ in
            presenter.onTapOkDelete()
        })
        .sheet(item: $presenter.selectedAudioUrl, content: { audioUrl in
            if #available(iOS 16.0, *) {
                AudioPlayerView(audioUrl: audioUrl)
                    .navigationStacked()
                    .presentationDetents([.medium])
            } else {
                Text("iOS 15„ÅØÂØæÂøú„Åó„Å¶„Åä„Çä„Åæ„Åõ„Çì")
            }
        })
        .task {
            await presenter.onAppear()
        }
    }
}

extension URL: Identifiable {
    public var id: String {
        absoluteString
    }
}

#Preview {
    AudioListView()
        .navigationStacked()
}

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/5/17 11:47:21*

User is working on an AudioListView implementation in SwiftUI and wants to organize the audio data by date and improve the representation of fileSize and duration.

---

## üîß „ÉÑ„Éº„É´
*2024/5/17 11:47:21*

Model set context updated.

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/5/17 11:47:21*

To achieve better organization by date and improve the display of `fileSize` and `duration` without using `DisclosureGroup`, you can refactor the `AudioListView` to group audio files by date and present the `fileSize` and `duration` more clearly. Here's a revised implementation:

1. Create a dictionary to group audio files by date.
2. Use a custom view to display each audio file's details.

Here is the updated code:

```swift
import SwiftUI

public struct AudioData: Sendable {
    let audioUrl: URL
    let createdAt: Date
    let fileSize: Int
    let duration: TimeInterval
}

extension AudioData: Identifiable {
    public var id: String {
        audioUrl.absoluteString
    }
}

@MainActor
class AudioListPresenter: ObservableObject {
    @Published var audioDatas: [AudioData] = []
    @Published var searchedAudioDatas: [AudioData] = []
    @Published var searchText: String = ""
    @Published var isLoading: Bool = false
    @Published var appError: Error? = nil
    @Published var showAlert: Bool = false
    @Published var selectedAudioUrl: URL? = nil

    func onTapAudio(audioData: AudioData) {
        // Handle audio tap
    }

    func onTapTrash() {
        // Handle trash button tap
    }

    func onTapOkDelete() {
        // Handle OK button tap for delete
    }

    func onAppear() async {
        // Handle view appear
    }
}

extension Date {
    var asISO8601: String {
        let formatter = ISO8601DateFormatter()
        return formatter.string(from: self)
    }
}

extension TimeInterval {
    var mmss: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}

extension Int {
    var formattedSize: String {
        ByteCountFormatter.string(fromByteCount: Int64(self), countStyle: .file)
    }
}

struct AudioFileRow: View {
    let audioData: AudioData

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(audioData.audioUrl.lastPathComponent)
                .font(.headline)
            HStack {
                Text("Date:")
                Spacer()
                Text(audioData.createdAt.asISO8601)
            }
            HStack {
                Text("Duration:")
                Spacer()
                Text(audioData.duration.mmss)
            }
            HStack {
                Text("Size:")
                Spacer()
                Text(audioData.fileSize.formattedSize)
            }
            HStack {
                Text("Extension:")
                Spacer()
                Text(audioData.audioUrl.pathExtension)
            }
        }
        .padding()
    }
}

struct AudioListView: View {
    @StateObject private var presenter: AudioListPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            if presenter.audioDatas.isEmpty {
                Text("„Ç®„É©„ÉºÔºÅ Âè≥‰∏ä„Åã„ÇâÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                    .isHidden(presenter.appError.isNil, remove: true)
                Text("„Éá„Éº„Çø„Åå1‰ª∂„ÇÇ„ÅÇ„Åæ„Åõ„Çì")
                    .isHidden(presenter.appError.isNotNil, remove: true)
            } else {
                ForEach(groupedAudioDatas.keys.sorted(), id: \.self) { date in
                    Section(header: Text(date)) {
                        ForEach(groupedAudioDatas[date] ?? []) { audioData in
                            AudioFileRow(audioData: audioData)
                                .onTapGesture {
                                    presenter.onTapAudio(audioData: audioData)
                                }
                        }
                    }
                }
            }
        }
        .searchable(text: $presenter.searchText)
        .toolbar {
            ToolbarItemGroup(placement: .topBarTrailing) {
                Button {
                    presenter.onTapTrash()
                } label: {
                    Image(systemName: "trash")
                        .foregroundColor(.red)
                }
            }
        }
        .navigationTitle("Audio List")
        .overlay(LoadingView(isLoading: $presenter.isLoading))
        .alert(isPresented: $presenter.showAlert) {
            Alert(title: Text("Error"), message: Text(presenter.appError?.localizedDescription ?? ""), dismissButton: .default(Text("OK"), action: {
                presenter.onTapOkDelete()
            }))
        }
        .sheet(item: $presenter.selectedAudioUrl) { audioUrl in
            if #available(iOS 16.0, *) {
                AudioPlayerView(audioUrl: audioUrl)
                    .presentationDetents([.medium])
            } else {
                Text("iOS 15„ÅØÂØæÂøú„Åó„Å¶„Åä„Çä„Åæ„Åõ„Çì")
            }
        }
        .task {
            await presenter.onAppear()
        }
    }

    private var groupedAudioDatas: [String: [AudioData]] {
        Dictionary(grouping: presenter.searchedAudioDatas) { audioData in
            let formatter = DateFormatter()
            formatter.dateStyle = .medium
            return formatter.string(from: audioData.createdAt)
        }
    }
}

extension URL: Identifiable {
    public var id: String {
        absoluteString
    }
}

struct LoadingView: View {
    @Binding var isLoading: Bool

    var body: some View {
        if isLoading {
            ProgressView("Loading...")
                .progressViewStyle(CircularProgressViewStyle())
        }
    }
}

struct AudioPlayerView: View {
    let audioUrl: URL

    var body: some View {
        Text("Audio player for \(audioUrl.lastPathComponent)")
    }
}

#Preview {
    AudioListView()
}
```

### Changes Made:
1. **Grouped Audio Files by Date**: Audio files are grouped by their creation date and displayed in sections.
2. **Custom View for Audio Details**: `AudioFileRow` presents each audio file's details in a clear layout.
3. **Removed `DisclosureGroup`**: Simplified the interface by removing the `DisclosureGroup`.

This should provide a more organized and user-friendly presentation of the audio files.

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/5/17 11:49:00*

ËæûÊõ∏Âûã„Çí‰Ωø„ÅÜ„ÅÆ„ÅØ„ÇÑ„ÇÅ„Å¶„Åª„Åó„ÅÑ„ÄÇ„ÇÇ„Å£„Å®„Çπ„Éû„Éº„Éà„Å´„Åß„Åç„Å™„ÅÑ„ÅÆ„Åã„Å™Ôºü

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/5/17 11:49:41*

ËæûÊõ∏Âûã„Çí‰Ωø„Çè„Åö„Å´„ÄÅ„ÇÇ„Å£„Å®„Çπ„Éû„Éº„Éà„Å´Êó•‰ªò„Åî„Å®„Å´„Ç™„Éº„Éá„Ç£„Ç™„Éá„Éº„Çø„ÇíË°®Á§∫„Åô„ÇãÊñπÊ≥ï„Å®„Åó„Å¶„ÄÅ`ForEach`„ÅÆ‰Ωø„ÅÑÊñπ„ÇíÂ∑•Â§´„Åó„Å¶„ÄÅ„Çª„ÇØ„Ç∑„Éß„É≥„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´`AudioData`„ÇíÊó•‰ªò„Åî„Å®„Å´„Ç∞„É´„Éº„ÉóÂåñ„Åó„ÄÅÂêÑÊó•‰ªò„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„Åî„Å®„Å´„Ç™„Éº„Éá„Ç£„Ç™„Éá„Éº„Çø„ÇíË°®Á§∫„Åô„ÇãÂÆüË£Ö„Åß„Åô„ÄÇ

„Åæ„Åö„ÄÅÊó•‰ªò„Åî„Å®„Å´„Ç∞„É´„Éº„ÉóÂåñ„Åô„Çã„Åü„ÇÅ„ÅÆÊã°Âºµ„É°„ÇΩ„ÉÉ„Éâ„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ

```swift
import SwiftUI

public struct AudioData: Sendable {
    let audioUrl: URL
    let createdAt: Date
    let fileSize: Int
    let duration: TimeInterval
}

extension AudioData: Identifiable {
    public var id: String {
        audioUrl.absoluteString
    }
}

@MainActor
class AudioListPresenter: ObservableObject {
    @Published var audioDatas: [AudioData] = []
    @Published var searchedAudioDatas: [AudioData] = []
    @Published var searchText: String = ""
    @Published var isLoading: Bool = false
    @Published var appError: Error? = nil
    @Published var showAlert: Bool = false
    @Published var selectedAudioUrl: URL? = nil

    func onTapAudio(audioData: AudioData) {
        // Handle audio tap
    }

    func onTapTrash() {
        // Handle trash button tap
    }

    func onTapOkDelete() {
        // Handle OK button tap for delete
    }

    func onAppear() async {
        // Handle view appear
    }
}

extension Date {
    var asISO8601: String {
        let formatter = ISO8601DateFormatter()
        return formatter.string(from: self)
    }
    
    var mediumFormat: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: self)
    }
}

extension TimeInterval {
    var mmss: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}

extension Int {
    var formattedSize: String {
        ByteCountFormatter.string(fromByteCount: Int64(self), countStyle: .file)
    }
}

struct AudioFileRow: View {
    let audioData: AudioData

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(audioData.audioUrl.lastPathComponent)
                .font(.headline)
            HStack {
                Text("Date:")
                Spacer()
                Text(audioData.createdAt.asISO8601)
            }
            HStack {
                Text("Duration:")
                Spacer()
                Text(audioData.duration.mmss)
            }
            HStack {
                Text("Size:")
                Spacer()
                Text(audioData.fileSize.formattedSize)
            }
            HStack {
                Text("Extension:")
                Spacer()
                Text(audioData.audioUrl.pathExtension)
            }
        }
        .padding()
    }
}

struct AudioListView: View {
    @StateObject private var presenter: AudioListPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            if presenter.audioDatas.isEmpty {
                Text("„Ç®„É©„ÉºÔºÅ Âè≥‰∏ä„Åã„ÇâÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                    .isHidden(presenter.appError.isNil, remove: true)
                Text("„Éá„Éº„Çø„Åå1‰ª∂„ÇÇ„ÅÇ„Åæ„Åõ„Çì")
                    .isHidden(presenter.appError.isNotNil, remove: true)
            } else {
                ForEach(groupedAudioDatas, id: \.self) { group in
                    Section(header: Text(group.date.mediumFormat)) {
                        ForEach(group.audioDatas) { audioData in
                            AudioFileRow(audioData: audioData)
                                .onTapGesture {
                                    presenter.onTapAudio(audioData: audioData)
                                }
                        }
                    }
                }
            }
        }
        .searchable(text: $presenter.searchText)
        .toolbar {
            ToolbarItemGroup(placement: .topBarTrailing) {
                Button {
                    presenter.onTapTrash()
                } label: {
                    Image(systemName: "trash")
                        .foregroundColor(.red)
                }
            }
        }
        .navigationTitle("Audio List")
        .overlay(LoadingView(isLoading: $presenter.isLoading))
        .alert(isPresented: $presenter.showAlert) {
            Alert(title: Text("Error"), message: Text(presenter.appError?.localizedDescription ?? ""), dismissButton: .default(Text("OK"), action: {
                presenter.onTapOkDelete()
            }))
        }
        .sheet(item: $presenter.selectedAudioUrl) { audioUrl in
            if #available(iOS 16.0, *) {
                AudioPlayerView(audioUrl: audioUrl)
                    .presentationDetents([.medium])
            } else {
                Text("iOS 15„ÅØÂØæÂøú„Åó„Å¶„Åä„Çä„Åæ„Åõ„Çì")
            }
        }
        .task {
            await presenter.onAppear()
        }
    }

    private var groupedAudioDatas: [AudioGroup] {
        Dictionary(grouping: presenter.searchedAudioDatas, by: { $0.createdAt.startOfDay })
            .map { AudioGroup(date: $0.key, audioDatas: $0.value) }
            .sorted(by: { $0.date > $1.date })
    }
}

struct AudioGroup: Identifiable {
    var id: Date { date }
    let date: Date
    let audioDatas: [AudioData]
}

extension Date {
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }
}

extension URL: Identifiable {
    public var id: String {
        absoluteString
    }
}

struct LoadingView: View {
    @Binding var isLoading: Bool

    var body: some View {
        if isLoading {
            ProgressView("Loading...")
                .progressViewStyle(CircularProgressViewStyle())
        }
    }
}

struct AudioPlayerView: View {
    let audioUrl: URL

    var body: some View {
        Text("Audio player for \(audioUrl.lastPathComponent)")
    }
}

#Preview {
    AudioListView()
}
```

### ‰∏ª„Å™Â§âÊõ¥ÁÇπ
1. **Êó•‰ªò„Åî„Å®„ÅÆ„Ç∞„É´„Éº„ÉóÂåñ**Ôºö`Dictionary`„ÅÆ`grouping`„Çí‰ΩøÁî®„Åó„ÄÅÊó•‰ªò„Åî„Å®„Å´`AudioData`„Çí„Ç∞„É´„Éº„ÉóÂåñ„Åó„ÄÅ„Åù„Çå„Çí`AudioGroup`ÊßãÈÄ†‰Ωì„Å´„Éû„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ
2. **„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ‰ΩøÁî®**ÔºöÂêÑÊó•‰ªò„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„Çí`ForEach`„ÅßÁîüÊàê„Åó„ÄÅ„Åù„ÅÆ‰∏≠„Å´„Ç™„Éº„Éá„Ç£„Ç™„Éá„Éº„Çø„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
3. **Êã°Âºµ„É°„ÇΩ„ÉÉ„Éâ**Ôºö`Date`„ÅÆÊã°Âºµ„Å®„Åó„Å¶`startOfDay`„ÇíËøΩÂä†„Åó„ÄÅÂêå„ÅòÊó•‰ªò„ÅÆ„Éá„Éº„Çø„Çí„Ç∞„É´„Éº„ÉóÂåñ„Åó„Åæ„Åô„ÄÇ

„Åì„ÅÆÊñπÊ≥ï„Åß„ÄÅÊó•‰ªò„Åî„Å®„Å´„Ç™„Éº„Éá„Ç£„Ç™„Éá„Éº„Çø„Çí„Çπ„Éû„Éº„Éà„Å´Ë°®Á§∫„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/5/17 11:50:55*

Dictionary „ÅÆÂá¶ÁêÜ„ÇíÊ•µÂäõ„Å™„Åè„Åó„Åü„ÅÑ„Çì„Å†„ÄÇ
„Åæ„Åö„ÄÅAudioData„ÅÆ„É™„Çπ„Éà„Åã„ÇâÊúâÂäπ„Å™Êó•‰ªò‰∏ÄË¶ß„ÇíÂèñÂæó„Åó„Å¶„ÄÅ„Åù„Çå„ÇíForEach„ÅßÂõû„Åó„Å¶„ÄÅÂêå„ÅòÊó•‰ªò„ÅÆ„ÇÇ„ÅÆ„Çí„Éí„ÉÉ„Éà„Åï„Åõ„Å¶Ë°®Á§∫„Åï„Åõ„Çã„Ç§„É°„Éº„Ç∏

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/5/17 11:51:31*

ËæûÊõ∏„Çí‰ΩøÁî®„Åõ„Åö„ÄÅ`AudioData`„ÅÆ„É™„Çπ„Éà„Åã„ÇâÊúâÂäπ„Å™Êó•‰ªò‰∏ÄË¶ß„ÇíÂèñÂæó„Åó„ÄÅ„Åù„Çå„Çí`ForEach`„ÅßÂõû„Åó„Å¶Âêå„ÅòÊó•‰ªò„ÅÆ„ÇÇ„ÅÆ„ÇíË°®Á§∫„Åô„ÇãÊñπÊ≥ï„ÇíÂÆüË£Ö„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Å´„Çà„Çä„ÄÅ„Ç≥„Éº„Éâ„Åå„Çà„Çä„Ç∑„É≥„Éó„É´„Å´„Å™„Çä„Åæ„Åô„ÄÇ

‰ª•‰∏ã„ÅØ„Åù„ÅÆÂÆüË£Ö‰æã„Åß„ÅôÔºö

```swift
import SwiftUI

public struct AudioData: Sendable {
    let audioUrl: URL
    let createdAt: Date
    let fileSize: Int
    let duration: TimeInterval
}

extension AudioData: Identifiable {
    public var id: String {
        audioUrl.absoluteString
    }
}

@MainActor
class AudioListPresenter: ObservableObject {
    @Published var audioDatas: [AudioData] = []
    @Published var searchedAudioDatas: [AudioData] = []
    @Published var searchText: String = ""
    @Published var isLoading: Bool = false
    @Published var appError: Error? = nil
    @Published var showAlert: Bool = false
    @Published var selectedAudioUrl: URL? = nil

    func onTapAudio(audioData: AudioData) {
        // Handle audio tap
    }

    func onTapTrash() {
        // Handle trash button tap
    }

    func onTapOkDelete() {
        // Handle OK button tap for delete
    }

    func onAppear() async {
        // Handle view appear
    }
}

extension Date {
    var asISO8601: String {
        let formatter = ISO8601DateFormatter()
        return formatter.string(from: self)
    }
    
    var mediumFormat: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: self)
    }
}

extension TimeInterval {
    var mmss: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}

extension Int {
    var formattedSize: String {
        ByteCountFormatter.string(fromByteCount: Int64(self), countStyle: .file)
    }
}

struct AudioFileRow: View {
    let audioData: AudioData

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(audioData.audioUrl.lastPathComponent)
                .font(.headline)
            HStack {
                Text("Date:")
                Spacer()
                Text(audioData.createdAt.asISO8601)
            }
            HStack {
                Text("Duration:")
                Spacer()
                Text(audioData.duration.mmss)
            }
            HStack {
                Text("Size:")
                Spacer()
                Text(audioData.fileSize.formattedSize)
            }
            HStack {
                Text("Extension:")
                Spacer()
                Text(audioData.audioUrl.pathExtension)
            }
        }
        .padding()
    }
}

struct AudioListView: View {
    @StateObject private var presenter: AudioListPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            if presenter.audioDatas.isEmpty {
                Text("„Ç®„É©„ÉºÔºÅ Âè≥‰∏ä„Åã„ÇâÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                    .isHidden(presenter.appError.isNil, remove: true)
                Text("„Éá„Éº„Çø„Åå1‰ª∂„ÇÇ„ÅÇ„Åæ„Åõ„Çì")
                    .isHidden(presenter.appError.isNotNil, remove: true)
            } else {
                ForEach(uniqueDates, id: \.self) { date in
                    Section(header: Text(date.mediumFormat)) {
                        ForEach(presenter.searchedAudioDatas.filter { $0.createdAt.startOfDay == date }) { audioData in
                            AudioFileRow(audioData: audioData)
                                .onTapGesture {
                                    presenter.onTapAudio(audioData: audioData)
                                }
                        }
                    }
                }
            }
        }
        .searchable(text: $presenter.searchText)
        .toolbar {
            ToolbarItemGroup(placement: .topBarTrailing) {
                Button {
                    presenter.onTapTrash()
                } label: {
                    Image(systemName: "trash")
                        .foregroundColor(.red)
                }
            }
        }
        .navigationTitle("Audio List")
        .overlay(LoadingView(isLoading: $presenter.isLoading))
        .alert(isPresented: $presenter.showAlert) {
            Alert(title: Text("Error"), message: Text(presenter.appError?.localizedDescription ?? ""), dismissButton: .default(Text("OK"), action: {
                presenter.onTapOkDelete()
            }))
        }
        .sheet(item: $presenter.selectedAudioUrl) { audioUrl in
            if #available(iOS 16.0, *) {
                AudioPlayerView(audioUrl: audioUrl)
                    .presentationDetents([.medium])
            } else {
                Text("iOS 15„ÅØÂØæÂøú„Åó„Å¶„Åä„Çä„Åæ„Åõ„Çì")
            }
        }
        .task {
            await presenter.onAppear()
        }
    }

    private var uniqueDates: [Date] {
        let dates = presenter.searchedAudioDatas.map { $0.createdAt.startOfDay }
        return Array(Set(dates)).sorted(by: >)
    }
}

extension Date {
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }
}

extension URL: Identifiable {
    public var id: String {
        absoluteString
    }
}

struct LoadingView: View {
    @Binding var isLoading: Bool

    var body: some View {
        if isLoading {
            ProgressView("Loading...")
                .progressViewStyle(CircularProgressViewStyle())
        }
    }
}

struct AudioPlayerView: View {
    let audioUrl: URL

    var body: some View {
        Text("Audio player for \(audioUrl.lastPathComponent)")
    }
}

#Preview {
    AudioListView()
}
```

### ‰∏ª„Å™Â§âÊõ¥ÁÇπ
1. **`uniqueDates` „Éó„É≠„Éë„ÉÜ„Ç£**Ôºö`AudioData`„ÅÆ„É™„Çπ„Éà„Åã„ÇâÊúâÂäπ„Å™Êó•‰ªò‰∏ÄË¶ß„ÇíÂèñÂæó„Åó„ÄÅÈáçË§á„ÇíÊéíÈô§„Åó„Å¶„ÇΩ„Éº„Éà„Åó„Åæ„Åô„ÄÇ
2. **`ForEach` „ÅÆ‰Ωø„ÅÑÊñπ**Ôºö`uniqueDates`„Çí‰ΩøÁî®„Åó„Å¶„Çª„ÇØ„Ç∑„Éß„É≥„Çí‰ΩúÊàê„Åó„ÄÅÂêÑ„Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„ÅßÊó•‰ªò„Å´‰∏ÄËá¥„Åô„Çã`AudioData`„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ

„Åì„ÅÆÊñπÊ≥ï„Åß„ÄÅËæûÊõ∏„Çí‰Ωø„Çè„Åö„Å´Êó•‰ªò„Åî„Å®„Å´„Ç™„Éº„Éá„Ç£„Ç™„Éá„Éº„Çø„Çí„Çπ„Éû„Éº„Éà„Å´Ë°®Á§∫„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/5/17 12:15:51*

„Åì„Çì„Å™„Åµ„ÅÜ„Å´„Åó„Åü„ÅÑ„ÄÇ„É¶„Éã„Éº„ÇØ„Å´„Åô„Çã„Ç™„Éö„É¨„Éº„Çø„Éº„ÇÑ„ÇΩ„Éº„Éà„Åô„Çã„Ç™„Éö„É¨„Éº„Çø„Éº„ÅØ„Å™„ÅÑ„ÅÆ„ÅãÔºü

@MainActor
final class AudioListPresenter: ObservableObject {
    private(set) var audioDatas: [AudioData] = []
    @Published private(set) var searchedAudioDatas: [AudioData] = []
    @Publisher private(set) var uniqueDates: [Date] = []

    @Published var selectedAudioUrl: URL?
    @Published var searchText: String = ""
    @Published var isLoading: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false

    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let audioFileManageDriver: AudioFileManageDriver = AudioFileManageDriver()

    var player: AVAudioPlayer?

    init() {
        $searchText
            .compactMap { [weak self] searchText in
                self?.audioDatas.filter { audioData in
                    searchText.isEmpty || "\(audioData.audioUrl.lastPathComponent)".localizedCaseInsensitiveContains(searchText)
                }
                .sorted(by: \.createdAt, order: .descending)
            }
            .assign(to: &$searchedAudioDatas)
        
        $searchedAudioDatas
            .map {
                Calendar.current.startOfDay(for: $0.createdAt)
            }
            .assign(to: &$uniqueDates)
    }
}

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/5/17 12:16:40*

`Combine`„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ`Publisher`„Çí‰ΩúÊàê„Åó„ÄÅ„É¶„Éã„Éº„ÇØ„Å™Êó•‰ªò„ÇíÁîüÊàê„Åó„ÄÅ„Ç™„Éº„Éá„Ç£„Ç™„Éá„Éº„Çø„Çí„ÇΩ„Éº„Éà„Åô„ÇãÊñπÊ≥ï„Çí‰ª•‰∏ã„Å´Á§∫„Åó„Åæ„Åô„ÄÇ`map`„ÄÅ`removeDuplicates`„ÄÅ„Åä„Çà„Å≥`sorted`„Ç™„Éö„É¨„Éº„Çø„Éº„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ

„Åæ„Åö„ÄÅ`AudioListPresenter`„Çí‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´‰øÆÊ≠£„Åó„Åæ„ÅôÔºö

```swift
import SwiftUI
import Combine
import AVFoundation

public struct AudioData: Sendable {
    let audioUrl: URL
    let createdAt: Date
    let fileSize: Int
    let duration: TimeInterval
}

extension AudioData: Identifiable {
    public var id: String {
        audioUrl.absoluteString
    }
}

@MainActor
final class AudioListPresenter: ObservableObject {
    @Published private(set) var audioDatas: [AudioData] = []
    @Published private(set) var searchedAudioDatas: [AudioData] = []
    @Published private(set) var uniqueDates: [Date] = []

    @Published var selectedAudioUrl: URL?
    @Published var searchText: String = ""
    @Published var isLoading: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false

    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let audioFileManageDriver: AudioFileManageDriver = AudioFileManageDriver()

    var player: AVAudioPlayer?

    private var cancellables = Set<AnyCancellable>()

    init() {
        $searchText
            .combineLatest($audioDatas)
            .map { searchText, audioDatas in
                audioDatas.filter { audioData in
                    searchText.isEmpty || audioData.audioUrl.lastPathComponent.localizedCaseInsensitiveContains(searchText)
                }
            }
            .map { filteredAudioDatas in
                filteredAudioDatas.sorted(by: { $0.createdAt > $1.createdAt })
            }
            .assign(to: &$searchedAudioDatas)

        $searchedAudioDatas
            .map { $0.map { $0.createdAt.startOfDay } }
            .map { Array(Set($0)).sorted(by: >) }
            .assign(to: &$uniqueDates)
    }

    func onTapAudio(audioData: AudioData) {
        // Handle audio tap
    }

    func onTapTrash() {
        // Handle trash button tap
    }

    func onTapOkDelete() {
        // Handle OK button tap for delete
    }

    func onAppear() async {
        // Handle view appear
    }
}

extension Date {
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }
    
    var mediumFormat: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: self)
    }
}

extension TimeInterval {
    var mmss: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}

extension Int {
    var formattedSize: String {
        ByteCountFormatter.string(fromByteCount: Int64(self), countStyle: .file)
    }
}

struct AudioFileRow: View {
    let audioData: AudioData

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(audioData.audioUrl.lastPathComponent)
                .font(.headline)
            HStack {
                Text("Date:")
                Spacer()
                Text(audioData.createdAt.asISO8601)
            }
            HStack {
                Text("Duration:")
                Spacer()
                Text(audioData.duration.mmss)
            }
            HStack {
                Text("Size:")
                Spacer()
                Text(audioData.fileSize.formattedSize)
            }
            HStack {
                Text("Extension:")
                Spacer()
                Text(audioData.audioUrl.pathExtension)
            }
        }
        .padding()
    }
}

struct AudioListView: View {
    @StateObject private var presenter: AudioListPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            if presenter.audioDatas.isEmpty {
                Text("„Ç®„É©„ÉºÔºÅ Âè≥‰∏ä„Åã„ÇâÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                    .isHidden(presenter.appError == nil, remove: true)
                Text("„Éá„Éº„Çø„Åå1‰ª∂„ÇÇ„ÅÇ„Åæ„Åõ„Çì")
                    .isHidden(presenter.appError != nil, remove: true)
            } else {
                ForEach(presenter.uniqueDates, id: \.self) { date in
                    Section(header: Text(date.mediumFormat)) {
                        ForEach(presenter.searchedAudioDatas.filter { $0.createdAt.startOfDay == date }) { audioData in
                            AudioFileRow(audioData: audioData)
                                .onTapGesture {
                                    presenter.onTapAudio(audioData: audioData)
                                }
                        }
                    }
                }
            }
        }
        .searchable(text: $presenter.searchText)
        .toolbar {
            ToolbarItemGroup(placement: .topBarTrailing) {
                Button {
                    presenter.onTapTrash()
                } label: {
                    Image(systemName: "trash")
                        .foregroundColor(.red)
                }
            }
        }
        .navigationTitle("Audio List")
        .overlay(LoadingView(isLoading: $presenter.isLoading))
        .alert(isPresented: $presenter.showAlert) {
            Alert(title: Text("Error"), message: Text(presenter.appError?.localizedDescription ?? ""), dismissButton: .default(Text("OK"), action: {
                presenter.onTapOkDelete()
            }))
        }
        .sheet(item: $presenter.selectedAudioUrl) { audioUrl in
            if #available(iOS 16.0, *) {
                AudioPlayerView(audioUrl: audioUrl)
                    .presentationDetents([.medium])
            } else {
                Text("iOS 15„ÅØÂØæÂøú„Åó„Å¶„Åä„Çä„Åæ„Åõ„Çì")
            }
        }
        .task {
            await presenter.onAppear()
        }
    }
}

extension URL: Identifiable {
    public var id: String {
        absoluteString
    }
}

struct LoadingView: View {
    @Binding var isLoading: Bool

    var body: some View {
        if isLoading {
            ProgressView("Loading...")
                .progressViewStyle(CircularProgressViewStyle())
        }
    }
}

struct AudioPlayerView: View {
    let audioUrl: URL

    var body: some View {
        Text("Audio player for \(audioUrl.lastPathComponent)")
    }
}

#Preview {
    AudioListView()
}
```

### Â§âÊõ¥ÁÇπ„ÅÆË™¨Êòé

1. **Combine„ÅÆ‰ΩøÁî®**Ôºö
    - `$searchText`„Å®`$audioDatas`„Çí`combineLatest`„Åó„Å¶„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Å®„ÇΩ„Éº„Éà„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ
    - `searchedAudioDatas`„Çí`map`„Åó„Å¶„ÄÅÊó•‰ªò„ÅÆ„É™„Çπ„Éà„ÇíÂèñÂæó„Åó„ÄÅ„É¶„Éã„Éº„ÇØ„Å´„Åó„Å¶„ÇΩ„Éº„Éà„Åó„Åæ„Åô„ÄÇ

2. **Publisher„ÉÅ„Çß„Éº„É≥**Ôºö
    - `combineLatest`„Åß`searchText`„Å®`audioDatas`„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶„ÄÅ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Å®„ÇΩ„Éº„Éà„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ
    - `map`„Ç™„Éö„É¨„Éº„Çø„Éº„Åß„ÄÅ`searchedAudioDatas`„Åã„ÇâÊó•‰ªò„ÅÆ„É™„Çπ„Éà„ÇíÂèñÂæó„Åó„ÄÅ`Set`„Åß„É¶„Éã„Éº„ÇØ„Å´„Åó„Å¶„ÄÅ`sorted`„Åß„ÇΩ„Éº„Éà„Åó„Åæ„Åô„ÄÇ

„Åì„Çå„Å´„Çà„Çä„ÄÅËæûÊõ∏„Çí‰Ωø„Çè„Åö„Å´„É¶„Éã„Éº„ÇØ„Å™Êó•‰ªò„ÇíÁîüÊàê„Åó„ÄÅ„Åù„Çå„Å´Âü∫„Å•„ÅÑ„Å¶„Ç™„Éº„Éá„Ç£„Ç™„Éá„Éº„Çø„ÇíË°®Á§∫„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/5/17 12:17:12*

.map { Array(Set($0)) } No exact matches in call to initializer  „Å®„Å™„Å£„Åü

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/5/17 12:17:52*

`Array(Set($0))`„ÅØ„Ç≥„É≥„Éë„Ç§„É´„Ç®„É©„Éº„ÇíÂºï„ÅçËµ∑„Åì„Åó„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„ÄÅSet„ÅåDate„ÅÆÈÖçÂàó„Çí„É¶„Éã„Éº„ÇØÂåñ„Åô„ÇãÈöõ„Å´ÂøÖË¶Å„Åß„Åô„Åå„ÄÅÂûã„ÅÆÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åì„ÅÆ„Ç®„É©„Éº„ÇíËß£Ê±∫„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ‰ª£„Çè„Çä„Å´`NSOrderedSet`„Çí‰ΩøÁî®„Åó„Å¶„É¶„Éã„Éº„ÇØ„Å™Êó•‰ªò„ÇíÂèñÂæó„Åó„ÄÅ„Åù„Çå„Çí„ÇΩ„Éº„Éà„Åô„ÇãÊñπÊ≥ï„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ

‰ª•‰∏ã„ÅØ‰øÆÊ≠£Âæå„ÅÆ„Ç≥„Éº„Éâ„Åß„ÅôÔºö

```swift
import SwiftUI
import Combine
import AVFoundation

public struct AudioData: Sendable {
    let audioUrl: URL
    let createdAt: Date
    let fileSize: Int
    let duration: TimeInterval
}

extension AudioData: Identifiable {
    public var id: String {
        audioUrl.absoluteString
    }
}

@MainActor
final class AudioListPresenter: ObservableObject {
    @Published private(set) var audioDatas: [AudioData] = []
    @Published private(set) var searchedAudioDatas: [AudioData] = []
    @Published private(set) var uniqueDates: [Date] = []

    @Published var selectedAudioUrl: URL?
    @Published var searchText: String = ""
    @Published var isLoading: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false

    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let audioFileManageDriver: AudioFileManageDriver = AudioFileManageDriver()

    var player: AVAudioPlayer?

    private var cancellables = Set<AnyCancellable>()

    init() {
        $searchText
            .combineLatest($audioDatas)
            .map { searchText, audioDatas in
                audioDatas.filter { audioData in
                    searchText.isEmpty || audioData.audioUrl.lastPathComponent.localizedCaseInsensitiveContains(searchText)
                }
            }
            .map { filteredAudioDatas in
                filteredAudioDatas.sorted(by: { $0.createdAt > $1.createdAt })
            }
            .assign(to: &$searchedAudioDatas)

        $searchedAudioDatas
            .map { $0.map { $0.createdAt.startOfDay } }
            .map { dates in
                Array(NSOrderedSet(array: dates)) as! [Date]
            }
            .map { $0.sorted(by: >) }
            .assign(to: &$uniqueDates)
    }

    func onTapAudio(audioData: AudioData) {
        // Handle audio tap
    }

    func onTapTrash() {
        // Handle trash button tap
    }

    func onTapOkDelete() {
        // Handle OK button tap for delete
    }

    func onAppear() async {
        // Handle view appear
    }
}

extension Date {
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }
    
    var mediumFormat: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: self)
    }
}

extension TimeInterval {
    var mmss: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}

extension Int {
    var formattedSize: String {
        ByteCountFormatter.string(fromByteCount: Int64(self), countStyle: .file)
    }
}

struct AudioFileRow: View {
    let audioData: AudioData

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(audioData.audioUrl.lastPathComponent)
                .font(.headline)
            HStack {
                Text("Date:")
                Spacer()
                Text(audioData.createdAt.asISO8601)
            }
            HStack {
                Text("Duration:")
                Spacer()
                Text(audioData.duration.mmss)
            }
            HStack {
                Text("Size:")
                Spacer()
                Text(audioData.fileSize.formattedSize)
            }
            HStack {
                Text("Extension:")
                Spacer()
                Text(audioData.audioUrl.pathExtension)
            }
        }
        .padding()
    }
}

struct AudioListView: View {
    @StateObject private var presenter: AudioListPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            if presenter.audioDatas.isEmpty {
                Text("„Ç®„É©„ÉºÔºÅ Âè≥‰∏ä„Åã„ÇâÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                    .isHidden(presenter.appError == nil, remove: true)
                Text("„Éá„Éº„Çø„Åå1‰ª∂„ÇÇ„ÅÇ„Åæ„Åõ„Çì")
                    .isHidden(presenter.appError != nil, remove: true)
            } else {
                ForEach(presenter.uniqueDates, id: \.self) { date in
                    Section(header: Text(date.mediumFormat)) {
                        ForEach(presenter.searchedAudioDatas.filter { $0.createdAt.startOfDay == date }) { audioData in
                            AudioFileRow(audioData: audioData)
                                .onTapGesture {
                                    presenter.onTapAudio(audioData: audioData)
                                }
                        }
                    }
                }
            }
        }
        .searchable(text: $presenter.searchText)
        .toolbar {
            ToolbarItemGroup(placement: .topBarTrailing) {
                Button {
                    presenter.onTapTrash()
                } label: {
                    Image(systemName: "trash")
                        .foregroundColor(.red)
                }
            }
        }
        .navigationTitle("Audio List")
        .overlay(LoadingView(isLoading: $presenter.isLoading))
        .alert(isPresented: $presenter.showAlert) {
            Alert(title: Text("Error"), message: Text(presenter.appError?.localizedDescription ?? ""), dismissButton: .default(Text("OK"), action: {
                presenter.onTapOkDelete()
            }))
        }
        .sheet(item: $presenter.selectedAudioUrl) { audioUrl in
            if #available(iOS 16.0, *) {
                AudioPlayerView(audioUrl: audioUrl)
                    .presentationDetents([.medium])
            } else {
                Text("iOS 15„ÅØÂØæÂøú„Åó„Å¶„Åä„Çä„Åæ„Åõ„Çì")
            }
        }
        .task {
            await presenter.onAppear()
        }
    }
}

extension URL: Identifiable {
    public var id: String {
        absoluteString
    }
}

struct LoadingView: View {
    @Binding var isLoading: Bool

    var body: some View {
        if isLoading {
            ProgressView("Loading...")
                .progressViewStyle(CircularProgressViewStyle())
        }
    }
}

struct AudioPlayerView: View {
    let audioUrl: URL

    var body: some View {
        Text("Audio player for \(audioUrl.lastPathComponent)")
    }
}

#Preview {
    AudioListView()
}
```

### Â§âÊõ¥ÁÇπ„ÅÆË™¨Êòé

1. **Combine„ÅÆ‰ΩøÁî®**Ôºö
    - `$searchText`„Å®`$audioDatas`„Çí`combineLatest`„Åó„Å¶„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Å®„ÇΩ„Éº„Éà„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ
    - `searchedAudioDatas`„Çí`map`„Åó„Å¶„ÄÅÊó•‰ªò„ÅÆ„É™„Çπ„Éà„ÇíÂèñÂæó„Åó„ÄÅ`NSOrderedSet`„Çí‰ΩøÁî®„Åó„Å¶„É¶„Éã„Éº„ÇØÂåñ„Åó„Åæ„Åô„ÄÇ

2. **Publisher„ÉÅ„Çß„Éº„É≥**Ôºö
    - `combineLatest`„Åß`searchText`„Å®`audioDatas`„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶„ÄÅ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Å®„ÇΩ„Éº„Éà„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ
    - `map`„Ç™„Éö„É¨„Éº„Çø„Éº„Åß„ÄÅ`searchedAudioDatas`„Åã„ÇâÊó•‰ªò„ÅÆ„É™„Çπ„Éà„ÇíÂèñÂæó„Åó„ÄÅ`NSOrderedSet`„Åß„É¶„Éã„Éº„ÇØÂåñ„Åó„Å¶„Åã„Çâ„ÇΩ„Éº„Éà„Åó„Åæ„Åô„ÄÇ

„Åì„ÅÆÊñπÊ≥ï„Åß„ÄÅËæûÊõ∏„Çí‰Ωø„Çè„Åö„Å´„É¶„Éã„Éº„ÇØ„Å™Êó•‰ªò„ÇíÁîüÊàê„Åó„ÄÅ„Åù„Çå„Å´Âü∫„Å•„ÅÑ„Å¶„Ç™„Éº„Éá„Ç£„Ç™„Éá„Éº„Çø„ÇíË°®Á§∫„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ

---
