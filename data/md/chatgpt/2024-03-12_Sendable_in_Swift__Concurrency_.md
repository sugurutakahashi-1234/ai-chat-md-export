# Sendable in Swift: Concurrency.

日付: 2024-03-12

---

## 👤 ユーザー
*2024/03/12 23:01:27*

Swift で Sendable を指定させる prptovol

---

## 🤖 アシスタント
*2024/03/12 23:02:29*

Swiftにおいて、`Sendable`プロトコルを指定することで、型がスレッド間で安全に送信できることを示すことができます。これはSwiftのConcurrencyモデルの一部であり、データの競合やアクセス違反を防ぐために重要です。特にSwift 5.5以降、非同期処理やタスク間のデータのやり取りが重要になってくる中で、`Sendable`プロトコルは安全性の確保に役立ちます。

`Sendable`を使うことで、クラス、構造体、列挙型などのカスタム型が、複数のスレッドや非同期タスク間で安全に共有または送信できることをコンパイラに保証します。`Sendable`プロトコルは、特に何も実装する必要はなく、型に準拠すること自体が意味を持ちます。

例えば、以下のようにして、独自の構造体や列挙型に`Sendable`を適用することができます：

```swift
struct MyStruct: Sendable {
    var property: Int
}

enum MyEnum: Sendable {
    case caseOne, caseTwo
}
```

ただし、全ての型が自動的に`Sendable`に準拠できるわけではありません。例えば、参照型（クラス）を使用する場合、データの共有がスレッド間で安全に行われるように追加の配慮が必要になる場合があります。クラスが`Sendable`に準拠するには、そのクラスが参照透過性を持ち、同時に複数のスレッドから安全にアクセスできることを保証する必要があります。これは通常、クラスが不変であるか、適切なスレッド同期メカニズムを使用している場合にのみ達成可能です。

SwiftのConcurrencyモデルは、データの安全な送信と共有を中心に構築されているため、`Sendable`プロトコルの正しい使用はアプリケーションの安全性と信頼性を大幅に向上させることができます。

---

## 👤 ユーザー
*2024/03/12 23:02:51*

こんな感じでHogeを必ずSendableにさせたい。

protocol HogeProtocol: AnySendable {
    var moge: Int { get }
    func fuga()
}

final class Hoge: HogeProtocol {
    var moge: Int = 0
    
    func fuga() {
    }
    
    func piyo(num: Int, closure: ((Int) -&gt; Void)) {}
}

---

## 🤖 アシスタント
*2024/03/12 23:04:35*

Swiftでプロトコルを定義し、そのプロトコルを準拠する型に`Sendable`を強制することは、コードの安全性を高める上で非常に良いアプローチです。ただし、Swiftの現在のバージョン（私の最終更新時点ではSwift 5.5以上）では`AnySendable`というプロトコルは存在しません。代わりに、プロトコルが`Sendable`を準拠することを要求するには、プロトコル自体に`Sendable`を継承させる形で宣言します。

以下のコードは、あなたが意図した動作を実現するための一例です。`HogeProtocol`が`Sendable`を準拠するように変更し、その結果としてこのプロトコルに準拠する全ての型も`Sendable`でなければならなくなります。

```swift
protocol HogeProtocol: Sendable {
    var moge: Int { get }
    func fuga()
}

final class Hoge: HogeProtocol {
    var moge: Int = 0
    
    func fuga() {
        // 実装内容
    }
    
    func piyo(num: Int, closure: @escaping (Int) -> Void) {}
}
```

ここで重要な点は、クラスが`Sendable`に準拠するためには、そのクラスのインスタンスが複数のスレッド間で安全に共有されることを保証する必要があります。`final class`であっても、クラスのインスタンスは参照型であり、デフォルトでスレッドセーフではありません。そのため、`Sendable`をクラスに適用する場合、特にクロージャなどの非同期コードを含む場合には、適切な同期メカニズムを使用するか、インスタンスが不変であることを保証する必要があります。

Swift Concurrencyの一部として導入された`@Sendable`属性をクロージャに適用することで、そのクロージャがスレッド間で安全に送信できることを示すことができます。ただし、`@Sendable`属性は関数型やクロージャに対してのみ適用可能であり、クラスや構造体に直接適用するものではありません。

上記のコード例では、`piyo`関数のクロージャ引数に`@escaping`属性を追加しましたが、クラスが`Sendable`に準拠するために必要な同期処理や不変性の保証は含まれていません。これらは実装の詳細やアプリケーションの要件に応じて適切に考慮する必要があります。

---
