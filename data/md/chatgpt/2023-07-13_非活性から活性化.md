# 非活性から活性化

日付: 2023-07-13

---

## 👤 ユーザー
*2023/07/13 18:26:20*

SwiftUI のViewを表示してから30秒たったら非活性から活性になるボタンをつくってほしい

MVVMモデルで実装して欲しい

---

## 🤖 アシスタント
*2023/07/13 18:27:02*

SwiftUIでMVVMパターンを使用して、指定した時間（この場合は30秒）後に活性化するボタンを作成するための一例を以下に示します。

まず、モデルとビューモデルを作成します：

```swift
// Model
class TimerModel: ObservableObject {
    var timer: Timer?

    func start(after seconds: Int, completion: @escaping () -> Void) {
        timer = Timer.scheduledTimer(withTimeInterval: TimeInterval(seconds), repeats: false) { _ in
            completion()
        }
    }

    func cancel() {
        timer?.invalidate()
        timer = nil
    }
}

// ViewModel
class TimerViewModel: ObservableObject {
    private let model: TimerModel
    @Published var isButtonActive: Bool = false

    init(model: TimerModel) {
        self.model = model
    }

    func startTimer() {
        model.start(after: 30) {
            DispatchQueue.main.async {
                self.isButtonActive = true
            }
        }
    }

    func cancelTimer() {
        model.cancel()
    }
}
```

次に、ビューを作成します：

```swift
struct TimerView: View {
    @ObservedObject var viewModel: TimerViewModel

    var body: some View {
        Button(action: {
            // button action here
        }) {
            Text("My Button")
        }
        .disabled(!viewModel.isButtonActive)
        .onAppear {
            viewModel.startTimer()
        }
        .onDisappear {
            viewModel.cancelTimer()
        }
    }
}
```

ここで、ボタンは`viewModel.isButtonActive`が`true`になるまで無効化されています。`Button`の`disabled(_:)`修飾子を使用してこの制御を行っています。`onAppear(_:)`修飾子により、ビューが表示されたときにタイマーが開始され、`onDisappear(_:)`修飾子により、ビューが消えたときにタイマーがキャンセルされます。

なお、この例ではタイマーの経過時間は30秒に固定されていますが、必要に応じて動的に変更することも可能です。

---

## 👤 ユーザー
*2023/07/13 18:28:20*

self.isButtonActive = true の処理は Viewではなく presenterでおこなうようにしてほしい

---

## 🤖 アシスタント
*2023/07/13 18:28:45*

了解しました。その要望に基づき、`Presenter`を導入し、`Presenter`からビューモデルの状態を更新するようにコードを改良します。まず、`Presenter`の定義を追加します：

```swift
class TimerPresenter {
    private let viewModel: TimerViewModel

    init(viewModel: TimerViewModel) {
        self.viewModel = viewModel
    }

    func startTimer() {
        viewModel.model.start(after: 30) {
            DispatchQueue.main.async {
                self.viewModel.isButtonActive = true
            }
        }
    }

    func cancelTimer() {
        viewModel.model.cancel()
    }
}
```

そして、`TimerViewModel`クラスを次のように修正します：

```swift
class TimerViewModel: ObservableObject {
    let model: TimerModel
    @Published var isButtonActive: Bool = false

    init(model: TimerModel) {
        self.model = model
    }
}
```

最後に、`TimerView`を`Presenter`を使用するように修正します：

```swift
struct TimerView: View {
    @ObservedObject var viewModel: TimerViewModel
    private var presenter: TimerPresenter

    init(viewModel: TimerViewModel) {
        self.viewModel = viewModel
        self.presenter = TimerPresenter(viewModel: viewModel)
    }

    var body: some View {
        Button(action: {
            // button action here
        }) {
            Text("My Button")
        }
        .disabled(!viewModel.isButtonActive)
        .onAppear {
            presenter.startTimer()
        }

---
