# プライベート関数の作成

日付: 2024-12-23

---

## 👤 ユーザー
*2024/12/23 17:16:59*

このupdateGuildMemberをプライベートにする方法

import 'package:flutter/foundation.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guild_api_provider.dart';

part 'update_guild_member.g.dart';

@riverpod
class LeaveGuildNotifier extends _$LeaveGuildNotifier {
  @override
  Future&lt;String?&gt; build() async =&gt; null;

  Future&lt;void&gt; leaveGuild({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final result = await updateGuildMember(
        ref: ref,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.LEFT,
      );
      debugPrint('Result : $result');
      state = AsyncValue.data(result);
     } on Exception catch (e, stackTrace) {
      debugPrint('Error in GetGuildInfoNotifier: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

@riverpod
class KickGuildNotifier extends _$KickGuildNotifier {
  @override
  Future&lt;String?&gt; build() async =&gt; null;

  Future&lt;void&gt; kickGuild({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final result = await updateGuildMember(
        ref: ref,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.KICKED,
      );
      debugPrint('Result : $result');
      state = AsyncValue.data(result);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error in KickGuildNotifier: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

@riverpod
class RequestGuildNotifier extends _$RequestGuildNotifier {
  @override
  Future&lt;String?&gt; build() async =&gt; null;

  Future&lt;void&gt; requestGuild({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final result = await updateGuildMember(
        ref: ref,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.REQUESTED,
      );
      debugPrint('Result : $result');
      state = AsyncValue.data(result);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error in RequestGuildNotifier: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

@riverpod
class ApproveGuildNotifier extends _$ApproveGuildNotifier {
  @override
  Future&lt;String?&gt; build() async =&gt; null;

  Future&lt;void&gt; approveGuild({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final result = await updateGuildMember(
        ref: ref,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.APPROVED,
      );
      debugPrint('Result : $result');
      state = AsyncValue.data(result);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error in ApproveGuildNotifier: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

Future&lt;String?&gt; updateGuildMember({
  required Ref ref,
  required String guildId,
  required String userId,
  required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
}) async {
  final api = await ref.watch(guildApiProvider.future);
  final response = await api.guildControllerUpdateGuildMember(
    UpdateGuildMemberRequestDto(
      updateStatus: true,
      memberStatus: memberStatus,
    ),
    guildId: guildId,
    userId: userId,
  );
  debugPrint('Response Body: ${response.data}');
  debugPrint('Response Body.data: ${response.data?.data}');
  return response.data?.data;
}

---

## 🤖 アシスタント
*2024/12/23 17:17:32*

`updateGuildMember` をプライベートにするには、クラスやファイル内でのみ利用可能な形に変更する必要があります。以下のいずれかの方法で実現できます。

---

### **方法 1: プライベート関数にする**
関数の先頭にアンダースコア（`_`）を付けて、プライベートスコープにすることができます。

```dart
Future<String?> _updateGuildMember({
  required Ref ref,
  required String guildId,
  required String userId,
  required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
}) async {
  final api = await ref.watch(guildApiProvider.future);
  final response = await api.guildControllerUpdateGuildMember(
    UpdateGuildMemberRequestDto(
      updateStatus: true,
      memberStatus: memberStatus,
    ),
    guildId: guildId,
    userId: userId,
  );
  debugPrint('Response Body: ${response.data}');
  debugPrint('Response Body.data: ${response.data?.data}');
  return response.data?.data;
}
```

この変更に伴い、すべての呼び出し箇所も `_updateGuildMember` に変更する必要があります。

---

### **方法 2: Notifier クラスに組み込む**
関数を個別に公開するのではなく、`LeaveGuildNotifier` などのクラスに組み込む方法です。これにより外部からはアクセスできなくなります。

```dart
@riverpod
class LeaveGuildNotifier extends _$LeaveGuildNotifier {
  @override
  Future<String?> build() async => null;

  Future<void> leaveGuild({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final result = await _updateGuildMember(
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.LEFT,
      );
      debugPrint('Result : $result');
      state = AsyncValue.data(result);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error in GetGuildInfoNotifier: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }

  Future<String?> _updateGuildMember({
    required String guildId,
    required String userId,
    required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
  }) async {
    final api = await ref.watch(guildApiProvider.future);
    final response = await api.guildControllerUpdateGuildMember(
      UpdateGuildMemberRequestDto(
        updateStatus: true,
        memberStatus: memberStatus,
      ),
      guildId: guildId,
      userId: userId,
    );
    debugPrint('Response Body: ${response.data}');
    debugPrint('Response Body.data: ${response.data?.data}');
    return response.data?.data;
  }
}
```

この方法では、`_updateGuildMember` は `LeaveGuildNotifier` の内部専用関数となります。

---

### **方法 3: ファイルスコープに制限する**
関数を現在のファイル内でのみ利用可能にする場合は、ファイル内でプライベートスコープとして定義します。

1. 関数名の先頭にアンダースコア（`_`）を追加します。
2. 関数を現在のファイル内で定義された全ての Notifier クラスで利用可能にします。

```dart
Future<String?> _updateGuildMember({
  required Ref ref,
  required String guildId,
  required String userId,
  required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
}) async {
  final api = await ref.watch(guildApiProvider.future);
  final response = await api.guildControllerUpdateGuildMember(
    UpdateGuildMemberRequestDto(
      updateStatus: true,
      memberStatus: memberStatus,
    ),
    guildId: guildId,
    userId: userId,
  );
  debugPrint('Response Body: ${response.data}');
  debugPrint('Response Body.data: ${response.data?.data}');
  return response.data?.data;
}
```

Notifier 内でこの関数を呼び出す際は、`_updateGuildMember` を利用します。

---

### **どの方法を選ぶべきか**
- **方法 1:** 関数を簡単にプライベート化したい場合。
- **方法 2:** Notifier 内で完結させたい場合（外部からアクセスされない設計が求められる場合）。
- **方法 3:** ファイル内の他のクラスから共有したい場合。

プロジェクトの設計方針に合わせて選択してください。

---
