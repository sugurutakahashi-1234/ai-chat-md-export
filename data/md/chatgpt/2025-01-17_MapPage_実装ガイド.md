# MapPage 実装ガイド

日付: 2025-01-17

---

## 👤 ユーザー
*2025/01/17 18:55:01*

以下のMapPage についてShowShootableSpotDetailButton と ShowOurSpotDetailButton を仮で置いているが、これらを正しい実装に修正したい。
また、追加 itemBoxという概念も追加したい。

これから詳細の依頼を伝えます。

-  myGuildSpotListState と itemBoxListState を使って、GoogleMap上にピンを立ててほしい。
    - ItemBoxのピンは宝箱のアイコンを四角で表現してほしい。
        - タップしたら OpenItemBoxNotifier を使って  openItemBox() を実行してほしい
        - openItemBox() に成功したら、レスポンスのList&lt;ItemDTO&gt; を表示するようなダイアログを表示してほしい。そのダイアログは一旦適当でいいが、ダイアログの下の中央のバツアイコンをおいて、タップすると閉じられるようにしてほしい
        - 失敗したら、スナックバーでメッセージを表示してほしい。
    - Spotのピンは以下の3種類に分けられる
        - SpotのギルドIdがnullの場合: 
            - ピンでGuildSpotDTO.photoUrl で取得できる画像を四角で表現してほしい。
            - タップしたら、現在のShowShootableSpotDetailButton と同じ処理をしてほしい。その際にタップした SpotIdを渡してほしい
        - SpotのギルドIdがnull ではなく、myGuildId と一致していない場合:
            - ピンで赤色の旗のアイコンを立ててほしい
            - タップしたら、現在のShowShootableSpotDetailButton と同じ処理をしてほしい。その際にタップした SpotIdを渡してほしい
        - SpotのギルドIdがnull ではなく、myGuildId と一致している場合:
            - ピンで緑色の旗のアイコンを立ててほしい
            - タップしたら、現在のShowOurSpotDetailButton と同じ処理をしてほしい。その際にタップした SpotIdを渡してほしい

myGuildId は 今は useEffect 内で宣言しているがもっと外側で宣言してもらっても構わない。

アウトプットはMapPageだけでいい。
他のクラスは情報として与えます。

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final googleMapController = useState&lt;GoogleMapController?&gt;(null);
    final currentLocationState = ref.watch(currentLocationNotifierProvider);
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    useEffect(
      () {
        Future.microtask(() async {
          try {
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            await ref
                .read(getItemBoxListNotifierProvider.notifier)
                .getItemBoxList();

            final myAccount = await ref
                .read(getMyAccountNotifierProvider.notifier)
                .getMyAccount();
            final myGuildId = myAccount.guildId;

            if (myGuildId != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildId);
            }
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // フォアグラウンドに戻ってきたら位置情報を再取得
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
            ),
            // TODO: [地図] 仮置きのボタン配置
            Center(
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Spacer(),
                  FloatingActionButton(
                    heroTag: 'ShowShootableSpotDetailButton',
                    onPressed: () {
                      ref
                          .read(
                            showShootableSpotDetailNotifierProvider.notifier,
                          )
                          .show('TODO: SpotId を設定する');
                    },
                    child: const Icon(Icons.camera_alt),
                  ),
                  const Spacer(),
                  FloatingActionButton(
                    heroTag: 'ShowOurSpotDetailButton',
                    onPressed: () {
                      ref
                          .read(showOurSpotDetailNotifierProvider.notifier)
                          .show('TODO: SpotId を設定する');
                    },
                    child: const Icon(Icons.flag),
                  ),
                  const Spacer(),
                ],
              ),
            ),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation = await ref
                          .read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref
                          .read(showExplorerListNotifierProvider.notifier)
                          .show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () =&gt; const Center(child: CircularProgressIndicator()),
        error: (error, stack) =&gt; Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('設定アプリから位置情報取得をONにしてください'),
          ),
        ),
      ),
    );
  }
}

// ライフサイクルイベントを監視するクラス
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}



import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';

part 'get_guild_spot_list.g.dart';

@Riverpod(keepAlive: true)
class GetGuildSpotListNotifier extends _$GetGuildSpotListNotifier {
  @override
  Future&lt;List&lt;GuildSpotDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;void&gt; getGuildSpotList(String guildId) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildsApiProvider.future);
      final response = await api.guildControllerGetGuildSpots(guildId: guildId);
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      state = AsyncValue.data(response.data?.data);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';

part 'get_item_box_list.g.dart';

@Riverpod(keepAlive: true)
class GetItemBoxListNotifier extends _$GetItemBoxListNotifier {
  @override
  Future&lt;List&lt;ItemBoxDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;void&gt; getItemBoxList() async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(itemBoxesApiProvider.future);
      final response = await api.itemBoxControllerGetItemBoxes();
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      state = AsyncValue.data(response.data?.data);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

import 'package:flutter/foundation.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';

part 'open_item_box.g.dart';

@riverpod
class OpenItemBoxNotifier extends _$OpenItemBoxNotifier {
  @override
  Future&lt;List&lt;ItemDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;List&lt;ItemDTO&gt;&gt; openItemBox(
    String itemBoxId,
    LatLng location,
  ) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(itemBoxesApiProvider.future);
      final response = await api.itemBoxControllerOpenBox(
        OpenBoxRequestDTO(
          itemBoxId: itemBoxId,
          userLatitute: location.latitude,
          userLongitude: location.longitude,
        ),
      );
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      final data = response.data?.data;
      if (data == null) {
        throw Exception('No data found');
      }
      state = AsyncValue.data(data);
      return data;
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
      rethrow;
    }
  }
}

import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'show_shootable_spot_detail.g.dart';

@riverpod
class ShowShootableSpotDetailNotifier
    extends _$ShowShootableSpotDetailNotifier {
  @override
  String? build() =&gt; null;

  void show(String spotId) {
    debugPrint('spotId: $spotId');
    state = spotId;
  }

  void hide() =&gt; state = null;
}

import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'show_our_spot_detail.g.dart';

@riverpod
class ShowOurSpotDetailNotifier extends _$ShowOurSpotDetailNotifier {
  @override
  String? build() =&gt; null;

  void show(String spotId) {
    debugPrint('spotId: $spotId');
    state = spotId;
  }

  void hide() =&gt; state = null;
}



@freezed
class ItemBoxDTO with _$ItemBoxDTO {
  factory ItemBoxDTO({
    @JsonKey(name: 'itemBoxId') required String? itemBoxId,
    @JsonKey(name: 'itemBoxName') required String? itemBoxName,
    @JsonKey(name: 'itemBoxDescription') String? itemBoxDescription,
    @JsonKey(name: 'itemName') String? itemName,
    @JsonKey(name: 'itemCategory') ItemBoxDTOItemCategory? itemCategory,
    @JsonKey(name: 'itemBoxStatus')
    required ItemBoxDTOItemBoxStatus? itemBoxStatus,
    @JsonKey(name: 'itemBoxLatitude') required num? itemBoxLatitude,
    @JsonKey(name: 'itemBoxLongitude') required num? itemBoxLongitude,
  }) = _ItemBoxDTO;

  factory ItemBoxDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$ItemBoxDTOFromJson(jsonMap);
}


@freezed
class GuildSpotDTO with _$GuildSpotDTO {
  factory GuildSpotDTO({
    @JsonKey(name: 'spotId') required String? spotId,
    @JsonKey(name: 'guildId') String? guildId,
    @JsonKey(name: 'spotName') required String? spotName,
    @JsonKey(name: 'spotStatus') required GuildSpotDTOSpotStatus? spotStatus,
    @JsonKey(name: 'rarity') required GuildSpotDTORarity? rarity,
    @JsonKey(name: 'photoUrl') required String? photoUrl,
    @JsonKey(name: 'spotLongitude') required num? spotLongitude,
    @JsonKey(name: 'spotLatitude') required num? spotLatitude,
    @JsonKey(name: 'spotAddress') required String? spotAddress,
    @JsonKey(name: 'guildSpotStatus')
    required GuildSpotDTOGuildSpotStatus? guildSpotStatus,
  }) = _GuildSpotDTO;

  factory GuildSpotDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$GuildSpotDTOFromJson(jsonMap);
}

@freezed
class ItemDTO with _$ItemDTO {
  factory ItemDTO({
    @JsonKey(name: 'itemId') required String? itemId,
    @JsonKey(name: 'itemName') required String? itemName,
    @JsonKey(name: 'itemDescription') String? itemDescription,
    @JsonKey(name: 'itemPrice') required num? itemPrice,
    @JsonKey(name: 'itemStatus') required ItemDTOItemStatus? itemStatus,
    @JsonKey(name: 'itemCategory') required ItemDTOItemCategory? itemCategory,
  }) = _ItemDTO;

  factory ItemDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$ItemDTOFromJson(jsonMap);
}

---

## 🔧 ツール
*2025/01/17 18:57:03*

**Setting up markers**

I’m thinking through the user's requirements, including placing itemBox and spot markers, adjusting icons and colors, and managing taps for different interactions.

**Crafting markers**

I’m working through displaying itemBox and guild spot markers on a map, noting icon customization, tap actions, and managing markers in a Set for GoogleMap interaction.

**Mapping markers**

Setting up markers involves parsing guild spots and item boxes, converting coordinates, and storing them in a Set for GoogleMap. Progress is steady and methodical.

**Placing markers**

Assigning guild spot markers their icons, adding itemBox markers with icons and tap actions, and using BitmapDescriptor for custom icons before passing them to GoogleMap.

**Refining placeholder icons**

I’m finalizing placeholder icons for photoUrl, setting up a useState for itemBoxes, and incorporating itemBox interaction logic. This approach keeps the code self-contained and focused.

**Refining the dialog box**

I’m adding item names and icons to the dialog box with a cancel button. Removing specific floating action buttons and managing `myGuildId` in state are also planned.

---

## 🤖 アシスタント
*2025/01/17 18:57:03*

以下は `MapPage` の一例です。  
- `myGuildId` を `useEffect` の外に持ち出し、`useState` で保持しています。  
- `myGuildSpotListState` と `itemBoxListState` をもとに `Marker` を生成し、`GoogleMap` の `markers` プロパティに渡しています。  
- Spot のピンはギルドID の有無・一致状況でアイコン色を切り替え、タップ時の処理は `showShootableSpotDetailNotifier` / `showOurSpotDetailNotifier` に投げています。  
- ItemBox のピンは宝箱アイコン（ここでは便宜的に `Icons.card_giftcard`）を使い、タップ時に `openItemBox()` → 成功ならダイアログ、失敗ならスナックバーを表示するようにしています。  
- ダイアログは簡易な実装例ですので、必要に応じてレイアウトやデザインを調整してください。  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController を保持
    final googleMapController = useState<GoogleMapController?>(null);

    // 現在位置
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // 取得した Spot 一覧
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);

    // 取得した ItemBox 一覧
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    // 自分のギルドID を保持
    final myGuildIdState = useState<String?>(null);

    useEffect(
      () {
        Future.microtask(() async {
          try {
            // 自分のギルド情報
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

            // ItemBox 一覧
            await ref.read(getItemBoxListNotifierProvider.notifier).getItemBoxList();

            // 自分のアカウント情報からギルドID を取得
            final myAccount = await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            // ギルドがあれば Spot を取得
            if (myGuildIdState.value != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // フォアグラウンドに戻ってきたら位置情報を再取得
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    // マーカーをまとめる
    final Set<Marker> markers = {};

    // Spot のマーカー生成
    final guildSpots = myGuildSpotListState.asData?.value ?? [];
    final myGuildId = myGuildIdState.value;
    for (final spot in guildSpots) {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';

      // デフォルトマーカー色
      BitmapDescriptor icon;
      void Function()? onTap;

      if (spot.guildId == null) {
        // ギルドID が null → photoUrl アイコンを四角… ここでは暫定的にデフォルトマーカーを用いる
        icon = BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueAzure);
        // タップ → 撃てるスポット詳細を表示
        onTap = () {
          ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        };
      } else if (spot.guildId != myGuildId) {
        // 自分のギルドでない → 赤いフラッグ
        icon = BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueRed);
        // タップ → 撃てるスポット詳細を表示
        onTap = () {
          ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        };
      } else {
        // 自分のギルド → 緑のフラッグ
        icon = BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueGreen);
        // タップ → 自分のスポット詳細を表示
        onTap = () {
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);
        };
      }

      markers.add(
        Marker(
          markerId: MarkerId('spot_$spotId'),
          position: LatLng(lat, lng),
          icon: icon,
          onTap: onTap,
        ),
      );
    }

    // ItemBox のマーカー生成
    final itemBoxes = itemBoxListState.asData?.value ?? [];
    for (final itemBox in itemBoxes) {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';

      markers.add(
        Marker(
          markerId: MarkerId('itemBox_$itemBoxId'),
          position: LatLng(lat, lng),
          // アイコンは宝箱アイコンを簡易的に表現(ギフトアイコンを使用)
          icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueOrange),
          onTap: () async {
            // ItemBox を開けるロジック
            // 位置情報が取れている前提で currentLocationState を使う
            final userLocation = currentLocationState.asData?.value;
            if (userLocation == null) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('現在地を取得できませんでした')),
              );
              return;
            }

            try {
              final items = await ref
                  .read(openItemBoxNotifierProvider.notifier)
                  .openItemBox(itemBoxId, userLocation);

              // 成功 → ダイアログでアイテム一覧を表示
              if (context.mounted) {
                showDialog(
                  context: context,
                  barrierDismissible: false,
                  builder: (ctx) {
                    return Dialog(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Text('取得したアイテム'),
                            const SizedBox(height: 16),
                            for (final item in items)
                              Text(item.itemName ?? 'No Name'),
                            const SizedBox(height: 16),
                            IconButton(
                              onPressed: () => Navigator.pop(ctx),
                              icon: const Icon(Icons.cancel),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                );
              }
            } catch (e) {
              // 失敗 → スナックバーでメッセージを表示
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('宝箱を開けられませんでした: $e')),
              );
            }
          },
        ),
      );
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers,
            ),
            // ---- ここから下は他のボタン類（CurrentLocationButton / Explore / SpotList） ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // 現在地へ戻るボタン
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore リスト表示ボタン
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot リスト表示ボタン
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('設定アプリから位置情報取得をONにしてください'),
          ),
        ),
      ),
    );
  }
}

// ライフサイクルイベントを監視するクラス
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

### 補足

- **カスタム画像アイコンをマップに表示したい場合**  
  Flutter/`google_maps_flutter` では、 `BitmapDescriptor.fromAssetImage()` や `BitmapDescriptor.fromBytes()` を使って独自アイコンを設定できます。  
  ネットワーク画像を使用する場合は、いったん `Image` をダウンロードしてから `ByteData` に変換し、 `fromBytes` する必要がありますが、やや手間が増えます。まずは上記のように単純に `BitmapDescriptor.defaultMarkerWithHue(...)` を使ったり、アセット画像を使うのがおすすめです。

- **タップ後のダイアログ**  
  現在は簡易なダイアログを表示しています。デザインや表示内容はお好みで調整してください。  
  ダイアログの外をタップして閉じたい場合などは、 `barrierDismissible: true` にするなどのカスタマイズが可能です。  

- **`myGuildId` の取り回し**  
  今回は `useState` で `myGuildId` を保持していますが、グローバルな `Provider` として管理しても構いません。

---

## 👤 ユーザー
*2025/01/17 19:15:15*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-3hypojgZjNbjadybivK5kS",
  "size_bytes": 423771,
  "width": 461,
  "height": 673,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
ありがとう。処理は合っている。
マーカーを変更したい。
マーカーは自作にしたいんだ。

この画像はサンプルであるが3種類のマーカーである。
それぞれは以下である。

- 右上: 「自分のギルド → 緑のフラッグ」を丸で表現
- 中央左: ギルドID が null → photoUrl アイコンを四角
- 左下: アイコンは宝箱アイコンを四角

足りないものとして、自分のギルドでない → 赤いフラッグを丸で表現してほしい。

---

## 🤖 アシスタント
*2025/01/17 19:18:10*

下記はサンプル実装の一例です。  
- **「自分のギルド → 緑のフラッグ」を丸アイコン**  
- **「他のギルド → 赤いフラッグ」を丸アイコン**  
- **「ギルドID が null → photoUrl アイコンを四角**  
- **「アイテムボックス → 宝箱アイコンを四角」**  

それぞれ画像ファイル(`.png`など)を用意する前提で、`assets/`配下に格納している例を示します（実際のファイルパス・ファイル名・デザインはご自由に変更してください）。  
なお、**「photoUrl を四角にしたい」**という場合、ネットワーク上の画像をダウンロードして `BitmapDescriptor` に変換する処理が必要になります。サンプルでは簡易的に `NetworkImage` を使い `image.toByteData()` でバイトデータ化している部分に注目してください。  

---

## ポイントまとめ

1. **Marker 用の `BitmapDescriptor` を事前に用意する**  
   - 今回は `greenCircle.png` / `redCircle.png` / `treasureBox.png` などのアセット画像を用意し、`BitmapDescriptor.fromAssetImage` で読み込んでいます。  
2. **`photoUrl` を使った四角アイコンを表示したい場合**  
   - 一度ネットワーク画像を読み込んで、`ui.instantiateImageCodec` → `toByteData()` などで `BitmapDescriptor.fromBytes` を生成します。  
3. **`useEffect` や `FutureBuilder` などを活用して非同期的にアイコンを読み込み、`useState` などで保持しておく**  
   - マーカー描画時にそれらを代入することで、地図に反映させます。  

---

以下に `MapPage` のサンプルコードを示します。  
実際には画像アセットや UI デザインをプロジェクトに合わせて調整してください。

```dart
import 'dart:typed_data';
import 'dart:ui' as ui; // ★ NetworkImage → image.toByteData() で使用

import 'package:flutter/material.dart';
import 'package:flutter/hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

// ★ ここで、アセットから BitmapDescriptor を作るヘルパー関数を用意
Future<BitmapDescriptor> bitmapDescriptorFromAsset(
  String assetName, {
  int width = 64,
  int height = 64,
}) async {
  // 画像を読み込み
  final ImageConfiguration config = ImageConfiguration(
    size: Size(width.toDouble(), height.toDouble()),
  );
  return BitmapDescriptor.fromAssetImage(config, assetName);
}

// ★ ネットワーク画像から四角アイコンを作るサンプル
Future<BitmapDescriptor> bitmapDescriptorFromNetworkImage(
  String imageUrl, {
  int width = 100,
  int height = 100,
}) async {
  final ImageStream stream = NetworkImage(imageUrl).resolve(const ImageConfiguration());
  final Completer<ui.Image> completer = Completer<ui.Image>();
  late ImageStreamListener listener;

  listener = ImageStreamListener((ImageInfo frame, bool sync) {
    completer.complete(frame.image);
    stream.removeListener(listener);
  }, onError: (dynamic error, StackTrace? stackTrace) {
    completer.completeError(error, stackTrace);
    stream.removeListener(listener);
  });

  stream.addListener(listener);

  final ui.Image image = await completer.future;

  // ★ ここで四角形に切り抜きたい場合は、Canvas で描画時に工夫する
  //   今はシンプルにそのまま画像を ByteData 化している
  final ByteData? byteData = await image.toByteData(format: ui.ImageByteFormat.png);
  if (byteData == null) {
    throw Exception('Failed to convert network image to byte data.');
  }
  return BitmapDescriptor.fromBytes(byteData.buffer.asUint8List());
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController を保持
    final googleMapController = useState<GoogleMapController?>(null);

    // 現在位置
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // Spot 一覧
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);

    // ItemBox 一覧
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    // 自分のギルドID を保持
    final myGuildIdState = useState<String?>(null);

    // ★ カスタムアイコンを保持する State
    final greenCircleIcon = useState<BitmapDescriptor?>(null);
    final redCircleIcon = useState<BitmapDescriptor?>(null);
    final treasureBoxIcon = useState<BitmapDescriptor?>(null);

    useEffect(
      () {
        // 初期ロード & アイコン準備
        Future.microtask(() async {
          try {
            // アイコンの読み込み (アセット想定)
            greenCircleIcon.value = await bitmapDescriptorFromAsset(
              'assets/images/green_circle.png', 
              width: 64, 
              height: 64,
            );
            redCircleIcon.value = await bitmapDescriptorFromAsset(
              'assets/images/red_circle.png',
              width: 64,
              height: 64,
            );
            treasureBoxIcon.value = await bitmapDescriptorFromAsset(
              'assets/images/treasure_box.png', // 例: 宝箱アイコン画像
              width: 72,
              height: 72,
            );

            // 自分のギルド情報
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

            // ItemBox 一覧
            await ref.read(getItemBoxListNotifierProvider.notifier).getItemBoxList();

            // 自分のアカウント情報からギルドID を取得
            final myAccount =
                await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            // ギルドがあれば Spot を取得
            if (myGuildIdState.value != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // フォアグラウンドに戻ってきたら位置情報を再取得
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    // マーカーをまとめる
    final Set<Marker> markers = {};

    // Spot のマーカー生成
    final guildSpots = myGuildSpotListState.asData?.value ?? [];
    final myGuildId = myGuildIdState.value;

    for (final spot in guildSpots) {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';

      // デフォルトマーカー
      BitmapDescriptor icon = BitmapDescriptor.defaultMarker;
      void Function()? onTap;

      if (spot.guildId == null) {
        // → photoUrl アイコンを四角
        //   photoUrl が正しく取れる場合はネットワーク画像として読み込む
        if (spot.photoUrl != null && spot.photoUrl!.isNotEmpty) {
          // ネットワーク画像を同期的にロードすると毎回 Future が走るので、
          // ここでは簡単に「同期的に生成してしまう」例を示しているが、
          // 実際は Marker をビルドする前に事前にキャッシュした方が良い
          // （大量にあると毎回 Future が走ってパフォーマンスが落ちるため）
          markers.add(
            Marker(
              markerId: MarkerId('spot_$spotId'),
              position: LatLng(lat, lng),
              onTap: () {
                // 撃てるスポット詳細を表示
                ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
              },
              icon: BitmapDescriptor.defaultMarker, // 一旦デフォルトで建てておき、
            ),
          );

          // 非同期で更新してしまう例 (サンプル。実運用では効率化が必要)
          (() async {
            final networkIcon =
                await bitmapDescriptorFromNetworkImage(spot.photoUrl!, width: 120, height: 120);
            googleMapController.value?.showMarkerInfoWindow(MarkerId('spot_$spotId'));
            // マーカーを再生成し直す、などのロジックがいる
            // ただ、GoogleMap は Marker を「再描画」できないので setState or Riverpod の state 更新が必要。
            // ここでは話が複雑になるので割愛
          })();

        } else {
          // photoUrl なし → とりあえずデフォルトアイコン
          icon = BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueAzure);
        }

        onTap = () {
          ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        };
      } else if (spot.guildId != myGuildId) {
        // → 他のギルド → 赤いフラッグを丸で表現
        icon = redCircleIcon.value ?? BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueRed);
        onTap = () {
          ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        };
      } else {
        // → 自分のギルド → 緑のフラッグを丸で表現
        icon =
            greenCircleIcon.value ?? BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueGreen);
        onTap = () {
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);
        };
      }

      markers.add(
        Marker(
          markerId: MarkerId('spot_$spotId'),
          position: LatLng(lat, lng),
          icon: icon,
          onTap: onTap,
        ),
      );
    }

    // ItemBox のマーカー生成
    final itemBoxes = itemBoxListState.asData?.value ?? [];
    for (final itemBox in itemBoxes) {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';

      markers.add(
        Marker(
          markerId: MarkerId('itemBox_$itemBoxId'),
          position: LatLng(lat, lng),
          // 宝箱を四角で表現 (ここでは treasure_box.png)
          icon: treasureBoxIcon.value ??
              BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueOrange),
          onTap: () async {
            // ItemBox を開けるロジック
            final userLocation = currentLocationState.asData?.value;
            if (userLocation == null) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('現在地を取得できませんでした')),
              );
              return;
            }

            try {
              final items = await ref
                  .read(openItemBoxNotifierProvider.notifier)
                  .openItemBox(itemBoxId, userLocation);

              // 成功 → ダイアログでアイテム一覧を表示
              if (context.mounted) {
                showDialog(
                  context: context,
                  barrierDismissible: false,
                  builder: (ctx) {
                    return Dialog(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Text('取得したアイテム'),
                            const SizedBox(height: 16),
                            for (final item in items)
                              Text(item.itemName ?? 'No Name'),
                            const SizedBox(height: 16),
                            IconButton(
                              onPressed: () => Navigator.pop(ctx),
                              icon: const Icon(Icons.cancel),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                );
              }
            } catch (e) {
              // 失敗 → スナックバーでメッセージを表示
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('宝箱を開けられませんでした: $e')),
              );
            }
          },
        ),
      );
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers,
            ),
            // ---- 下部ボタン類 ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // 現在地へ戻るボタン
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore リスト
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot リスト
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('設定アプリから位置情報取得をONにしてください'),
          ),
        ),
      ),
    );
  }
}

// ライフサイクルイベントを監視するクラス
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

---

### 実装の流れ

1. **丸/四角の画像を用意する**  
   - 例: `assets/images/green_circle.png`、`assets/images/red_circle.png`、`assets/images/treasure_box.png`  
2. **`pubspec.yaml` にアセットパスを登録**  
   ```yaml
   flutter:
     assets:
       - assets/images/green_circle.png
       - assets/images/red_circle.png
       - assets/images/treasure_box.png
   ```
3. **`useEffect` で `BitmapDescriptor.fromAssetImage` を呼び出し、`useState`(Riverpodなら`StateProvider`等) で保持**  
4. **`Marker` 生成時に `icon: yourIconState.value ?? BitmapDescriptor.defaultMarker` を割り当て**  
5. **`photoUrl` がある場合は非同期でネットワーク画像を読み込んで `BitmapDescriptor.fromBytes` を生成**  
   - 大量にある場合はキャッシュ戦略が必須になるため注意  

こうすることで、  
- 自分のギルド: 緑丸  
- 他のギルド: 赤丸  
- ギルドID null（photoUrlあり）: 四角写真  
- アイテムボックス: 四角宝箱  
といった形で描画できます。  

&gt; **補足**:  
&gt; Flutter / `google_maps_flutter` では Marker を「後から差し替え」しようとするとやや制約があり、 `Set<Marker>` を再構築して `setState`（`HookConsumerWidget` なら `ref.invalidate(...)` 等）で更新が必要です。  
&gt; 大量の Spot / ItemBox がある場合、**個別にネットワークアイコンを生成→Marker再生成** というフローがパフォーマンス的に厳しくなる可能性があります。あらかじめサムネイルを作る / ローカルキャッシュを使う など工夫してください。

---

## 👤 ユーザー
*2025/01/17 21:27:51*

widget_to_markerを使えばwidgetをマーカーとして設定できそう。
これで4種類のマーカーをwidgetで実装してみてくれないかな。
自分の旗、相手の旗、宝箱はマテリアルアイコンを軸に実装してほしい。
そして、spot.guildId == null なマーカーはspot.photoUrlから画像を取得してほしい。

あと、if (spot.guildId == null) や else if spot.guildId == myGuildId などは少し見通しが悪いので、enum で SpotType を定義して、判定してから適切に処理してほしい。

さらにマーカーをまとめた MarkerType のenumを定義して設定して、ItemBox と Spot を持って、SpotはさらにSpotTypeを持つような 定義にして、全体の見通しをよくしてほしい。

widget_to_markerは以下である。

widget_to_marker: ^1.0.6
https://pub.dev/packages/widget_to_marker

READMEをここに添付します。


## Features
When using Google Maps, we always have a problem with adding a marker on the map, and the available tools were either drawing the marker through canvas path or using an image, but the problem is if we want to add words or data or add custom edit to this marker, but this package has solved the problem and now you can use any widget in flutter as a marker for google map !
using the .toBitmapDescriptor() function on the widget to use it as a marker icon!
# Getting started
## Add dependency

```dart
dependencies:
  widget_to_marker: ^1.0.6
```
##  1 - Create Your Widget To Make it as Marker:

```dart
import 'package:widget_to_marker/widget_to_marker.dart';

class TextOnImage extends StatelessWidget {
  const TextOnImage({
    super.key,
    required this.text,
  });
  final String text;
  @override
  Widget build(BuildContext context) {
    return Stack(
      alignment: Alignment.center,
      children: [
        Image(
          image: const AssetImage(
            "assets/marker.png",
          ),
          height: 150,
          width: 150,
        ),
        Text(
          text,
          style: TextStyle(color: Colors.black),
        )
      ],
    );
  }
}
```
##  2 - Add it to the marker with   `.toBitmapDescriptor()`:
```dart
Marker(
      markerId: const MarkerId("3"),
      position: const LatLng(30.01124477440843, 30.78459296375513),
      icon: await TextOnImage(
        text: "Hello World",
      ).toBitmapDescriptor(
         logicalSize: const Size(150, 150), imageSize: const Size(150, 150)
      ),
    )
```
## Note
 You Can Use waitToRender Attribute to set duration for rendering large network and asset images

## Enjoy!!

![image](https://user-images.githubusercontent.com/88829064/210017494-ef63d4a2-fdec-46d9-b2a2-4f0451932e01.png)

---

## 🤖 アシスタント
*2025/01/17 21:28:55*

下記は `widget_to_marker` を使ったサンプル実装例です。  
- **MarkerType** と **SpotType** の2種類の enum を定義し、  
  - **MarkerType**: `spot` / `itemBox`  
  - **SpotType**: `noneGuild` / `myGuild` / `otherGuild`  
- **MarkerData** クラスを定義し、`Spot` なのか `ItemBox` なのかをひとまとめに扱いつつ、Spot の場合はさらに SpotType をもたせています。  
- `widget_to_marker` の `.toBitmapDescriptor(...)` を活用して、**Widget でマーカーをデザイン** しています。  
- **ギルドIDが null (`SpotType.noneGuild`) → `photoUrl` を表示した四角の画像**  
- **自分のギルド (`SpotType.myGuild`) → 緑旗（Material Icon）**  
- **他のギルド (`SpotType.otherGuild`) → 赤旗（Material Icon）**  
- **アイテムボックス (`MarkerType.itemBox`) → 宝箱（Material Icon）**  

&gt; **ポイント**:  
&gt; - ネットワーク画像の場合は読み込みに時間がかかるため、`waitToRender: const Duration(seconds: 1)` などを指定しないと、アイコン生成がうまくいかない（真っ白になる）場合があります。サンプルでは `waitToRender` を指定しています。  
&gt; - 実際には、たくさんのピンを一度に生成するとパフォーマンスに影響が出ることもあるので注意してください。  
&gt; - `WidgetToMarker` は各マーカーごとに `Future` を伴うため、Marker の再生成のタイミングが複雑になる場合があります。必要に応じてキャッシュやプリロード処理を入れるとよいでしょう。

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';

// ----- enum 定義 -----

/// Spot がどの状態かを示す
enum SpotType {
  noneGuild, // guildId == null
  myGuild,   // guildId == myGuildId
  otherGuild // guildId != myGuildId
}

/// マーカーが Spot か ItemBox かを表す
enum MarkerType {
  spot,
  itemBox,
}

// ----- MarkerData 定義 -----
// Spot または ItemBox のいずれかを保持し、Spot の場合は SpotType も保持
class MarkerData {
  final MarkerType markerType;
  final SpotType? spotType;
  final GuildSpotDTO? spot;
  final ItemBoxDTO? itemBox;

  MarkerData({
    required this.markerType,
    this.spotType,
    this.spot,
    this.itemBox,
  });
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController を保持
    final googleMapController = useState<GoogleMapController?>(null);

    // 現在位置
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // Spot 一覧
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);

    // ItemBox 一覧
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    // 自分のギルドID を保持
    final myGuildIdState = useState<String?>(null);

    // Map へ設置する Marker を保持
    final markers = useState<Set<Marker>>({});

    // マーカー生成中フラグ（loading 表示などをしたい場合に使う）
    final isMarkersBuilding = useState<bool>(false);

    // マーカーを生成して Set<Marker> を返す関数
    Future<Set<Marker>> buildMarkers({
      required List<GuildSpotDTO> spots,
      required List<ItemBoxDTO> itemBoxes,
      required String? myGuildId,
    }) async {
      final markerSet = <Marker>{};

      // ---- Spot を MarkerData にまとめる ----
      final spotMarkerDataList = spots.map((spot) {
        SpotType spotType;
        if (spot.guildId == null) {
          spotType = SpotType.noneGuild;
        } else if (spot.guildId == myGuildId) {
          spotType = SpotType.myGuild;
        } else {
          spotType = SpotType.otherGuild;
        }
        return MarkerData(
          markerType: MarkerType.spot,
          spotType: spotType,
          spot: spot,
        );
      }).toList();

      // ---- ItemBox を MarkerData にまとめる ----
      final itemBoxMarkerDataList = itemBoxes.map((iBox) {
        return MarkerData(
          markerType: MarkerType.itemBox,
          itemBox: iBox,
        );
      }).toList();

      // 全部まとめる
      final allMarkersData = [
        ...spotMarkerDataList,
        ...itemBoxMarkerDataList,
      ];

      // MarkerData を1つずつ処理し、Marker を生成
      for (final data in allMarkersData) {
        // 緯度経度を取得
        double lat = 0;
        double lng = 0;
        String markerId = '';

        if (data.markerType == MarkerType.spot && data.spot != null) {
          lat = data.spot!.spotLatitude?.toDouble() ?? 0;
          lng = data.spot!.spotLongitude?.toDouble() ?? 0;
          markerId = 'spot_${data.spot!.spotId ?? ''}';
        } else if (data.markerType == MarkerType.itemBox && data.itemBox != null) {
          lat = data.itemBox!.itemBoxLatitude?.toDouble() ?? 0;
          lng = data.itemBox!.itemBoxLongitude?.toDouble() ?? 0;
          markerId = 'itemBox_${data.itemBox!.itemBoxId ?? ''}';
        }

        // 作りたい Widget
        final markerWidget = _buildMarkerWidget(data);

        // Widget から BitmapDescriptor へ変換
        final iconDescriptor = await markerWidget.toBitmapDescriptor(
          // 表示サイズ
          logicalSize: const Size(80, 80),
          imageSize: const Size(80, 80),
          // ネットワーク画像読み込みを待つために waitToRender を設定
          waitToRender: const Duration(milliseconds: 600),
        );

        // Marker を組み立てる
        markerSet.add(
          Marker(
            markerId: MarkerId(markerId),
            position: LatLng(lat, lng),
            icon: iconDescriptor,
            onTap: () async {
              // タップ時のアクション
              if (data.markerType == MarkerType.spot && data.spot != null) {
                // Spot の処理
                switch (data.spotType) {
                  case SpotType.noneGuild:
                    // 撃てるスポット詳細
                    ref
                        .read(showShootableSpotDetailNotifierProvider.notifier)
                        .show(data.spot!.spotId ?? '');
                    break;
                  case SpotType.myGuild:
                    // 自分のスポット詳細
                    ref
                        .read(showOurSpotDetailNotifierProvider.notifier)
                        .show(data.spot!.spotId ?? '');
                    break;
                  case SpotType.otherGuild:
                    // 撃てるスポット詳細
                    ref
                        .read(showShootableSpotDetailNotifierProvider.notifier)
                        .show(data.spot!.spotId ?? '');
                    break;
                }
              } else if (data.markerType == MarkerType.itemBox && data.itemBox != null) {
                // ItemBox の処理
                final userLocation = currentLocationState.asData?.value;
                if (userLocation == null) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('現在地を取得できませんでした')),
                  );
                  return;
                }
                try {
                  final items = await ref
                      .read(openItemBoxNotifierProvider.notifier)
                      .openItemBox(data.itemBox!.itemBoxId ?? '', userLocation);

                  // 成功 → ダイアログ表示
                  if (context.mounted) {
                    showDialog(
                      context: context,
                      barrierDismissible: false,
                      builder: (ctx) {
                        return Dialog(
                          child: Padding(
                            padding: const EdgeInsets.all(16),
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                const Text('取得したアイテム'),
                                const SizedBox(height: 16),
                                for (final item in items)
                                  Text(item.itemName ?? 'No Name'),
                                const SizedBox(height: 16),
                                IconButton(
                                  onPressed: () => Navigator.pop(ctx),
                                  icon: const Icon(Icons.cancel),
                                ),
                              ],
                            ),
                          ),
                        );
                      },
                    );
                  }
                } catch (e) {
                  // 失敗 → スナックバー表示
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('宝箱を開けられませんでした: $e')),
                  );
                }
              }
            },
          ),
        );
      }

      return markerSet;
    }

    // useEffect で初回ロード処理
    useEffect(
      () {
        Future.microtask(() async {
          try {
            // アカウントやギルド情報などの初期化
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            await ref.read(getItemBoxListNotifierProvider.notifier).getItemBoxList();

            final myAccount =
                await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            // Spot を取得
            if (myGuildIdState.value != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }

            // マーカー作成
            await _refreshMarkers();
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // フォアグラウンド復帰で位置情報再取得
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    // マーカーを再構築する関数
    Future<void> _refreshMarkers() async {
      try {
        isMarkersBuilding.value = true;
        final spots = myGuildSpotListState.asData?.value ?? [];
        final itemBoxes = itemBoxListState.asData?.value ?? [];
        final myGuildId = myGuildIdState.value;

        final newMarkers = await buildMarkers(
          spots: spots,
          itemBoxes: itemBoxes,
          myGuildId: myGuildId,
        );
        markers.value = newMarkers;
      } finally {
        isMarkersBuilding.value = false;
      }
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers.value,
            ),
            if (isMarkersBuilding.value)
              const Center(child: CircularProgressIndicator()),
            // ---- 下部ボタン類 ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // 現在地へ戻るボタン
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore リスト
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot リスト
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('設定アプリから位置情報取得をONにしてください'),
          ),
        ),
      ),
    );
  }

  /// MarkerData から表示する Widget を組み立てる
  /// widget_to_marker の .toBitmapDescriptor に渡すため
  Widget _buildMarkerWidget(MarkerData data) {
    switch (data.markerType) {
      case MarkerType.spot:
        {
          switch (data.spotType) {
            case SpotType.noneGuild:
              // guildId == null → photoUrl アイコンを四角
              final photoUrl = data.spot?.photoUrl;
              if (photoUrl != null && photoUrl.isNotEmpty) {
                return ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: Image.network(
                    photoUrl,
                    fit: BoxFit.cover,
                    width: 80,
                    height: 80,
                  ),
                );
              } else {
                // photoUrl なし → placeholder
                return Container(
                  width: 80,
                  height: 80,
                  color: Colors.grey,
                  child: const Center(child: Text('No Photo')),
                );
              }
            case SpotType.myGuild:
              // 自分の旗 → 緑色フラッグ (Material Icon)
              return Container(
                width: 80,
                height: 80,
                decoration: const BoxDecoration(
                  shape: BoxShape.circle,
                  color: Colors.white,
                ),
                child: const Icon(
                  Icons.flag,
                  color: Colors.green,
                  size: 40,
                ),
              );
            case SpotType.otherGuild:
              // 相手の旗 → 赤色フラッグ
              return Container(
                width: 80,
                height: 80,
                decoration: const BoxDecoration(
                  shape: BoxShape.circle,
                  color: Colors.white,
                ),
                child: const Icon(
                  Icons.flag,
                  color: Colors.red,
                  size: 40,
                ),
              );
            default:
              // fallback
              return const SizedBox();
          }
        }
      case MarkerType.itemBox:
        // アイテムボックス → 宝箱アイコン (Material Icon)
        return Container(
          width: 80,
          height: 80,
          decoration: BoxDecoration(
            border: Border.all(color: Colors.brown, width: 2),
            borderRadius: BorderRadius.circular(12),
            color: Colors.white,
          ),
          child: const Icon(
            Icons.card_giftcard,
            color: Colors.brown,
            size: 40,
          ),
        );
    }
  }
}

// ライフサイクルイベントを監視するクラス
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

## 実装の流れ

1. **`pubspec.yaml` に `widget_to_marker: ^1.0.6` を追加**  
   ```yaml
   dependencies:
     widget_to_marker: ^1.0.6
   ```
2. **`MarkerType` / `SpotType` の enum を定義し、どのようなマーカーを表示するかを判定**  
   - `noneGuild` (`guildId == null`) / `myGuild` / `otherGuild`  
3. **`MarkerData` クラスで Spot / ItemBox をひとまとめに扱い、`markerType` と `spotType` を持たせる**  
4. `MapPage` 内で Spot や ItemBox のリストから `MarkerData` を作り、ループして `widget_to_marker` で `BitmapDescriptor` を生成 → `Marker` に設定  
5. **`_buildMarkerWidget`** 関数の中で実際の **Widget**（`Icon` や `Image.network` など）を返し、**丸い背景や四角い枠** を装飾している  
6. 生成した `Marker` を `markers` に加えて `GoogleMap` の `markers` プロパティに渡す  

---

### 注意点

- **ネットワーク画像** の場合は読み込みに時間がかかり、最初は白いマーカーになったりする可能性があります。そこで `waitToRender` を設定したり、**あらかじめキャッシュ** するなど工夫が必要です。  
- マーカーが大量にある場合、一度に `.toBitmapDescriptor(...)` を連続実行するとパフォーマンスが低下する恐れがあります。  
- **Marker の更新** は、マーカーを再構築して `markers.value = ...` してやる必要があります。必要に応じて都度 `_refreshMarkers()` を呼び出すなどしてください。

---

## 👤 ユーザー
*2025/01/17 21:34:07*

SpotType はそのままで MarkerType や MarkerData は使わなくていいや。

---

## 🤖 アシスタント
*2025/01/17 21:35:08*

以下は `widget_to_marker` を用いて、 **Spot** と **ItemBox** のマーカーをそれぞれ **Widget** で実装するサンプルです。  
- **Spot** は `SpotType` ( `noneGuild` / `myGuild` / `otherGuild` ) で分岐し、  
  - ギルドID=null → `photoUrl` の画像を四角で表示  
  - 自分のギルド → 緑色フラッグを丸アイコン  
  - 他のギルド → 赤色フラッグを丸アイコン  
- **ItemBox** は宝箱アイコンを四角に表示。  
- `widget_to_marker` の `.toBitmapDescriptor(...)` を使って `Marker` の `icon` に設定しています。  

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';

/// Spot の種類を表す
enum SpotType {
  noneGuild, // guildId == null
  myGuild,   // guildId == myGuildId
  otherGuild // guildId != myGuildId
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController を保持
    final googleMapController = useState<GoogleMapController?>(null);

    // 現在位置
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // Spot 一覧
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);

    // ItemBox 一覧
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    // 自分のギルドID を保持
    final myGuildIdState = useState<String?>(null);

    // Map へ設置する Marker
    final markers = useState<Set<Marker>>({});
    // マーカー生成中フラグ（必要ならロード中表示に使う）
    final isMarkersBuilding = useState<bool>(false);

    useEffect(
      () {
        Future.microtask(() async {
          try {
            // 自分のギルド・アイテムボックスなど初期データ取得
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            await ref.read(getItemBoxListNotifierProvider.notifier).getItemBoxList();

            final myAccount =
                await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            if (myGuildIdState.value != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }

            // マーカー生成
            await _refreshMarkers();
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // フォアグラウンド復帰で位置情報再取得
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    // マーカーを再構築
    Future<void> _refreshMarkers() async {
      try {
        isMarkersBuilding.value = true;
        final spots = myGuildSpotListState.asData?.value ?? [];
        final itemBoxes = itemBoxListState.asData?.value ?? [];
        final myGuildId = myGuildIdState.value;

        final newMarkers = await _buildAllMarkers(
          spots: spots,
          itemBoxes: itemBoxes,
          myGuildId: myGuildId,
        );
        markers.value = newMarkers;
      } finally {
        isMarkersBuilding.value = false;
      }
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers.value,
            ),
            // ★ マーカー作成中にインジケータを出す例
            if (isMarkersBuilding.value)
              const Center(child: CircularProgressIndicator()),

            // ---- 下部ボタン類 ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // 現在地へ戻るボタン
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore リスト
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot リスト
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('設定アプリから位置情報取得をONにしてください'),
          ),
        ),
      ),
    );
  }

  /// Spot / ItemBox それぞれのマーカーを作り、Set<Marker> を返す
  Future<Set<Marker>> _buildAllMarkers({
    required List<GuildSpotDTO> spots,
    required List<ItemBoxDTO> itemBoxes,
    required String? myGuildId,
  }) async {
    final markerSet = <Marker>{};

    // ---- Spot マーカー生成 ----
    for (final spot in spots) {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';

      // SpotType 判定
      SpotType spotType;
      if (spot.guildId == null) {
        spotType = SpotType.noneGuild;
      } else if (spot.guildId == myGuildId) {
        spotType = SpotType.myGuild;
      } else {
        spotType = SpotType.otherGuild;
      }

      // Widget を組み立て
      final widget = _buildSpotMarkerWidget(spotType, spot.photoUrl);

      // BitmapDescriptor に変換
      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(80, 80),
        imageSize: const Size(80, 80),
        // 画像を待つ
        waitToRender: const Duration(milliseconds: 500),
      );

      // Marker を追加
      markerSet.add(
        Marker(
          markerId: MarkerId('spot_$spotId'),
          position: LatLng(lat, lng),
          icon: iconDescriptor,
          onTap: () async {
            switch (spotType) {
              case SpotType.noneGuild:
                // 撃てるスポットの詳細
                _showShootableSpotDetail(spotId);
                break;
              case SpotType.myGuild:
                // 自分のスポット詳細
                _showOurSpotDetail(spotId);
                break;
              case SpotType.otherGuild:
                // 撃てるスポットの詳細
                _showShootableSpotDetail(spotId);
                break;
            }
          },
        ),
      );
    }

    // ---- ItemBox マーカー生成 ----
    for (final itemBox in itemBoxes) {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';

      // Widget を組み立て (宝箱アイコン)
      final widget = _buildItemBoxMarkerWidget();

      // BitmapDescriptor に変換
      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(80, 80),
        imageSize: const Size(80, 80),
        waitToRender: const Duration(milliseconds: 300),
      );

      // Marker を追加
      markerSet.add(
        Marker(
          markerId: MarkerId('itemBox_$itemBoxId'),
          position: LatLng(lat, lng),
          icon: iconDescriptor,
          onTap: () async {
            // ItemBox を開ける
            await _openItemBox(itemBoxId);
          },
        ),
      );
    }

    return markerSet;
  }

  /// Spot 用のマーカーWidgetを返す
  Widget _buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    switch (spotType) {
      case SpotType.noneGuild:
        // guildId == null → photoUrl
        if (photoUrl != null && photoUrl.isNotEmpty) {
          return ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: Image.network(
              photoUrl,
              fit: BoxFit.cover,
              width: 80,
              height: 80,
            ),
          );
        } else {
          // photoUrl が無い場合はプレースホルダー
          return Container(
            width: 80,
            height: 80,
            color: Colors.grey,
            child: const Center(child: Text('No Photo')),
          );
        }

      case SpotType.myGuild:
        // 自分のギルド → 緑の旗を丸で
        return Container(
          width: 80,
          height: 80,
          decoration: const BoxDecoration(
            shape: BoxShape.circle,
            color: Colors.white,
          ),
          child: const Icon(
            Icons.flag,
            color: Colors.green,
            size: 40,
          ),
        );

      case SpotType.otherGuild:
        // 他のギルド → 赤い旗を丸で
        return Container(
          width: 80,
          height: 80,
          decoration: const BoxDecoration(
            shape: BoxShape.circle,
            color: Colors.white,
          ),
          child: const Icon(
            Icons.flag,
            color: Colors.red,
            size: 40,
          ),
        );
    }
  }

  /// ItemBox 用のマーカーWidgetを返す
  Widget _buildItemBoxMarkerWidget() {
    return Container(
      width: 80,
      height: 80,
      decoration: BoxDecoration(
        border: Border.all(color: Colors.brown, width: 2),
        borderRadius: BorderRadius.circular(12),
        color: Colors.white,
      ),
      child: const Icon(
        Icons.card_giftcard,
        color: Colors.brown,
        size: 40,
      ),
    );
  }

  // ---- 以下、onTap 時の処理 ----

  void _showShootableSpotDetail(String spotId) {
    // 撃てるスポット詳細を表示
    // showShootableSpotDetailNotifierProvider を使う
    // 例:
    // ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
  }

  void _showOurSpotDetail(String spotId) {
    // 自分のスポット詳細を表示
    // showOurSpotDetailNotifierProvider を使う
    // 例:
    // ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);
  }

  Future<void> _openItemBox(String itemBoxId) async {
    // 現在地を取得 → openItemBox
    // 例:
    // final userLocation = ref.read(currentLocationNotifierProvider).asData?.value;
    // if (userLocation == null) return;
    // try {
    //   final items = await ref.read(openItemBoxNotifierProvider.notifier)
    //       .openItemBox(itemBoxId, userLocation);
    //   // 成功時はダイアログ表示
    // } catch (e) {
    //   // 失敗時はスナックバーなど表示
    // }
  }
}

// ライフサイクルイベントを監視するクラス
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

---

## 解説

1. **SpotType**  
   - `noneGuild` (`guildId == null`), `myGuild`, `otherGuild` の3種類を定義。  
2. **初期データ取得**  
   - `getMyGuildNotifierProvider` で自分のギルド、 `getItemBoxListNotifierProvider` でアイテムボックス一覧を取得。  
   - `myGuildIdState` にギルドID を保持。  
   - `myGuildIdState.value` が存在すれば `getGuildSpotListNotifierProvider` を呼んで Spot 一覧を取得。  
3. **`_buildAllMarkers()`** で Spot・ItemBox それぞれのマーカーを生成  
   - Spot は `SpotType` を判定し、 `_buildSpotMarkerWidget(spotType, photoUrl)` でマーカー用 Widget を返す。  
   - ItemBox は `_buildItemBoxMarkerWidget()` で宝箱風の Widget を返す。  
   - `widget_to_marker` の `.toBitmapDescriptor(...)` を await して `Marker.icon` に設定。  
   - `Marker.onTap` でそれぞれの処理（Spot の場合は `showShootableSpotDetail` or `showOurSpotDetail`、 ItemBox の場合は `openItemBox`）を実行。  
4. **ネットワーク画像の注意**  
   - `waitToRender` を付与しないと、ネットワーク画像が描画される前に `toBitmapDescriptor` が走り、真っ白な画像になりがち。  
   - 画像が大量にある場合、マーカー生成に時間がかかるため、**キャッシュ** や **事前ロード** を検討してください。  
5. **Marker の更新**  
   - 何か変更があれば `_refreshMarkers()` を呼び直して `markers.value = ...` を更新すれば再描画されます。  

このように `widget_to_marker` を使うことで、**自由な Widget** をマーカーとして表示できます。

---

## 👤 ユーザー
*2025/01/17 22:03:15*

refreshMarkers 時点で spots, itemBoxes が 0 件だということがわかった。
これは refreshMarkersの段階で引数で spots や itemBoxes を渡した方がよさそうである。
そのために getGuildSpotList()とgetItemBoxList()で値を返すように変更した。
これを使って処理時に確実にspotsやitemBoxesが取得してからその値を渡すようにするように変えたい。

また、spots ではなく spotList、itemBoxesではなくitemBoxListにしてほしい。
また、マーカーは白の四角枠であるが、下にマーカーのような白の逆三角で地点を指し示すようなにマーカーであることをより表してほしい。これは簡素な実装でよい。

getGuildSpotListやgetItemBoxListの処理は以下である。

@Riverpod(keepAlive: true)
class GetItemBoxListNotifier extends _$GetItemBoxListNotifier {
  @override
  Future&lt;List&lt;ItemBoxDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;List&lt;ItemBoxDTO&gt;&gt; getItemBoxList() async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(itemBoxesApiProvider.future);
      final response = await api.itemBoxControllerGetItemBoxes();
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      final data = response.data?.data;
      if (data == null) {
        throw Exception('No data found');
      }
      state = AsyncValue.data(data);
      return data;
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
      rethrow;
    }
  }
}

@Riverpod(keepAlive: true)
class GetGuildSpotListNotifier extends _$GetGuildSpotListNotifier {
  @override
  Future&lt;List&lt;GuildSpotDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;List&lt;GuildSpotDTO&gt;&gt; getGuildSpotList(String guildId) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildsApiProvider.future);
      final response = await api.guildControllerGetGuildSpots(guildId: guildId);
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      final data = response.data?.data;
      if (data == null) {
        throw Exception('No data found');
      }
      state = AsyncValue.data(data);
      return data;
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
      rethrow;
    }
  }
}

---

## 🤖 アシスタント
*2025/01/17 22:05:20*

以下は、**`getGuildSpotList()`** と **`getItemBoxList()`** で返された値をそのまま引数として受け取り、  
`refreshMarkers`（ここでは `_refreshMarkers`）内で確実に **`spotList`** と **`itemBoxList`** を使ってマーカーを描画する実装例です。

主な変更点:

1. **`getGuildSpotList()` / `getItemBoxList()`** で **`List<GuildSpotDTO>` / `List<ItemBoxDTO>`** をリターンするように変更し、それを取得後に `_refreshMarkers(spotList, itemBoxList)` を呼び出す。  
2. **`spots`** → **`spotList`**、**`itemBoxes`** → **`itemBoxList`** に名称変更。  
3. マーカーの下に**白い逆三角形**をつけることで「ここを指している」感をシンプルに出す。  

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';

/// Spot の種類を表す
enum SpotType {
  noneGuild, // guildId == null
  myGuild,   // guildId == myGuildId
  otherGuild // guildId != myGuildId
}

/// 逆三角形を描画するシンプルな Painter
class TrianglePainter extends CustomPainter {
  final Color color;
  TrianglePainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // 左上
      ..lineTo(size.width, 0) // 右上
      ..lineTo(size.width / 2, size.height) // 底辺の中央
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) => false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController を保持
    final googleMapController = useState<GoogleMapController?>(null);

    // 現在地
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // 自分のギルドID
    final myGuildIdState = useState<String?>(null);

    // マーカーたち
    final markers = useState<Set<Marker>>({});
    // マーカー生成中フラグ
    final isMarkersBuilding = useState(false);

    useEffect(
      () {
        Future.microtask(() async {
          try {
            // 自分のギルドを取得 (アカウント→ギルドID)
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            final myAccount = await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            // ItemBox一覧を取得 (リターン値を受け取る)
            final itemBoxList = await ref.read(getItemBoxListNotifierProvider.notifier)
                .getItemBoxList();

            // Spot一覧を取得 (リターン値を受け取る)
            List<GuildSpotDTO> spotList = [];
            if (myGuildIdState.value != null) {
              spotList = await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }

            // 取得した値を元にマーカーを生成
            await _refreshMarkers(spotList, itemBoxList);
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // フォアグラウンド復帰で位置情報再取得
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    /// [spotList] と [itemBoxList] を受け取り、マーカーを再作成する
    Future<void> _refreshMarkers(
      List<GuildSpotDTO> spotList,
      List<ItemBoxDTO> itemBoxList,
    ) async {
      try {
        isMarkersBuilding.value = true;
        final newMarkers = await _buildAllMarkers(
          spotList: spotList,
          itemBoxList: itemBoxList,
          myGuildId: myGuildIdState.value,
        );
        markers.value = newMarkers;
      } finally {
        isMarkersBuilding.value = false;
      }
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers.value,
            ),
            // マーカー作成中にインジケータを出す（必要なければ消してOK）
            if (isMarkersBuilding.value)
              const Center(child: CircularProgressIndicator()),

            // ---- 下部ボタン類 ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // 現在地へ戻るボタン
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore リスト
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot リスト
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('設定アプリから位置情報取得をONにしてください'),
          ),
        ),
      ),
    );
  }

  /// SpotList / ItemBoxList それぞれのマーカーをまとめて生成
  Future<Set<Marker>> _buildAllMarkers({
    required List<GuildSpotDTO> spotList,
    required List<ItemBoxDTO> itemBoxList,
    required String? myGuildId,
  }) async {
    final markerSet = <Marker>{};

    // ---- Spot マーカー生成 ----
    for (final spot in spotList) {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';

      final spotType = _getSpotType(spot.guildId, myGuildId);

      // Spot用のWidget
      final widget = _buildSpotMarkerWidget(spotType, spot.photoUrl);

      // widget_to_marker で変換
      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(80, 90),
        imageSize: const Size(80, 90),
        waitToRender: const Duration(milliseconds: 500),
      );

      markerSet.add(
        Marker(
          markerId: MarkerId('spot_$spotId'),
          position: LatLng(lat, lng),
          icon: iconDescriptor,
          onTap: () => _onSpotMarkerTap(spotId, spotType),
        ),
      );
    }

    // ---- ItemBox マーカー生成 ----
    for (final iBox in itemBoxList) {
      final lat = iBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = iBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = iBox.itemBoxId ?? '';

      // アイテムボックス用のWidget
      final widget = _buildItemBoxMarkerWidget();

      // widget_to_marker で変換
      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(80, 90),
        imageSize: const Size(80, 90),
        waitToRender: const Duration(milliseconds: 300),
      );

      markerSet.add(
        Marker(
          markerId: MarkerId('itemBox_$itemBoxId'),
          position: LatLng(lat, lng),
          icon: iconDescriptor,
          onTap: () => _onItemBoxMarkerTap(itemBoxId),
        ),
      );
    }

    return markerSet;
  }

  /// spot.guildId と myGuildId から SpotType を判定
  SpotType _getSpotType(String? guildId, String? myGuildId) {
    if (guildId == null) {
      return SpotType.noneGuild;
    } else if (guildId == myGuildId) {
      return SpotType.myGuild;
    } else {
      return SpotType.otherGuild;
    }
  }

  /// Spotのマーカーを表すWidget (白枠 + 下に逆三角)
  Widget _buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    // Content部分 (四角形に表示)
    Widget content;
    switch (spotType) {
      case SpotType.noneGuild:
        // guildId == null → photoUrl
        if (photoUrl != null && photoUrl.isNotEmpty) {
          content = ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: Image.network(
              photoUrl,
              fit: BoxFit.cover,
              width: 80,
              height: 80,
            ),
          );
        } else {
          content = Container(
            width: 80,
            height: 80,
            color: Colors.grey,
            alignment: Alignment.center,
            child: const Text(
              'No Photo',
              style: TextStyle(fontSize: 12),
            ),
          );
        }
        break;

      case SpotType.myGuild:
        // 自分のギルド → 緑の旗 (丸アイコン背景)
        content = Container(
          width: 80,
          height: 80,
          decoration: const BoxDecoration(
            color: Colors.white,
            shape: BoxShape.circle,
          ),
          child: const Icon(
            Icons.flag,
            color: Colors.green,
            size: 40,
          ),
        );
        break;

      case SpotType.otherGuild:
        // 他ギルド → 赤の旗 (丸アイコン背景)
        content = Container(
          width: 80,
          height: 80,
          decoration: const BoxDecoration(
            color: Colors.white,
            shape: BoxShape.circle,
          ),
          child: const Icon(
            Icons.flag,
            color: Colors.red,
            size: 40,
          ),
        );
        break;
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // 四角 or 丸アイコン部分
        content,
        // 下に逆三角で地点を指す
        CustomPaint(
          size: const Size(20, 10), // 幅20, 高さ10
          painter: TrianglePainter(color: Colors.white),
        ),
      ],
    );
  }

  /// ItemBoxのマーカーを表すWidget (白枠 + 下に逆三角)
  Widget _buildItemBoxMarkerWidget() {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // 四角い枠に宝箱アイコン
        Container(
          width: 80,
          height: 80,
          decoration: BoxDecoration(
            border: Border.all(color: Colors.brown, width: 2),
            borderRadius: BorderRadius.circular(12),
            color: Colors.white,
          ),
          child: const Icon(
            Icons.card_giftcard,
            color: Colors.brown,
            size: 40,
          ),
        ),
        // 下に逆三角
        CustomPaint(
          size: const Size(20, 10),
          painter: TrianglePainter(color: Colors.white),
        ),
      ],
    );
  }

  // ---- タップ時の挙動 ----

  void _onSpotMarkerTap(String spotId, SpotType spotType) {
    switch (spotType) {
      case SpotType.noneGuild:
        // 撃てるスポット詳細を表示
        // ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        break;
      case SpotType.myGuild:
        // 自分のスポット詳細を表示
        // ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);
        break;
      case SpotType.otherGuild:
        // 撃てるスポット詳細を表示
        // ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        break;
    }
  }

  void _onItemBoxMarkerTap(String itemBoxId) async {
    // 現在地を取得してopenItemBoxを実行
    // 例:
    // final userLocation = ref.read(currentLocationNotifierProvider).asData?.value;
    // if (userLocation == null) return;
    // try {
    //   final items = await ref.read(openItemBoxNotifierProvider.notifier)
    //       .openItemBox(itemBoxId, userLocation);
    //   // 成功時、アイテム一覧をダイアログ表示
    // } catch (e) {
    //   // 失敗時、スナックバーなどでエラー表示
    // }
  }
}

// ---- ライフサイクルイベントを監視するクラス ----
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

---

## 解説

1. **`getGuildSpotList()` / `getItemBoxList()` が返す値をそのまま受け取り**  
   ```dart
   final itemBoxList = await ref
       .read(getItemBoxListNotifierProvider.notifier)
       .getItemBoxList();

   List<GuildSpotDTO> spotList = [];
   if (myGuildIdState.value != null) {
     spotList = await ref
         .read(getGuildSpotListNotifierProvider.notifier)
         .getGuildSpotList(myGuildIdState.value!);
   }
   ```
2. **`_refreshMarkers(spotList, itemBoxList)`** として引数を渡す  
   ```dart
   await _refreshMarkers(spotList, itemBoxList);
   ```
3. `_buildAllMarkers()` 内で `spotList` と `itemBoxList` を使ってマーカーを一括生成  
   - `SpotType` 判定 ( `noneGuild` / `myGuild` / `otherGuild` )  
   - `_buildSpotMarkerWidget(...)` / `_buildItemBoxMarkerWidget()` で**カスタムWidget**を構築  
   - `.toBitmapDescriptor()` を `await` して **Marker** にセット  
4. **マーカーの見た目**  
   - **四角 / 丸** のコンテナを**白背景**にする  
   - 下に `CustomPaint` で**逆三角形**を描画し、地図上の地点を指し示すイメージに  
5. **Spot をタップ** →  `showShootableSpotDetail` or `showOurSpotDetail` に誘導  
   **ItemBox をタップ** →  `openItemBox(...)` → 成功ならダイアログ表示、失敗ならスナックバーなど  
6. **画像 (`photoUrl`) の読み込み**  
   - `waitToRender: const Duration(milliseconds: 500)` を入れておかないと、ネットワーク画像が先にレンダリングされる前にバイトデータ化され、白い四角になる可能性があります。  
   - 大量にある場合は、**キャッシュ**や**非同期生成の仕組み**を工夫しましょう。  

この構成で、`spotList` と `itemBoxList` が 0 件であっても、必ず `_refreshMarkers(spotList, itemBoxList)` の呼び出しによりマーカー描画処理が実行されるため、**値を取得してからマーカーを生成**できるようになります。

---
