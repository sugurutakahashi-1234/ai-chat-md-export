# MapPage å®Ÿè£…ã‚¬ã‚¤ãƒ‰

æ—¥ä»˜: 2025-01-17

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/01/17 18:55:01*

ä»¥ä¸‹ã®MapPage ã«ã¤ã„ã¦ShowShootableSpotDetailButton ã¨ ShowOurSpotDetailButton ã‚’ä»®ã§ç½®ã„ã¦ã„ã‚‹ãŒã€ã“ã‚Œã‚‰ã‚’æ­£ã—ã„å®Ÿè£…ã«ä¿®æ­£ã—ãŸã„ã€‚
ã¾ãŸã€è¿½åŠ  itemBoxã¨ã„ã†æ¦‚å¿µã‚‚è¿½åŠ ã—ãŸã„ã€‚

ã“ã‚Œã‹ã‚‰è©³ç´°ã®ä¾é ¼ã‚’ä¼ãˆã¾ã™ã€‚

-  myGuildSpotListState ã¨ itemBoxListState ã‚’ä½¿ã£ã¦ã€GoogleMapä¸Šã«ãƒ”ãƒ³ã‚’ç«‹ã¦ã¦ã»ã—ã„ã€‚
    - ItemBoxã®ãƒ”ãƒ³ã¯å®ç®±ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’ã§è¡¨ç¾ã—ã¦ã»ã—ã„ã€‚
        - ã‚¿ãƒƒãƒ—ã—ãŸã‚‰ OpenItemBoxNotifier ã‚’ä½¿ã£ã¦  openItemBox() ã‚’å®Ÿè¡Œã—ã¦ã»ã—ã„
        - openItemBox() ã«æˆåŠŸã—ãŸã‚‰ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®List&lt;ItemDTO&gt; ã‚’è¡¨ç¤ºã™ã‚‹ã‚ˆã†ãªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¦ã»ã—ã„ã€‚ãã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã¯ä¸€æ—¦é©å½“ã§ã„ã„ãŒã€ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®ä¸‹ã®ä¸­å¤®ã®ãƒãƒ„ã‚¢ã‚¤ã‚³ãƒ³ã‚’ãŠã„ã¦ã€ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨é–‰ã˜ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã»ã—ã„
        - å¤±æ•—ã—ãŸã‚‰ã€ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã¦ã»ã—ã„ã€‚
    - Spotã®ãƒ”ãƒ³ã¯ä»¥ä¸‹ã®3ç¨®é¡ã«åˆ†ã‘ã‚‰ã‚Œã‚‹
        - Spotã®ã‚®ãƒ«ãƒ‰IdãŒnullã®å ´åˆ: 
            - ãƒ”ãƒ³ã§GuildSpotDTO.photoUrl ã§å–å¾—ã§ãã‚‹ç”»åƒã‚’å››è§’ã§è¡¨ç¾ã—ã¦ã»ã—ã„ã€‚
            - ã‚¿ãƒƒãƒ—ã—ãŸã‚‰ã€ç¾åœ¨ã®ShowShootableSpotDetailButton ã¨åŒã˜å‡¦ç†ã‚’ã—ã¦ã»ã—ã„ã€‚ãã®éš›ã«ã‚¿ãƒƒãƒ—ã—ãŸ SpotIdã‚’æ¸¡ã—ã¦ã»ã—ã„
        - Spotã®ã‚®ãƒ«ãƒ‰IdãŒnull ã§ã¯ãªãã€myGuildId ã¨ä¸€è‡´ã—ã¦ã„ãªã„å ´åˆ:
            - ãƒ”ãƒ³ã§èµ¤è‰²ã®æ——ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’ç«‹ã¦ã¦ã»ã—ã„
            - ã‚¿ãƒƒãƒ—ã—ãŸã‚‰ã€ç¾åœ¨ã®ShowShootableSpotDetailButton ã¨åŒã˜å‡¦ç†ã‚’ã—ã¦ã»ã—ã„ã€‚ãã®éš›ã«ã‚¿ãƒƒãƒ—ã—ãŸ SpotIdã‚’æ¸¡ã—ã¦ã»ã—ã„
        - Spotã®ã‚®ãƒ«ãƒ‰IdãŒnull ã§ã¯ãªãã€myGuildId ã¨ä¸€è‡´ã—ã¦ã„ã‚‹å ´åˆ:
            - ãƒ”ãƒ³ã§ç·‘è‰²ã®æ——ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’ç«‹ã¦ã¦ã»ã—ã„
            - ã‚¿ãƒƒãƒ—ã—ãŸã‚‰ã€ç¾åœ¨ã®ShowOurSpotDetailButton ã¨åŒã˜å‡¦ç†ã‚’ã—ã¦ã»ã—ã„ã€‚ãã®éš›ã«ã‚¿ãƒƒãƒ—ã—ãŸ SpotIdã‚’æ¸¡ã—ã¦ã»ã—ã„

myGuildId ã¯ ä»Šã¯ useEffect å†…ã§å®£è¨€ã—ã¦ã„ã‚‹ãŒã‚‚ã£ã¨å¤–å´ã§å®£è¨€ã—ã¦ã‚‚ã‚‰ã£ã¦ã‚‚æ§‹ã‚ãªã„ã€‚

ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆã¯MapPageã ã‘ã§ã„ã„ã€‚
ä»–ã®ã‚¯ãƒ©ã‚¹ã¯æƒ…å ±ã¨ã—ã¦ä¸ãˆã¾ã™ã€‚

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final googleMapController = useState&lt;GoogleMapController?&gt;(null);
    final currentLocationState = ref.watch(currentLocationNotifierProvider);
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    useEffect(
      () {
        Future.microtask(() async {
          try {
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            await ref
                .read(getItemBoxListNotifierProvider.notifier)
                .getItemBoxList();

            final myAccount = await ref
                .read(getMyAccountNotifierProvider.notifier)
                .getMyAccount();
            final myGuildId = myAccount.guildId;

            if (myGuildId != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildId);
            }
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«æˆ»ã£ã¦ããŸã‚‰ä½ç½®æƒ…å ±ã‚’å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
            ),
            // TODO: [åœ°å›³] ä»®ç½®ãã®ãƒœã‚¿ãƒ³é…ç½®
            Center(
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Spacer(),
                  FloatingActionButton(
                    heroTag: 'ShowShootableSpotDetailButton',
                    onPressed: () {
                      ref
                          .read(
                            showShootableSpotDetailNotifierProvider.notifier,
                          )
                          .show('TODO: SpotId ã‚’è¨­å®šã™ã‚‹');
                    },
                    child: const Icon(Icons.camera_alt),
                  ),
                  const Spacer(),
                  FloatingActionButton(
                    heroTag: 'ShowOurSpotDetailButton',
                    onPressed: () {
                      ref
                          .read(showOurSpotDetailNotifierProvider.notifier)
                          .show('TODO: SpotId ã‚’è¨­å®šã™ã‚‹');
                    },
                    child: const Icon(Icons.flag),
                  ),
                  const Spacer(),
                ],
              ),
            ),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation = await ref
                          .read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref
                          .read(showExplorerListNotifierProvider.notifier)
                          .show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () =&gt; const Center(child: CircularProgressIndicator()),
        error: (error, stack) =&gt; Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('è¨­å®šã‚¢ãƒ—ãƒªã‹ã‚‰ä½ç½®æƒ…å ±å–å¾—ã‚’ONã«ã—ã¦ãã ã•ã„'),
          ),
        ),
      ),
    );
  }
}

// ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–ã™ã‚‹ã‚¯ãƒ©ã‚¹
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}



import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';

part 'get_guild_spot_list.g.dart';

@Riverpod(keepAlive: true)
class GetGuildSpotListNotifier extends _$GetGuildSpotListNotifier {
  @override
  Future&lt;List&lt;GuildSpotDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;void&gt; getGuildSpotList(String guildId) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildsApiProvider.future);
      final response = await api.guildControllerGetGuildSpots(guildId: guildId);
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      state = AsyncValue.data(response.data?.data);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';

part 'get_item_box_list.g.dart';

@Riverpod(keepAlive: true)
class GetItemBoxListNotifier extends _$GetItemBoxListNotifier {
  @override
  Future&lt;List&lt;ItemBoxDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;void&gt; getItemBoxList() async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(itemBoxesApiProvider.future);
      final response = await api.itemBoxControllerGetItemBoxes();
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      state = AsyncValue.data(response.data?.data);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

import 'package:flutter/foundation.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';

part 'open_item_box.g.dart';

@riverpod
class OpenItemBoxNotifier extends _$OpenItemBoxNotifier {
  @override
  Future&lt;List&lt;ItemDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;List&lt;ItemDTO&gt;&gt; openItemBox(
    String itemBoxId,
    LatLng location,
  ) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(itemBoxesApiProvider.future);
      final response = await api.itemBoxControllerOpenBox(
        OpenBoxRequestDTO(
          itemBoxId: itemBoxId,
          userLatitute: location.latitude,
          userLongitude: location.longitude,
        ),
      );
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      final data = response.data?.data;
      if (data == null) {
        throw Exception('No data found');
      }
      state = AsyncValue.data(data);
      return data;
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
      rethrow;
    }
  }
}

import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'show_shootable_spot_detail.g.dart';

@riverpod
class ShowShootableSpotDetailNotifier
    extends _$ShowShootableSpotDetailNotifier {
  @override
  String? build() =&gt; null;

  void show(String spotId) {
    debugPrint('spotId: $spotId');
    state = spotId;
  }

  void hide() =&gt; state = null;
}

import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'show_our_spot_detail.g.dart';

@riverpod
class ShowOurSpotDetailNotifier extends _$ShowOurSpotDetailNotifier {
  @override
  String? build() =&gt; null;

  void show(String spotId) {
    debugPrint('spotId: $spotId');
    state = spotId;
  }

  void hide() =&gt; state = null;
}



@freezed
class ItemBoxDTO with _$ItemBoxDTO {
  factory ItemBoxDTO({
    @JsonKey(name: 'itemBoxId') required String? itemBoxId,
    @JsonKey(name: 'itemBoxName') required String? itemBoxName,
    @JsonKey(name: 'itemBoxDescription') String? itemBoxDescription,
    @JsonKey(name: 'itemName') String? itemName,
    @JsonKey(name: 'itemCategory') ItemBoxDTOItemCategory? itemCategory,
    @JsonKey(name: 'itemBoxStatus')
    required ItemBoxDTOItemBoxStatus? itemBoxStatus,
    @JsonKey(name: 'itemBoxLatitude') required num? itemBoxLatitude,
    @JsonKey(name: 'itemBoxLongitude') required num? itemBoxLongitude,
  }) = _ItemBoxDTO;

  factory ItemBoxDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$ItemBoxDTOFromJson(jsonMap);
}


@freezed
class GuildSpotDTO with _$GuildSpotDTO {
  factory GuildSpotDTO({
    @JsonKey(name: 'spotId') required String? spotId,
    @JsonKey(name: 'guildId') String? guildId,
    @JsonKey(name: 'spotName') required String? spotName,
    @JsonKey(name: 'spotStatus') required GuildSpotDTOSpotStatus? spotStatus,
    @JsonKey(name: 'rarity') required GuildSpotDTORarity? rarity,
    @JsonKey(name: 'photoUrl') required String? photoUrl,
    @JsonKey(name: 'spotLongitude') required num? spotLongitude,
    @JsonKey(name: 'spotLatitude') required num? spotLatitude,
    @JsonKey(name: 'spotAddress') required String? spotAddress,
    @JsonKey(name: 'guildSpotStatus')
    required GuildSpotDTOGuildSpotStatus? guildSpotStatus,
  }) = _GuildSpotDTO;

  factory GuildSpotDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$GuildSpotDTOFromJson(jsonMap);
}

@freezed
class ItemDTO with _$ItemDTO {
  factory ItemDTO({
    @JsonKey(name: 'itemId') required String? itemId,
    @JsonKey(name: 'itemName') required String? itemName,
    @JsonKey(name: 'itemDescription') String? itemDescription,
    @JsonKey(name: 'itemPrice') required num? itemPrice,
    @JsonKey(name: 'itemStatus') required ItemDTOItemStatus? itemStatus,
    @JsonKey(name: 'itemCategory') required ItemDTOItemCategory? itemCategory,
  }) = _ItemDTO;

  factory ItemDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$ItemDTOFromJson(jsonMap);
}

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/01/17 18:57:03*

**Setting up markers**

Iâ€™m thinking through the user's requirements, including placing itemBox and spot markers, adjusting icons and colors, and managing taps for different interactions.

**Crafting markers**

Iâ€™m working through displaying itemBox and guild spot markers on a map, noting icon customization, tap actions, and managing markers in a Set for GoogleMap interaction.

**Mapping markers**

Setting up markers involves parsing guild spots and item boxes, converting coordinates, and storing them in a Set for GoogleMap. Progress is steady and methodical.

**Placing markers**

Assigning guild spot markers their icons, adding itemBox markers with icons and tap actions, and using BitmapDescriptor for custom icons before passing them to GoogleMap.

**Refining placeholder icons**

Iâ€™m finalizing placeholder icons for photoUrl, setting up a useState for itemBoxes, and incorporating itemBox interaction logic. This approach keeps the code self-contained and focused.

**Refining the dialog box**

Iâ€™m adding item names and icons to the dialog box with a cancel button. Removing specific floating action buttons and managing `myGuildId` in state are also planned.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/01/17 18:57:03*

ä»¥ä¸‹ã¯ `MapPage` ã®ä¸€ä¾‹ã§ã™ã€‚  
- `myGuildId` ã‚’ `useEffect` ã®å¤–ã«æŒã¡å‡ºã—ã€`useState` ã§ä¿æŒã—ã¦ã„ã¾ã™ã€‚  
- `myGuildSpotListState` ã¨ `itemBoxListState` ã‚’ã‚‚ã¨ã« `Marker` ã‚’ç”Ÿæˆã—ã€`GoogleMap` ã® `markers` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«æ¸¡ã—ã¦ã„ã¾ã™ã€‚  
- Spot ã®ãƒ”ãƒ³ã¯ã‚®ãƒ«ãƒ‰ID ã®æœ‰ç„¡ãƒ»ä¸€è‡´çŠ¶æ³ã§ã‚¢ã‚¤ã‚³ãƒ³è‰²ã‚’åˆ‡ã‚Šæ›¿ãˆã€ã‚¿ãƒƒãƒ—æ™‚ã®å‡¦ç†ã¯ `showShootableSpotDetailNotifier` / `showOurSpotDetailNotifier` ã«æŠ•ã’ã¦ã„ã¾ã™ã€‚  
- ItemBox ã®ãƒ”ãƒ³ã¯å®ç®±ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆã“ã“ã§ã¯ä¾¿å®œçš„ã« `Icons.card_giftcard`ï¼‰ã‚’ä½¿ã„ã€ã‚¿ãƒƒãƒ—æ™‚ã« `openItemBox()` â†’ æˆåŠŸãªã‚‰ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã€å¤±æ•—ãªã‚‰ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚  
- ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã¯ç°¡æ˜“ãªå®Ÿè£…ä¾‹ã§ã™ã®ã§ã€å¿…è¦ã«å¿œã˜ã¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚„ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’èª¿æ•´ã—ã¦ãã ã•ã„ã€‚  

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController ã‚’ä¿æŒ
    final googleMapController = useState<GoogleMapController?>(null);

    // ç¾åœ¨ä½ç½®
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // å–å¾—ã—ãŸ Spot ä¸€è¦§
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);

    // å–å¾—ã—ãŸ ItemBox ä¸€è¦§
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ID ã‚’ä¿æŒ
    final myGuildIdState = useState<String?>(null);

    useEffect(
      () {
        Future.microtask(() async {
          try {
            // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰æƒ…å ±
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

            // ItemBox ä¸€è¦§
            await ref.read(getItemBoxListNotifierProvider.notifier).getItemBoxList();

            // è‡ªåˆ†ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±ã‹ã‚‰ã‚®ãƒ«ãƒ‰ID ã‚’å–å¾—
            final myAccount = await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            // ã‚®ãƒ«ãƒ‰ãŒã‚ã‚Œã° Spot ã‚’å–å¾—
            if (myGuildIdState.value != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«æˆ»ã£ã¦ããŸã‚‰ä½ç½®æƒ…å ±ã‚’å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    // ãƒãƒ¼ã‚«ãƒ¼ã‚’ã¾ã¨ã‚ã‚‹
    final Set<Marker> markers = {};

    // Spot ã®ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ
    final guildSpots = myGuildSpotListState.asData?.value ?? [];
    final myGuildId = myGuildIdState.value;
    for (final spot in guildSpots) {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';

      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ã‚«ãƒ¼è‰²
      BitmapDescriptor icon;
      void Function()? onTap;

      if (spot.guildId == null) {
        // ã‚®ãƒ«ãƒ‰ID ãŒ null â†’ photoUrl ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’â€¦ ã“ã“ã§ã¯æš«å®šçš„ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ã‚«ãƒ¼ã‚’ç”¨ã„ã‚‹
        icon = BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueAzure);
        // ã‚¿ãƒƒãƒ— â†’ æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
        onTap = () {
          ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        };
      } else if (spot.guildId != myGuildId) {
        // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ã§ãªã„ â†’ èµ¤ã„ãƒ•ãƒ©ãƒƒã‚°
        icon = BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueRed);
        // ã‚¿ãƒƒãƒ— â†’ æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
        onTap = () {
          ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        };
      } else {
        // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ â†’ ç·‘ã®ãƒ•ãƒ©ãƒƒã‚°
        icon = BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueGreen);
        // ã‚¿ãƒƒãƒ— â†’ è‡ªåˆ†ã®ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
        onTap = () {
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);
        };
      }

      markers.add(
        Marker(
          markerId: MarkerId('spot_$spotId'),
          position: LatLng(lat, lng),
          icon: icon,
          onTap: onTap,
        ),
      );
    }

    // ItemBox ã®ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ
    final itemBoxes = itemBoxListState.asData?.value ?? [];
    for (final itemBox in itemBoxes) {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';

      markers.add(
        Marker(
          markerId: MarkerId('itemBox_$itemBoxId'),
          position: LatLng(lat, lng),
          // ã‚¢ã‚¤ã‚³ãƒ³ã¯å®ç®±ã‚¢ã‚¤ã‚³ãƒ³ã‚’ç°¡æ˜“çš„ã«è¡¨ç¾(ã‚®ãƒ•ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã‚’ä½¿ç”¨)
          icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueOrange),
          onTap: () async {
            // ItemBox ã‚’é–‹ã‘ã‚‹ãƒ­ã‚¸ãƒƒã‚¯
            // ä½ç½®æƒ…å ±ãŒå–ã‚Œã¦ã„ã‚‹å‰æã§ currentLocationState ã‚’ä½¿ã†
            final userLocation = currentLocationState.asData?.value;
            if (userLocation == null) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('ç¾åœ¨åœ°ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ')),
              );
              return;
            }

            try {
              final items = await ref
                  .read(openItemBoxNotifierProvider.notifier)
                  .openItemBox(itemBoxId, userLocation);

              // æˆåŠŸ â†’ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ã‚¢ã‚¤ãƒ†ãƒ ä¸€è¦§ã‚’è¡¨ç¤º
              if (context.mounted) {
                showDialog(
                  context: context,
                  barrierDismissible: false,
                  builder: (ctx) {
                    return Dialog(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Text('å–å¾—ã—ãŸã‚¢ã‚¤ãƒ†ãƒ '),
                            const SizedBox(height: 16),
                            for (final item in items)
                              Text(item.itemName ?? 'No Name'),
                            const SizedBox(height: 16),
                            IconButton(
                              onPressed: () => Navigator.pop(ctx),
                              icon: const Icon(Icons.cancel),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                );
              }
            } catch (e) {
              // å¤±æ•— â†’ ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('å®ç®±ã‚’é–‹ã‘ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸ: $e')),
              );
            }
          },
        ),
      );
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers,
            ),
            // ---- ã“ã“ã‹ã‚‰ä¸‹ã¯ä»–ã®ãƒœã‚¿ãƒ³é¡ï¼ˆCurrentLocationButton / Explore / SpotListï¼‰ ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore ãƒªã‚¹ãƒˆè¡¨ç¤ºãƒœã‚¿ãƒ³
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot ãƒªã‚¹ãƒˆè¡¨ç¤ºãƒœã‚¿ãƒ³
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('è¨­å®šã‚¢ãƒ—ãƒªã‹ã‚‰ä½ç½®æƒ…å ±å–å¾—ã‚’ONã«ã—ã¦ãã ã•ã„'),
          ),
        ),
      ),
    );
  }
}

// ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–ã™ã‚‹ã‚¯ãƒ©ã‚¹
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

### è£œè¶³

- **ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã‚¢ã‚¤ã‚³ãƒ³ã‚’ãƒãƒƒãƒ—ã«è¡¨ç¤ºã—ãŸã„å ´åˆ**  
  Flutter/`google_maps_flutter` ã§ã¯ã€ `BitmapDescriptor.fromAssetImage()` ã‚„ `BitmapDescriptor.fromBytes()` ã‚’ä½¿ã£ã¦ç‹¬è‡ªã‚¢ã‚¤ã‚³ãƒ³ã‚’è¨­å®šã§ãã¾ã™ã€‚  
  ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€ã„ã£ãŸã‚“ `Image` ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ã‹ã‚‰ `ByteData` ã«å¤‰æ›ã—ã€ `fromBytes` ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ã‚„ã‚„æ‰‹é–“ãŒå¢—ãˆã¾ã™ã€‚ã¾ãšã¯ä¸Šè¨˜ã®ã‚ˆã†ã«å˜ç´”ã« `BitmapDescriptor.defaultMarkerWithHue(...)` ã‚’ä½¿ã£ãŸã‚Šã€ã‚¢ã‚»ãƒƒãƒˆç”»åƒã‚’ä½¿ã†ã®ãŒãŠã™ã™ã‚ã§ã™ã€‚

- **ã‚¿ãƒƒãƒ—å¾Œã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°**  
  ç¾åœ¨ã¯ç°¡æ˜“ãªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚ãƒ‡ã‚¶ã‚¤ãƒ³ã‚„è¡¨ç¤ºå†…å®¹ã¯ãŠå¥½ã¿ã§èª¿æ•´ã—ã¦ãã ã•ã„ã€‚  
  ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®å¤–ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é–‰ã˜ãŸã„å ´åˆãªã©ã¯ã€ `barrierDismissible: true` ã«ã™ã‚‹ãªã©ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå¯èƒ½ã§ã™ã€‚  

- **`myGuildId` ã®å–ã‚Šå›ã—**  
  ä»Šå›ã¯ `useState` ã§ `myGuildId` ã‚’ä¿æŒã—ã¦ã„ã¾ã™ãŒã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãª `Provider` ã¨ã—ã¦ç®¡ç†ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/01/17 19:15:15*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-3hypojgZjNbjadybivK5kS",
  "size_bytes": 423771,
  "width": 461,
  "height": 673,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
ã‚ã‚ŠãŒã¨ã†ã€‚å‡¦ç†ã¯åˆã£ã¦ã„ã‚‹ã€‚
ãƒãƒ¼ã‚«ãƒ¼ã‚’å¤‰æ›´ã—ãŸã„ã€‚
ãƒãƒ¼ã‚«ãƒ¼ã¯è‡ªä½œã«ã—ãŸã„ã‚“ã ã€‚

ã“ã®ç”»åƒã¯ã‚µãƒ³ãƒ—ãƒ«ã§ã‚ã‚‹ãŒ3ç¨®é¡ã®ãƒãƒ¼ã‚«ãƒ¼ã§ã‚ã‚‹ã€‚
ãã‚Œãã‚Œã¯ä»¥ä¸‹ã§ã‚ã‚‹ã€‚

- å³ä¸Š: ã€Œè‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ â†’ ç·‘ã®ãƒ•ãƒ©ãƒƒã‚°ã€ã‚’ä¸¸ã§è¡¨ç¾
- ä¸­å¤®å·¦: ã‚®ãƒ«ãƒ‰ID ãŒ null â†’ photoUrl ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’
- å·¦ä¸‹: ã‚¢ã‚¤ã‚³ãƒ³ã¯å®ç®±ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’

è¶³ã‚Šãªã„ã‚‚ã®ã¨ã—ã¦ã€è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ã§ãªã„ â†’ èµ¤ã„ãƒ•ãƒ©ãƒƒã‚°ã‚’ä¸¸ã§è¡¨ç¾ã—ã¦ã»ã—ã„ã€‚

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/01/17 19:18:10*

ä¸‹è¨˜ã¯ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ã®ä¸€ä¾‹ã§ã™ã€‚  
- **ã€Œè‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ â†’ ç·‘ã®ãƒ•ãƒ©ãƒƒã‚°ã€ã‚’ä¸¸ã‚¢ã‚¤ã‚³ãƒ³**  
- **ã€Œä»–ã®ã‚®ãƒ«ãƒ‰ â†’ èµ¤ã„ãƒ•ãƒ©ãƒƒã‚°ã€ã‚’ä¸¸ã‚¢ã‚¤ã‚³ãƒ³**  
- **ã€Œã‚®ãƒ«ãƒ‰ID ãŒ null â†’ photoUrl ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’**  
- **ã€Œã‚¢ã‚¤ãƒ†ãƒ ãƒœãƒƒã‚¯ã‚¹ â†’ å®ç®±ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’ã€**  

ãã‚Œãã‚Œç”»åƒãƒ•ã‚¡ã‚¤ãƒ«(`.png`ãªã©)ã‚’ç”¨æ„ã™ã‚‹å‰æã§ã€`assets/`é…ä¸‹ã«æ ¼ç´ã—ã¦ã„ã‚‹ä¾‹ã‚’ç¤ºã—ã¾ã™ï¼ˆå®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãƒ»ãƒ•ã‚¡ã‚¤ãƒ«åãƒ»ãƒ‡ã‚¶ã‚¤ãƒ³ã¯ã”è‡ªç”±ã«å¤‰æ›´ã—ã¦ãã ã•ã„ï¼‰ã€‚  
ãªãŠã€**ã€ŒphotoUrl ã‚’å››è§’ã«ã—ãŸã„ã€**ã¨ã„ã†å ´åˆã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã®ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ `BitmapDescriptor` ã«å¤‰æ›ã™ã‚‹å‡¦ç†ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚ã‚µãƒ³ãƒ—ãƒ«ã§ã¯ç°¡æ˜“çš„ã« `NetworkImage` ã‚’ä½¿ã„ `image.toByteData()` ã§ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿åŒ–ã—ã¦ã„ã‚‹éƒ¨åˆ†ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚  

---

## ãƒã‚¤ãƒ³ãƒˆã¾ã¨ã‚

1. **Marker ç”¨ã® `BitmapDescriptor` ã‚’äº‹å‰ã«ç”¨æ„ã™ã‚‹**  
   - ä»Šå›ã¯ `greenCircle.png` / `redCircle.png` / `treasureBox.png` ãªã©ã®ã‚¢ã‚»ãƒƒãƒˆç”»åƒã‚’ç”¨æ„ã—ã€`BitmapDescriptor.fromAssetImage` ã§èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™ã€‚  
2. **`photoUrl` ã‚’ä½¿ã£ãŸå››è§’ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤ºã—ãŸã„å ´åˆ**  
   - ä¸€åº¦ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ã€`ui.instantiateImageCodec` â†’ `toByteData()` ãªã©ã§ `BitmapDescriptor.fromBytes` ã‚’ç”Ÿæˆã—ã¾ã™ã€‚  
3. **`useEffect` ã‚„ `FutureBuilder` ãªã©ã‚’æ´»ç”¨ã—ã¦éåŒæœŸçš„ã«ã‚¢ã‚¤ã‚³ãƒ³ã‚’èª­ã¿è¾¼ã¿ã€`useState` ãªã©ã§ä¿æŒã—ã¦ãŠã**  
   - ãƒãƒ¼ã‚«ãƒ¼æç”»æ™‚ã«ãã‚Œã‚‰ã‚’ä»£å…¥ã™ã‚‹ã“ã¨ã§ã€åœ°å›³ã«åæ˜ ã•ã›ã¾ã™ã€‚  

---

ä»¥ä¸‹ã« `MapPage` ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¾ã™ã€‚  
å®Ÿéš›ã«ã¯ç”»åƒã‚¢ã‚»ãƒƒãƒˆã‚„ UI ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«åˆã‚ã›ã¦èª¿æ•´ã—ã¦ãã ã•ã„ã€‚

```dart
import 'dart:typed_data';
import 'dart:ui' as ui; // â˜… NetworkImage â†’ image.toByteData() ã§ä½¿ç”¨

import 'package:flutter/material.dart';
import 'package:flutter/hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

// â˜… ã“ã“ã§ã€ã‚¢ã‚»ãƒƒãƒˆã‹ã‚‰ BitmapDescriptor ã‚’ä½œã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’ç”¨æ„
Future<BitmapDescriptor> bitmapDescriptorFromAsset(
  String assetName, {
  int width = 64,
  int height = 64,
}) async {
  // ç”»åƒã‚’èª­ã¿è¾¼ã¿
  final ImageConfiguration config = ImageConfiguration(
    size: Size(width.toDouble(), height.toDouble()),
  );
  return BitmapDescriptor.fromAssetImage(config, assetName);
}

// â˜… ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒã‹ã‚‰å››è§’ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä½œã‚‹ã‚µãƒ³ãƒ—ãƒ«
Future<BitmapDescriptor> bitmapDescriptorFromNetworkImage(
  String imageUrl, {
  int width = 100,
  int height = 100,
}) async {
  final ImageStream stream = NetworkImage(imageUrl).resolve(const ImageConfiguration());
  final Completer<ui.Image> completer = Completer<ui.Image>();
  late ImageStreamListener listener;

  listener = ImageStreamListener((ImageInfo frame, bool sync) {
    completer.complete(frame.image);
    stream.removeListener(listener);
  }, onError: (dynamic error, StackTrace? stackTrace) {
    completer.completeError(error, stackTrace);
    stream.removeListener(listener);
  });

  stream.addListener(listener);

  final ui.Image image = await completer.future;

  // â˜… ã“ã“ã§å››è§’å½¢ã«åˆ‡ã‚ŠæŠœããŸã„å ´åˆã¯ã€Canvas ã§æç”»æ™‚ã«å·¥å¤«ã™ã‚‹
  //   ä»Šã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ãã®ã¾ã¾ç”»åƒã‚’ ByteData åŒ–ã—ã¦ã„ã‚‹
  final ByteData? byteData = await image.toByteData(format: ui.ImageByteFormat.png);
  if (byteData == null) {
    throw Exception('Failed to convert network image to byte data.');
  }
  return BitmapDescriptor.fromBytes(byteData.buffer.asUint8List());
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController ã‚’ä¿æŒ
    final googleMapController = useState<GoogleMapController?>(null);

    // ç¾åœ¨ä½ç½®
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // Spot ä¸€è¦§
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);

    // ItemBox ä¸€è¦§
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ID ã‚’ä¿æŒ
    final myGuildIdState = useState<String?>(null);

    // â˜… ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä¿æŒã™ã‚‹ State
    final greenCircleIcon = useState<BitmapDescriptor?>(null);
    final redCircleIcon = useState<BitmapDescriptor?>(null);
    final treasureBoxIcon = useState<BitmapDescriptor?>(null);

    useEffect(
      () {
        // åˆæœŸãƒ­ãƒ¼ãƒ‰ & ã‚¢ã‚¤ã‚³ãƒ³æº–å‚™
        Future.microtask(() async {
          try {
            // ã‚¢ã‚¤ã‚³ãƒ³ã®èª­ã¿è¾¼ã¿ (ã‚¢ã‚»ãƒƒãƒˆæƒ³å®š)
            greenCircleIcon.value = await bitmapDescriptorFromAsset(
              'assets/images/green_circle.png', 
              width: 64, 
              height: 64,
            );
            redCircleIcon.value = await bitmapDescriptorFromAsset(
              'assets/images/red_circle.png',
              width: 64,
              height: 64,
            );
            treasureBoxIcon.value = await bitmapDescriptorFromAsset(
              'assets/images/treasure_box.png', // ä¾‹: å®ç®±ã‚¢ã‚¤ã‚³ãƒ³ç”»åƒ
              width: 72,
              height: 72,
            );

            // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰æƒ…å ±
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

            // ItemBox ä¸€è¦§
            await ref.read(getItemBoxListNotifierProvider.notifier).getItemBoxList();

            // è‡ªåˆ†ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±ã‹ã‚‰ã‚®ãƒ«ãƒ‰ID ã‚’å–å¾—
            final myAccount =
                await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            // ã‚®ãƒ«ãƒ‰ãŒã‚ã‚Œã° Spot ã‚’å–å¾—
            if (myGuildIdState.value != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«æˆ»ã£ã¦ããŸã‚‰ä½ç½®æƒ…å ±ã‚’å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    // ãƒãƒ¼ã‚«ãƒ¼ã‚’ã¾ã¨ã‚ã‚‹
    final Set<Marker> markers = {};

    // Spot ã®ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ
    final guildSpots = myGuildSpotListState.asData?.value ?? [];
    final myGuildId = myGuildIdState.value;

    for (final spot in guildSpots) {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';

      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ã‚«ãƒ¼
      BitmapDescriptor icon = BitmapDescriptor.defaultMarker;
      void Function()? onTap;

      if (spot.guildId == null) {
        // â†’ photoUrl ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’
        //   photoUrl ãŒæ­£ã—ãå–ã‚Œã‚‹å ´åˆã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒã¨ã—ã¦èª­ã¿è¾¼ã‚€
        if (spot.photoUrl != null && spot.photoUrl!.isNotEmpty) {
          // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒã‚’åŒæœŸçš„ã«ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨æ¯å› Future ãŒèµ°ã‚‹ã®ã§ã€
          // ã“ã“ã§ã¯ç°¡å˜ã«ã€ŒåŒæœŸçš„ã«ç”Ÿæˆã—ã¦ã—ã¾ã†ã€ä¾‹ã‚’ç¤ºã—ã¦ã„ã‚‹ãŒã€
          // å®Ÿéš›ã¯ Marker ã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹å‰ã«äº‹å‰ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãŸæ–¹ãŒè‰¯ã„
          // ï¼ˆå¤§é‡ã«ã‚ã‚‹ã¨æ¯å› Future ãŒèµ°ã£ã¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒè½ã¡ã‚‹ãŸã‚ï¼‰
          markers.add(
            Marker(
              markerId: MarkerId('spot_$spotId'),
              position: LatLng(lat, lng),
              onTap: () {
                // æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
                ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
              },
              icon: BitmapDescriptor.defaultMarker, // ä¸€æ—¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§å»ºã¦ã¦ãŠãã€
            ),
          );

          // éåŒæœŸã§æ›´æ–°ã—ã¦ã—ã¾ã†ä¾‹ (ã‚µãƒ³ãƒ—ãƒ«ã€‚å®Ÿé‹ç”¨ã§ã¯åŠ¹ç‡åŒ–ãŒå¿…è¦)
          (() async {
            final networkIcon =
                await bitmapDescriptorFromNetworkImage(spot.photoUrl!, width: 120, height: 120);
            googleMapController.value?.showMarkerInfoWindow(MarkerId('spot_$spotId'));
            // ãƒãƒ¼ã‚«ãƒ¼ã‚’å†ç”Ÿæˆã—ç›´ã™ã€ãªã©ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒã„ã‚‹
            // ãŸã ã€GoogleMap ã¯ Marker ã‚’ã€Œå†æç”»ã€ã§ããªã„ã®ã§ setState or Riverpod ã® state æ›´æ–°ãŒå¿…è¦ã€‚
            // ã“ã“ã§ã¯è©±ãŒè¤‡é›‘ã«ãªã‚‹ã®ã§å‰²æ„›
          })();

        } else {
          // photoUrl ãªã— â†’ ã¨ã‚Šã‚ãˆãšãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚¤ã‚³ãƒ³
          icon = BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueAzure);
        }

        onTap = () {
          ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        };
      } else if (spot.guildId != myGuildId) {
        // â†’ ä»–ã®ã‚®ãƒ«ãƒ‰ â†’ èµ¤ã„ãƒ•ãƒ©ãƒƒã‚°ã‚’ä¸¸ã§è¡¨ç¾
        icon = redCircleIcon.value ?? BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueRed);
        onTap = () {
          ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        };
      } else {
        // â†’ è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ â†’ ç·‘ã®ãƒ•ãƒ©ãƒƒã‚°ã‚’ä¸¸ã§è¡¨ç¾
        icon =
            greenCircleIcon.value ?? BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueGreen);
        onTap = () {
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);
        };
      }

      markers.add(
        Marker(
          markerId: MarkerId('spot_$spotId'),
          position: LatLng(lat, lng),
          icon: icon,
          onTap: onTap,
        ),
      );
    }

    // ItemBox ã®ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ
    final itemBoxes = itemBoxListState.asData?.value ?? [];
    for (final itemBox in itemBoxes) {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';

      markers.add(
        Marker(
          markerId: MarkerId('itemBox_$itemBoxId'),
          position: LatLng(lat, lng),
          // å®ç®±ã‚’å››è§’ã§è¡¨ç¾ (ã“ã“ã§ã¯ treasure_box.png)
          icon: treasureBoxIcon.value ??
              BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueOrange),
          onTap: () async {
            // ItemBox ã‚’é–‹ã‘ã‚‹ãƒ­ã‚¸ãƒƒã‚¯
            final userLocation = currentLocationState.asData?.value;
            if (userLocation == null) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('ç¾åœ¨åœ°ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ')),
              );
              return;
            }

            try {
              final items = await ref
                  .read(openItemBoxNotifierProvider.notifier)
                  .openItemBox(itemBoxId, userLocation);

              // æˆåŠŸ â†’ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ã‚¢ã‚¤ãƒ†ãƒ ä¸€è¦§ã‚’è¡¨ç¤º
              if (context.mounted) {
                showDialog(
                  context: context,
                  barrierDismissible: false,
                  builder: (ctx) {
                    return Dialog(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Text('å–å¾—ã—ãŸã‚¢ã‚¤ãƒ†ãƒ '),
                            const SizedBox(height: 16),
                            for (final item in items)
                              Text(item.itemName ?? 'No Name'),
                            const SizedBox(height: 16),
                            IconButton(
                              onPressed: () => Navigator.pop(ctx),
                              icon: const Icon(Icons.cancel),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                );
              }
            } catch (e) {
              // å¤±æ•— â†’ ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('å®ç®±ã‚’é–‹ã‘ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸ: $e')),
              );
            }
          },
        ),
      );
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers,
            ),
            // ---- ä¸‹éƒ¨ãƒœã‚¿ãƒ³é¡ ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore ãƒªã‚¹ãƒˆ
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot ãƒªã‚¹ãƒˆ
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('è¨­å®šã‚¢ãƒ—ãƒªã‹ã‚‰ä½ç½®æƒ…å ±å–å¾—ã‚’ONã«ã—ã¦ãã ã•ã„'),
          ),
        ),
      ),
    );
  }
}

// ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–ã™ã‚‹ã‚¯ãƒ©ã‚¹
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

---

### å®Ÿè£…ã®æµã‚Œ

1. **ä¸¸/å››è§’ã®ç”»åƒã‚’ç”¨æ„ã™ã‚‹**  
   - ä¾‹: `assets/images/green_circle.png`ã€`assets/images/red_circle.png`ã€`assets/images/treasure_box.png`  
2. **`pubspec.yaml` ã«ã‚¢ã‚»ãƒƒãƒˆãƒ‘ã‚¹ã‚’ç™»éŒ²**  
   ```yaml
   flutter:
     assets:
       - assets/images/green_circle.png
       - assets/images/red_circle.png
       - assets/images/treasure_box.png
   ```
3. **`useEffect` ã§ `BitmapDescriptor.fromAssetImage` ã‚’å‘¼ã³å‡ºã—ã€`useState`(Riverpodãªã‚‰`StateProvider`ç­‰) ã§ä¿æŒ**  
4. **`Marker` ç”Ÿæˆæ™‚ã« `icon: yourIconState.value ?? BitmapDescriptor.defaultMarker` ã‚’å‰²ã‚Šå½“ã¦**  
5. **`photoUrl` ãŒã‚ã‚‹å ´åˆã¯éåŒæœŸã§ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ `BitmapDescriptor.fromBytes` ã‚’ç”Ÿæˆ**  
   - å¤§é‡ã«ã‚ã‚‹å ´åˆã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ãŒå¿…é ˆã«ãªã‚‹ãŸã‚æ³¨æ„  

ã“ã†ã™ã‚‹ã“ã¨ã§ã€  
- è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰: ç·‘ä¸¸  
- ä»–ã®ã‚®ãƒ«ãƒ‰: èµ¤ä¸¸  
- ã‚®ãƒ«ãƒ‰ID nullï¼ˆphotoUrlã‚ã‚Šï¼‰: å››è§’å†™çœŸ  
- ã‚¢ã‚¤ãƒ†ãƒ ãƒœãƒƒã‚¯ã‚¹: å››è§’å®ç®±  
ã¨ã„ã£ãŸå½¢ã§æç”»ã§ãã¾ã™ã€‚  

&gt; **è£œè¶³**:  
&gt; Flutter / `google_maps_flutter` ã§ã¯ Marker ã‚’ã€Œå¾Œã‹ã‚‰å·®ã—æ›¿ãˆã€ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚„ã‚„åˆ¶ç´„ãŒã‚ã‚Šã€ `Set<Marker>` ã‚’å†æ§‹ç¯‰ã—ã¦ `setState`ï¼ˆ`HookConsumerWidget` ãªã‚‰ `ref.invalidate(...)` ç­‰ï¼‰ã§æ›´æ–°ãŒå¿…è¦ã§ã™ã€‚  
&gt; å¤§é‡ã® Spot / ItemBox ãŒã‚ã‚‹å ´åˆã€**å€‹åˆ¥ã«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¤ã‚³ãƒ³ã‚’ç”Ÿæˆâ†’Markerå†ç”Ÿæˆ** ã¨ã„ã†ãƒ•ãƒ­ãƒ¼ãŒãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çš„ã«å³ã—ããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã‚ã‚‰ã‹ã˜ã‚ã‚µãƒ ãƒã‚¤ãƒ«ã‚’ä½œã‚‹ / ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ã† ãªã©å·¥å¤«ã—ã¦ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/01/17 21:27:51*

widget_to_markerã‚’ä½¿ãˆã°widgetã‚’ãƒãƒ¼ã‚«ãƒ¼ã¨ã—ã¦è¨­å®šã§ããã†ã€‚
ã“ã‚Œã§4ç¨®é¡ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’widgetã§å®Ÿè£…ã—ã¦ã¿ã¦ãã‚Œãªã„ã‹ãªã€‚
è‡ªåˆ†ã®æ——ã€ç›¸æ‰‹ã®æ——ã€å®ç®±ã¯ãƒãƒ†ãƒªã‚¢ãƒ«ã‚¢ã‚¤ã‚³ãƒ³ã‚’è»¸ã«å®Ÿè£…ã—ã¦ã»ã—ã„ã€‚
ãã—ã¦ã€spot.guildId == null ãªãƒãƒ¼ã‚«ãƒ¼ã¯spot.photoUrlã‹ã‚‰ç”»åƒã‚’å–å¾—ã—ã¦ã»ã—ã„ã€‚

ã‚ã¨ã€if (spot.guildId == null) ã‚„ else if spot.guildId == myGuildId ãªã©ã¯å°‘ã—è¦‹é€šã—ãŒæ‚ªã„ã®ã§ã€enum ã§ SpotType ã‚’å®šç¾©ã—ã¦ã€åˆ¤å®šã—ã¦ã‹ã‚‰é©åˆ‡ã«å‡¦ç†ã—ã¦ã»ã—ã„ã€‚

ã•ã‚‰ã«ãƒãƒ¼ã‚«ãƒ¼ã‚’ã¾ã¨ã‚ãŸ MarkerType ã®enumã‚’å®šç¾©ã—ã¦è¨­å®šã—ã¦ã€ItemBox ã¨ Spot ã‚’æŒã£ã¦ã€Spotã¯ã•ã‚‰ã«SpotTypeã‚’æŒã¤ã‚ˆã†ãª å®šç¾©ã«ã—ã¦ã€å…¨ä½“ã®è¦‹é€šã—ã‚’ã‚ˆãã—ã¦ã»ã—ã„ã€‚

widget_to_markerã¯ä»¥ä¸‹ã§ã‚ã‚‹ã€‚

widget_to_marker: ^1.0.6
https://pub.dev/packages/widget_to_marker

READMEã‚’ã“ã“ã«æ·»ä»˜ã—ã¾ã™ã€‚


## Features
When using Google Maps, we always have a problem with adding a marker on the map, and the available tools were either drawing the marker through canvas path or using an image, but the problem is if we want to add words or data or add custom edit to this marker, but this package has solved the problem and now you can use any widget in flutter as a marker for google map !
using the .toBitmapDescriptor() function on the widget to use it as a marker icon!
# Getting started
## Add dependency

```dart
dependencies:
  widget_to_marker: ^1.0.6
```
##  1 - Create Your Widget To Make it as Marker:

```dart
import 'package:widget_to_marker/widget_to_marker.dart';

class TextOnImage extends StatelessWidget {
  const TextOnImage({
    super.key,
    required this.text,
  });
  final String text;
  @override
  Widget build(BuildContext context) {
    return Stack(
      alignment: Alignment.center,
      children: [
        Image(
          image: const AssetImage(
            "assets/marker.png",
          ),
          height: 150,
          width: 150,
        ),
        Text(
          text,
          style: TextStyle(color: Colors.black),
        )
      ],
    );
  }
}
```
##  2 - Add it to the marker with   `.toBitmapDescriptor()`:
```dart
Marker(
      markerId: const MarkerId("3"),
      position: const LatLng(30.01124477440843, 30.78459296375513),
      icon: await TextOnImage(
        text: "Hello World",
      ).toBitmapDescriptor(
         logicalSize: const Size(150, 150), imageSize: const Size(150, 150)
      ),
    )
```
## Note
 You Can Use waitToRender Attribute to set duration for rendering large network and asset images

## Enjoy!!

![image](https://user-images.githubusercontent.com/88829064/210017494-ef63d4a2-fdec-46d9-b2a2-4f0451932e01.png)

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/01/17 21:28:55*

ä¸‹è¨˜ã¯ `widget_to_marker` ã‚’ä½¿ã£ãŸã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ä¾‹ã§ã™ã€‚  
- **MarkerType** ã¨ **SpotType** ã®2ç¨®é¡ã® enum ã‚’å®šç¾©ã—ã€  
  - **MarkerType**: `spot` / `itemBox`  
  - **SpotType**: `noneGuild` / `myGuild` / `otherGuild`  
- **MarkerData** ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã€`Spot` ãªã®ã‹ `ItemBox` ãªã®ã‹ã‚’ã²ã¨ã¾ã¨ã‚ã«æ‰±ã„ã¤ã¤ã€Spot ã®å ´åˆã¯ã•ã‚‰ã« SpotType ã‚’ã‚‚ãŸã›ã¦ã„ã¾ã™ã€‚  
- `widget_to_marker` ã® `.toBitmapDescriptor(...)` ã‚’æ´»ç”¨ã—ã¦ã€**Widget ã§ãƒãƒ¼ã‚«ãƒ¼ã‚’ãƒ‡ã‚¶ã‚¤ãƒ³** ã—ã¦ã„ã¾ã™ã€‚  
- **ã‚®ãƒ«ãƒ‰IDãŒ null (`SpotType.noneGuild`) â†’ `photoUrl` ã‚’è¡¨ç¤ºã—ãŸå››è§’ã®ç”»åƒ**  
- **è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ (`SpotType.myGuild`) â†’ ç·‘æ——ï¼ˆMaterial Iconï¼‰**  
- **ä»–ã®ã‚®ãƒ«ãƒ‰ (`SpotType.otherGuild`) â†’ èµ¤æ——ï¼ˆMaterial Iconï¼‰**  
- **ã‚¢ã‚¤ãƒ†ãƒ ãƒœãƒƒã‚¯ã‚¹ (`MarkerType.itemBox`) â†’ å®ç®±ï¼ˆMaterial Iconï¼‰**  

&gt; **ãƒã‚¤ãƒ³ãƒˆ**:  
&gt; - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒã®å ´åˆã¯èª­ã¿è¾¼ã¿ã«æ™‚é–“ãŒã‹ã‹ã‚‹ãŸã‚ã€`waitToRender: const Duration(seconds: 1)` ãªã©ã‚’æŒ‡å®šã—ãªã„ã¨ã€ã‚¢ã‚¤ã‚³ãƒ³ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã„ï¼ˆçœŸã£ç™½ã«ãªã‚‹ï¼‰å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã‚µãƒ³ãƒ—ãƒ«ã§ã¯ `waitToRender` ã‚’æŒ‡å®šã—ã¦ã„ã¾ã™ã€‚  
&gt; - å®Ÿéš›ã«ã¯ã€ãŸãã•ã‚“ã®ãƒ”ãƒ³ã‚’ä¸€åº¦ã«ç”Ÿæˆã™ã‚‹ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å½±éŸ¿ãŒå‡ºã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚  
&gt; - `WidgetToMarker` ã¯å„ãƒãƒ¼ã‚«ãƒ¼ã”ã¨ã« `Future` ã‚’ä¼´ã†ãŸã‚ã€Marker ã®å†ç”Ÿæˆã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒè¤‡é›‘ã«ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚å¿…è¦ã«å¿œã˜ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚„ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰å‡¦ç†ã‚’å…¥ã‚Œã‚‹ã¨ã‚ˆã„ã§ã—ã‚‡ã†ã€‚

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';

// ----- enum å®šç¾© -----

/// Spot ãŒã©ã®çŠ¶æ…‹ã‹ã‚’ç¤ºã™
enum SpotType {
  noneGuild, // guildId == null
  myGuild,   // guildId == myGuildId
  otherGuild // guildId != myGuildId
}

/// ãƒãƒ¼ã‚«ãƒ¼ãŒ Spot ã‹ ItemBox ã‹ã‚’è¡¨ã™
enum MarkerType {
  spot,
  itemBox,
}

// ----- MarkerData å®šç¾© -----
// Spot ã¾ãŸã¯ ItemBox ã®ã„ãšã‚Œã‹ã‚’ä¿æŒã—ã€Spot ã®å ´åˆã¯ SpotType ã‚‚ä¿æŒ
class MarkerData {
  final MarkerType markerType;
  final SpotType? spotType;
  final GuildSpotDTO? spot;
  final ItemBoxDTO? itemBox;

  MarkerData({
    required this.markerType,
    this.spotType,
    this.spot,
    this.itemBox,
  });
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController ã‚’ä¿æŒ
    final googleMapController = useState<GoogleMapController?>(null);

    // ç¾åœ¨ä½ç½®
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // Spot ä¸€è¦§
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);

    // ItemBox ä¸€è¦§
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ID ã‚’ä¿æŒ
    final myGuildIdState = useState<String?>(null);

    // Map ã¸è¨­ç½®ã™ã‚‹ Marker ã‚’ä¿æŒ
    final markers = useState<Set<Marker>>({});

    // ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆä¸­ãƒ•ãƒ©ã‚°ï¼ˆloading è¡¨ç¤ºãªã©ã‚’ã—ãŸã„å ´åˆã«ä½¿ã†ï¼‰
    final isMarkersBuilding = useState<bool>(false);

    // ãƒãƒ¼ã‚«ãƒ¼ã‚’ç”Ÿæˆã—ã¦ Set<Marker> ã‚’è¿”ã™é–¢æ•°
    Future<Set<Marker>> buildMarkers({
      required List<GuildSpotDTO> spots,
      required List<ItemBoxDTO> itemBoxes,
      required String? myGuildId,
    }) async {
      final markerSet = <Marker>{};

      // ---- Spot ã‚’ MarkerData ã«ã¾ã¨ã‚ã‚‹ ----
      final spotMarkerDataList = spots.map((spot) {
        SpotType spotType;
        if (spot.guildId == null) {
          spotType = SpotType.noneGuild;
        } else if (spot.guildId == myGuildId) {
          spotType = SpotType.myGuild;
        } else {
          spotType = SpotType.otherGuild;
        }
        return MarkerData(
          markerType: MarkerType.spot,
          spotType: spotType,
          spot: spot,
        );
      }).toList();

      // ---- ItemBox ã‚’ MarkerData ã«ã¾ã¨ã‚ã‚‹ ----
      final itemBoxMarkerDataList = itemBoxes.map((iBox) {
        return MarkerData(
          markerType: MarkerType.itemBox,
          itemBox: iBox,
        );
      }).toList();

      // å…¨éƒ¨ã¾ã¨ã‚ã‚‹
      final allMarkersData = [
        ...spotMarkerDataList,
        ...itemBoxMarkerDataList,
      ];

      // MarkerData ã‚’1ã¤ãšã¤å‡¦ç†ã—ã€Marker ã‚’ç”Ÿæˆ
      for (final data in allMarkersData) {
        // ç·¯åº¦çµŒåº¦ã‚’å–å¾—
        double lat = 0;
        double lng = 0;
        String markerId = '';

        if (data.markerType == MarkerType.spot && data.spot != null) {
          lat = data.spot!.spotLatitude?.toDouble() ?? 0;
          lng = data.spot!.spotLongitude?.toDouble() ?? 0;
          markerId = 'spot_${data.spot!.spotId ?? ''}';
        } else if (data.markerType == MarkerType.itemBox && data.itemBox != null) {
          lat = data.itemBox!.itemBoxLatitude?.toDouble() ?? 0;
          lng = data.itemBox!.itemBoxLongitude?.toDouble() ?? 0;
          markerId = 'itemBox_${data.itemBox!.itemBoxId ?? ''}';
        }

        // ä½œã‚ŠãŸã„ Widget
        final markerWidget = _buildMarkerWidget(data);

        // Widget ã‹ã‚‰ BitmapDescriptor ã¸å¤‰æ›
        final iconDescriptor = await markerWidget.toBitmapDescriptor(
          // è¡¨ç¤ºã‚µã‚¤ã‚º
          logicalSize: const Size(80, 80),
          imageSize: const Size(80, 80),
          // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒèª­ã¿è¾¼ã¿ã‚’å¾…ã¤ãŸã‚ã« waitToRender ã‚’è¨­å®š
          waitToRender: const Duration(milliseconds: 600),
        );

        // Marker ã‚’çµ„ã¿ç«‹ã¦ã‚‹
        markerSet.add(
          Marker(
            markerId: MarkerId(markerId),
            position: LatLng(lat, lng),
            icon: iconDescriptor,
            onTap: () async {
              // ã‚¿ãƒƒãƒ—æ™‚ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
              if (data.markerType == MarkerType.spot && data.spot != null) {
                // Spot ã®å‡¦ç†
                switch (data.spotType) {
                  case SpotType.noneGuild:
                    // æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆè©³ç´°
                    ref
                        .read(showShootableSpotDetailNotifierProvider.notifier)
                        .show(data.spot!.spotId ?? '');
                    break;
                  case SpotType.myGuild:
                    // è‡ªåˆ†ã®ã‚¹ãƒãƒƒãƒˆè©³ç´°
                    ref
                        .read(showOurSpotDetailNotifierProvider.notifier)
                        .show(data.spot!.spotId ?? '');
                    break;
                  case SpotType.otherGuild:
                    // æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆè©³ç´°
                    ref
                        .read(showShootableSpotDetailNotifierProvider.notifier)
                        .show(data.spot!.spotId ?? '');
                    break;
                }
              } else if (data.markerType == MarkerType.itemBox && data.itemBox != null) {
                // ItemBox ã®å‡¦ç†
                final userLocation = currentLocationState.asData?.value;
                if (userLocation == null) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('ç¾åœ¨åœ°ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ')),
                  );
                  return;
                }
                try {
                  final items = await ref
                      .read(openItemBoxNotifierProvider.notifier)
                      .openItemBox(data.itemBox!.itemBoxId ?? '', userLocation);

                  // æˆåŠŸ â†’ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
                  if (context.mounted) {
                    showDialog(
                      context: context,
                      barrierDismissible: false,
                      builder: (ctx) {
                        return Dialog(
                          child: Padding(
                            padding: const EdgeInsets.all(16),
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                const Text('å–å¾—ã—ãŸã‚¢ã‚¤ãƒ†ãƒ '),
                                const SizedBox(height: 16),
                                for (final item in items)
                                  Text(item.itemName ?? 'No Name'),
                                const SizedBox(height: 16),
                                IconButton(
                                  onPressed: () => Navigator.pop(ctx),
                                  icon: const Icon(Icons.cancel),
                                ),
                              ],
                            ),
                          ),
                        );
                      },
                    );
                  }
                } catch (e) {
                  // å¤±æ•— â†’ ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼è¡¨ç¤º
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('å®ç®±ã‚’é–‹ã‘ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸ: $e')),
                  );
                }
              }
            },
          ),
        );
      }

      return markerSet;
    }

    // useEffect ã§åˆå›ãƒ­ãƒ¼ãƒ‰å‡¦ç†
    useEffect(
      () {
        Future.microtask(() async {
          try {
            // ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚„ã‚®ãƒ«ãƒ‰æƒ…å ±ãªã©ã®åˆæœŸåŒ–
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            await ref.read(getItemBoxListNotifierProvider.notifier).getItemBoxList();

            final myAccount =
                await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            // Spot ã‚’å–å¾—
            if (myGuildIdState.value != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }

            // ãƒãƒ¼ã‚«ãƒ¼ä½œæˆ
            await _refreshMarkers();
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    // ãƒãƒ¼ã‚«ãƒ¼ã‚’å†æ§‹ç¯‰ã™ã‚‹é–¢æ•°
    Future<void> _refreshMarkers() async {
      try {
        isMarkersBuilding.value = true;
        final spots = myGuildSpotListState.asData?.value ?? [];
        final itemBoxes = itemBoxListState.asData?.value ?? [];
        final myGuildId = myGuildIdState.value;

        final newMarkers = await buildMarkers(
          spots: spots,
          itemBoxes: itemBoxes,
          myGuildId: myGuildId,
        );
        markers.value = newMarkers;
      } finally {
        isMarkersBuilding.value = false;
      }
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers.value,
            ),
            if (isMarkersBuilding.value)
              const Center(child: CircularProgressIndicator()),
            // ---- ä¸‹éƒ¨ãƒœã‚¿ãƒ³é¡ ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore ãƒªã‚¹ãƒˆ
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot ãƒªã‚¹ãƒˆ
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('è¨­å®šã‚¢ãƒ—ãƒªã‹ã‚‰ä½ç½®æƒ…å ±å–å¾—ã‚’ONã«ã—ã¦ãã ã•ã„'),
          ),
        ),
      ),
    );
  }

  /// MarkerData ã‹ã‚‰è¡¨ç¤ºã™ã‚‹ Widget ã‚’çµ„ã¿ç«‹ã¦ã‚‹
  /// widget_to_marker ã® .toBitmapDescriptor ã«æ¸¡ã™ãŸã‚
  Widget _buildMarkerWidget(MarkerData data) {
    switch (data.markerType) {
      case MarkerType.spot:
        {
          switch (data.spotType) {
            case SpotType.noneGuild:
              // guildId == null â†’ photoUrl ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’
              final photoUrl = data.spot?.photoUrl;
              if (photoUrl != null && photoUrl.isNotEmpty) {
                return ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: Image.network(
                    photoUrl,
                    fit: BoxFit.cover,
                    width: 80,
                    height: 80,
                  ),
                );
              } else {
                // photoUrl ãªã— â†’ placeholder
                return Container(
                  width: 80,
                  height: 80,
                  color: Colors.grey,
                  child: const Center(child: Text('No Photo')),
                );
              }
            case SpotType.myGuild:
              // è‡ªåˆ†ã®æ—— â†’ ç·‘è‰²ãƒ•ãƒ©ãƒƒã‚° (Material Icon)
              return Container(
                width: 80,
                height: 80,
                decoration: const BoxDecoration(
                  shape: BoxShape.circle,
                  color: Colors.white,
                ),
                child: const Icon(
                  Icons.flag,
                  color: Colors.green,
                  size: 40,
                ),
              );
            case SpotType.otherGuild:
              // ç›¸æ‰‹ã®æ—— â†’ èµ¤è‰²ãƒ•ãƒ©ãƒƒã‚°
              return Container(
                width: 80,
                height: 80,
                decoration: const BoxDecoration(
                  shape: BoxShape.circle,
                  color: Colors.white,
                ),
                child: const Icon(
                  Icons.flag,
                  color: Colors.red,
                  size: 40,
                ),
              );
            default:
              // fallback
              return const SizedBox();
          }
        }
      case MarkerType.itemBox:
        // ã‚¢ã‚¤ãƒ†ãƒ ãƒœãƒƒã‚¯ã‚¹ â†’ å®ç®±ã‚¢ã‚¤ã‚³ãƒ³ (Material Icon)
        return Container(
          width: 80,
          height: 80,
          decoration: BoxDecoration(
            border: Border.all(color: Colors.brown, width: 2),
            borderRadius: BorderRadius.circular(12),
            color: Colors.white,
          ),
          child: const Icon(
            Icons.card_giftcard,
            color: Colors.brown,
            size: 40,
          ),
        );
    }
  }
}

// ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–ã™ã‚‹ã‚¯ãƒ©ã‚¹
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

## å®Ÿè£…ã®æµã‚Œ

1. **`pubspec.yaml` ã« `widget_to_marker: ^1.0.6` ã‚’è¿½åŠ **  
   ```yaml
   dependencies:
     widget_to_marker: ^1.0.6
   ```
2. **`MarkerType` / `SpotType` ã® enum ã‚’å®šç¾©ã—ã€ã©ã®ã‚ˆã†ãªãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹ã‹ã‚’åˆ¤å®š**  
   - `noneGuild` (`guildId == null`) / `myGuild` / `otherGuild`  
3. **`MarkerData` ã‚¯ãƒ©ã‚¹ã§ Spot / ItemBox ã‚’ã²ã¨ã¾ã¨ã‚ã«æ‰±ã„ã€`markerType` ã¨ `spotType` ã‚’æŒãŸã›ã‚‹**  
4. `MapPage` å†…ã§ Spot ã‚„ ItemBox ã®ãƒªã‚¹ãƒˆã‹ã‚‰ `MarkerData` ã‚’ä½œã‚Šã€ãƒ«ãƒ¼ãƒ—ã—ã¦ `widget_to_marker` ã§ `BitmapDescriptor` ã‚’ç”Ÿæˆ â†’ `Marker` ã«è¨­å®š  
5. **`_buildMarkerWidget`** é–¢æ•°ã®ä¸­ã§å®Ÿéš›ã® **Widget**ï¼ˆ`Icon` ã‚„ `Image.network` ãªã©ï¼‰ã‚’è¿”ã—ã€**ä¸¸ã„èƒŒæ™¯ã‚„å››è§’ã„æ ** ã‚’è£…é£¾ã—ã¦ã„ã‚‹  
6. ç”Ÿæˆã—ãŸ `Marker` ã‚’ `markers` ã«åŠ ãˆã¦ `GoogleMap` ã® `markers` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«æ¸¡ã™  

---

### æ³¨æ„ç‚¹

- **ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒ** ã®å ´åˆã¯èª­ã¿è¾¼ã¿ã«æ™‚é–“ãŒã‹ã‹ã‚Šã€æœ€åˆã¯ç™½ã„ãƒãƒ¼ã‚«ãƒ¼ã«ãªã£ãŸã‚Šã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãã“ã§ `waitToRender` ã‚’è¨­å®šã—ãŸã‚Šã€**ã‚ã‚‰ã‹ã˜ã‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥** ã™ã‚‹ãªã©å·¥å¤«ãŒå¿…è¦ã§ã™ã€‚  
- ãƒãƒ¼ã‚«ãƒ¼ãŒå¤§é‡ã«ã‚ã‚‹å ´åˆã€ä¸€åº¦ã« `.toBitmapDescriptor(...)` ã‚’é€£ç¶šå®Ÿè¡Œã™ã‚‹ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒä½ä¸‹ã™ã‚‹æã‚ŒãŒã‚ã‚Šã¾ã™ã€‚  
- **Marker ã®æ›´æ–°** ã¯ã€ãƒãƒ¼ã‚«ãƒ¼ã‚’å†æ§‹ç¯‰ã—ã¦ `markers.value = ...` ã—ã¦ã‚„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å¿…è¦ã«å¿œã˜ã¦éƒ½åº¦ `_refreshMarkers()` ã‚’å‘¼ã³å‡ºã™ãªã©ã—ã¦ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/01/17 21:34:07*

SpotType ã¯ãã®ã¾ã¾ã§ MarkerType ã‚„ MarkerData ã¯ä½¿ã‚ãªãã¦ã„ã„ã‚„ã€‚

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/01/17 21:35:08*

ä»¥ä¸‹ã¯ `widget_to_marker` ã‚’ç”¨ã„ã¦ã€ **Spot** ã¨ **ItemBox** ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ãã‚Œãã‚Œ **Widget** ã§å®Ÿè£…ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã§ã™ã€‚  
- **Spot** ã¯ `SpotType` ( `noneGuild` / `myGuild` / `otherGuild` ) ã§åˆ†å²ã—ã€  
  - ã‚®ãƒ«ãƒ‰ID=null â†’ `photoUrl` ã®ç”»åƒã‚’å››è§’ã§è¡¨ç¤º  
  - è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ â†’ ç·‘è‰²ãƒ•ãƒ©ãƒƒã‚°ã‚’ä¸¸ã‚¢ã‚¤ã‚³ãƒ³  
  - ä»–ã®ã‚®ãƒ«ãƒ‰ â†’ èµ¤è‰²ãƒ•ãƒ©ãƒƒã‚°ã‚’ä¸¸ã‚¢ã‚¤ã‚³ãƒ³  
- **ItemBox** ã¯å®ç®±ã‚¢ã‚¤ã‚³ãƒ³ã‚’å››è§’ã«è¡¨ç¤ºã€‚  
- `widget_to_marker` ã® `.toBitmapDescriptor(...)` ã‚’ä½¿ã£ã¦ `Marker` ã® `icon` ã«è¨­å®šã—ã¦ã„ã¾ã™ã€‚  

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';

/// Spot ã®ç¨®é¡ã‚’è¡¨ã™
enum SpotType {
  noneGuild, // guildId == null
  myGuild,   // guildId == myGuildId
  otherGuild // guildId != myGuildId
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController ã‚’ä¿æŒ
    final googleMapController = useState<GoogleMapController?>(null);

    // ç¾åœ¨ä½ç½®
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // Spot ä¸€è¦§
    final myGuildSpotListState = ref.watch(getGuildSpotListNotifierProvider);

    // ItemBox ä¸€è¦§
    final itemBoxListState = ref.watch(getItemBoxListNotifierProvider);

    // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ID ã‚’ä¿æŒ
    final myGuildIdState = useState<String?>(null);

    // Map ã¸è¨­ç½®ã™ã‚‹ Marker
    final markers = useState<Set<Marker>>({});
    // ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆä¸­ãƒ•ãƒ©ã‚°ï¼ˆå¿…è¦ãªã‚‰ãƒ­ãƒ¼ãƒ‰ä¸­è¡¨ç¤ºã«ä½¿ã†ï¼‰
    final isMarkersBuilding = useState<bool>(false);

    useEffect(
      () {
        Future.microtask(() async {
          try {
            // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ãƒœãƒƒã‚¯ã‚¹ãªã©åˆæœŸãƒ‡ãƒ¼ã‚¿å–å¾—
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            await ref.read(getItemBoxListNotifierProvider.notifier).getItemBoxList();

            final myAccount =
                await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            if (myGuildIdState.value != null) {
              await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }

            // ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ
            await _refreshMarkers();
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    // ãƒãƒ¼ã‚«ãƒ¼ã‚’å†æ§‹ç¯‰
    Future<void> _refreshMarkers() async {
      try {
        isMarkersBuilding.value = true;
        final spots = myGuildSpotListState.asData?.value ?? [];
        final itemBoxes = itemBoxListState.asData?.value ?? [];
        final myGuildId = myGuildIdState.value;

        final newMarkers = await _buildAllMarkers(
          spots: spots,
          itemBoxes: itemBoxes,
          myGuildId: myGuildId,
        );
        markers.value = newMarkers;
      } finally {
        isMarkersBuilding.value = false;
      }
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers.value,
            ),
            // â˜… ãƒãƒ¼ã‚«ãƒ¼ä½œæˆä¸­ã«ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ã‚’å‡ºã™ä¾‹
            if (isMarkersBuilding.value)
              const Center(child: CircularProgressIndicator()),

            // ---- ä¸‹éƒ¨ãƒœã‚¿ãƒ³é¡ ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore ãƒªã‚¹ãƒˆ
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot ãƒªã‚¹ãƒˆ
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('è¨­å®šã‚¢ãƒ—ãƒªã‹ã‚‰ä½ç½®æƒ…å ±å–å¾—ã‚’ONã«ã—ã¦ãã ã•ã„'),
          ),
        ),
      ),
    );
  }

  /// Spot / ItemBox ãã‚Œãã‚Œã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ä½œã‚Šã€Set<Marker> ã‚’è¿”ã™
  Future<Set<Marker>> _buildAllMarkers({
    required List<GuildSpotDTO> spots,
    required List<ItemBoxDTO> itemBoxes,
    required String? myGuildId,
  }) async {
    final markerSet = <Marker>{};

    // ---- Spot ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ ----
    for (final spot in spots) {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';

      // SpotType åˆ¤å®š
      SpotType spotType;
      if (spot.guildId == null) {
        spotType = SpotType.noneGuild;
      } else if (spot.guildId == myGuildId) {
        spotType = SpotType.myGuild;
      } else {
        spotType = SpotType.otherGuild;
      }

      // Widget ã‚’çµ„ã¿ç«‹ã¦
      final widget = _buildSpotMarkerWidget(spotType, spot.photoUrl);

      // BitmapDescriptor ã«å¤‰æ›
      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(80, 80),
        imageSize: const Size(80, 80),
        // ç”»åƒã‚’å¾…ã¤
        waitToRender: const Duration(milliseconds: 500),
      );

      // Marker ã‚’è¿½åŠ 
      markerSet.add(
        Marker(
          markerId: MarkerId('spot_$spotId'),
          position: LatLng(lat, lng),
          icon: iconDescriptor,
          onTap: () async {
            switch (spotType) {
              case SpotType.noneGuild:
                // æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆã®è©³ç´°
                _showShootableSpotDetail(spotId);
                break;
              case SpotType.myGuild:
                // è‡ªåˆ†ã®ã‚¹ãƒãƒƒãƒˆè©³ç´°
                _showOurSpotDetail(spotId);
                break;
              case SpotType.otherGuild:
                // æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆã®è©³ç´°
                _showShootableSpotDetail(spotId);
                break;
            }
          },
        ),
      );
    }

    // ---- ItemBox ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ ----
    for (final itemBox in itemBoxes) {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';

      // Widget ã‚’çµ„ã¿ç«‹ã¦ (å®ç®±ã‚¢ã‚¤ã‚³ãƒ³)
      final widget = _buildItemBoxMarkerWidget();

      // BitmapDescriptor ã«å¤‰æ›
      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(80, 80),
        imageSize: const Size(80, 80),
        waitToRender: const Duration(milliseconds: 300),
      );

      // Marker ã‚’è¿½åŠ 
      markerSet.add(
        Marker(
          markerId: MarkerId('itemBox_$itemBoxId'),
          position: LatLng(lat, lng),
          icon: iconDescriptor,
          onTap: () async {
            // ItemBox ã‚’é–‹ã‘ã‚‹
            await _openItemBox(itemBoxId);
          },
        ),
      );
    }

    return markerSet;
  }

  /// Spot ç”¨ã®ãƒãƒ¼ã‚«ãƒ¼Widgetã‚’è¿”ã™
  Widget _buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    switch (spotType) {
      case SpotType.noneGuild:
        // guildId == null â†’ photoUrl
        if (photoUrl != null && photoUrl.isNotEmpty) {
          return ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: Image.network(
              photoUrl,
              fit: BoxFit.cover,
              width: 80,
              height: 80,
            ),
          );
        } else {
          // photoUrl ãŒç„¡ã„å ´åˆã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
          return Container(
            width: 80,
            height: 80,
            color: Colors.grey,
            child: const Center(child: Text('No Photo')),
          );
        }

      case SpotType.myGuild:
        // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ â†’ ç·‘ã®æ——ã‚’ä¸¸ã§
        return Container(
          width: 80,
          height: 80,
          decoration: const BoxDecoration(
            shape: BoxShape.circle,
            color: Colors.white,
          ),
          child: const Icon(
            Icons.flag,
            color: Colors.green,
            size: 40,
          ),
        );

      case SpotType.otherGuild:
        // ä»–ã®ã‚®ãƒ«ãƒ‰ â†’ èµ¤ã„æ——ã‚’ä¸¸ã§
        return Container(
          width: 80,
          height: 80,
          decoration: const BoxDecoration(
            shape: BoxShape.circle,
            color: Colors.white,
          ),
          child: const Icon(
            Icons.flag,
            color: Colors.red,
            size: 40,
          ),
        );
    }
  }

  /// ItemBox ç”¨ã®ãƒãƒ¼ã‚«ãƒ¼Widgetã‚’è¿”ã™
  Widget _buildItemBoxMarkerWidget() {
    return Container(
      width: 80,
      height: 80,
      decoration: BoxDecoration(
        border: Border.all(color: Colors.brown, width: 2),
        borderRadius: BorderRadius.circular(12),
        color: Colors.white,
      ),
      child: const Icon(
        Icons.card_giftcard,
        color: Colors.brown,
        size: 40,
      ),
    );
  }

  // ---- ä»¥ä¸‹ã€onTap æ™‚ã®å‡¦ç† ----

  void _showShootableSpotDetail(String spotId) {
    // æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
    // showShootableSpotDetailNotifierProvider ã‚’ä½¿ã†
    // ä¾‹:
    // ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
  }

  void _showOurSpotDetail(String spotId) {
    // è‡ªåˆ†ã®ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
    // showOurSpotDetailNotifierProvider ã‚’ä½¿ã†
    // ä¾‹:
    // ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);
  }

  Future<void> _openItemBox(String itemBoxId) async {
    // ç¾åœ¨åœ°ã‚’å–å¾— â†’ openItemBox
    // ä¾‹:
    // final userLocation = ref.read(currentLocationNotifierProvider).asData?.value;
    // if (userLocation == null) return;
    // try {
    //   final items = await ref.read(openItemBoxNotifierProvider.notifier)
    //       .openItemBox(itemBoxId, userLocation);
    //   // æˆåŠŸæ™‚ã¯ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
    // } catch (e) {
    //   // å¤±æ•—æ™‚ã¯ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ãªã©è¡¨ç¤º
    // }
  }
}

// ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–ã™ã‚‹ã‚¯ãƒ©ã‚¹
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

---

## è§£èª¬

1. **SpotType**  
   - `noneGuild` (`guildId == null`), `myGuild`, `otherGuild` ã®3ç¨®é¡ã‚’å®šç¾©ã€‚  
2. **åˆæœŸãƒ‡ãƒ¼ã‚¿å–å¾—**  
   - `getMyGuildNotifierProvider` ã§è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ã€ `getItemBoxListNotifierProvider` ã§ã‚¢ã‚¤ãƒ†ãƒ ãƒœãƒƒã‚¯ã‚¹ä¸€è¦§ã‚’å–å¾—ã€‚  
   - `myGuildIdState` ã«ã‚®ãƒ«ãƒ‰ID ã‚’ä¿æŒã€‚  
   - `myGuildIdState.value` ãŒå­˜åœ¨ã™ã‚Œã° `getGuildSpotListNotifierProvider` ã‚’å‘¼ã‚“ã§ Spot ä¸€è¦§ã‚’å–å¾—ã€‚  
3. **`_buildAllMarkers()`** ã§ Spotãƒ»ItemBox ãã‚Œãã‚Œã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ç”Ÿæˆ  
   - Spot ã¯ `SpotType` ã‚’åˆ¤å®šã—ã€ `_buildSpotMarkerWidget(spotType, photoUrl)` ã§ãƒãƒ¼ã‚«ãƒ¼ç”¨ Widget ã‚’è¿”ã™ã€‚  
   - ItemBox ã¯ `_buildItemBoxMarkerWidget()` ã§å®ç®±é¢¨ã® Widget ã‚’è¿”ã™ã€‚  
   - `widget_to_marker` ã® `.toBitmapDescriptor(...)` ã‚’ await ã—ã¦ `Marker.icon` ã«è¨­å®šã€‚  
   - `Marker.onTap` ã§ãã‚Œãã‚Œã®å‡¦ç†ï¼ˆSpot ã®å ´åˆã¯ `showShootableSpotDetail` or `showOurSpotDetail`ã€ ItemBox ã®å ´åˆã¯ `openItemBox`ï¼‰ã‚’å®Ÿè¡Œã€‚  
4. **ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒã®æ³¨æ„**  
   - `waitToRender` ã‚’ä»˜ä¸ã—ãªã„ã¨ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒãŒæç”»ã•ã‚Œã‚‹å‰ã« `toBitmapDescriptor` ãŒèµ°ã‚Šã€çœŸã£ç™½ãªç”»åƒã«ãªã‚ŠãŒã¡ã€‚  
   - ç”»åƒãŒå¤§é‡ã«ã‚ã‚‹å ´åˆã€ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆã«æ™‚é–“ãŒã‹ã‹ã‚‹ãŸã‚ã€**ã‚­ãƒ£ãƒƒã‚·ãƒ¥** ã‚„ **äº‹å‰ãƒ­ãƒ¼ãƒ‰** ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚  
5. **Marker ã®æ›´æ–°**  
   - ä½•ã‹å¤‰æ›´ãŒã‚ã‚Œã° `_refreshMarkers()` ã‚’å‘¼ã³ç›´ã—ã¦ `markers.value = ...` ã‚’æ›´æ–°ã™ã‚Œã°å†æç”»ã•ã‚Œã¾ã™ã€‚  

ã“ã®ã‚ˆã†ã« `widget_to_marker` ã‚’ä½¿ã†ã“ã¨ã§ã€**è‡ªç”±ãª Widget** ã‚’ãƒãƒ¼ã‚«ãƒ¼ã¨ã—ã¦è¡¨ç¤ºã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/01/17 22:03:15*

refreshMarkers æ™‚ç‚¹ã§ spots, itemBoxes ãŒ 0 ä»¶ã ã¨ã„ã†ã“ã¨ãŒã‚ã‹ã£ãŸã€‚
ã“ã‚Œã¯ refreshMarkersã®æ®µéšã§å¼•æ•°ã§ spots ã‚„ itemBoxes ã‚’æ¸¡ã—ãŸæ–¹ãŒã‚ˆã•ãã†ã§ã‚ã‚‹ã€‚
ãã®ãŸã‚ã« getGuildSpotList()ã¨getItemBoxList()ã§å€¤ã‚’è¿”ã™ã‚ˆã†ã«å¤‰æ›´ã—ãŸã€‚
ã“ã‚Œã‚’ä½¿ã£ã¦å‡¦ç†æ™‚ã«ç¢ºå®Ÿã«spotsã‚„itemBoxesãŒå–å¾—ã—ã¦ã‹ã‚‰ãã®å€¤ã‚’æ¸¡ã™ã‚ˆã†ã«ã™ã‚‹ã‚ˆã†ã«å¤‰ãˆãŸã„ã€‚

ã¾ãŸã€spots ã§ã¯ãªã spotListã€itemBoxesã§ã¯ãªãitemBoxListã«ã—ã¦ã»ã—ã„ã€‚
ã¾ãŸã€ãƒãƒ¼ã‚«ãƒ¼ã¯ç™½ã®å››è§’æ ã§ã‚ã‚‹ãŒã€ä¸‹ã«ãƒãƒ¼ã‚«ãƒ¼ã®ã‚ˆã†ãªç™½ã®é€†ä¸‰è§’ã§åœ°ç‚¹ã‚’æŒ‡ã—ç¤ºã™ã‚ˆã†ãªã«ãƒãƒ¼ã‚«ãƒ¼ã§ã‚ã‚‹ã“ã¨ã‚’ã‚ˆã‚Šè¡¨ã—ã¦ã»ã—ã„ã€‚ã“ã‚Œã¯ç°¡ç´ ãªå®Ÿè£…ã§ã‚ˆã„ã€‚

getGuildSpotListã‚„getItemBoxListã®å‡¦ç†ã¯ä»¥ä¸‹ã§ã‚ã‚‹ã€‚

@Riverpod(keepAlive: true)
class GetItemBoxListNotifier extends _$GetItemBoxListNotifier {
  @override
  Future&lt;List&lt;ItemBoxDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;List&lt;ItemBoxDTO&gt;&gt; getItemBoxList() async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(itemBoxesApiProvider.future);
      final response = await api.itemBoxControllerGetItemBoxes();
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      final data = response.data?.data;
      if (data == null) {
        throw Exception('No data found');
      }
      state = AsyncValue.data(data);
      return data;
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
      rethrow;
    }
  }
}

@Riverpod(keepAlive: true)
class GetGuildSpotListNotifier extends _$GetGuildSpotListNotifier {
  @override
  Future&lt;List&lt;GuildSpotDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;List&lt;GuildSpotDTO&gt;&gt; getGuildSpotList(String guildId) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildsApiProvider.future);
      final response = await api.guildControllerGetGuildSpots(guildId: guildId);
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      final data = response.data?.data;
      if (data == null) {
        throw Exception('No data found');
      }
      state = AsyncValue.data(data);
      return data;
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
      rethrow;
    }
  }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/01/17 22:05:20*

ä»¥ä¸‹ã¯ã€**`getGuildSpotList()`** ã¨ **`getItemBoxList()`** ã§è¿”ã•ã‚ŒãŸå€¤ã‚’ãã®ã¾ã¾å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚Šã€  
`refreshMarkers`ï¼ˆã“ã“ã§ã¯ `_refreshMarkers`ï¼‰å†…ã§ç¢ºå®Ÿã« **`spotList`** ã¨ **`itemBoxList`** ã‚’ä½¿ã£ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’æç”»ã™ã‚‹å®Ÿè£…ä¾‹ã§ã™ã€‚

ä¸»ãªå¤‰æ›´ç‚¹:

1. **`getGuildSpotList()` / `getItemBoxList()`** ã§ **`List<GuildSpotDTO>` / `List<ItemBoxDTO>`** ã‚’ãƒªã‚¿ãƒ¼ãƒ³ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã—ã€ãã‚Œã‚’å–å¾—å¾Œã« `_refreshMarkers(spotList, itemBoxList)` ã‚’å‘¼ã³å‡ºã™ã€‚  
2. **`spots`** â†’ **`spotList`**ã€**`itemBoxes`** â†’ **`itemBoxList`** ã«åç§°å¤‰æ›´ã€‚  
3. ãƒãƒ¼ã‚«ãƒ¼ã®ä¸‹ã«**ç™½ã„é€†ä¸‰è§’å½¢**ã‚’ã¤ã‘ã‚‹ã“ã¨ã§ã€Œã“ã“ã‚’æŒ‡ã—ã¦ã„ã‚‹ã€æ„Ÿã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«å‡ºã™ã€‚  

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/open_item_box.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';

/// Spot ã®ç¨®é¡ã‚’è¡¨ã™
enum SpotType {
  noneGuild, // guildId == null
  myGuild,   // guildId == myGuildId
  otherGuild // guildId != myGuildId
}

/// é€†ä¸‰è§’å½¢ã‚’æç”»ã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãª Painter
class TrianglePainter extends CustomPainter {
  final Color color;
  TrianglePainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // å·¦ä¸Š
      ..lineTo(size.width, 0) // å³ä¸Š
      ..lineTo(size.width / 2, size.height) // åº•è¾ºã®ä¸­å¤®
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) => false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController ã‚’ä¿æŒ
    final googleMapController = useState<GoogleMapController?>(null);

    // ç¾åœ¨åœ°
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ID
    final myGuildIdState = useState<String?>(null);

    // ãƒãƒ¼ã‚«ãƒ¼ãŸã¡
    final markers = useState<Set<Marker>>({});
    // ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆä¸­ãƒ•ãƒ©ã‚°
    final isMarkersBuilding = useState(false);

    useEffect(
      () {
        Future.microtask(() async {
          try {
            // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ã‚’å–å¾— (ã‚¢ã‚«ã‚¦ãƒ³ãƒˆâ†’ã‚®ãƒ«ãƒ‰ID)
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            final myAccount = await ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            // ItemBoxä¸€è¦§ã‚’å–å¾— (ãƒªã‚¿ãƒ¼ãƒ³å€¤ã‚’å—ã‘å–ã‚‹)
            final itemBoxList = await ref.read(getItemBoxListNotifierProvider.notifier)
                .getItemBoxList();

            // Spotä¸€è¦§ã‚’å–å¾— (ãƒªã‚¿ãƒ¼ãƒ³å€¤ã‚’å—ã‘å–ã‚‹)
            List<GuildSpotDTO> spotList = [];
            if (myGuildIdState.value != null) {
              spotList = await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildIdState.value!);
            }

            // å–å¾—ã—ãŸå€¤ã‚’å…ƒã«ãƒãƒ¼ã‚«ãƒ¼ã‚’ç”Ÿæˆ
            await _refreshMarkers(spotList, itemBoxList);
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation = ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () => WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    /// [spotList] ã¨ [itemBoxList] ã‚’å—ã‘å–ã‚Šã€ãƒãƒ¼ã‚«ãƒ¼ã‚’å†ä½œæˆã™ã‚‹
    Future<void> _refreshMarkers(
      List<GuildSpotDTO> spotList,
      List<ItemBoxDTO> itemBoxList,
    ) async {
      try {
        isMarkersBuilding.value = true;
        final newMarkers = await _buildAllMarkers(
          spotList: spotList,
          itemBoxList: itemBoxList,
          myGuildId: myGuildIdState.value,
        );
        markers.value = newMarkers;
      } finally {
        isMarkersBuilding.value = false;
      }
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) => Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers.value,
            ),
            // ãƒãƒ¼ã‚«ãƒ¼ä½œæˆä¸­ã«ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ã‚’å‡ºã™ï¼ˆå¿…è¦ãªã‘ã‚Œã°æ¶ˆã—ã¦OKï¼‰
            if (isMarkersBuilding.value)
              const Center(child: CircularProgressIndicator()),

            // ---- ä¸‹éƒ¨ãƒœã‚¿ãƒ³é¡ ----
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                  FloatingActionButton(
                    heroTag: 'CurrentLocationButton',
                    onPressed: () async {
                      final refreshedLocation =
                          await ref.read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  // Explore ãƒªã‚¹ãƒˆ
                  FloatingActionButton.extended(
                    heroTag: 'ShowExploreListButton',
                    onPressed: () {
                      ref.read(showExplorerListNotifierProvider.notifier).show();
                    },
                    label: const Text('Explore'),
                    icon: const Icon(Icons.explore),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  // Spot ãƒªã‚¹ãƒˆ
                  FloatingActionButton(
                    heroTag: 'ShowSpotListButton',
                    onPressed: () {
                      ref.read(showSpotListNotifierProvider.notifier).show();
                    },
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('è¨­å®šã‚¢ãƒ—ãƒªã‹ã‚‰ä½ç½®æƒ…å ±å–å¾—ã‚’ONã«ã—ã¦ãã ã•ã„'),
          ),
        ),
      ),
    );
  }

  /// SpotList / ItemBoxList ãã‚Œãã‚Œã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ã¾ã¨ã‚ã¦ç”Ÿæˆ
  Future<Set<Marker>> _buildAllMarkers({
    required List<GuildSpotDTO> spotList,
    required List<ItemBoxDTO> itemBoxList,
    required String? myGuildId,
  }) async {
    final markerSet = <Marker>{};

    // ---- Spot ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ ----
    for (final spot in spotList) {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';

      final spotType = _getSpotType(spot.guildId, myGuildId);

      // Spotç”¨ã®Widget
      final widget = _buildSpotMarkerWidget(spotType, spot.photoUrl);

      // widget_to_marker ã§å¤‰æ›
      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(80, 90),
        imageSize: const Size(80, 90),
        waitToRender: const Duration(milliseconds: 500),
      );

      markerSet.add(
        Marker(
          markerId: MarkerId('spot_$spotId'),
          position: LatLng(lat, lng),
          icon: iconDescriptor,
          onTap: () => _onSpotMarkerTap(spotId, spotType),
        ),
      );
    }

    // ---- ItemBox ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ ----
    for (final iBox in itemBoxList) {
      final lat = iBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = iBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = iBox.itemBoxId ?? '';

      // ã‚¢ã‚¤ãƒ†ãƒ ãƒœãƒƒã‚¯ã‚¹ç”¨ã®Widget
      final widget = _buildItemBoxMarkerWidget();

      // widget_to_marker ã§å¤‰æ›
      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(80, 90),
        imageSize: const Size(80, 90),
        waitToRender: const Duration(milliseconds: 300),
      );

      markerSet.add(
        Marker(
          markerId: MarkerId('itemBox_$itemBoxId'),
          position: LatLng(lat, lng),
          icon: iconDescriptor,
          onTap: () => _onItemBoxMarkerTap(itemBoxId),
        ),
      );
    }

    return markerSet;
  }

  /// spot.guildId ã¨ myGuildId ã‹ã‚‰ SpotType ã‚’åˆ¤å®š
  SpotType _getSpotType(String? guildId, String? myGuildId) {
    if (guildId == null) {
      return SpotType.noneGuild;
    } else if (guildId == myGuildId) {
      return SpotType.myGuild;
    } else {
      return SpotType.otherGuild;
    }
  }

  /// Spotã®ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ã™Widget (ç™½æ  + ä¸‹ã«é€†ä¸‰è§’)
  Widget _buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    // Contentéƒ¨åˆ† (å››è§’å½¢ã«è¡¨ç¤º)
    Widget content;
    switch (spotType) {
      case SpotType.noneGuild:
        // guildId == null â†’ photoUrl
        if (photoUrl != null && photoUrl.isNotEmpty) {
          content = ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: Image.network(
              photoUrl,
              fit: BoxFit.cover,
              width: 80,
              height: 80,
            ),
          );
        } else {
          content = Container(
            width: 80,
            height: 80,
            color: Colors.grey,
            alignment: Alignment.center,
            child: const Text(
              'No Photo',
              style: TextStyle(fontSize: 12),
            ),
          );
        }
        break;

      case SpotType.myGuild:
        // è‡ªåˆ†ã®ã‚®ãƒ«ãƒ‰ â†’ ç·‘ã®æ—— (ä¸¸ã‚¢ã‚¤ã‚³ãƒ³èƒŒæ™¯)
        content = Container(
          width: 80,
          height: 80,
          decoration: const BoxDecoration(
            color: Colors.white,
            shape: BoxShape.circle,
          ),
          child: const Icon(
            Icons.flag,
            color: Colors.green,
            size: 40,
          ),
        );
        break;

      case SpotType.otherGuild:
        // ä»–ã‚®ãƒ«ãƒ‰ â†’ èµ¤ã®æ—— (ä¸¸ã‚¢ã‚¤ã‚³ãƒ³èƒŒæ™¯)
        content = Container(
          width: 80,
          height: 80,
          decoration: const BoxDecoration(
            color: Colors.white,
            shape: BoxShape.circle,
          ),
          child: const Icon(
            Icons.flag,
            color: Colors.red,
            size: 40,
          ),
        );
        break;
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // å››è§’ or ä¸¸ã‚¢ã‚¤ã‚³ãƒ³éƒ¨åˆ†
        content,
        // ä¸‹ã«é€†ä¸‰è§’ã§åœ°ç‚¹ã‚’æŒ‡ã™
        CustomPaint(
          size: const Size(20, 10), // å¹…20, é«˜ã•10
          painter: TrianglePainter(color: Colors.white),
        ),
      ],
    );
  }

  /// ItemBoxã®ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ã™Widget (ç™½æ  + ä¸‹ã«é€†ä¸‰è§’)
  Widget _buildItemBoxMarkerWidget() {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // å››è§’ã„æ ã«å®ç®±ã‚¢ã‚¤ã‚³ãƒ³
        Container(
          width: 80,
          height: 80,
          decoration: BoxDecoration(
            border: Border.all(color: Colors.brown, width: 2),
            borderRadius: BorderRadius.circular(12),
            color: Colors.white,
          ),
          child: const Icon(
            Icons.card_giftcard,
            color: Colors.brown,
            size: 40,
          ),
        ),
        // ä¸‹ã«é€†ä¸‰è§’
        CustomPaint(
          size: const Size(20, 10),
          painter: TrianglePainter(color: Colors.white),
        ),
      ],
    );
  }

  // ---- ã‚¿ãƒƒãƒ—æ™‚ã®æŒ™å‹• ----

  void _onSpotMarkerTap(String spotId, SpotType spotType) {
    switch (spotType) {
      case SpotType.noneGuild:
        // æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
        // ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        break;
      case SpotType.myGuild:
        // è‡ªåˆ†ã®ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
        // ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);
        break;
      case SpotType.otherGuild:
        // æ’ƒã¦ã‚‹ã‚¹ãƒãƒƒãƒˆè©³ç´°ã‚’è¡¨ç¤º
        // ref.read(showShootableSpotDetailNotifierProvider.notifier).show(spotId);
        break;
    }
  }

  void _onItemBoxMarkerTap(String itemBoxId) async {
    // ç¾åœ¨åœ°ã‚’å–å¾—ã—ã¦openItemBoxã‚’å®Ÿè¡Œ
    // ä¾‹:
    // final userLocation = ref.read(currentLocationNotifierProvider).asData?.value;
    // if (userLocation == null) return;
    // try {
    //   final items = await ref.read(openItemBoxNotifierProvider.notifier)
    //       .openItemBox(itemBoxId, userLocation);
    //   // æˆåŠŸæ™‚ã€ã‚¢ã‚¤ãƒ†ãƒ ä¸€è¦§ã‚’ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
    // } catch (e) {
    //   // å¤±æ•—æ™‚ã€ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ãªã©ã§ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
    // }
  }
}

// ---- ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–ã™ã‚‹ã‚¯ãƒ©ã‚¹ ----
class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}
```

---

## è§£èª¬

1. **`getGuildSpotList()` / `getItemBoxList()` ãŒè¿”ã™å€¤ã‚’ãã®ã¾ã¾å—ã‘å–ã‚Š**  
   ```dart
   final itemBoxList = await ref
       .read(getItemBoxListNotifierProvider.notifier)
       .getItemBoxList();

   List<GuildSpotDTO> spotList = [];
   if (myGuildIdState.value != null) {
     spotList = await ref
         .read(getGuildSpotListNotifierProvider.notifier)
         .getGuildSpotList(myGuildIdState.value!);
   }
   ```
2. **`_refreshMarkers(spotList, itemBoxList)`** ã¨ã—ã¦å¼•æ•°ã‚’æ¸¡ã™  
   ```dart
   await _refreshMarkers(spotList, itemBoxList);
   ```
3. `_buildAllMarkers()` å†…ã§ `spotList` ã¨ `itemBoxList` ã‚’ä½¿ã£ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’ä¸€æ‹¬ç”Ÿæˆ  
   - `SpotType` åˆ¤å®š ( `noneGuild` / `myGuild` / `otherGuild` )  
   - `_buildSpotMarkerWidget(...)` / `_buildItemBoxMarkerWidget()` ã§**ã‚«ã‚¹ã‚¿ãƒ Widget**ã‚’æ§‹ç¯‰  
   - `.toBitmapDescriptor()` ã‚’ `await` ã—ã¦ **Marker** ã«ã‚»ãƒƒãƒˆ  
4. **ãƒãƒ¼ã‚«ãƒ¼ã®è¦‹ãŸç›®**  
   - **å››è§’ / ä¸¸** ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’**ç™½èƒŒæ™¯**ã«ã™ã‚‹  
   - ä¸‹ã« `CustomPaint` ã§**é€†ä¸‰è§’å½¢**ã‚’æç”»ã—ã€åœ°å›³ä¸Šã®åœ°ç‚¹ã‚’æŒ‡ã—ç¤ºã™ã‚¤ãƒ¡ãƒ¼ã‚¸ã«  
5. **Spot ã‚’ã‚¿ãƒƒãƒ—** â†’  `showShootableSpotDetail` or `showOurSpotDetail` ã«èª˜å°  
   **ItemBox ã‚’ã‚¿ãƒƒãƒ—** â†’  `openItemBox(...)` â†’ æˆåŠŸãªã‚‰ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤ºã€å¤±æ•—ãªã‚‰ã‚¹ãƒŠãƒƒã‚¯ãƒãƒ¼ãªã©  
6. **ç”»åƒ (`photoUrl`) ã®èª­ã¿è¾¼ã¿**  
   - `waitToRender: const Duration(milliseconds: 500)` ã‚’å…¥ã‚Œã¦ãŠã‹ãªã„ã¨ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»åƒãŒå…ˆã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã‚‹å‰ã«ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿åŒ–ã•ã‚Œã€ç™½ã„å››è§’ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚  
   - å¤§é‡ã«ã‚ã‚‹å ´åˆã¯ã€**ã‚­ãƒ£ãƒƒã‚·ãƒ¥**ã‚„**éåŒæœŸç”Ÿæˆã®ä»•çµ„ã¿**ã‚’å·¥å¤«ã—ã¾ã—ã‚‡ã†ã€‚  

ã“ã®æ§‹æˆã§ã€`spotList` ã¨ `itemBoxList` ãŒ 0 ä»¶ã§ã‚ã£ã¦ã‚‚ã€å¿…ãš `_refreshMarkers(spotList, itemBoxList)` ã®å‘¼ã³å‡ºã—ã«ã‚ˆã‚Šãƒãƒ¼ã‚«ãƒ¼æç”»å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€**å€¤ã‚’å–å¾—ã—ã¦ã‹ã‚‰ãƒãƒ¼ã‚«ãƒ¼ã‚’ç”Ÿæˆ**ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---
