# エラーハンドリング修正案

Date: 2023-06-25

---

## 👤 User
*2023-06-25 15:59:03*

エラー設計をした


extension Publisher where Output: OptionalProtocol {
    func mapIsNotNil() -&gt; AnyPublisher&lt;Bool, Failure&gt; {
        map { $0.optional != nil }
            .eraseToAnyPublisher()
    }
}

protocol OptionalProtocol {
    associatedtype Wrapped
    var optional: Wrapped? { get }
}

extension Optional: OptionalProtocol {
    var optional: Wrapped? { self }
}

public enum ApiRequestError: Error {
    case hoge
}
public enum AppAuthError: Error {
    case moge
}

// TODO: ローカライズ
public enum AppError: LocalizedError {
    case apiRequestError(ApiRequestError)
    case authError(AppAuthError)
    case customMessageError(message: String) // 困ったときに使うエラー
    case generalError
    case unexpectedError

    // 実質的に alert のタイトルになる（LocalizedError の errorDescription の override である）
    public var errorDescription: String? {
        switch self {
        case .apiRequestError:
            return "通信エラー"
        case .authError:
            return "認証エラー"
        case .unexpectedError:
            return "システムエラー"
        default:
            return "エラー"
        }
    }

    public var alertMessageText: String {
        switch self {
        case .unexpectedError:
            return "予期せぬエラーが発生しました"
        default:
            return "エラーが発生しました"
        }
    }

    public var alertCancelButtonText: String {
        switch self {
        default:
            return "閉じる"
        }
    }
    public var alertCancelButton: some View {
        Button(alertCancelButtonText, role: .cancel) {}
    }

    public var alertMessage: some View {
        Text(alertMessageText)
    }
}


class Presenter: ObservableObject {
    @Published var appError: AppError?
    @Published var shouldShowAlert: Bool = false
    
    init() {
        //
        $appError
            .mapIsNotNil()
            .assign(to: &$shouldShowAlert)
    }
}

struct ContentView: View {
    @StateObject var presenter = Presenter()
    
    var body: some View {
        Button("エラー発生") {
            presenter.appError = AppError.unexpectedError
        }
        .alert(isPresented: $presenter.shouldShowAlert, error: presenter.appError) { error in
            error.alertCancelButton
        } message: { error in
            error.alertMessage
        }
    }
}

---

## 🤖 Assistant
*2023-06-25 15:59:54*

あなたのコードを見ると、SwiftUIとCombineを使用してエラーハンドリングの設計をしているようですね。しかしながら、いくつか問題点があります。

1. SwiftUIの `alert(isPresented:content:)`メソッドはerror型の引数を取りません。あなたが使おうとしているエラー型の引数を持つalertはSwiftUIのビルトインメソッドではありません。

2. `assign(to:)`メソッドはPublisherの出力値をPublishedプロパティに直接割り当てるために使われますが、`$shouldShowAlert`がBool型であるため、mapIsNotNil()がBool型の値を出力するPublisherでなければなりません。

この問題を修正するためには、自分でalertをカスタマイズするか、もしくは既存のalertをエラーハンドリングに適応させる必要があります。以下に修正案を示します。

```swift
class Presenter: ObservableObject {
    @Published var appError: AppError?
    var shouldShowAlert: AnyPublisher<Bool, Never> {
        $appError
            .map { $0 != nil }
            .eraseToAnyPublisher()
    }
}

struct ContentView: View {
    @StateObject var presenter = Presenter()
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        Button("エラー発生") {
            presenter.appError = AppError.unexpectedError
        }
        .alert(isPresented: presenter.shouldShowAlert
            .receive(on: DispatchQueue.main)
            .sink { _ in },
               content: {
                    Alert(title: Text(presenter.appError?.errorDescription ?? ""),
                          message: Text(presenter.appError?.alertMessageText ?? ""),
                          dismissButton: .default(Text(presenter.appError?.alertCancelButtonText ?? ""), action: {
                              presenter.appError = nil
                          }))
                })
    }
}
```

以上のコードでは、次の変更点があります。

1. `shouldShowAlert`は `AnyPublisher<Bool, Never>`型となり、`$appError`がnilでないかどうかを出力するようになっています。この結果、エラーが存在すれば `shouldShowAlert`は `true`となり、エラーが解消（nilになった）されれば `false`となります。

2. SwiftUIのビルトインメソッド `alert(isPresented:content:)`を使用しています。 `isPresented`には `shouldShowAlert`を指定し、contentにはAlertを定義しています。Alertのタイトル、メッセージ、ボタンのテキストはすべて `appError`から取得しています。

3. Alertのデフォルトボタンのアクションでは、`appError`をnilに設定してエラーを解消し、その結果 `shouldShowAlert`も `false`になります。これにより、Alertは表示されなくなります。

これらの

---

## 👤 User
*2023-06-25 16:00:19*

上記の問題はクリアになっている

以下をどの場所でも繰り返し使いたいので、共通化するようなものを提供して欲しい

.alert(isPresented: $presenter.shouldShowAlert, error: presenter.appError) { error in
            error.alertCancelButton
        } message: { error in
            error.alertMessage
        }

---

## 🤖 Assistant
*2023-06-25 16:00:55*

その機能を共通化するには、自分で定義したビューモディファイアを作成することで解決できます。これにより、エラーアラートをどのビューでも簡単に使用できます。以下にカスタムビューモディファイアの例を示します。

まずはビューモディファイアを定義しましょう：

```swift
struct ErrorAlertModifier: ViewModifier {
    @Binding var isPresented: Bool
    var error: AppError?
    
    func body(content: Content) -> some View {
        content
            .alert(isPresented: $isPresented) {
                Alert(
                    title: Text(error?.errorDescription ?? ""),
                    message: Text(error?.alertMessageText ?? ""),
                    dismissButton: .default(Text(error?.alertCancelButtonText ?? ""), action: {
                        self.isPresented = false
                    })
                )
            }
    }
}
```

そして、そのビューモディファイアを使うための拡張を作成します：

```swift
extension View {
    func errorAlert(isPresented: Binding<Bool>, error: AppError?) -> some View {
        self.modifier(ErrorAlertModifier(isPresented: isPresented, error: error))
    }
}
```

これで準備が完了です。これを使用してみましょう：

```swift
struct ContentView: View {
    @StateObject var presenter = Presenter()
    
    var body: some View {
        Button("エラー発生") {
            presenter.appError = AppError.unexpectedError
        }
        .errorAlert(isPresented: $presenter.shouldShowAlert, error: presenter.appError)
    }
}
```

`errorAlert`メソッドを使って、エラーアラートの表示を制御します。これは`isPresented`と`error`パラメータを受け取ります。

ここでは`ContentView`で`Presenter`クラスのインスタンスを作成し、"エラー発生"ボタンを押すと`appError`にエラーを設定します。そして`errorAlert`ビューモディファイアを使用してエラーアラートを表示します。これにより、エラーハンドリングのロジックを共通化し、繰り返し使用することができます。

---
