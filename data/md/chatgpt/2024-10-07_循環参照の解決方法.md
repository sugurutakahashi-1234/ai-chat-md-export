# 循環参照の解決方法

Date: 2024-10-07

---

## 👤 User
*2024-10-07 13:49:30*

self が循環参照になっている

private func textEnToSpeech(text: String) {
        guard let speaker = speaker else {
            return
        }

        Task {
            do {
                try await speechRepository.startTextToSpeech(speechText: SpeechText(value: text), speed: speed, speaker: speaker)
                
                DispatchQueue.main.async {
                    if self.pauseAlert == ConversationStudyViewModel.PauseAlertType.none {
                        self.status = .studentEnSpeaking
                    }
                }
            } catch {
                print(error)
                DispatchQueue.main.async {
                    self.error = .textToSpeechError
                    print(error)
                }
            }
        }
    }

---

## 🤖 Assistant
*2024-10-07 13:49:40*

`self` が `Task` の中でキャプチャされて循環参照が発生する可能性があります。解決するには、`self` を弱参照（`weak self`）としてキャプチャし、クロージャ内で `self` が `nil` かどうかを確認します。以下のように書き換えてみてください。

```swift
private func textEnToSpeech(text: String) {
    guard let speaker = speaker else {
        return
    }

    Task { [weak self] in
        do {
            try await speechRepository.startTextToSpeech(speechText: SpeechText(value: text), speed: speed, speaker: speaker)
            
            DispatchQueue.main.async {
                guard let self = self else { return }
                
                if self.pauseAlert == ConversationStudyViewModel.PauseAlertType.none {
                    self.status = .studentEnSpeaking
                }
            }
        } catch {
            print(error)
            DispatchQueue.main.async {
                guard let self = self else { return }
                
                self.error = .textToSpeechError
                print(error)
            }
        }
    }
}
```

`[weak self]` を追加することで、`self` がクロージャ内で強参照されないようにして、循環参照を防ぐことができます。さらに、`self` が存在しているかを確認してから `self` にアクセスしています。

---

## 👤 User
*2024-10-07 13:49:49*

DispatchQueue.main.async ではなくて MainActorを使いたい

---

## 🤖 Assistant
*2024-10-07 13:49:56*

`DispatchQueue.main.async` の代わりに `MainActor` を使うことで、メインスレッドでの処理をより簡潔に行うことができます。`MainActor` を使った実装に変更する方法は以下の通りです。

```swift
private func textEnToSpeech(text: String) {
    guard let speaker = speaker else {
        return
    }

    Task { [weak self] in
        do {
            try await speechRepository.startTextToSpeech(speechText: SpeechText(value: text), speed: speed, speaker: speaker)
            
            await MainActor.run {
                guard let self = self else { return }
                
                if self.pauseAlert == ConversationStudyViewModel.PauseAlertType.none {
                    self.status = .studentEnSpeaking
                }
            }
        } catch {
            print(error)
            await MainActor.run {
                guard let self = self else { return }
                
                self.error = .textToSpeechError
                print(error)
            }
        }
    }
}
```

ポイントは、`DispatchQueue.main.async` の代わりに `await MainActor.run` を使うことです。これにより、メインスレッドでの UI 更新が `MainActor` 上で確実に行われます。

---
