# ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³è³¼å…¥æ™‚åˆ»å–å¾—

æ—¥ä»˜: 2024-09-27

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/9/27 14:37:17*

Swiftã§InAppã§ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³è³¼å…¥æƒ…å ±ã®è³¼å…¥æ™‚åˆ»ã‚’ç¿’å¾—ã—ãŸã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/9/27 14:37:29*

In-App Purchaseã§ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥æƒ…å ±ã‚’å–å¾—ã—ã€è³¼å…¥æ™‚åˆ»ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€`StoreKit`ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ã„ã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€`StoreKit.Transaction`ã‹ã‚‰è³¼å…¥æ—¥ã‚’å–å¾—ã§ãã¾ã™ã€‚ä»¥ä¸‹ã«ã€è³¼å…¥å±¥æ­´ã‹ã‚‰ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥æ™‚åˆ»ã‚’å–å¾—ã™ã‚‹ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

### æ‰‹é †:
1. ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥å±¥æ­´ã‚’å–å¾—
2. è©²å½“ã™ã‚‹ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®`purchaseDate`ã‚’å–å¾—

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`StoreKit`ã‚’ç”¨ã„ã¦ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥æƒ…å ±ã‚’å–å¾—ã—ã€è³¼å…¥æ™‚åˆ»ã‚’å–å¾—ã™ã‚‹ä¾‹ã§ã™ã€‚

```swift
import StoreKit

func fetchSubscriptionPurchaseDate() async throws -> Date? {
    // è³¼å…¥å±¥æ­´ã‚’å–å¾—
    let result = try await StoreKit.Transaction.latest(for: .currentUser)
    
    // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã«é–¢é€£ã™ã‚‹ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    for transaction in result {
        switch transaction.productType {
        case .autoRenewable:
            // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®å ´åˆã€è³¼å…¥æ—¥ã‚’å–å¾—
            return transaction.purchaseDate
        default:
            break
        }
    }
    return nil // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
}
```

### èª¬æ˜:
- `StoreKit.Transaction.latest(for:)` ã§ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³¼å…¥å±¥æ­´ã‚’å–å¾—ã—ã¾ã™ã€‚
- `transaction.productType == .autoRenewable` ã§è‡ªå‹•æ›´æ–°å‹ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã€`transaction.purchaseDate` ã‹ã‚‰è³¼å…¥æ—¥ã‚’å–å¾—ã—ã¾ã™ã€‚

ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥æ™‚åˆ»ï¼ˆ`Date`å‹ï¼‰ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã‚‚ã—ã‚‚è¤‡æ•°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹å ´åˆã‚„ã€ç‰¹å®šã®ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆIDã«ç´ä»˜ã„ãŸæƒ…å ±ã ã‘ã‚’å–å¾—ã—ãŸã„å ´åˆã¯ã€ã•ã‚‰ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/9/27 14:52:08*

ãã®ã‚¢ãƒ—ãƒªå†…ã§æœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ã‚‚ã®ã§å–å¾—ã—ãŸã„ã‚“ã 

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/9/27 14:52:25*

æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€`StoreKit2`ã®`Transaction`ã‚¯ãƒ©ã‚¹ã‚„`StoreKit.Product.SubscriptionInfo`ã‚’ä½¿ç”¨ã—ã¦ã€æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆç‰¹ã«æœªçµ‚äº†ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ï¼‰ã‚’ç¢ºèªã§ãã¾ã™ã€‚

`StoreKit.Transaction`ã®ä¸­ã§ã€æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã¯ã€`isUpgraded`, `revocationDate`, `expirationDate` ãªã©ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦æœ‰åŠ¹æ€§ã‚’åˆ¤æ–­ã—ã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥æ™‚åˆ»ã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã®ä¾‹ã§ã™ã€‚

### æ‰‹é †:
1. `StoreKit.Product.SubscriptionInfo.Status`ã‚’ä½¿ç”¨ã—ã¦ã€ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç¢ºèªã€‚
2. `expirationDate`ã‚„`isRevoked`ãªã©ã‚’ç¢ºèªã—ã¦ã€æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡ºã€‚
3. æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥æ™‚åˆ»ã‚’å–å¾—ã€‚

### ã‚³ãƒ¼ãƒ‰ä¾‹:

```swift
import StoreKit

func fetchActiveSubscriptionPurchaseDate() async throws -> Date? {
    // è³¼å…¥å±¥æ­´ã‚’å–å¾—
    let result = try await StoreKit.Transaction.latest(for: .currentUser)
    
    // è³¼å…¥å±¥æ­´ã‹ã‚‰æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    for transaction in result {
        switch transaction.productType {
        case .autoRenewable:
            if let expirationDate = transaction.expirationDate, expirationDate > Date() {
                // æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®å ´åˆã€è³¼å…¥æ—¥ã‚’è¿”ã™
                return transaction.purchaseDate
            }
        default:
            break
        }
    }
    return nil // æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
}
```

### èª¬æ˜:
- `StoreKit.Transaction.latest(for: .currentUser)` ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœ€æ–°ã®è³¼å…¥å±¥æ­´ã‚’å–å¾—ã—ã¾ã™ã€‚
- å„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®`productType`ã‚’ç¢ºèªã—ã€`autoRenewable`ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚
- `expirationDate`ã§ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹æœŸé™ã‚’ç¢ºèªã—ã€ç¾åœ¨ã®æ—¥ä»˜ã¨æ¯”è¼ƒã—ã¦æœ‰åŠ¹ãªå ´åˆã®ã¿è³¼å…¥æ—¥ã‚’è¿”ã—ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ã§ã‚ã‚‹å ´åˆã€ãã®è³¼å…¥æ—¥ã‚’å–å¾—ã§ãã¾ã™ã€‚

### è£œè¶³:
- `expirationDate`ãŒ`nil`ã®å ´åˆã¯ã€æ°¸ç¶šçš„ã«æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã¨è¦‹ãªã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ãŒã€é€šå¸¸ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã§ã¯ã“ã®å€¤ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚
- ã¾ãŸã€ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰/ãƒ€ã‚¦ãƒ³ã‚°ãƒ¬ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã¯`isUpgraded`ãƒ•ãƒ©ã‚°ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã“ã¨ã§ã€å¤ã„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/9/27 15:19:46*

æœ€æ–°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–æ¸ˆã¿ãª Transaction ã‚’è¿”ã™ã‚ˆã†ãªé–¢æ•°ã®æ–¹ãŒã‚ˆããªã„ã‹ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/9/27 15:20:03*

User prefers a function that returns the latest subscribed `Transaction` for in-app purchases.

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2024/9/27 15:20:03*

Model set context updated.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/9/27 15:20:03*

ç¢ºã‹ã«ã€æœ€æ–°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æ¸ˆã¿ã®`Transaction`ã‚’è¿”ã™é–¢æ•°ã‚’ä½œæˆã™ã‚‹æ–¹ãŒã€å†åˆ©ç”¨ã—ã‚„ã™ãã€ã‚ˆã‚Šã‚·ãƒ³ãƒ—ãƒ«ã«ç›®çš„ã‚’é”æˆã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ä»¥ä¸‹ã«ã€æœ€æ–°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–ã•ã‚ŒãŸ`Transaction`ã‚’è¿”ã™é–¢æ•°ã®ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

### æœ€æ–°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–æ¸ˆã¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™é–¢æ•°

```swift
import StoreKit

func fetchLatestSubscribedTransaction() async throws -> StoreKit.Transaction? {
    // è³¼å…¥å±¥æ­´ã‚’å–å¾—
    let result = try await StoreKit.Transaction.latest(for: .currentUser)
    
    // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥å±¥æ­´ã®ä¸­ã§æœ€æ–°ã‹ã¤æœ‰åŠ¹ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    for transaction in result {
        switch transaction.productType {
        case .autoRenewable:
            // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹æœŸé™ã‚’ç¢ºèª
            if let expirationDate = transaction.expirationDate, expirationDate > Date() {
                // æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿”ã™
                return transaction
            }
        default:
            break
        }
    }
    return nil // æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
}
```

### ä½¿ç”¨ä¾‹

ã“ã®é–¢æ•°ã‚’ä½¿ã£ã¦ã€ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–æ¸ˆã¿ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—ã—ã€ãã®è³¼å…¥æ—¥ã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã§ã™ã€‚

```swift
Task {
    do {
        if let transaction = try await fetchLatestSubscribedTransaction() {
            let purchaseDate = transaction.purchaseDate
            print("æœ€æ–°ã®è³¼å…¥æ—¥: \(purchaseDate)")
        } else {
            print("æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
        }
    } catch {
        print("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: \(error)")
    }
}
```

### èª¬æ˜:
- `fetchLatestSubscribedTransaction`é–¢æ•°ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³¼å…¥å±¥æ­´ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã—ã¾ã™ã€‚
- `transaction.expirationDate`ã§ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒã¾ã æœ‰åŠ¹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚
- ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ã§ã‚ã‚Œã°ã€ãã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã—ã¾ã™ã€‚

ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚Šã€ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–æ¸ˆã¿ã‹ã¤æœ‰åŠ¹ãª`Transaction`ã‚’ç°¡å˜ã«å–å¾—ã§ãã€å†åˆ©ç”¨ãŒã—ã‚„ã™ããªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/9/27 15:20:25*

æœ‰åŠ¹ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒè¤‡æ•°ã‚ã‚‹å ´åˆã¯ã©ã†ãªã®ã‹ï¼Ÿ

func fetchLatestSubscribedTransaction() async throws -&gt; StoreKit.Transaction? {
    // è³¼å…¥å±¥æ­´ã‚’å–å¾—
    let result = try await StoreKit.Transaction.latest(for: .currentUser)
    
    // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥å±¥æ­´ã®ä¸­ã§æœ€æ–°ã‹ã¤æœ‰åŠ¹ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    for transaction in result {
        switch transaction.productType {
        case .autoRenewable:
            // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹æœŸé™ã‚’ç¢ºèª
            if let expirationDate = transaction.expirationDate, expirationDate &gt; Date() {
                // æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿”ã™
                return transaction
            }
        default:
            break
        }
    }
    return nil // æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/9/27 15:20:40*

æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒè¤‡æ•°ã‚ã‚‹å ´åˆã€ãã‚Œã‚‰ã®ä¸­ã§æœ€ã‚‚æ–°ã—ã„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™ã“ã¨ãŒæœ›ã¾ã—ã„ã§ã™ã€‚ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸæœ‰åŠ¹ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã—ã¦ã„ã¾ã™ãŒã€è¤‡æ•°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹å ´åˆã€æœ€æ–°ã®ã‚‚ã®ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ—¥ä»˜ã§æ¯”è¼ƒã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ä»¥ä¸‹ã«ã€æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒè¤‡æ•°ã‚ã‚‹å ´åˆã«æœ€æ–°ã®ã‚‚ã®ã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

### æœ€æ–°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–æ¸ˆã¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™ï¼ˆè¤‡æ•°ã®æœ‰åŠ¹ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã«å¯¾å¿œï¼‰

```swift
import StoreKit

func fetchLatestSubscribedTransaction() async throws -> StoreKit.Transaction? {
    // è³¼å…¥å±¥æ­´ã‚’å–å¾—
    let result = try await StoreKit.Transaction.latest(for: .currentUser)
    
    // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã™ã¹ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    let validTransactions = result.filter { transaction in
        switch transaction.productType {
        case .autoRenewable:
            if let expirationDate = transaction.expirationDate {
                // æœ‰åŠ¹æœŸé™ãŒç¾åœ¨æ™‚åˆ»ã‚ˆã‚Šå¾Œã§ã‚ã‚Œã°æœ‰åŠ¹ã¨ã¿ãªã™
                return expirationDate > Date()
            }
        default:
            break
        }
        return false
    }
    
    // æœ€æ–°ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™
    return validTransactions.max(by: { $0.purchaseDate < $1.purchaseDate })
}
```

### èª¬æ˜:
- `result.filter`ã‚’ä½¿ã£ã¦ã€æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ã¿ã‚’æŠ½å‡ºã—ã¦ã„ã¾ã™ã€‚
- `expirationDate`ãŒç¾åœ¨ã®æ—¥ä»˜ã‚ˆã‚Šã‚‚å¾Œã§ã‚ã‚‹å ´åˆã€ãã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯æœ‰åŠ¹ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚
- è¤‡æ•°ã®æœ‰åŠ¹ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹å ´åˆã€`max(by:)`ã‚’ä½¿ã£ã¦ã€`purchaseDate`ãŒæœ€ã‚‚æ–°ã—ã„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—ã—ã¾ã™ã€‚

### ä½¿ç”¨ä¾‹

ã“ã®é–¢æ•°ã‚’ä½¿ã£ã¦ã€æœ€æ–°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–æ¸ˆã¿ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—ã§ãã¾ã™ã€‚

```swift
Task {
    do {
        if let transaction = try await fetchLatestSubscribedTransaction() {
            let purchaseDate = transaction.purchaseDate
            print("æœ€æ–°ã®è³¼å…¥æ—¥: \(purchaseDate)")
        } else {
            print("æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
        }
    } catch {
        print("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: \(error)")
    }
}
```

ã“ã‚Œã«ã‚ˆã‚Šã€è¤‡æ•°ã®æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚ã£ã¦ã‚‚ã€å¸¸ã«æœ€æ–°ã®ã‚‚ã®ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/9/27 15:22:09*

autoRenewable ã¨ã¯

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/9/27 15:22:27*

`autoRenewable` ã¯ã€`StoreKit` ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ä½¿ã‚ã‚Œã‚‹ `Product.ProductType` ã®ä¸€ã¤ã§ã€è‡ªå‹•æ›´æ–°å‹ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆAuto-Renewable Subscriptionï¼‰ã‚’æŒ‡ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€å®šæœŸçš„ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«èª²é‡‘ã•ã‚Œã‚‹ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãªã„é™ã‚Šã€è‡ªå‹•çš„ã«æ›´æ–°ã•ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚

### è‡ªå‹•æ›´æ–°å‹ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ (Auto-Renewable Subscription) ã®ç‰¹å¾´
- **è‡ªå‹•æ›´æ–°**: ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æœŸé–“ãŒçµ‚äº†ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã«æ¬¡ã®æœŸé–“ã«æ›´æ–°ã•ã‚Œã€èª²é‡‘ãŒç™ºç”Ÿã—ã¾ã™ã€‚
- **ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯App Storeã®è¨­å®šã§ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’ç®¡ç†ãŠã‚ˆã³ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ãã¾ã™ã€‚
- **ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æœŸé–“**: ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®æœŸé–“ã¯ã€é–‹ç™ºè€…ãŒé¸ã‚“ã æœŸé–“ï¼ˆä¾‹ãˆã°1é€±é–“ã€1ãƒ¶æœˆã€3ãƒ¶æœˆã€1å¹´ï¼‰ã”ã¨ã«æ›´æ–°ã•ã‚Œã¾ã™ã€‚
- **App Storeã§ã®ç®¡ç†**: ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®è³¼å…¥ã€æ›´æ–°ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãªã©ã¯ã™ã¹ã¦App Storeã«ã‚ˆã£ã¦ç®¡ç†ã•ã‚Œã¾ã™ã€‚

### ä¸»ãªç”¨é€”
è‡ªå‹•æ›´æ–°å‹ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã¯ã€ãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚¢ãƒ—ãƒªã€éŸ³æ¥½ãƒ»å‹•ç”»ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã€ãƒ•ã‚£ãƒƒãƒˆãƒã‚¹ã‚¢ãƒ—ãƒªã€æ•™è‚²ã‚¢ãƒ—ãƒªãªã©ã€å®šæœŸçš„ã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚„ã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›ã™ã‚‹ã‚¢ãƒ—ãƒªã§ã‚ˆãä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

### ä¾‹: 
ä¾‹ãˆã°ã€Spotifyã‚„Netflixãªã©ã®ã‚µãƒ¼ãƒ“ã‚¹ã¯è‡ªå‹•æ›´æ–°å‹ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯1ãƒ¶æœˆå˜ä½ã§æ–™é‡‘ãŒè‡ªå‹•çš„ã«èª²é‡‘ã•ã‚Œã€ç‰¹åˆ¥ãªæ“ä½œã‚’è¡Œã‚ãªã„é™ã‚Šã€æ¬¡ã®æœˆã‚‚ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒç¶™ç¶šã—ã¾ã™ã€‚

### `ProductType.autoRenewable` ã®ä½¿ç”¨
Swiftã§ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’æ‰±ã†éš›ã«ã¯ã€ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆãŒè‡ªå‹•æ›´æ–°å‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€`ProductType.autoRenewable`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

#### ä¾‹:
```swift
switch transaction.productType {
case .autoRenewable:
    print("ã“ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯è‡ªå‹•æ›´æ–°å‹ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚")
default:
    break
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`transaction.productType` ãŒ `.autoRenewable` ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã€è‡ªå‹•æ›´æ–°å‹ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã«å¯¾ã—ã¦ã®ã¿ç‰¹å®šã®å‡¦ç†ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/9/27 15:22:58*

ãã‚“ã–ã„ã—ãªã„ã®ã ãŒ

try await StoreKit.Transaction.latest(for: .currentUser)

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/9/27 15:23:15*

`StoreKit.Transaction.latest(for:)` ã¯ã€`StoreKit2`ã®APIã§ã™ãŒã€æœ€æ–°ã®`Transaction`ã‚’å–å¾—ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒ`latest(for:)`ã¨ã—ã¦ç›´æ¥å­˜åœ¨ã—ãªã„å ´åˆã€ä»£æ›¿ã®æ–¹æ³•ã¨ã—ã¦ã€`StoreKit.Transaction.all`ã‚’ä½¿ã£ã¦ã€è³¼å…¥å±¥æ­´å…¨ä½“ã‚’å–å¾—ã—ã€ãã®ä¸­ã‹ã‚‰æœ€æ–°ã®ã‚‚ã®ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€`StoreKit2`ã‚’ä½¿ç”¨ã—ã¦æœ€æ–°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã®ä¾‹ã§ã™ã€‚

### ä»£æ›¿ã‚³ãƒ¼ãƒ‰ä¾‹ï¼ˆ`all(for:)`ã‚’ä½¿ç”¨ï¼‰

```swift
import StoreKit

func fetchLatestSubscribedTransaction() async throws -> StoreKit.Transaction? {
    // ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã™ã¹ã¦ã®è³¼å…¥å±¥æ­´ã‚’å–å¾—
    let result = try await StoreKit.Transaction.all(for: .currentUser)
    
    // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    let validTransactions = result.compactMap { transaction in
        if transaction.productType == .autoRenewable, 
           let expirationDate = transaction.expirationDate,
           expirationDate > Date() {
            // æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿”ã™
            return transaction
        }
        return nil
    }
    
    // æœ€æ–°ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—
    return validTransactions.max(by: { $0.purchaseDate < $1.purchaseDate })
}
```

### èª¬æ˜:
- `StoreKit.Transaction.all(for:)` ã¯ã€æŒ‡å®šã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã™ã¹ã¦ã®è³¼å…¥å±¥æ­´ã‚’å–å¾—ã—ã¾ã™ã€‚
- `compactMap` ã‚’ä½¿ã£ã¦ã€`autoRenewable` ã‚¿ã‚¤ãƒ—ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã€`expirationDate`ãŒç¾åœ¨ã‚ˆã‚Šå¾Œã®æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ã¿ã‚’æ®‹ã—ã¾ã™ã€‚
- æœ€å¾Œã«ã€`purchaseDate`ãŒæœ€ã‚‚æ–°ã—ã„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã—ã¾ã™ã€‚

### ä½¿ç”¨ä¾‹

```swift
Task {
    do {
        if let transaction = try await fetchLatestSubscribedTransaction() {
            let purchaseDate = transaction.purchaseDate
            print("æœ€æ–°ã®è³¼å…¥æ—¥: \(purchaseDate)")
        } else {
            print("æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
        }
    } catch {
        print("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: \(error)")
    }
}
```

### è£œè¶³:
- `StoreKit.Transaction.all(for:)` ã‚’ä½¿ç”¨ã—ã¦ã€ã™ã¹ã¦ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—ã—ãŸå¾Œã€ç‰¹å®šã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
- `autoRenewable` ã‚„æœ‰åŠ¹æœŸé™ (`expirationDate`) ã‚’ä½¿ã£ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã€æœ€ã‚‚æ–°ã—ã„æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’é¸ã³ã¾ã™ã€‚

ã“ã®æ–¹æ³•ã«ã‚ˆã‚Šã€æœ€æ–°ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—ã§ãã¾ã™ã€‚

---
