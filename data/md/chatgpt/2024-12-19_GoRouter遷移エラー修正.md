# GoRouter遷移エラー修正

Date: 2024-12-19

---

## 👤 User
*2024-12-19 16:27:11*

この画面に遷移するとなぜかエラーになる
@pragma('vm:entry-point')
void _drawFrame() {
  PlatformDispatcher.instance._drawFrame();
}

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/screen.dart';

class MyPage extends HookConsumerWidget {
  const MyPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cameraList = List&lt;String&gt;.generate(10, (index) =&gt; 'Camera $index');

    return Scaffold(
      appBar: AppBar(title: const Text('MyPage')),
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ElevatedButton(
              onPressed: () {
                context.push(Screen.profile.path);
              },
              child: const Text('Profile'),
            ),
            Expanded(
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: cameraList.length,
                itemBuilder: (context, index) {
                  return ListTile(
                    title: Text(cameraList[index]),
                    onTap: () {
                      context.push(Screen.deckDetail.path);
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

---

## 🤖 Assistant
*2024-12-19 16:27:23*

このコードのエラー原因として考えられるポイントをいくつか挙げます。

1. **`context.push`でのパス不一致**  
   `Screen.profile.path`や`Screen.deckDetail.path`が適切に設定されていない可能性があります。`GoRouter`のルート設定にこれらのパスが正しく定義されているか確認してください。

   ```dart
   final router = GoRouter(
     routes: [
       GoRoute(
         path: '/profile',
         builder: (context, state) => const ProfilePage(),
       ),
       GoRoute(
         path: '/deckDetail',
         builder: (context, state) => const DeckDetailPage(),
       ),
     ],
   );
   ```

2. **`ListView.builder`での`Expanded`の使用**  
   `ListView.builder`が`Expanded`でラップされているため、UIのレイアウトに問題がある可能性があります。`Column`内で`Expanded`を使うと、他の要素と衝突する可能性があります。以下のように変更してみてください。

   ```dart
   return Scaffold(
     appBar: AppBar(title: const Text('MyPage')),
     body: Column(
       children: [
         ElevatedButton(
           onPressed: () {
             context.push(Screen.profile.path);
           },
           child: const Text('Profile'),
         ),
         Expanded(
           child: ListView.builder(
             itemCount: cameraList.length,
             itemBuilder: (context, index) {
               return ListTile(
                 title: Text(cameraList[index]),
                 onTap: () {
                   context.push(Screen.deckDetail.path);
                 },
               );
             },
           ),
         ),
       ],
     ),
   );
   ```

3. **GoRouterの初期化**  
   `GoRouter`のインスタンスが適切に初期化されていない場合、遷移時にエラーが発生する可能性があります。`MaterialApp.router`で`routerConfig`に`GoRouter`を渡しているか確認してください。

   ```dart
   void main() {
     final router = GoRouter(
       routes: [
         GoRoute(
           path: '/profile',
           builder: (context, state) => const ProfilePage(),
         ),
         GoRoute(
           path: '/deckDetail',
           builder: (context, state) => const DeckDetailPage(),
         ),
       ],
     );

     runApp(ProviderScope(
       child: MaterialApp.router(
         routerConfig: router,
       ),
     ));
   }
   ```

4. **プラグマの影響**  
   `_drawFrame`の記述が関係している可能性は低いですが、もしその部分がエラーのトリガーになっている場合は、フレーム描画がFlutterのランタイムに依存している可能性を検討してください。この部分が不要であれば削除してください。

上記の修正を試した後もエラーが発生する場合、エラーメッセージ全体を共有してください。それに基づいて詳細な原因を特定します。

---

## 👤 User
*2024-12-19 16:28:08*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-Xz7nXptAq9Dyf5Zdcb9QG5",
  "size_bytes": 132444,
  "width": 560,
  "height": 759,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
こういうエラーなんだ

---

## 🤖 Assistant
*2024-12-19 16:28:36*

このエラーに関連して、「Hero」や「visitChildren」というキーワードが表示されていることから、Flutterの`Hero`ウィジェットに関連した問題である可能性が高いです。具体的な問題と解決策を以下に説明します。

### 問題の可能性
1. **`Hero`タグの重複**
   - Flutterの`Hero`ウィジェットは、`tag`プロパティでユニークな値を必要とします。同じ`tag`を持つ`Hero`ウィジェットが複数存在すると、エラーが発生します。
   - 例えば、画面間で遷移するときに、同じ`tag`を持つ`Hero`が複数定義されていると、`Hero`ウィジェットが正しく動作せず、エラーが発生する可能性があります。

2. **`Hero`の使い方の不整合**
   - 遷移先画面で対応する`Hero`が存在しない、または不適切に設定されている場合も問題が発生します。

### 解決策
1. **`Hero`タグの確認と修正**
   - アプリ内の全ての`Hero`ウィジェットを確認し、それぞれの`tag`がユニークであることを確認してください。
   - 例:
     ```dart
     Hero(
       tag: 'uniqueTag1',
       child: Image.asset('image1.png'),
     )
     ```
     遷移先画面でも同じ`tag`を使用してください。
     ```dart
     Hero(
       tag: 'uniqueTag1',
       child: Image.asset('image1.png'),
     )
     ```

2. **`Hero`が不要であれば削除**
   - 現在の画面や遷移先で`Hero`アニメーションが必要ない場合は、`Hero`ウィジェットを削除することで問題を回避できます。

3. **エラーログをさらに確認**
   - エラーの完全なログを確認し、どのウィジェットまたはどの画面でエラーが発生しているのかを特定してください。

### 修正版例
以下は、`Hero`タグがユニークになるように調整した例です。

```dart
ListView.builder(
  itemCount: cameraList.length,
  itemBuilder: (context, index) {
    return ListTile(
      title: Hero(
        tag: 'cameraHero$index', // 各カメラにユニークなtagを割り当て
        child: Text(cameraList[index]),
      ),
      onTap: () {
        context.push(Screen.deckDetail.path);
      },
    );
  },
)
```

遷移先画面でも同じ`tag`を持つ`Hero`を定義してください。

```dart
class DeckDetailPage extends StatelessWidget {
  final int index;

  const DeckDetailPage({Key? key, required this.index}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Deck Detail')),
      body: Center(
        child: Hero(
          tag: 'cameraHero$index', // 遷移元と同じtagを使用
          child: Text('Detail of Camera $index'),
        ),
      ),
    );
  }
}
```

これで`Hero`アニメーションのエラーが解消される可能性があります。問題が続く場合は、エラーの詳細ログを共有してください。

---

## 👤 User
*2024-12-19 16:31:05*

以下のどれでもエラーになるみたい
context.push(Screen.myPage.path);
context.push(Screen.notificationList.path);
context.push(Screen.wallet.path);

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/design_token/app_theme.dart';
import 'package:snpit_guild_app/presentation/pages/explorer_list_page.dart';
import 'package:snpit_guild_app/presentation/pages/shootable_spot_detail_page.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/router/spot_list_router.dart';

class TabPage extends HookConsumerWidget {
  const TabPage({required this.navigationShell, super.key});
  final StatefulNavigationShell navigationShell;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref
      ..listen&lt;bool&gt;(showShootableSpotDetailNotifierProvider, (previous, next) {
        if (next) {
          _showShootableSpotDetailSheet(context, ref);
        }
      })
      ..listen&lt;bool&gt;(showExplorerListNotifierProvider, (previous, next) {
        if (next) {
          _showExploreListSheet(context, ref);
        }
      })
      ..listen&lt;bool&gt;(showSpotListNotifierProvider, (previous, next) {
        if (next) {
          _showSpotListSheet(context, ref);
        }
      });

    return Scaffold(
      appBar: AppBar(
        leadingWidth: 100,
        leading: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              icon: const Icon(Icons.person),
              onPressed: () {
                context.push(Screen.myPage.path);
              },
            ),
            IconButton(
              icon: const Icon(Icons.notifications),
              onPressed: () {
                context.push(Screen.notificationList.path);
              },
            ),
          ],
        ),
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 16),
            child: InkWell(
              onTap: () {
                context.push(Screen.wallet.path);
              },
              child: const Row(
                children: [
                  Icon(Icons.token, size: 20),
                  SizedBox(width: 4),
                  Text('35.05 STP'), // TODO: 仮データ
                ],
              ),
            ),
          ),
        ],
      ),
      body: navigationShell,
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: navigationShell.currentIndex,
        onTap: navigationShell.goBranch,
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.map), label: 'Map'),
          BottomNavigationBarItem(icon: Icon(Icons.group), label: 'Guild'),
        ],
      ),
    );
  }

  void _showShootableSpotDetailSheet(BuildContext context, WidgetRef ref) {
    showModalBottomSheet&lt;void&gt;(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        return const FractionallySizedBox(
          heightFactor: 0.5,
          child: ClipRRect(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
            child: ShootableSpotDetailPage(),
          ),
        );
      },
    ).then((_) {
      ref.read(showShootableSpotDetailNotifierProvider.notifier).hide();
    });
  }

  void _showExploreListSheet(BuildContext context, WidgetRef ref) {
    showModalBottomSheet&lt;void&gt;(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        return const FractionallySizedBox(
          heightFactor: 0.5,
          child: ClipRRect(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
            child: ExplorerListPage(),
          ),
        );
      },
    ).then((_) {
      ref.read(showExplorerListNotifierProvider.notifier).hide();
    });
  }

  void _showSpotListSheet(BuildContext context, WidgetRef ref) {
    // sheet が立ち上がるタイミングで最初の画面にリセットしないと、sheet を表示したときに前回閉じた画面が表示される
    spotListRouter.go(Screen.spotList.path);

    showModalBottomSheet&lt;void&gt;(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        return FractionallySizedBox(
          heightFactor: 0.5,
          child: ClipRRect(
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            child: MaterialApp.router(
              theme: appTheme,
              routerConfig: spotListRouter,
              debugShowCheckedModeBanner: false,
            ),
          ),
        );
      },
    ).then((_) {
      ref.read(showSpotListNotifierProvider.notifier).hide();
    });
  }
}

---

## 🤖 Assistant
*2024-12-19 16:31:35*

このコードを分析すると、以下のような原因が考えられます。特に、`context.push`を呼び出した際にエラーが発生する場合、`GoRouter`に関連する問題が考えられます。

---

### 考えられる原因と解決策

#### 1. **`Screen`のパスがGoRouterに正しく定義されていない**
`Screen.myPage.path`, `Screen.notificationList.path`, `Screen.wallet.path`に対応するパスが、`GoRouter`のルート設定で正しく定義されていない場合、エラーになります。

- **確認事項**:
  1. `Screen`の各パスがGoRouterで正しく設定されていることを確認してください。
  2. 各ルートに対して対応するページが正しく定義されていることを確認してください。

- **例**:
```dart
final GoRouter router = GoRouter(
  routes: [
    GoRoute(
      path: '/myPage',
      builder: (context, state) => const MyPage(),
    ),
    GoRoute(
      path: '/notificationList',
      builder: (context, state) => const NotificationListPage(),
    ),
    GoRoute(
      path: '/wallet',
      builder: (context, state) => const WalletPage(),
    ),
  ],
);
```

---

#### 2. **Navigatorが混在している**
コード内で`MaterialApp.router`を用いて`GoRouter`を設定していますが、同じアプリ内で異なる`Navigator`インスタンスを使用すると、ルート遷移で問題が発生することがあります。

- **確認事項**:
  - 全てのルート設定が`GoRouter`で統一されていることを確認してください。
  - 特に、`showModalBottomSheet`内で新しい`MaterialApp.router`を使用していますが、これが現在の`GoRouter`のコンテキストと干渉している可能性があります。

- **解決策**:
  `showModalBottomSheet`内で新しい`MaterialApp.router`を使用する代わりに、既存の`GoRouter`を使ってルート遷移を管理してください。

---

#### 3. **`StatefulNavigationShell`との互換性**
`StatefulNavigationShell`と`GoRouter`の設定が競合している可能性があります。

- **確認事項**:
  - `StatefulNavigationShell`が正しく初期化されているか確認してください。
  - 現在の`GoRouter`設定と`navigationShell`が連携して動作しているか確認してください。

- **解決策**:
  `navigationShell`で管理している状態を`GoRouter`の状態と同期させるコードを追加してください。

---

#### 4. **`showModalBottomSheet`の影響**
`showModalBottomSheet`を表示中に`context.push`を呼び出すと、`Navigator`のスタックが正しく処理されないことがあります。

- **解決策**:
  `context.push`を呼び出す際に、現在の`Navigator`が有効な状態かどうかを確認してください。また、シート表示中の遷移が必要ない場合は、シートを閉じてから遷移を行うように変更してください。

---

#### 5. **`context`が適切でない**
`context.push`で利用する`context`が、意図した`GoRouter`のコンテキストでない可能性があります。

- **解決策**:
  `BuildContext`をスコープ内で適切に渡していることを確認してください。また、`GoRouter.of(context).push(...)`を明示的に使用することで、`GoRouter`のインスタンスを直接指定して遷移できます。

---

### 修正版の例

以下は、上記の問題を考慮した修正版コードの例です。

```dart
class TabPage extends HookConsumerWidget {
  const TabPage({required this.navigationShell, super.key});
  final StatefulNavigationShell navigationShell;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.listen<bool>(showShootableSpotDetailNotifierProvider, (previous, next) {
      if (next) {
        _showShootableSpotDetailSheet(context, ref);
      }
    });

    return Scaffold(
      appBar: AppBar(
        leadingWidth: 100,
        leading: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              icon: const Icon(Icons.person),
              onPressed: () => GoRouter.of(context).push(Screen.myPage.path),
            ),
            IconButton(
              icon: const Icon(Icons.notifications),
              onPressed: () => GoRouter.of(context).push(Screen.notificationList.path),
            ),
          ],
        ),
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 16),
            child: InkWell(
              onTap: () => GoRouter.of(context).push(Screen.wallet.path),
              child: const Row(
                children: [
                  Icon(Icons.token, size: 20),
                  SizedBox(width: 4),
                  Text('35.05 STP'), // TODO: 仮データ
                ],
              ),
            ),
          ),
        ],
      ),
      body: navigationShell,
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: navigationShell.currentIndex,
        onTap: navigationShell.goBranch,
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.map), label: 'Map'),
          BottomNavigationBarItem(icon: Icon(Icons.group), label: 'Guild'),
        ],
      ),
    );
  }
}
```

---

### その他の調査ポイント
1. エラーログの詳細を確認して、具体的なエラー箇所を特定してください。
2. `Screen`クラスの実装が正しいか確認してください。

問題が解決しない場合は、`Screen`クラスや`GoRouter`設定の詳細を共有してください。

---

## 👤 User
*2024-12-19 16:32:42*

════════ Exception caught by scheduler library ═════════════════════════════════
The following assertion was thrown during a scheduler callback:
There are multiple heroes that share the same tag within a subtree.
Within each subtree for which heroes are to be animated (i.e. a PageRoute subtree), each Hero must have a unique non-null tag.
In this case, multiple heroes had the following tag: &lt;default FloatingActionButton tag&gt;
Here is the subtree for one of the offending heroes: Hero
    tag: &lt;default FloatingActionButton tag&gt;
    dependencies: [_ModalScopeStatus]
    state: _HeroState#141cb

When the exception was thrown, this was the stack:

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final locationAsync = ref.watch(currentLocationNotifierProvider);
    final googleMapController = useState&lt;GoogleMapController?&gt;(null);

    useEffect(
      () {
        final observer = _LifecycleObserver(
          onResume: () async {
            // フォアグラウンドに戻ってきたら位置情報を再取得
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    return Scaffold(
      body: locationAsync.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
            ),
            Center(
              child: ElevatedButton(
                onPressed: () =&gt; _checkCameraPermission(context, ref),
                child: const Icon(Icons.camera_alt),
              ),
            ),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  FloatingActionButton(
                    onPressed: () async {
                      final refreshedLocation = await ref
                          .read(currentLocationNotifierProvider.future);
                      final controller = googleMapController.value;
                      if (controller != null) {
                        await controller.animateCamera(
                          CameraUpdate.newLatLng(refreshedLocation),
                        );
                      }
                    },
                    child: const Icon(Icons.my_location),
                  ),
                  ElevatedButton(
                    onPressed: () =&gt; ref
                        .read(showExplorerListNotifierProvider.notifier)
                        .show(),
                    style: ElevatedButton.styleFrom(
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(16),
                      ),
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 12,
                      ),
                    ),
                    child: const Row(
                      children: [
                        Icon(Icons.explore),
                        SizedBox(width: 8),
                        Text('Explore'),
                      ],
                    ),
                  ),
                  FloatingActionButton(
                    onPressed: () =&gt;
                        ref.read(showSpotListNotifierProvider.notifier).show(),
                    child: const Icon(Icons.photo),
                  ),
                ],
              ),
            ),
          ],
        ),
        loading: () =&gt; const Center(child: CircularProgressIndicator()),
        error: (error, stack) =&gt; Center(
          child: ElevatedButton(
            onPressed: () async {
              final _ = await openAppSettings();
            },
            child: const Text('設定アプリから位置情報取得をONにしてください'),
          ),
        ),
      ),
    );
  }

  Future&lt;void&gt; _checkCameraPermission(
    BuildContext context,
    WidgetRef ref,
  ) async {
    // カメラの使用許可をリクエストする
    final status = await Permission.camera.request();

    if (status.isGranted) {
      // カメラの使用が許可された場合
      ref.read(showShootableSpotDetailNotifierProvider.notifier).show();
    } else if (status.isPermanentlyDenied) {
      // 永久に拒否されている場合
      if (context.mounted) {
        _showPermissionDialog(context);
      }
    } else {
      // その他のケース（拒否された場合など）
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('カメラの使用が許可されていません。')),
        );
      }
    }
  }

  void _showPermissionDialog(BuildContext context) {
    showDialog&lt;void&gt;(
      context: context,
      builder: (context) =&gt; AlertDialog(
        title: const Text('カメラの使用許可が必要です'),
        content: const Text('カメラを使用するには、設定でカメラの使用許可をオンにしてください。'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () async {
              final _ = await openAppSettings();
            },
            child: const Text('設定を開く'),
          ),
        ],
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## 🤖 Assistant
*2024-12-19 16:33:01*

このエラーは、`FloatingActionButton`ウィジェットが`Hero`ウィジェットとして内部的に使用しており、同じ`tag`（デフォルトでは`<default FloatingActionButton tag>`）を持つ複数の`FloatingActionButton`が同じツリー内に存在するために発生しています。`Hero`ウィジェットの`tag`はユニークでなければならないため、この競合が問題を引き起こしています。

### 解決方法

#### 1. **`FloatingActionButton`の`HeroTag`を指定する**
`FloatingActionButton`には、`heroTag`プロパティを使用して一意の値を指定できます。このプロパティを設定することで、`Hero`タグの競合を防ぐことができます。

修正版コード:
```dart
Positioned(
  bottom: 16,
  left: 16,
  right: 16,
  child: Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
      FloatingActionButton(
        heroTag: 'locationButton', // ユニークなタグを指定
        onPressed: () async {
          final refreshedLocation = await ref
              .read(currentLocationNotifierProvider.future);
          final controller = googleMapController.value;
          if (controller != null) {
            await controller.animateCamera(
              CameraUpdate.newLatLng(refreshedLocation),
            );
          }
        },
        child: const Icon(Icons.my_location),
      ),
      ElevatedButton(
        onPressed: () => ref
            .read(showExplorerListNotifierProvider.notifier)
            .show(),
        style: ElevatedButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 24,
            vertical: 12,
          ),
        ),
        child: const Row(
          children: [
            Icon(Icons.explore),
            SizedBox(width: 8),
            Text('Explore'),
          ],
        ),
      ),
      FloatingActionButton(
        heroTag: 'photoButton', // ユニークなタグを指定
        onPressed: () =>
            ref.read(showSpotListNotifierProvider.notifier).show(),
        child: const Icon(Icons.photo),
      ),
    ],
  ),
),
```

---

#### 2. **`Hero`アニメーションを無効化する**
もし`Hero`アニメーションが必要ない場合、`heroTag`に`null`を指定することでアニメーションを無効化できます。

修正版コード:
```dart
FloatingActionButton(
  heroTag: null, // Heroアニメーションを無効化
  onPressed: () async {
    final refreshedLocation = await ref
        .read(currentLocationNotifierProvider.future);
    final controller = googleMapController.value;
    if (controller != null) {
      await controller.animateCamera(
        CameraUpdate.newLatLng(refreshedLocation),
      );
    }
  },
  child: const Icon(Icons.my_location),
),
```

---

### 注意点
- `FloatingActionButton`を複数使用する場合は、**全てのボタンにユニークな`heroTag`を設定する**ことが推奨されます。
- `null`を指定するとアニメーションは無効化されますが、アニメーションを利用したスムーズな画面遷移が不要な場合にのみ選択してください。

これでエラーは解消されるはずです。問題が解決しない場合は、さらに詳細な状況を教えてください。

---
