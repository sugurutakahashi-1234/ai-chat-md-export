# チラつき防止方法

Date: 2025-02-10

---

## 👤 User
*2025-02-11 08:20:27*

こういう画面に二回目におとづれると前のデータが残っているので、一瞬前のデータが表示されたあとに、ローディングを挟んで、データが表示される。

前のデータが一瞬表示されることで画面がチラついてしまう。

これをちらつかない様にするためにどうすればいいか良いアドバイスが欲しい。

できることなら、二回目のローディングのときはローディングを表示せず、前回のデータを残しながら、値がきたら画面の内容を更新したい。 
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/infrastructure/entities/extensions/camera_dto_x.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/cameras/get_camera_list.dart';
import 'package:snpit_guild_app/presentation/providers/editing_camera_list.dart';
import 'package:snpit_guild_app/presentation/widgets/camera_row.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';

class CameraListPage extends HookConsumerWidget {
  const CameraListPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cameraListAsyncValue = ref.watch(getMyCameraListNotifierProvider);
    final editingCameraListStateValue =
        ref.watch(editingCameraListNotifierProvider);
    final selectedCameraIndexState = useState&lt;int?&gt;(null);
    final selectedCamera = useState&lt;CameraDTO?&gt;(null);

    Future&lt;void&gt; onTapPutCamera() async {
      final camera = selectedCamera.value;
      if (camera != null) {
        ref.read(editingCameraListNotifierProvider.notifier).addCamera(camera);
      }

      context.pop();
    }

    Future&lt;void&gt; onTapCamera(int index, CameraDTO camera) async {
      if (!context.mounted) {
        return;
      }

      selectedCameraIndexState.value = index;
      selectedCamera.value = camera;
    }

    useEffect(
      () {
        Future.microtask(() async {
          try {
            await ref
                .read(getMyCameraListNotifierProvider.notifier)
                .getMyCameraList();
          } on Exception catch (error) {
            if (context.mounted) {
              showErrorSnackBar(context, error);
            }
          }
        });
        return null;
      },
      [],
    );

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: false,
        title: const Text(
          'Camera list',
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: () {
              context.pop();
            },
          ),
        ],
      ),
      body: cameraListAsyncValue.when(
        data: (ownedCameraList) {
          final cameraList = ownedCameraList
                  ?.where(
                    (camera) =&gt; !editingCameraListStateValue.any(
                      (editingCamera) =&gt;
                          editingCamera.cameraId == camera.cameraId,
                    ),
                  )
                  .toList()
                  .sorted() ??
              [];

          if (cameraList.isEmpty) {
            return const Center(
              child: Text('No cameras available to select'),
            );
          }

          return Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: cameraList.asMap().entries.map((entry) {
                final index = entry.key;
                final camera = entry.value;

                return Padding(
                  padding: const EdgeInsets.only(bottom: 8),
                  child: Material(
                    color: Colors.transparent,
                    child: Ink(
                      decoration: BoxDecoration(
                        color: ColorToken.bg,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                          color: selectedCameraIndexState.value == index
                              ? ColorToken.primary
                              : ColorToken.border,
                        ),
                      ),
                      child: InkWell(
                        onTap: () async {
                          await onTapCamera(index, camera);
                        },
                        borderRadius: BorderRadius.circular(8),
                        child: CameraRow(camera: camera),
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
          );
        },
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Center(
            child: Text('Error: $error'),
          );
        },
      ),
      bottomNavigationBar: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: ElevatedButton(
            onPressed: cameraListAsyncValue.value
                        ?.where(
                          (camera) =&gt; !editingCameraListStateValue.any(
                            (editingCamera) =&gt;
                                editingCamera.cameraId == camera.cameraId,
                          ),
                        )
                        .isNotEmpty ==
                    true
                ? () async {
                    await onTapPutCamera();
                  }
                : null,
            child: const Text('Put Camera'),
          ),
        ),
      ),
    );
  }
}  import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:snpit_guild_app/domain/api_error.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';
import 'package:snpit_guild_app/utils/api_handling_utils.dart';

part 'get_camera_list.g.dart';

@Riverpod(keepAlive: true)
class GetMyCameraListNotifier extends _$GetMyCameraListNotifier {
  @override
  Future&lt;List&lt;CameraDTO&gt;?&gt; build() async =&gt; null;

  Future&lt;List&lt;CameraDTO&gt;&gt; getMyCameraList() async {
    state = const AsyncValue.loading();
    try {
      try {
        final api = await ref.watch(camerasApiProvider.future);
        final response = await api.camerasControllerGetBalance();
        debugPrint('Response Body: ${response.data}');
        debugPrint('Response Body.data: ${response.data?.data}');
        checkForApiError(response.data);
        final data = response.data?.data;
        if (data == null) {
          throw Exception('No data found');
        }
        state = AsyncValue.data(data);
        return data;
      } on DioException catch (error) {
        debugPrintDioException(error);
        checkForApiError(error.response?.data);
        rethrow;
      } on Exception {
        rethrow;
      }
    } on ApiError catch (error, stackTrace) {
      apiErrorHandling(error, ref);
      state = AsyncValue.error(error, stackTrace);
      rethrow;
    } on Exception catch (error, stackTrace) {
      debugPrint('Error: $error');
      state = AsyncValue.error(error, stackTrace);
      rethrow;
    }
  }
}

---

## 🔧 Tool
*2025-02-11 08:21:01*

**データの持続と変化の追跡**

ページを再訪問すると、一瞬古いデータが表示された後、新しいデータに切り替わる。古いデータを表示しながら新しいデータを読み込む方法を検討している。

**古いデータの管理**

古いデータを状態に保存し、新しいデータが来たときにUIがどのように表示するかを選択している。

**データ管理方法の見直し**

古いデータをキープしつつ、バックグラウンドで読み込み中の状態を示す変数を設定。データがロードされたら状態を更新している。

**データ更新の提案**

getMyCameraList関数を更新し、前回のデータを含む状態を作成したり、一時的なリフレッシュインジケーターを表示することで読み込みスピナーを条件付きで処理している。

**データの利用状況に応じたUIの切り替え**

データが既にある場合はそれを表示し、無い場合はスピナーを表示し、再ロードされたらUIを更新している。

**データとインジケーターの表示**

データの読み込み/エラー/完了時に表示を切り替え、前回のデータを進行中インジケーターと共に表示するオプションも考慮している。

**データとインジケーターの表示方法を考える**  
データの再読み込み後にUIを更新し、進行中インジケーターを使って以前のデータを表示するオプションを検討している。

**データの状態を管理する方法を模索中**  
AsyncValueGuardや他のパターンを使って手動でリフレッシュを処理し、ローカルな状態やプロバイダに古いデータを保つ方法を検討している。

**進行中のデータ処理**

古いデータがある場合はスピナーを表示せず、データを再取得してUIを更新している。これにより、進行中の操作がスムーズに行える。

**進行中のデータ更新を工夫する**  
古いデータを再利用し、進行中のデータを「球場インジケーター」で表示することで、フェードを防ぐ手法を取り入れている。

---

## 🤖 Assistant
*2025-02-11 08:21:01*

Flutter／Riverpod で「前のデータが一瞬表示されたあとに loading を挟んで新しいデータが出る」という“チラつき”を防ぎたい場合、**「すでにあるデータは保持しつつ、その裏で更新を走らせたい」**というアプローチがおすすめです。

よくあるパターンとしては、

1. **一度取得したデータが state に格納されている場合**  
   - もう一度データを取得しにいく際に `state = AsyncValue.loading()` にしないで、**「古いデータ（前回取得したデータ）を保持しつつ、読み込み中であることを別のフラグなどで管理する」**  
   - UI 側では、もし古いデータがあるならそれを表示し、“裏で” 新しいデータをロードして差し替えを行う。

2. Riverpod や Flutter_hooks などの機能を使って、**表示部分は常に「前回のデータ or 最新のデータ」を映し、読み込みのモーションを最小限にする**。

下記のような実装方法が考えられます。

---

## 1. 既存の `AsyncValue<List<CameraDTO>?>` を“ロード中”でも値を持たせる

### 実装の流れ

- **「データ取得開始 → すでに state にデータがあるならそれを保持したまま → fetch 完了後にデータ差し替え」**という流れにする。
- つまり、`getMyCameraList()` 内で無条件に `state = AsyncValue.loading()` を代入するのではなく、
  1. **もし state にデータがすでにあれば**（つまり二回目以降など）、いったん `state` を `AsyncValue.data(古いデータ)` のままにしておき、
  2. **裏で API を叩いて完了したら新しいデータを `state` に反映**  
  というふうに書き換えます。

### 具体例

```dart
Future<List<CameraDTO>> getMyCameraList() async {
  final oldData = state.valueOrNull; 
  // すでにデータがある場合、わざわざ state を loading にせず
  // 「前のデータは保持したまま裏で処理する」ようにする

  // もしまったくデータがなければ初回なので loading にする
  if (oldData == null) {
    state = const AsyncValue.loading();
  }

  try {
    final api = await ref.watch(camerasApiProvider.future);
    final response = await api.camerasControllerGetBalance();
    checkForApiError(response.data);
    final data = response.data?.data;
    if (data == null) {
      throw Exception('No data found');
    }
    // データ取得完了したら新しいデータを入れる
    state = AsyncValue.data(data);
    return data;
  } on DioException catch (error, stack) {
    // エラー発生時のハンドリング
    // （省略）
    rethrow;
  } on ApiError catch (error, stackTrace) {
    // APIエラー
    // （省略）
    rethrow;
  } on Exception catch (error, stackTrace) {
    // それ以外のエラー
    // （省略）
    rethrow;
  }
}
```

### UI 側での書き方の注意点

`cameraListAsyncValue.when(...)` の `loading` ケースには、「まったくの初回（データなし）でロード中」なのか「前回のデータはあって今リフレッシュ中」なのかで描画を変えると、チラつきを抑えやすくなります。

```dart
body: cameraListAsyncValue.when(
  data: (ownedCameraList) {
    // 普通にデータを表示
    final cameraList = ownedCameraList ?? [];
    // ...
    return 表示用Widget;
  },
  loading: () {
    // ここで cameraListAsyncValue.valueOrNull を見る
    final previousData = cameraListAsyncValue.valueOrNull;
    if (previousData != null) {
      // すでにデータを持っているなら、そのデータを表示しつつ
      // 「更新中である」ことを小さく示す（例：プルリフレッシュ用インジケータだけなど）
      return 表示用Widget(previousData); 
    } else {
      // データが一切ない場合は初回読み込みなので
      // Center(child: CircularProgressIndicator())
      return const Center(child: CircularProgressIndicator());
    }
  },
  error: (error, _) {
    return Text('Error: $error');
  },
),
```

こうすると、
- **初回表示時だけ** ローディングインジケータが出る  
- **2回目以降** は、いったん以前のデータを表示し続けながら“裏で取得”する  
ので、チラつき（前のデータが一瞬消えてローディング → 新データが出る）が起こらなくなります。

---

## 2. `keepAlive: true` と“そもそもページを離れても状態を破棄しない”方法

今回のコードでも `@Riverpod(keepAlive: true)` を使っているように見えますが、ページが破棄された後も `state` を保持するには有効です。ただし**「再度同じ画面に戻ってきた時に無条件にリロードを走らせてしまう」と、結局 UI では再描画が入ってしまう**ので、上記のように「ロード中でも前のデータを画面に表示し続ける」ロジックが必要です。

---

## 3. 画面遷移時にそもそも再取得させたくない場合

「もう保存されているデータが十分に最新なので、何もしないでいい」というケースでは、`useEffect` で `getMyCameraList()` を呼び出す処理を、二回目以降は呼ばないようにするなどの方法もあります。  
しかし、多くの場合は「戻ってきた際に最新化したい」という意図があると思うので、やはり「前のデータを保持したまま裏でリフレッシュする」が現場では多用されています。

---

## まとめ

- **「二回目以降は loading を表示せず、前回のデータを表示しながら差し替えたい」** → **「初回のみ `state = AsyncValue.loading()`、それ以降は前の `state` を持ちつつバックグラウンドで取得」** というロジックにする  
- UI 側では `loading:` ブロックの中でも「既存データがあるかどうか」で描画を出し分ける

このようにすると、二回目以降は**前のデータを保持し続けたまま**裏で API を叩くため、一瞬前のデータが消えてローディングインジケータに置き換わる、というチラつきを防止できます。ご参考になれば幸いです。

---

## 👤 User
*2025-02-11 08:38:21*

これはよくある書き方なのか？

---

## 🤖 Assistant
*2025-02-11 08:38:27*

はい、**Riverpod で「前回取得したデータを保持しつつ、裏で最新データを再取得する」パターンはよく使われる方法**です。  
というのも、Flutter アプリに限らず Web の React Query や SWR などでも、「古いデータをいったん表示しておきながら、非同期で最新データを取得して差し替える」アプローチはユーザー体験（チラつきを抑える）の観点から一般的だからです。

特にページを切り替えるたびにいったんローディングを出すと、前のデータが一瞬消えてしまい「チラつき」が発生しやすくなります。そのため、

- **初回ロード時：** state を `AsyncValue.loading()` にしてインジケータを出す  
- **2回目以降：** 「すでにあるデータを表示したまま裏で再取得」して、取得完了後に差し替える

という仕組みにすると、ユーザー側からは滑らかにデータが更新されているように見え、UI が突然リセットされる感じがなくなります。こうした書き方は実務でもよく見る“定番”パターンです。

---

## 👤 User
*2025-02-11 08:40:43*

return 表示用Widget(previousData); はどういうことなのか？なくても大丈夫なのか？

loading: () {
    // ここで cameraListAsyncValue.valueOrNull を見る
    final previousData = cameraListAsyncValue.valueOrNull;
    if (previousData != null) {
      // すでにデータを持っているなら、そのデータを表示しつつ
      // 「更新中である」ことを小さく示す（例：プルリフレッシュ用インジケータだけなど）
      return 表示用Widget(previousData); 
    } else {
      // データが一切ない場合は初回読み込みなので
      // Center(child: CircularProgressIndicator())
      return const Center(child: CircularProgressIndicator());
    }
  },

---

## 🔧 Tool
*2025-02-11 08:40:51*

**表示用Widgetでの対応**

返している`表示用Widget(previousData)`は古いデータを表示しつつ、新しいデータをロードしている。このステータス管理の一環で、スクリーンのちらつきを防ぐ役割を果たしているね。

---

## 🤖 Assistant
*2025-02-11 08:40:51*

`return 表示用Widget(previousData);` は、**「ロード中であっても前回のデータが存在するならば、それを使って UI を表示する」**という意図を実装している部分です。  

- **前回のデータ (`previousData`) があれば** → それを表示してチラつきを防ぐ  
- **前回のデータがなければ (null)** → 初回読み込みなので普通にローディングを出す  

もしここを削除して、ロード中は常に `Center(child: CircularProgressIndicator())` のみ表示するようにすると、

1. **初回ロード時** は問題ありませんが、  
2. **2回目以降** も再度ローディング画面に切り替わる  
   - その際、前回のデータが一瞬消えてしまう（チラつく原因）

という挙動になります。  

一方、**「ロード中でも前回のデータを表示したまま」** にすると、ユーザー視点では UI が途切れずに見えるため、チラつきを抑え、スムーズなアプリ体験を提供できます。したがって、**2回目以降の画面チラつきを防ぎたい場合は、この `return 表示用Widget(previousData);` のように“前回のデータを表示しておく”処理が重要**です。  

&gt; なくてもアプリとしては動きますが、「既にあるデータの再利用によるチラつき防止」ができなくなるので、**二回目以降もローディング画面に一瞬戻ってしまう**ことになります。

---

## 👤 User
*2025-02-11 08:41:50*

そもそも以下の制御でローディングにはならないのでは？

  if (oldData == null) {
    state = const AsyncValue.loading();
  }

---

## 🔧 Tool
*2025-02-11 08:42:05*

**データの状態を管理する**

oldDataがnullでない場合、stateをloadingに設定しない。古いデータを保持しつつ新しいデータを取得している。独自の変数を使って「loading中かどうか」を追跡している。

**古いデータを維持する方法**

oldDataがnullでないならstateをloadingにしない。新しいデータを取得中でも古いデータを表示し続けている。リフレッシュインジケーターを使って再読み込みを示している。

---

## 🤖 Assistant
*2025-02-11 08:42:05*

結論から言うと、**「二回目以降はローディング表示を出さず、前回のデータを表示したまま裏で再取得したい」という狙いであれば、その `if (oldData == null) { state = const AsyncValue.loading(); }` の制御で問題ありません**。  

つまり「すでに古いデータがある（`oldData != null`）なら、`state = loading` にせず、裏で API を叩いて取得し終わったら `state = AsyncValue.data(newData)` に上書きする」という方針です。  

これによって、二回目以降は**“ローディング画面が挟まらずに前回のデータを引き続き表示したまま”**になり、チラつきがなくなります。

---

## 実装意図

1. **初回（古いデータがない場合）**  
   - `oldData` が `null` → `state = const AsyncValue.loading();` としてローディング画面を表示する。  

2. **2回目以降（古いデータがある場合）**  
   - `oldData` が `null` ではない → ローディング状態にせず、**画面には前回のデータを表示したまま**  
   - その裏で非同期処理（API 叩き）を行い、**取得完了後に `state = AsyncValue.data(newData)`** をセットする。  

このようにすることで、**すでに保持しているデータがあるなら、わざわざローディング画面を出さずに（データを表示し続けて）裏で更新する**という流れになります。

---

## 「ローディング状態を出したい」場合はどうする？

もし「2回目以降も、微妙にローディングインジケータを出したい」場合は、別途「**リフレッシュ中である**」ことを示すためのフラグや UI を組み込む必要があります。

たとえば以下のような方法があります。

1. **Riverpod の `AsyncValue` を拡張する**  
   - 「前のデータを保持しつつ loading フラグを立てる」ために、`AsyncValue.data(...)` の状態を保持しながら別途「isRefreshing = true」のようなフラグを管理する。

2. **`AsyncValue.loading()` にはしないが、UI 側でリフレッシュインジケータを表示**  
   - Flutter の `RefreshIndicator` を使うなど、部分的に“ぐるぐる”を表示させて「再取得中である」ことだけはユーザーに分かるようにする。

たとえば、

```dart
final oldData = state.valueOrNull;
if (oldData == null) {
  // 初回: state をローディングにしてインジケータを出す
  state = const AsyncValue.loading();
} else {
  // 2回目以降: 画面表示用のデータは oldData を保持したまま
  // ただし、別のフラグなどを立てて「リフレッシュ中である」ことを示す方法はある
  // 例) ref.read(isRefreshingProvider.notifier).state = true;
}
// その後 API コール完了したら AsyncValue.data(newData) を入れて
// もし isRefreshingProvider を使っているなら state = false に戻す
```

- こうすることで、**ユーザーにはずっと前回のデータが表示**され、  
- 上部や画面内のどこかで「Now refreshing...」等の軽微なインジケータを出す  

という実装もよくあります。

---

## まとめ

- **`if (oldData == null)` の判定で “初回ロード時のみ state を loading にしている”** → 二回目以降は「前回データを表示しっぱなし」を実現している。  
- これにより、**二回目以降はローディング画面は挟まらず、チラつきが減る**。  
- もし「ローディング表示を出したい」場合は、`AsyncValue.loading()` に無条件にするのではなく、別途フラグなどで「リフレッシュ状態」を管理して UI を表示する手法がある。

結局、「二回目以降はローディングを出さない」というのが狙いであれば、このような制御で問題ありません。

---
