# æ­£æ–¹å½¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º

æ—¥ä»˜: 2025-01-22

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/1/22 12:44:53*

CameraPreview ã‚’æ­£æ–¹å½¢ã§è¡¨ç¤ºã—ãŸã„ã€‚
ä»¥ä¸‹ã ã¨ã€å†™çœŸã®ç¸¦é•·ã®æ˜ åƒã‚’ç„¡ç†ã‚„ã‚Šæ­£æ–¹å½¢ã«ã™ã‚‹ã®ã§ã€æ¨ªã«å¼•ãä¼¸ã°ã•ã‚ŒãŸå½¢ã«ãªã£ã¦ã—ã¾ã£ã¦ã„ã‚‹ã®ã§ä¿®æ­£ã—ãŸã„

import 'dart:io';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:image/image.dart' as img;
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/providers/camera_controller_provider.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/shot_photo.dart';
import 'package:snpit_guild_app/presentation/providers/weave_target_spot.dart';

class ShootingPage extends HookConsumerWidget {
  const ShootingPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cameraControllerState = ref.watch(cameraControllerProvider);
    final spotState = ref.watch(weaveTargetSpotNotifierProvider);
    final overlayImageUrl = spotState?.photoUrl ?? '';
    final overlayOpacity = useState&lt;double&gt;(0.5);
    final isProcessing = useState&lt;bool&gt;(false);

    // ã‚«ãƒ¡ãƒ©ã§æ’®å½±ã—ãŸç”»åƒã‚’æ­£æ–¹å½¢ã«ã‚¯ãƒ­ãƒƒãƒ—ã—ã¦è¿”ã™
    Future&lt;File&gt; takeSquarePicture(CameraController controller) async {
      final xFile = await controller.takePicture();

      final originalBytes = await xFile.readAsBytes();
      final originalImage = img.decodeImage(originalBytes);
      if (originalImage == null) {
        throw Exception('Failed to decode image');
      }

      final width = originalImage.width;
      final height = originalImage.height;
      final croppedSize = width &lt; height ? width : height;

      final xOffset = (width - croppedSize) ~/ 2;
      final yOffset = (height - croppedSize) ~/ 2;

      final cropped = img.copyCrop(
        originalImage,
        x: xOffset,
        y: yOffset,
        width: croppedSize,
        height: croppedSize,
      );

      final croppedBytes = img.encodeJpg(cropped);
      final file = File(xFile.path);
      await file.writeAsBytes(croppedBytes);

      return file;
    }

    Future&lt;void&gt; onTapCamera() async {
      if (cameraControllerState is AsyncData&lt;CameraController?&gt;) {
        final cameraController = cameraControllerState.value;
        if (cameraController == null) {
          debugPrint('CameraController is null');
          return;
        }

        if (!cameraController.value.isInitialized) {
          debugPrint('CameraController not initialized');
          return;
        }

        try {
          isProcessing.value = true;

          final xFile = await takeSquarePicture(cameraController);
          if (xFile.path.isNotEmpty) {
            final location =
                await ref.read(currentLocationNotifierProvider.future);

            ref
                .read(shotPhotoNotifierProvider.notifier)
                .shotPhoto(xFile.path, location);

            if (context.mounted) {
              await context.push(Screen.weaveSpot.path);
            }
          }
        } on CameraException catch (e) {
          debugPrint('takePicture failed: $e');
        } finally {
          isProcessing.value = false;
        }
      } else {
        debugPrint('Camera is not ready to take a picture yet');
      }
    }

    return cameraControllerState.when(
      loading: () =&gt; const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      ),
      error: (err, st) =&gt; Scaffold(
        body: Center(
          child: Text('Failed to initialize the camera: $err'),
        ),
      ),
      data: (cameraController) {
        if (cameraController == null) {
          return const Scaffold(
            body: Center(child: Text('Camera is not available')),
          );
        }

        if (!cameraController.value.isInitialized) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }

        return Scaffold(
          appBar: AppBar(
            backgroundColor: ColorPallet.gray1000,
          ),
          body: Stack(
            alignment: Alignment.center,
            children: [
              Column(
                children: [
                  Container(
                    height: 80,
                    color: ColorPallet.gray1000,
                  ),
                  Stack(
                    alignment: Alignment.center,
                    children: [
                      SizedBox(
                        width: MediaQuery.of(context).size.width,
                        height: MediaQuery.of(context).size.width,
                        child: CameraPreview(cameraController),
                      ),
                      if (overlayImageUrl.isNotEmpty)
                        SizedBox(
                          width: MediaQuery.of(context).size.width,
                          height: MediaQuery.of(context).size.width,
                          child: Opacity(
                            opacity: overlayOpacity.value,
                            child: Image.network(
                              overlayImageUrl,
                              fit: BoxFit.cover,
                            ),
                          ),
                        ),
                    ],
                  ),
                  Expanded(
                    child: Stack(
                      clipBehavior: Clip.none,
                      children: [
                        Container(color: ColorPallet.gray1000),
                        Column(
                          children: [
                            const SizedBox(height: 40),
                            Padding(
                              padding: const EdgeInsets.symmetric(
                                horizontal: 80,
                              ),
                              child: Slider(
                                activeColor: ColorToken.primary,
                                inactiveColor: ColorToken.secondary,
                                value: overlayOpacity.value,
                                onChanged: (v) =&gt; overlayOpacity.value = v,
                              ),
                            ),
                            Expanded(
                              child: Stack(
                                alignment: Alignment.center,
                                children: [
                                  // ãƒãƒ„ãƒœã‚¿ãƒ³ãŒæŠ¼ã›ã‚‹ã‚ˆã†ã« Row ã¨ Spacer ã§æç”»ç¯„å›²ã‚’åºƒã’ã¦ã„ã‚‹
                                  Row(
                                    children: [
                                      const Spacer(),
                                      GestureDetector(
                                        onTap: () async {
                                          await onTapCamera();
                                        },
                                        child: const CircleAvatar(
                                          radius: 36,
                                          backgroundColor:
                                              ColorToken.primaryLight,
                                          child: CircleAvatar(
                                            radius: 34,
                                            backgroundColor:
                                                ColorToken.primaryDark,
                                            child: Icon(
                                              Icons.camera_alt_outlined,
                                              color: ColorToken.text,
                                              size: 36,
                                            ),
                                          ),
                                        ),
                                      ),
                                      const Spacer(),
                                    ],
                                  ),
                                  Positioned(
                                    right: 56,
                                    child: Stack(
                                      alignment: Alignment.center,
                                      children: [
                                        CircleAvatar(
                                          radius: 18,
                                          backgroundColor: ColorToken.bgWhite
                                              .withValues(alpha: 0.2),
                                        ),
                                        IconButton(
                                          icon: const Icon(
                                            Icons.close,
                                            size: 24,
                                          ),
                                          color: ColorToken.text,
                                          onPressed: () async {
                                            context.pop();
                                          },
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              if (isProcessing.value)
                const Positioned.fill(
                  child: ColoredBox(
                    color: Colors.black45,
                    child: Center(
                      child: CircularProgressIndicator(),
                    ),
                  ),
                ),
            ],
          ),
        );
      },
    );
  }
}

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/1/22 12:45:32*

**Ensuring square alignment**

Taking a closer look at the CameraPreview aspect ratio, Iâ€™m working through ways to keep the preview square without stretching by using an AspectRatio widget.

**Ensuring aspect ratio**

Iâ€™m considering the use of AspectRatio or FittedBox to maintain a square preview while avoiding stretching. This approach should effectively accommodate the camera's aspect ratio constraints.

**Showcasing camera preview**

I'm examining a method to display a square camera preview by setting up a 1:1 AspectRatio, centering the preview, and cropping if necessary to respect the camera's aspect ratio constraints.

**Mapping the layout**

I'm experimenting with a `FittedBox` and `ClipRect` arrangement for a clear, undistorted square camera preview, adjusting the width and height according to the camera's aspect ratio.

**Evaluating fit strategies**

Iâ€™m gathering info on using a `AspectRatio` of 1.0 for a square preview. This might lead to letterboxing or pillarboxing, but it ensures the aspect ratio remains intact.

**Balancing aspect ratio**

Iâ€™m working through ensuring a square camera preview by scaling the preview to fit the container's width, while also considering the FittedBox method to manage aspect ratio discrepancies.

**Mapping camera preview**

Iâ€™m digging into how to maintain a non-stretched square camera preview by transforming it to fit the container's width, ensuring the aspect ratio is respected.

**Crafting the preview**

Iâ€™m finalizing a `ClipRect` and `FittedBox` setup to ensure the camera preview is both square and non-distorted by adjusting dimensions to fit the container's width.

**Finalizing the code**

Iâ€™m wrapping up the code snippet to ensure the camera preview is a square, non-distorted, and clipped to fit the container's dimensions.

**Combining elements**

Iâ€™m mulling over a stack to merge the clipped and overlaid camera preview, ensuring a square preview that respects aspect ratio constraints and applies an overlay if present.

**Adjusting the preview**

Iâ€™m piecing together a code snippet to ensure the camera preview in portrait mode maintains its aspect ratio without stretching, effectively using the width to determine the height.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/1/22 12:45:32*

`CameraPreview` ã«ã‚ˆã‚‹æ˜ åƒã‚’æ­£æ–¹å½¢é ˜åŸŸã«ã€Œæ­ªã¾ãšã€åã‚ãŸã„å ´åˆã¯ã€**å˜ã« width ã¨ height ã‚’åŒã˜ã«æŒ‡å®šã™ã‚‹ã ã‘ã§ã¯ç¸¦æ¨ªæ¯”ãŒå´©ã‚Œã¦ã‚¹ãƒˆãƒ¬ãƒƒãƒã•ã‚Œã‚‹**ã®ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ã« ClipRect ã‚„ FittedBox ãªã©ã‚’çµ„ã¿åˆã‚ã›ã¦â€œãƒˆãƒªãƒŸãƒ³ã‚°â€ã•ã‚Œã‚‹å½¢ã§ã¡ã‚‡ã†ã©æ­£æ–¹å½¢ã«ãŠã•ã¾ã‚‹ã‚ˆã†ã«ã™ã‚‹æ–¹æ³•ãŒã‚ˆãä½¿ã‚ã‚Œã¾ã™ã€‚

---

## ãƒã‚¤ãƒ³ãƒˆ

1. **è¡¨ç¤ºé ˜åŸŸï¼ˆå¤–å´ï¼‰ã¯æ­£æ–¹å½¢** ã‚’ç”¨æ„ã™ã‚‹  
   - `SizedBox` ãªã©ã§ `width` ã¨ `height` ã‚’åŒã˜ã«ã™ã‚‹ã€‚
2. **å®Ÿéš›ã®ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå†…å´ï¼‰ã®ç¸¦æ¨ªæ¯”ã¯ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ** ã™ã‚‹  
   - `FittedBox` + `BoxFit.cover` ã§å¤–æ ã‚’åŸ‹ã‚ã‚‹ã‚ˆã†ã«æ‹¡å¤§/ãƒˆãƒªãƒŸãƒ³ã‚°ã™ã‚‹ã€‚
   - ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã¯ `cameraController.value.aspectRatio` ã‹ã‚‰å–å¾—ã§ãã‚‹ï¼ˆæ¨ªå¹…Ã·ç¸¦å¹…ï¼‰ã€‚

```
æ­£æ–¹å½¢é ˜åŸŸ (å¤–æ )
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   1:1 (width=height)â”‚
 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
 â”‚  â”‚ã‚«ãƒ¡ãƒ©æ˜ åƒ   â”‚    â”‚ â† ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
 â”‚  â”‚ (FittedBoxã§   â”‚    â”‚    ç¸¦æ¨ªæ¯”ç¶­æŒï¼†æ‹¡å¤§)
 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ã“ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ã‚«ãƒ¡ãƒ©æ˜ åƒã®ç¸¦æ¨ªæ¯”ã¯å´©ã‚Œãšã€æ­£æ–¹å½¢ã«åˆ‡ã‚Šå–ã‚‰ã‚ŒãŸã€Œè¦‹ãŸç›®ã€ã«ãªã‚Šã¾ã™ã€‚

---

## å®Ÿè£…ä¾‹

ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€å®Ÿéš›ã«æ’®å½±é ˜åŸŸã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒã‚’**æ­£æ–¹å½¢ã«é‡ã­ã¦è¡¨ç¤º**ã™ã‚‹éƒ¨åˆ†ã ã‘ã‚’æŠœç²‹ã—ã¦ä¿®æ­£ã—ã¦ã„ã¾ã™ã€‚

```dart
// ãŸã¨ãˆã° build(...) å†…ã®ã‚«ãƒ¡ãƒ©æ˜ åƒè¡¨ç¤ºéƒ¨åˆ†ã ã‘å·®ã—æ›¿ãˆ
final screenWidth = MediaQuery.of(context).size.width;
// ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‹ã‚‰å–å¾—ã§ãã‚‹ã€Œæ¨ªå¹… Ã· ç¸¦å¹…ã€(ä¾‹: 16/9 = 1.777...)
final cameraAspectRatio = cameraController.value.aspectRatio;

// ã“ã“ãŒæ­£æ–¹å½¢ã§è¡¨ç¤ºã™ã‚‹éƒ¨åˆ†
SizedBox(
  width: screenWidth,
  height: screenWidth,
  child: Stack(
    children: [
      // --- ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ ã„ã£ã±ã„ã«ãƒˆãƒªãƒŸãƒ³ã‚°ã—ã¦è¡¨ç¤º ---
      ClipRect(
        child: FittedBox(
          fit: BoxFit.cover,
          child: SizedBox(
            // ã‚«ãƒ¡ãƒ©ã®å®Ÿéš›ã®ç¸¦æ¨ªæ¯”ã‚’ç¶­æŒã—ãŸã¾ã¾ã€FittedBox ã§æ‹¡å¤§ã•ã‚Œã‚‹åœŸå°ã‚’ä½œã‚‹
            width: screenWidth,
            height: screenWidth / cameraAspectRatio,
            child: CameraPreview(cameraController),
          ),
        ),
      ),
      // --- ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒ (ã‚‚ã—ã‚ã‚Œã°) ã‚‚åŒã˜ã‚ˆã†ã«é‡ã­ã‚‹ ---
      if (overlayImageUrl.isNotEmpty)
        Opacity(
          opacity: overlayOpacity.value,
          // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒã‚‚æ­£æ–¹å½¢é ˜åŸŸå†…ã§ cover ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
          child: ClipRect(
            child: FittedBox(
              fit: BoxFit.cover,
              child: SizedBox(
                width: screenWidth,
                height: screenWidth,
                // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¯ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ãŒã©ã†ã§ã‚ã‚Œã€æ­£æ–¹å½¢ã‚¨ãƒªã‚¢ã«åã‚ãŸã„å ´åˆã¯
                // ã‚«ãƒ¡ãƒ©ã¨åŒã˜ã cover ã—ã¦ãƒˆãƒªãƒŸãƒ³ã‚°ã™ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯åˆ¥é€” adjust ã™ã‚‹
                child: Image.network(overlayImageUrl, fit: BoxFit.cover),
              ),
            ),
          ),
        ),
    ],
  ),
),
```

### è§£èª¬

- `SizedBox(width: screenWidth, height: screenWidth)`  
  - **å¤–å´ã®è¡¨ç¤ºé ˜åŸŸã‚’æ­£æ–¹å½¢**ã«å›ºå®šã—ã¦ã„ã¾ã™ã€‚
- `ClipRect` + `FittedBox(fit: BoxFit.cover)`  
  - `FittedBox` ã«ã‚ˆã£ã¦ã€ä¸­ã«ã‚ã‚‹ `SizedBox`(ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼) ã‚’ **å¤–å´ã®æ­£æ–¹å½¢ã«å¯¾ã—ã¦æ‹¡å¤§ç¸®å°ï¼†ãƒˆãƒªãƒŸãƒ³ã‚°**ã—ã¦è¡¨ç¤ºã—ã¦ãã‚Œã¾ã™ã€‚
  - `BoxFit.cover` ã¯ã€Œå¤–æ ã‚’åŸ‹ã‚ã‚‹ã‚ˆã†ã«æ‹¡å¤§ã—ã€æº¢ã‚ŒãŸéƒ¨åˆ†ã¯åˆ‡ã‚Šæ¨ã¦ã‚‹ã€æŒ™å‹•ã§ã™ã€‚
- `SizedBox(width: screenWidth, height: screenWidth / cameraAspectRatio)`  
  - ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã®å®Ÿéš›ã®é ˜åŸŸã§ã™ã€‚  
  - ã“ã“ã¯ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯” (`cameraAspectRatio`) ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã«ã€Œå¹…=ç”»é¢å¹…ã€ã€Œé«˜ã•=å¹…Ã·(æ¨ªå¹…/ç¸¦å¹…)ã€ã¨ã„ã†è¨ˆç®—ã«ãªã£ã¦ã„ã¾ã™ã€‚ã‚‚ã—ç¸¦æ¨ªé€†ã§åˆã‚ãªã„å ´åˆã¯ `1 / cameraAspectRatio` ã‚’ä½¿ã†ãªã©èª¿æ•´ã—ã¦ãã ã•ã„ã€‚

---

## ã‚ˆã‚Šç°¡å˜ãªæ›¸ãæ–¹ (ç¸¦æ¨ªå›ºå®šã§ã‚ˆã„å ´åˆ)

ã‚‚ã—ã€Œç¸¦æ¨ªã«åˆã‚ã›ã¦è¡¨ç¤ºã—ã¤ã¤ã€è¡¨ç¤ºé ˜åŸŸã®å½¢ã ã‘ã‚’æ­£æ–¹å½¢ã«ã—ãŸã„ã€ã¨ã„ã†ã‚·ãƒ³ãƒ—ãƒ«ãªè¦æœ›ã®å ´åˆã¯ã€`AspectRatio` ã‚’ä½¿ã£ã¦æ­£æ–¹å½¢ (`aspectRatio: 1.0`) ã«ã—ã€ãã“ã« `CameraPreview` ã‚’ `BoxFit.cover` ã£ã½ããƒˆãƒªãƒŸãƒ³ã‚°è¡¨ç¤ºã™ã‚‹å®Ÿè£…ã§ã‚‚ã‚ˆã„ã§ã—ã‚‡ã†ã€‚
ãŸã ã— `CameraPreview` ã¯ãã®ã¾ã¾ã§ã¯ `BoxFit` ã‚’ç›´æ¥æŒ‡å®šã§ããªã„ã®ã§ã€ã‚„ã¯ã‚Š `FittedBox` ãªã©ã§åŒ…ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

---

ã“ã†ã—ãŸå®Ÿè£…ã«ã‚ˆã£ã¦ã€

1. ã‚«ãƒ¡ãƒ©æ˜ åƒã®ç¸¦æ¨ªæ¯”ã¯ãã®ã¾ã¾ç¶­æŒã•ã‚Œã‚‹ (æ­ªã¾ãªã„)
2. UI ä¸Šã¯æ­£æ–¹å½¢ã®é ˜åŸŸã«ãƒ”ãƒƒã‚¿ãƒªã‚«ãƒãƒ¼ã•ã‚Œã‚‹ãŸã‚ã€ä½™ç™½ã‚„é»’å¸¯ãŒå‡ºãšã€ä¸Šä¸‹orå·¦å³ãŒé©åˆ‡ã«ãƒˆãƒªãƒŸãƒ³ã‚°ã•ã‚Œã‚‹

ã¨ã„ã†å½¢ã§**è‡ªç„¶ã«æ­£æ–¹å½¢ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å®Ÿè£…**ã§ãã¾ã™ã€‚ãŠè©¦ã—ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/1/22 12:58:30*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-DmaLbLAqHg2RK1KCcQbSjk",
  "size_bytes": 205983,
  "width": 960,
  "height": 1280,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
ã“ã®ã‚ˆã†ã«ã†ã¾ãã„ã‹ãªã‹ã£ãŸã€‚æ­£æ–¹å½¢ã«æ˜ åƒãŒå‡ºåŠ›ã•ã‚Œã¦ã„ãªã„

import 'dart:io';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:image/image.dart' as img;
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/providers/camera_controller_provider.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/shot_photo.dart';
import 'package:snpit_guild_app/presentation/providers/weave_target_spot.dart';

class ShootingPage extends HookConsumerWidget {
  const ShootingPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cameraControllerState = ref.watch(cameraControllerProvider);
    final spotState = ref.watch(weaveTargetSpotNotifierProvider);
    final overlayImageUrl = spotState?.photoUrl ?? '';
    final overlayOpacity = useState&lt;double&gt;(0.5);
    final isProcessing = useState&lt;bool&gt;(false);

    // ã‚«ãƒ¡ãƒ©ã§æ’®å½±ã—ãŸç”»åƒã‚’æ­£æ–¹å½¢ã«ã‚¯ãƒ­ãƒƒãƒ—ã—ã¦è¿”ã™
    Future&lt;File&gt; takeSquarePicture(CameraController controller) async {
      final xFile = await controller.takePicture();

      final originalBytes = await xFile.readAsBytes();
      final originalImage = img.decodeImage(originalBytes);
      if (originalImage == null) {
        throw Exception('Failed to decode image');
      }

      final width = originalImage.width;
      final height = originalImage.height;
      final croppedSize = width &lt; height ? width : height;

      final xOffset = (width - croppedSize) ~/ 2;
      final yOffset = (height - croppedSize) ~/ 2;

      final cropped = img.copyCrop(
        originalImage,
        x: xOffset,
        y: yOffset,
        width: croppedSize,
        height: croppedSize,
      );

      final croppedBytes = img.encodeJpg(cropped);
      final file = File(xFile.path);
      await file.writeAsBytes(croppedBytes);

      return file;
    }

    Future&lt;void&gt; onTapCamera() async {
      if (cameraControllerState is AsyncData&lt;CameraController?&gt;) {
        final cameraController = cameraControllerState.value;
        if (cameraController == null) {
          debugPrint('CameraController is null');
          return;
        }

        if (!cameraController.value.isInitialized) {
          debugPrint('CameraController not initialized');
          return;
        }

        try {
          isProcessing.value = true;

          final xFile = await takeSquarePicture(cameraController);
          if (xFile.path.isNotEmpty) {
            final location =
                await ref.read(currentLocationNotifierProvider.future);

            ref
                .read(shotPhotoNotifierProvider.notifier)
                .shotPhoto(xFile.path, location);

            if (context.mounted) {
              await context.push(Screen.weaveSpot.path);
            }
          }
        } on CameraException catch (e) {
          debugPrint('takePicture failed: $e');
        } finally {
          isProcessing.value = false;
        }
      } else {
        debugPrint('Camera is not ready to take a picture yet');
      }
    }

    final screenWidth = MediaQuery.of(context).size.width;

    return cameraControllerState.when(
      loading: () =&gt; const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      ),
      error: (err, st) =&gt; Scaffold(
        body: Center(
          child: Text('Failed to initialize the camera: $err'),
        ),
      ),
      data: (cameraController) {
        if (cameraController == null) {
          return const Scaffold(
            body: Center(child: Text('Camera is not available')),
          );
        }

        if (!cameraController.value.isInitialized) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }

        return Scaffold(
          appBar: AppBar(
            backgroundColor: ColorPallet.gray1000,
          ),
          body: Stack(
            alignment: Alignment.center,
            children: [
              Column(
                children: [
                  Container(
                    height: 80,
                    color: ColorPallet.gray1000,
                  ),
                  SizedBox(
                    width: screenWidth,
                    height: screenWidth,
                    child: Stack(
                      children: [
                        ClipRect(
                          child: FittedBox(
                            fit: BoxFit.cover,
                            child: SizedBox(
                              width: screenWidth,
                              height: screenWidth /
                                  cameraController.value.aspectRatio,
                              child: CameraPreview(cameraController),
                            ),
                          ),
                        ),
                        if (overlayImageUrl.isNotEmpty)
                          Opacity(
                            opacity: overlayOpacity.value,
                            child: ClipRect(
                              child: FittedBox(
                                fit: BoxFit.cover,
                                child: SizedBox(
                                  width: screenWidth,
                                  height: screenWidth,
                                  child: Image.network(
                                    overlayImageUrl,
                                    fit: BoxFit.cover,
                                  ),
                                ),
                              ),
                            ),
                          ),
                      ],
                    ),
                  ),
                  Expanded(
                    child: Stack(
                      clipBehavior: Clip.none,
                      children: [
                        Container(color: ColorPallet.gray1000),
                        Column(
                          children: [
                            const SizedBox(height: 40),
                            Padding(
                              padding: const EdgeInsets.symmetric(
                                horizontal: 80,
                              ),
                              child: Slider(
                                activeColor: ColorToken.primary,
                                inactiveColor: ColorToken.secondary,
                                value: overlayOpacity.value,
                                onChanged: (v) =&gt; overlayOpacity.value = v,
                              ),
                            ),
                            Expanded(
                              child: Stack(
                                alignment: Alignment.center,
                                children: [
                                  // ãƒãƒ„ãƒœã‚¿ãƒ³ãŒæŠ¼ã›ã‚‹ã‚ˆã†ã« Row ã¨ Spacer ã§æç”»ç¯„å›²ã‚’åºƒã’ã¦ã„ã‚‹
                                  Row(
                                    children: [
                                      const Spacer(),
                                      GestureDetector(
                                        onTap: () async {
                                          await onTapCamera();
                                        },
                                        child: const CircleAvatar(
                                          radius: 36,
                                          backgroundColor:
                                              ColorToken.primaryLight,
                                          child: CircleAvatar(
                                            radius: 34,
                                            backgroundColor:
                                                ColorToken.primaryDark,
                                            child: Icon(
                                              Icons.camera_alt_outlined,
                                              color: ColorToken.text,
                                              size: 36,
                                            ),
                                          ),
                                        ),
                                      ),
                                      const Spacer(),
                                    ],
                                  ),
                                  Positioned(
                                    right: 56,
                                    child: Stack(
                                      alignment: Alignment.center,
                                      children: [
                                        CircleAvatar(
                                          radius: 18,
                                          backgroundColor: ColorToken.bgWhite
                                              .withValues(alpha: 0.2),
                                        ),
                                        IconButton(
                                          icon: const Icon(
                                            Icons.close,
                                            size: 24,
                                          ),
                                          color: ColorToken.text,
                                          onPressed: () async {
                                            context.pop();
                                          },
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              if (isProcessing.value)
                const Positioned.fill(
                  child: ColoredBox(
                    color: Colors.black45,
                    child: Center(
                      child: CircularProgressIndicator(),
                    ),
                  ),
                ),
            ],
          ),
        );
      },
    );
  }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/1/22 12:59:11*

ã”è³ªå•ã®ã‚³ãƒ¼ãƒ‰ã¯æ¦‚ã­ã€Œæ­£æ–¹å½¢ã®æ ã«å¯¾ã—ã¦ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’ã‚«ãƒãƒ¼è¡¨ç¤ºã™ã‚‹ã€ã¨ã„ã†æµã‚Œã«ãªã£ã¦ã„ã¾ã™ãŒã€**`cameraController.value.aspectRatio` ãŒç«¯æœ«ã‚„å‘ãã«ã‚ˆã£ã¦æƒ³å®šã¨é€†ã«ãªã‚‹**ãªã©ã®ç†ç”±ã§ã€æƒ³å®šå¤–ã«å¤§ããï¼ˆã‚ã‚‹ã„ã¯å°ã•ãï¼‰ãƒˆãƒªãƒŸãƒ³ã‚°ã•ã‚Œã¦ã—ã¾ã†ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚

ä»¥ä¸‹ã®ãƒã‚¤ãƒ³ãƒˆã‚’ç¢ºèªãƒ»ä¿®æ­£ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

---

## 1. ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯” (aspectRatio) ã®å‘ãã‚’ç¢ºèªã™ã‚‹

`cameraController.value.aspectRatio` ã¯ **é€šå¸¸ã€Œæ¨ªå¹… Ã· ç¸¦å¹…ã€** ã§è¿”ã£ã¦ãã¾ã™ã€‚  
- ç«¯æœ«ãŒç¸¦å‘ãã®å ´åˆãªã©ã¯ã€Œ0.7ã€ã‚„ã€Œ0.56ã€ã®ã‚ˆã†ãª **1 æœªæº€** ã®å€¤ã«ãªã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚  
- ç«¯æœ«ãŒæ¨ªå‘ãï¼ˆã‚ã‚‹ã„ã¯ã‚«ãƒ¡ãƒ©ãŒæ¨ªé•·ã®è§£åƒåº¦ï¼‰ãªã‚‰ã€1.3 ãªã© **1 ã‚’è¶…ãˆã‚‹**å€¤ã«ãªã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚

**æ­£æ–¹å½¢ã®é ˜åŸŸ (å¹… = `screenWidth`, é«˜ã• = `screenWidth`)** ã«å¯¾ã—ã¦ã€Œã‚«ãƒ¡ãƒ©æ˜ åƒã‚’ BoxFit.cover ã§åã‚ãŸã„ã€ã®ãŒç›®çš„ãªã‚‰ã€å†…éƒ¨ã§ä½¿ã† `SizedBox` å´ã¯

```dart
width: screenWidth,
height: screenWidth / cameraController.value.aspectRatio,
```

ã§ OK ãªå ´åˆã‚‚ã‚ã‚Œã°ã€é€†ã«

```dart
width: screenWidth * cameraController.value.aspectRatio,
height: screenWidth,
```

ãŒæ­£è§£ã«ãªã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚  
**å€¤ãŒ 1 æœªæº€ or 1 è¶… ãªã®ã‹**ã§ã©ã¡ã‚‰ãŒã€Œæ­£ã—ãã‚«ãƒãƒ¼è¡¨ç¤ºã•ã‚Œã‚‹ã‹ã€ãŒå¤‰ã‚ã‚‹ãŸã‚ã€ä¸€åº¦ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«

```dart
print('cameraAspectRatio: ${cameraController.value.aspectRatio}');
```

ã¨ã—ã¦ã€å®Ÿæ©Ÿã§ã©ã®ã‚ˆã†ãªæ•°å€¤ãŒå‡ºã¦ã„ã‚‹ã‹ç¢ºã‹ã‚ã‚‹ã¨ã‚ˆã„ã§ã—ã‚‡ã†ã€‚

> - **ç«¯æœ«ãŒç¸¦å‘ã**ã§ `aspectRatio` ãŒãŸã¨ãˆã° `0.5625`ï¼ˆ9:16ï¼‰ãªã‚‰ã°  
>   `height: screenWidth / 0.5625 = screenWidth * 1.777...` ã¨ãªã‚Šã€  
>   æ­£æ–¹å½¢ã‚ˆã‚Šã‚‚ã€Œç¸¦ã«é•·ã„ã€ã‚µã‚¤ã‚ºã«ãªã‚‹ã®ã§ä¸Šä¸‹ãŒãƒˆãƒªãƒŸãƒ³ã‚°ã•ã‚Œã¦æ­£æ–¹å½¢ã«åã¾ã‚Šã¾ã™ã€‚  
>   
> - **ç«¯æœ«ãŒæ¨ªå‘ã**ã§ `aspectRatio` ãŒ 1.777...ï¼ˆ16:9ï¼‰ã«ãªã‚‹ãªã‚‰ã°  
>   é€†ã« `width: screenWidth * aspectRatio` ãŒæ­£ã—ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

**å®Ÿæ©Ÿã®å‘ãã‚„ã‚«ãƒ¡ãƒ©ã®è§£åƒåº¦ã«ã‚ˆã£ã¦ã©ã¡ã‚‰ã‚’ä½¿ã†ã‹ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹**ã€ã‚‚ã—ãã¯ã€Œå¸¸ã«ç¸¦å‘ãã®ã‚«ãƒ¡ãƒ©ã§ä½¿ã†ã€ã‚ˆã†ã«è¨­å®šã—ã¦ãŠã‘ã°æ··ä¹±ãŒæ¸›ã‚Šã¾ã™ã€‚

---

## 2. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒã«ã‚‚åŒã˜ â€œã‚«ãƒãƒ¼ã®ã—ã‹ãŸâ€ ã‚’é©ç”¨ã™ã‚‹

ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’ BoxFit.cover ã§ãƒˆãƒªãƒŸãƒ³ã‚°è¡¨ç¤ºã—ã¦ã„ã‚‹ã®ã«ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒã‚’å˜ã«

```dart
width: screenWidth,
height: screenWidth, // æ­£æ–¹å½¢å›ºå®š
```

ã§ã‚«ãƒãƒ¼ã—ã¦ã„ã‚‹å ´åˆã€**ã¾ã£ãŸãåˆ¥ã®ç¸¦æ¨ªæ¯”**ã§ãƒˆãƒªãƒŸãƒ³ã‚°ã•ã‚Œã¦ã—ã¾ã„ã€çµæœçš„ã«é‡ãªã‚Šæ–¹ãŒãšã‚Œã‚‹ãƒ»ä¸Šä¸‹(ã¾ãŸã¯å·¦å³)ãŒåˆã‚ãªã„ã‚±ãƒ¼ã‚¹ãŒèµ·ãã¾ã™ã€‚

ã‚‚ã—ã€Œã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚‚ã‚«ãƒ¡ãƒ©ã¨ã¾ã£ãŸãåŒã˜å¤§ãã•ã«ãƒˆãƒªãƒŸãƒ³ã‚°ã—ã¦ã€é‡ã­åˆã‚ã›ãŸã„ã€ã®ã§ã‚ã‚Œã°ã€ã‚«ãƒ¡ãƒ©ã¨åŒã˜ã‚ˆã†ã«

```dart
ClipRect(
  child: FittedBox(
    fit: BoxFit.cover,
    child: SizedBox(
      // ã‚«ãƒ¡ãƒ©ã¨åŒã˜å¹…ãƒ»é«˜ã•ã® SizedBox ã‚’ç”¨æ„
      width: screenWidth,
      height: screenWidth / cameraController.value.aspectRatio,
      child: Image.network(overlayImageUrl, fit: BoxFit.cover),
    ),
  ),
),
```

ã®ã‚ˆã†ã« **åŒã˜ç®—å‡ºãƒ­ã‚¸ãƒƒã‚¯**ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ãŸã ã—ã€Œã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒãŒã‚‚ã¨ã‚‚ã¨æ­£æ–¹å½¢ã€ãªã‚‰ã€æ•¢ãˆã¦åŒã˜è¨ˆç®—ã‚’ã›ãšã¨ã‚‚ `width=height=screenWidth` ã§å•é¡Œãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã§ã™ãŒã€ãã†ã§ãªã„ç”»åƒã®å ´åˆã¯ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã ã‘ç¸¦æ¨ªæ¯”ãŒç•°ãªã‚‹è¡¨ç¤ºã«ãªã‚Šã€é‡ã­ã‚‹ã¨ã‚ºãƒ¬ãŒç”Ÿã˜ã¾ã™ã€‚

---

## 3. ç¸¦ç”»é¢å›ºå®šã§ã‚«ãƒ¡ãƒ©ã‚’é‹ç”¨ã™ã‚‹å ´åˆ

ã‚‚ã—ã‚¢ãƒ—ãƒªã‚’ **ç¸¦ç”»é¢ã§ä½¿ã†ã“ã¨ãŒç¢ºå®šã—ã¦ã„ã‚‹** ãªã‚‰ã€ã‚«ãƒ¡ãƒ©ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨­å®šè‡ªä½“ã‚’ã€Œç¸¦å‘ãã§è¿”ã™ã€ã‚ˆã†ã«å›ºå®šã—ã¦ã—ã¾ã†ã®ãŒæ¥½ã§ã™ã€‚  
ãŸã¨ãˆã° AndroidManifest ã‚„ iOS ã®è¨­å®šã§ `portraitUp` ã‚’å›ºå®šã«ã—ã€`cameraController` ã®åˆæœŸåŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚‚ç¸¦å‘ãç”¨ã«è¨­å®šã™ã‚‹ã¨ã€æ¯å›ã€ŒaspectRatio ã‚’é€†ã«ã™ã‚‹ã‹ã©ã†ã‹ã€ã‚’æ„è­˜ã—ãªãã¦ã‚‚æ¸ˆã‚€ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---

## 4. ãƒ†ã‚¹ãƒˆã™ã‚‹éš›ã¯å®Ÿæ©Ÿã®ç”»é¢å›è»¢ã‚‚ç¢ºèª

å®Ÿæ©Ÿã§ãƒ†ã‚¹ãƒˆã™ã‚‹å ´åˆã€ç”»é¢å›è»¢ã‚’æœ‰åŠ¹ã«ã—ã¦ã„ã‚‹ã¨ `aspectRatio` ãŒãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§å¤‰ã‚ã£ãŸã‚Šã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒæ€ã‚ã¬æ–¹å‘ã§åˆæœŸåŒ–ã•ã‚ŒãŸã‚Šã—ã¾ã™ã€‚  
ä¸€åº¦ç”»é¢å›è»¢ã‚’ã‚ªãƒ•ã«ã™ã‚‹ã€ã¾ãŸã¯æ˜ç¤ºçš„ã«ç¸¦å›ºå®šã«ã—ã¦æŒ™å‹•ãŒæ­£ã—ã„ã‹ç¢ºèªã™ã‚‹ã¨ã€å•é¡Œã®åˆ‡ã‚Šåˆ†ã‘ãŒã—ã‚„ã™ããªã‚Šã¾ã™ã€‚

---

## ã¾ã¨ã‚

- **ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ãŒç¸¦æ¨ªã©ã¡ã‚‰åŸºæº–ã‹**ã‚’ã¾ãšç¢ºèªã™ã‚‹  
- **`SizedBox` ã®ç¸¦æ¨ªã‚µã‚¤ã‚ºæŒ‡å®šãŒå®Ÿæ©Ÿã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã«åˆã£ã¦ã„ã‚‹ã‹**å†ãƒã‚§ãƒƒã‚¯ã™ã‚‹  
  - ã€Œå¹… = ç”»é¢å¹…ã€ã€Œé«˜ã• = `ç”»é¢å¹… / aspectRatio`ã€ãŒå¸¸ã«æ­£è§£ã§ã¯ãªãã€ç«¯æœ«å‘ã/ratio ã®å€¤ã«å¿œã˜ã¦é€†ã‚‚ã‚ã‚Šå¾—ã‚‹  
- **ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒã«ã‚‚åŒã˜è«–ç†ã§ BoxFit.cover ã‚’å½“ã¦ã‚‹**ã‹ã€ã‚ã‚‹ã„ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒãŒæ­£æ–¹å½¢å‰æãªã‚‰ãã‚Œã«åˆã‚ã›ãŸå®Ÿè£…ã«ã™ã‚‹  
- å¯èƒ½ãªã‚‰ã€Œç¸¦ç”»é¢å›ºå®šã€ãªã©ã«ã—ã€`cameraController` å´ã®è¨­å®šã‚„ã‚¢ãƒ—ãƒªã® `Orientation` ã‚’å›ºå®šã—ã¦ã—ã¾ã†ã¨æ¥½

ã“ã†ã—ãŸç‚¹ã‚’èª¿æ•´ã—ã¦ã„ãŸã ãã¨ã€**æ­£æ–¹å½¢é ˜åŸŸã«æ­ªã¿ãªãã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ãã¡ã‚“ã¨ã‚«ãƒãƒ¼è¡¨ç¤º**ã§ãã‚‹ã¯ãšã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/1/22 12:59:51*

ç¸¦ç”»é¢å›ºå®šã ã¨ãŠã‚‚ã£ã¦å®Ÿè£…ã‚’èª¿æ•´ã—ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/1/22 13:00:33*

ä»¥ä¸‹ã®ã‚µãƒ³ãƒ—ãƒ«ã¯ã€Œã‚¢ãƒ—ãƒªè‡ªä½“ã‚’ç¸¦ç”»é¢å›ºå®šï¼ˆportraitUpï¼‰ã€ã¨ã—ã¦åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚’å‰æã«ã—ãŸã‚³ãƒ¼ãƒ‰ä¾‹ã§ã™ã€‚  
Flutter å´ã ã‘ã§ãªãã€Android/iOS ã®ãƒã‚¤ãƒ†ã‚£ãƒ–è¨­å®šã§ã‚‚ç¸¦ç”»é¢å›ºå®šã«ã—ã¦ãŠãï¼ˆã‚ã‚‹ã„ã¯ç«¯æœ«å›è»¢ã‚’ã‚ªãƒ•ã«ã™ã‚‹ï¼‰ã“ã¨ã§ã€ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã®æ··ä¹±ãŒèµ·ãã«ãããªã‚Šã¾ã™ã€‚

---

## ãƒã‚¤ãƒ³ãƒˆ

1. **ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãŒè¿”ã™ `aspectRatio`** ã¯ã€é€šå¸¸ã€Œæ¨ªå¹… Ã· ç¸¦å¹…ã€ã®å€¤ã§ã™ã€‚  
   - ç¸¦å‘ãå›ºå®šã®ã‚¢ãƒ—ãƒªã§ã‚‚ã€ã‚«ãƒ¡ãƒ©ã®å†…éƒ¨è§£åƒåº¦ã¯æ¨ªå¹… > ç¸¦å¹…ã®ãŸã‚ã€`aspectRatio` ãŒ 1 ä»¥ä¸Šï¼ˆä¾‹: 1.777...ï¼‰ã«ãªã‚‹ã‚±ãƒ¼ã‚¹ãŒå¤šã„ã§ã™ã€‚
   - ç¸¦ã§ä½¿ã†å ´åˆã¯ã€å®Ÿéš›ã« **ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç¸¦é•·ã«è¦‹ã›ã‚‹ãŸã‚ã« `1 / aspectRatio`** ã‚’ä½¿ã†ã¨åˆ†ã‹ã‚Šã‚„ã™ã„ã§ã™ã€‚

2. **æ­£æ–¹å½¢ã®é ˜åŸŸ**ï¼ˆå¹…=ç”»é¢å¹…ã€é«˜ã•=ç”»é¢å¹…ï¼‰ã« **ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ã€Œcoverã€è¡¨ç¤ºã—ã¦ãƒˆãƒªãƒŸãƒ³ã‚°**ã™ã‚‹  
   - å®Ÿéš›ã«ã¯ç¸¦ã«é•·ã„ã‚µã‚¤ã‚ºï¼ˆãŸã¨ãˆã° `width = screenWidth`, `height = screenWidth / (1 / aspectRatio)` = `screenWidth * aspectRatio`ï¼‰ãŒå¿…è¦ãªã®ã§ `FittedBox` ã§ã€Œæº¢ã‚ŒãŸéƒ¨åˆ†ã¯åˆ‡ã‚Šæ¨ã¦ã€ã—ã¾ã™ã€‚

3. **ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒ**ã‚‚åŒã˜ã‚ˆã†ã«ã€Œæ­£æ–¹å½¢ã®é ˜åŸŸå†…ã§ coverã€ã™ã‚‹ã‹ã€ãã‚Œã«åˆã‚ã›ã¦ãƒˆãƒªãƒŸãƒ³ã‚°ã—ãŸã„å ´åˆã¯ **åŒã˜ã‚µã‚¤ã‚ºæŒ‡å®šã¨ `BoxFit.cover`** ã‚’ä½¿ã†ã¨é‡ãªã‚ŠãŒæ­£ç¢ºã«åˆã„ã¾ã™ã€‚

---

## ã‚³ãƒ¼ãƒ‰ä¾‹

ä»¥ä¸‹ã€ãƒ¦ãƒ¼ã‚¶ãŒæ·»ä»˜ã—ã¦ãã ã•ã£ãŸ `ShootingPage` ã‚’ **ã€Œç¸¦ç”»é¢å›ºå®šå‰æã€ã‹ã¤ã€Œæ­£æ–¹å½¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€** ã«ãªã‚‹ã‚ˆã†ã«æ›¸ãæ›ãˆãŸä¾‹ã§ã™ã€‚  
å¤‰æ›´ç‚¹ã®ä¸­å¿ƒã¯ `cameraAspectRatio` ã‚’ã€Œç¸¦å‘ãç”¨ã«è£œæ­£ï¼ˆ`1 / aspectRatio`ï¼‰ã€ã—ã€`SizedBox` ã®ã‚µã‚¤ã‚ºè¨ˆç®—ã‚’èª¿æ•´ã—ãŸéƒ¨åˆ†ã§ã™ã€‚

```dart
import 'dart:io';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:image/image.dart' as img;

// ä»–ã® import ã¯çœç•¥

class ShootingPage extends HookConsumerWidget {
  const ShootingPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cameraControllerState = ref.watch(cameraControllerProvider);
    final spotState = ref.watch(weaveTargetSpotNotifierProvider);
    final overlayImageUrl = spotState?.photoUrl ?? '';
    final overlayOpacity = useState<double>(0.5);
    final isProcessing = useState<bool>(false);

    // ã‚«ãƒ¡ãƒ©ã§æ’®å½±ã—ãŸç”»åƒã‚’æ­£æ–¹å½¢ã«ã‚¯ãƒ­ãƒƒãƒ—ã—ã¦è¿”ã™
    Future<File> takeSquarePicture(CameraController controller) async {
      final xFile = await controller.takePicture();

      final originalBytes = await xFile.readAsBytes();
      final originalImage = img.decodeImage(originalBytes);
      if (originalImage == null) {
        throw Exception('Failed to decode image');
      }

      final width = originalImage.width;
      final height = originalImage.height;
      final croppedSize = width < height ? width : height;

      final xOffset = (width - croppedSize) ~/ 2;
      final yOffset = (height - croppedSize) ~/ 2;

      final cropped = img.copyCrop(
        originalImage,
        x: xOffset,
        y: yOffset,
        width: croppedSize,
        height: croppedSize,
      );

      final croppedBytes = img.encodeJpg(cropped);
      final file = File(xFile.path);
      await file.writeAsBytes(croppedBytes);

      return file;
    }

    Future<void> onTapCamera() async {
      if (cameraControllerState is AsyncData<CameraController?>) {
        final cameraController = cameraControllerState.value;
        if (cameraController == null) {
          debugPrint('CameraController is null');
          return;
        }

        if (!cameraController.value.isInitialized) {
          debugPrint('CameraController not initialized');
          return;
        }

        try {
          isProcessing.value = true;

          final xFile = await takeSquarePicture(cameraController);
          if (xFile.path.isNotEmpty) {
            final location =
                await ref.read(currentLocationNotifierProvider.future);

            ref
                .read(shotPhotoNotifierProvider.notifier)
                .shotPhoto(xFile.path, location);

            if (context.mounted) {
              await context.push(Screen.weaveSpot.path);
            }
          }
        } on CameraException catch (e) {
          debugPrint('takePicture failed: $e');
        } finally {
          isProcessing.value = false;
        }
      } else {
        debugPrint('Camera is not ready to take a picture yet');
      }
    }

    final screenWidth = MediaQuery.of(context).size.width;

    return cameraControllerState.when(
      loading: () => const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      ),
      error: (err, st) => Scaffold(
        body: Center(
          child: Text('Failed to initialize the camera: $err'),
        ),
      ),
      data: (cameraController) {
        if (cameraController == null) {
          return const Scaffold(
            body: Center(child: Text('Camera is not available')),
          );
        }

        if (!cameraController.value.isInitialized) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }

        // â—†â—†â—† ç¸¦ç”»é¢å›ºå®šå‰æ â—†â—†â—†
        // ã“ã“ã§ cameraController ã® aspectRatio ã¯ä¸€èˆ¬çš„ã«ã€Œæ¨ªÃ·ç¸¦ã€(1.3ä»¥ä¸Š) ãŒè¿”ã£ã¦ãã‚‹å ´åˆãŒå¤šã„
        // ç¸¦é•·ã§è¡¨ç¤ºã—ãŸã„ã®ã§ã€ 1 / aspectRatio ã§è£œæ­£ã—ã¦ãŠã
        double cameraAspectRatio = cameraController.value.aspectRatio;
        if (cameraAspectRatio > 1) {
          // æ¨ªãŒç¸¦ã‚ˆã‚Šã‚‚å¤§ãã„(1ã‚ˆã‚Šå¤§ãã„)ãªã‚‰ã€ç¸¦å‘ãã«è¦‹ã›ã‚‹ãŸã‚ 1/ratio ã«ã™ã‚‹
          cameraAspectRatio = 1 / cameraAspectRatio;
        }
        // ã“ã‚Œã§ãŸã¨ãˆã°å®Ÿéš›ã‚«ãƒ¡ãƒ©ãŒ16:9ã ã£ãŸã‚‰ã€ 16Ã·9=1.777.. â†’ 1/1.777..=0.5625

        return Scaffold(
          appBar: AppBar(
            backgroundColor: ColorPallet.gray1000,
          ),
          body: Stack(
            alignment: Alignment.center,
            children: [
              Column(
                children: [
                  // ä¸Šéƒ¨ä½™ç™½
                  Container(
                    height: 80,
                    color: ColorPallet.gray1000,
                  ),
                  // æ­£æ–¹å½¢é ˜åŸŸã«å¯¾ã—ã¦ã€ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ cover è¡¨ç¤ºã™ã‚‹
                  SizedBox(
                    width: screenWidth,
                    height: screenWidth,
                    child: Stack(
                      children: [
                        // --- ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ ---
                        ClipRect(
                          child: FittedBox(
                            fit: BoxFit.cover,
                            child: SizedBox(
                              // ç¸¦å‘ãå›ºå®šãªã®ã§ã€Œå¹… = screenWidthã€ã€Œé«˜ã• = screenWidth / (æ¨ªÃ·ç¸¦è£œæ­£å¾Œ)ã€
                              width: screenWidth,
                              height: screenWidth / cameraAspectRatio,
                              child: CameraPreview(cameraController),
                            ),
                          ),
                        ),
                        if (overlayImageUrl.isNotEmpty)
                          Opacity(
                            opacity: overlayOpacity.value,
                            child: ClipRect(
                              child: FittedBox(
                                fit: BoxFit.cover,
                                child: SizedBox(
                                  width: screenWidth,
                                  height: screenWidth, 
                                  // ã‚‚ã—ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚‚åŒã˜ãã€Œç¸¦æ¨ªæ¯”ãŒ16:9ã®ç”»åƒã€ãªã©ã‚’
                                  // ã‚«ãƒ¡ãƒ©ã¨åŒã˜ã‚ˆã†ã«ãƒˆãƒªãƒŸãƒ³ã‚°ã—ãŸã„å ´åˆã¯
                                  // â†‘ã“ã“ã®é«˜ã•ã‚‚åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã«ã™ã‚‹
                                  child: Image.network(
                                    overlayImageUrl,
                                    fit: BoxFit.cover,
                                  ),
                                ),
                              ),
                            ),
                          ),
                      ],
                    ),
                  ),
                  Expanded(
                    child: Stack(
                      clipBehavior: Clip.none,
                      children: [
                        Container(color: ColorPallet.gray1000),
                        Column(
                          children: [
                            const SizedBox(height: 40),
                            // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤é€æ˜åº¦èª¿æ•´ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
                            Padding(
                              padding: const EdgeInsets.symmetric(
                                horizontal: 80,
                              ),
                              child: Slider(
                                activeColor: ColorToken.primary,
                                inactiveColor: ColorToken.secondary,
                                value: overlayOpacity.value,
                                onChanged: (v) => overlayOpacity.value = v,
                              ),
                            ),
                            Expanded(
                              child: Stack(
                                alignment: Alignment.center,
                                children: [
                                  Row(
                                    children: [
                                      const Spacer(),
                                      GestureDetector(
                                        onTap: () async {
                                          await onTapCamera();
                                        },
                                        child: const CircleAvatar(
                                          radius: 36,
                                          backgroundColor:
                                              ColorToken.primaryLight,
                                          child: CircleAvatar(
                                            radius: 34,
                                            backgroundColor:
                                                ColorToken.primaryDark,
                                            child: Icon(
                                              Icons.camera_alt_outlined,
                                              color: ColorToken.text,
                                              size: 36,
                                            ),
                                          ),
                                        ),
                                      ),
                                      const Spacer(),
                                    ],
                                  ),
                                  Positioned(
                                    right: 56,
                                    child: Stack(
                                      alignment: Alignment.center,
                                      children: [
                                        CircleAvatar(
                                          radius: 18,
                                          backgroundColor: ColorToken.bgWhite
                                              .withValues(alpha: 0.2),
                                        ),
                                        IconButton(
                                          icon: const Icon(
                                            Icons.close,
                                            size: 24,
                                          ),
                                          color: ColorToken.text,
                                          onPressed: () async {
                                            context.pop();
                                          },
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              if (isProcessing.value)
                const Positioned.fill(
                  child: ColoredBox(
                    color: Colors.black45,
                    child: Center(
                      child: CircularProgressIndicator(),
                    ),
                  ),
                ),
            ],
          ),
        );
      },
    );
  }
}
```

### ã“ã“ã§ã®ä¸»ãªå¤‰æ›´ç‚¹

- ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ `double cameraAspectRatio = cameraController.value.aspectRatio;` ã§å–å¾—å¾Œã€  
  **ã€Œç¸¦ç”»é¢ã«è¦‹ã›ã‚‹ãŸã‚ã« `cameraAspectRatio = 1 / cameraAspectRatio` ã™ã‚‹ã€**ï¼ˆ1 ã‚ˆã‚Šå¤§ãã„å ´åˆã®ã¿ï¼‰ã€‚
  - ã“ã‚Œã§ã€é€šå¸¸ã€Œæ¨ª:ç¸¦ = 16:9ã€â†’ `aspectRatio=1.777...` ã®ã¨ãã§ã‚‚ `0.5625`ï¼ˆ9/16ï¼‰ã¨ã—ã¦è¨ˆç®—ã§ãã¾ã™ã€‚  
  - `FittedBox` + `BoxFit.cover` ã«ã‚ˆã£ã¦æº¢ã‚ŒãŸéƒ¨åˆ†ã¯åˆ‡ã‚Šæ¨ã¦ã¤ã¤ã€æ­£æ–¹å½¢ã®æ ã«è¡¨ç¤ºã—ã¾ã™ã€‚
- `SizedBox(width: screenWidth, height: screenWidth)` ã¯ **ã€Œå¤–æ ï¼æ­£æ–¹å½¢ã€**  
  - ãã®ä¸­ã« `SizedBox(width: screenWidth, height: screenWidth / cameraAspectRatio)` ã‚’ç½®ã„ã¦ `fit: BoxFit.cover` ã™ã‚‹ã“ã¨ã§ã€æ­£æ–¹å½¢ã‹ã‚‰ã¯ã¿å‡ºã‚‹éƒ¨åˆ†ã‚’ãƒˆãƒªãƒŸãƒ³ã‚°ã€‚

---

## ç¢ºèªæ‰‹é †

1. **ç«¯æœ«ãƒ»ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ç¸¦ç”»é¢ã«å›ºå®š**ã§ãã¦ã„ã‚‹ã‹ã‚’ç¢ºèª  
   - Android ã®å ´åˆã€`AndroidManifest.xml` ã‚„ `MainActivity` ã§ `android:screenOrientation="portrait"` ã«ã™ã‚‹  
   - iOS ã®å ´åˆã€`Info.plist` ã® UISupportedInterfaceOrientations ã§ `Portrait` ä»¥å¤–ã‚’æ¶ˆã™  
2. å®Ÿè¡Œã—ã¦ã¿ã¦ã€**ã‚«ãƒ¡ãƒ©ã®æ˜ åƒãŒæ­£æ–¹å½¢é ˜åŸŸã«å¯¾ã—ã¦ä¸Šä¸‹æ–¹å‘ã«ã‚«ãƒãƒ¼è¡¨ç¤º**ã•ã‚Œã‚‹ã‹ç¢ºèª  
   - ç¸¦é•·ã®ã‚«ãƒ¡ãƒ©æ˜ åƒãªã‚‰ä¸Šä¸‹ãŒä¸€éƒ¨ãƒˆãƒªãƒŸãƒ³ã‚°ã•ã‚Œã€æ­£æ–¹å½¢ã‚’åŸ‹ã‚ã‚‹å½¢ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚  
   - é€†ã«ä½™ç™½ã‚„æ¨ªã®ä¼¸ã³ã¯ç™ºç”Ÿã—ãªã„ã¯ãšã§ã™ã€‚  
3. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒãŒã‚‚ã—åˆ¥ã®ç¸¦æ¨ªæ¯”ãªã‚‰ã€åŒæ§˜ã«ã€Œç¸¦æ¨ªæ¯”è¨ˆç®—ã‚’è¡Œã†ã‹ã©ã†ã‹ã€èª¿æ•´ã—ã€**ã‚«ãƒ¡ãƒ©æ˜ åƒã¨åˆã†å½¢**ã§è¼‰ã›ã‚‹ã€‚

ã“ã®æ–¹æ³•ã§ã€åŸºæœ¬çš„ã«ã€Œç¸¦ç”»é¢å›ºå®šï¼‹æ­£æ–¹å½¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€è¡¨ç¤ºãŒå®‰å®šã—ã¦å‹•ä½œã™ã‚‹ã¯ãšã§ã™ã€‚ãœã²ãŠè©¦ã—ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/1/22 13:05:12*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-YNqzMCVMYfmpqPaRMNtuFH",
  "size_bytes": 149764,
  "width": 597,
  "height": 1280,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
æ˜ åƒã®æ¯”ç‡ã¯è‰¯ã„ã¨æ€ã†ã€‚ãŸã ã€æ·»ä»˜ã—ãŸã‚ˆã†ã«è¡¨ç¤ºã—ã¦ã„ã‚‹æ˜ åƒãŒæ­£æ–¹å½¢ã§ã¯ãªããªã£ã¦ã„ã‚‹ã€‚

import 'dart:io';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:image/image.dart' as img;
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/providers/camera_controller_provider.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/shot_photo.dart';
import 'package:snpit_guild_app/presentation/providers/weave_target_spot.dart';

class ShootingPage extends HookConsumerWidget {
  const ShootingPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cameraControllerState = ref.watch(cameraControllerProvider);
    final spotState = ref.watch(weaveTargetSpotNotifierProvider);
    final overlayImageUrl = spotState?.photoUrl ?? '';
    final overlayOpacity = useState&lt;double&gt;(0.5);
    final isProcessing = useState&lt;bool&gt;(false);

    // ã‚«ãƒ¡ãƒ©ã§æ’®å½±ã—ãŸç”»åƒã‚’æ­£æ–¹å½¢ã«ã‚¯ãƒ­ãƒƒãƒ—ã—ã¦è¿”ã™
    Future&lt;File&gt; takeSquarePicture(CameraController controller) async {
      final xFile = await controller.takePicture();

      final originalBytes = await xFile.readAsBytes();
      final originalImage = img.decodeImage(originalBytes);
      if (originalImage == null) {
        throw Exception('Failed to decode image');
      }

      final width = originalImage.width;
      final height = originalImage.height;
      final croppedSize = width &lt; height ? width : height;

      final xOffset = (width - croppedSize) ~/ 2;
      final yOffset = (height - croppedSize) ~/ 2;

      final cropped = img.copyCrop(
        originalImage,
        x: xOffset,
        y: yOffset,
        width: croppedSize,
        height: croppedSize,
      );

      final croppedBytes = img.encodeJpg(cropped);
      final file = File(xFile.path);
      await file.writeAsBytes(croppedBytes);

      return file;
    }

    Future&lt;void&gt; onTapCamera() async {
      if (cameraControllerState is AsyncData&lt;CameraController?&gt;) {
        final cameraController = cameraControllerState.value;
        if (cameraController == null) {
          debugPrint('CameraController is null');
          return;
        }

        if (!cameraController.value.isInitialized) {
          debugPrint('CameraController not initialized');
          return;
        }

        try {
          isProcessing.value = true;

          final xFile = await takeSquarePicture(cameraController);
          if (xFile.path.isNotEmpty) {
            final location =
                await ref.read(currentLocationNotifierProvider.future);

            ref
                .read(shotPhotoNotifierProvider.notifier)
                .shotPhoto(xFile.path, location);

            if (context.mounted) {
              await context.push(Screen.weaveSpot.path);
            }
          }
        } on CameraException catch (e) {
          debugPrint('takePicture failed: $e');
        } finally {
          isProcessing.value = false;
        }
      } else {
        debugPrint('Camera is not ready to take a picture yet');
      }
    }

    final screenWidth = MediaQuery.of(context).size.width;

    return cameraControllerState.when(
      loading: () =&gt; const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      ),
      error: (err, st) =&gt; Scaffold(
        body: Center(
          child: Text('Failed to initialize the camera: $err'),
        ),
      ),
      data: (cameraController) {
        if (cameraController == null) {
          return const Scaffold(
            body: Center(child: Text('Camera is not available')),
          );
        }

        if (!cameraController.value.isInitialized) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }

        var cameraAspectRatio = cameraController.value.aspectRatio;
        if (cameraAspectRatio &gt; 1) {
          cameraAspectRatio = 1 / cameraAspectRatio;
        }
        
        return Scaffold(
          appBar: AppBar(
            backgroundColor: ColorPallet.gray1000,
          ),
          body: Stack(
            alignment: Alignment.center,
            children: [
              Column(
                children: [
                  Container(
                    height: 80,
                    color: ColorPallet.gray1000,
                  ),
                  SizedBox(
                    width: screenWidth,
                    height: screenWidth,
                    child: Stack(
                      children: [
                        ClipRect(
                          child: FittedBox(
                            fit: BoxFit.cover,
                            child: SizedBox(
                              width: screenWidth,
                              height: screenWidth / cameraAspectRatio,
                              child: CameraPreview(cameraController),
                            ),
                          ),
                        ),
                        if (overlayImageUrl.isNotEmpty)
                          Opacity(
                            opacity: overlayOpacity.value,
                            child: ClipRect(
                              child: FittedBox(
                                fit: BoxFit.cover,
                                child: SizedBox(
                                  width: screenWidth,
                                  height: screenWidth,
                                  child: Image.network(
                                    overlayImageUrl,
                                    fit: BoxFit.cover,
                                  ),
                                ),
                              ),
                            ),
                          ),
                      ],
                    ),
                  ),
                  Expanded(
                    child: Stack(
                      clipBehavior: Clip.none,
                      children: [
                        Container(color: ColorPallet.gray1000),
                        Column(
                          children: [
                            const SizedBox(height: 40),
                            Padding(
                              padding: const EdgeInsets.symmetric(
                                horizontal: 80,
                              ),
                              child: Slider(
                                activeColor: ColorToken.primary,
                                inactiveColor: ColorToken.secondary,
                                value: overlayOpacity.value,
                                onChanged: (v) =&gt; overlayOpacity.value = v,
                              ),
                            ),
                            Expanded(
                              child: Stack(
                                alignment: Alignment.center,
                                children: [
                                  // ãƒãƒ„ãƒœã‚¿ãƒ³ãŒæŠ¼ã›ã‚‹ã‚ˆã†ã« Row ã¨ Spacer ã§æç”»ç¯„å›²ã‚’åºƒã’ã¦ã„ã‚‹
                                  Row(
                                    children: [
                                      const Spacer(),
                                      GestureDetector(
                                        onTap: () async {
                                          await onTapCamera();
                                        },
                                        child: const CircleAvatar(
                                          radius: 36,
                                          backgroundColor:
                                              ColorToken.primaryLight,
                                          child: CircleAvatar(
                                            radius: 34,
                                            backgroundColor:
                                                ColorToken.primaryDark,
                                            child: Icon(
                                              Icons.camera_alt_outlined,
                                              color: ColorToken.text,
                                              size: 36,
                                            ),
                                          ),
                                        ),
                                      ),
                                      const Spacer(),
                                    ],
                                  ),
                                  Positioned(
                                    right: 56,
                                    child: Stack(
                                      alignment: Alignment.center,
                                      children: [
                                        CircleAvatar(
                                          radius: 18,
                                          backgroundColor: ColorToken.bgWhite
                                              .withValues(alpha: 0.2),
                                        ),
                                        IconButton(
                                          icon: const Icon(
                                            Icons.close,
                                            size: 24,
                                          ),
                                          color: ColorToken.text,
                                          onPressed: () async {
                                            context.pop();
                                          },
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              if (isProcessing.value)
                const Positioned.fill(
                  child: ColoredBox(
                    color: Colors.black45,
                    child: Center(
                      child: CircularProgressIndicator(),
                    ),
                  ),
                ),
            ],
          ),
        );
      },
    );
  }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/1/22 13:05:54*

ã€Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é ˜åŸŸãã®ã‚‚ã®ã‚’å¸¸ã«**æ­£æ–¹å½¢**ã§è¡¨ç¤ºã—ãŸã„ã€å ´åˆã€å®Ÿéš›ã®ã‚«ãƒ¡ãƒ©æ˜ åƒï¼ˆå¤šãã®å ´åˆ 4:3 ã‚„ 16:9 ãªã©ç¸¦æ¨ªæ¯”ãŒ 1:1 ã§ã¯ãªã„ï¼‰ã‚’ã©ã“ã‹ã—ã‚‰ãƒˆãƒªãƒŸãƒ³ã‚°ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚  
`BoxFit.cover` ã§æ­£æ–¹å½¢ã®æ ã„ã£ã±ã„ã«æ‹¡å¤§ãƒ»ãƒˆãƒªãƒŸãƒ³ã‚°ã™ã‚‹ã¨ã€å·¦å³ã¾ãŸã¯ä¸Šä¸‹ãŒä¸€éƒ¨åˆ‡ã‚Œã¦ã€Œè¦‹ãˆã‚‹ç¯„å›²ã ã‘ãŒæ­£æ–¹å½¢ã€ã«ãªã‚Šã¾ã™ã€‚

ä¸‹è¨˜ã®å®Ÿè£…ä¾‹ã§ã¯ã€

- **å¤–å´ã‚’æ­£æ–¹å½¢ã® `SizedBox`** ã«å›ºå®š  
- ãã®ä¸­ã§ `FittedBox(fit: BoxFit.cover)`ï¼‹`AspectRatio(aspectRatio: realCameraRatio)` ã«ã‚ˆã£ã¦  
  ã€Œã‚«ãƒ¡ãƒ©æ˜ åƒã‚’æ‹¡å¤§ã—ã€ã‚ãµã‚Œã‚‹éƒ¨åˆ†ã‚’ãƒˆãƒªãƒŸãƒ³ã‚°ã—ã¦è¡¨ç¤ºã€ã—ã¾ã™ã€‚  

ã“ã†ã™ã‚‹ã¨ **ç”»é¢ä¸Šã®è¦‹ãŸç›®ã¯æ­£æ–¹å½¢**ã§ã€æ˜ åƒãŒæ­ªã¾ãšã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

---

## ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰

```dart
SizedBox(
  width: screenWidth,
  height: screenWidth, // ã“ã“ã‚’æ­£æ–¹å½¢ã«å›ºå®š
  child: ClipRect(
    child: FittedBox(
      fit: BoxFit.cover, // æ­£æ–¹å½¢ã‚’åŸ‹ã‚ã‚‹ã‚ˆã†ã«æ‹¡å¤§ãƒ»ã¯ã¿å‡ºã—éƒ¨åˆ†ã¯ãƒˆãƒªãƒŸãƒ³ã‚°
      child: AspectRatio(
        // cameraController.value.aspectRatio ã¯é€šå¸¸ã€Œæ¨ªå¹… Ã· ç¸¦å¹…ã€
        // ç¸¦ç”»é¢å›ºå®šãªã‚‰ 1ã‚ˆã‚Šå¤§ãã„å ´åˆãŒå¤šã„ (16:9 â†’ 1.777..)
        // å¿…è¦ã«å¿œã˜ã¦ 1/ratio ã‚’ä½¿ã†ãªã©èª¿æ•´ã—ã¦ãã ã•ã„
        aspectRatio: cameraController.value.aspectRatio,
        child: CameraPreview(cameraController),
      ),
    ),
  ),
),
```

### ãƒã‚¤ãƒ³ãƒˆ

1. **å¤–æ  (è¦ªã® `SizedBox`) ã‚’ width=height=åŒã˜å€¤ ã§ã€Œæ­£æ–¹å½¢ã€** ã«ã—ã¾ã™ã€‚  
2. ä¸­èº« (`AspectRatio`) ã¯ã‚«ãƒ¡ãƒ©ã®å…ƒã®ç¸¦æ¨ªæ¯”ã§è¡¨ç¤ºã•ã‚Œã‚‹ã®ã§ã€**æ™®é€šã¯æ­£æ–¹å½¢ã§ã¯ã‚ã‚Šã¾ã›ã‚“**ã€‚  
3. `FittedBox(fit: BoxFit.cover)` ã‚’ã‹ã‘ã‚‹ã“ã¨ã§ã€ã€Œæ­£æ–¹å½¢ã®é ˜åŸŸã‚’ä½™ç™½ãªãåŸ‹ã‚ã‚‹ã€ãŸã‚ã«æ‹¡å¤§â†’è¦‹åˆ‡ã‚ŒãŸéƒ¨åˆ†ã¯ãƒˆãƒªãƒŸãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚  
   - çµæœã€ç”»é¢ä¸Šã§ã¯ã€Œæ­£æ–¹å½¢ã«åˆ‡ã‚Šå–ã‚‰ã‚ŒãŸã‚«ãƒ¡ãƒ©æ˜ åƒã€ãŒè¡¨ç¤ºã•ã‚Œã‚‹å½¢ã«ãªã‚Šã¾ã™ã€‚  
4. **å·¦å³ã‚„ä¸Šä¸‹ãŒåˆ‡ã‚Œã‚‹ã®ã¯ä»•æ§˜**ã§ã™ã€‚ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’ç„¡ç†ã«æ­£æ–¹å½¢ã«åˆã‚ã›ã¦ã„ã‚‹ãŸã‚ã€å®Ÿéš›ã«ã¯æ˜ åƒã®ç«¯ãŒè¦‹ãˆãªããªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

---

## ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒã‚‚åŒæ§˜ã«

åŒã˜æ­£æ–¹å½¢ã®ä¸Šã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é‡ã­ã‚‹å ´åˆã‚‚ã€**åŒã˜ã‚ˆã†ã« `FittedBox`ï¼‹`BoxFit.cover` ã§æ­£æ–¹å½¢ã«åã‚ã‚‹**ã‹ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”»åƒã‚’ãã‚‚ãã‚‚æ­£æ–¹å½¢ã§ç”¨æ„ã—ã¦ã„ã‚‹ãªã‚‰å˜ç´”ã«

```dart
SizedBox(
  width: screenWidth,
  height: screenWidth,
  child: Image.network(overlayImageUrl, fit: BoxFit.cover),
)
```

ã§ã‚‚ OK ã§ã™ã€‚  
æ˜ åƒã¨ãƒ”ãƒƒã‚¿ãƒªé‡ã­ãŸã„å ´åˆã¯ã€**ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨ã¾ã£ãŸãåŒã˜ã‚µã‚¤ã‚ºæ„Ÿ**ã«ãªã‚‹ã‚ˆã†æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

---

## ã€Œæ˜ åƒã®æ¯”ç‡ã‚’å¤‰ãˆãšã«æ­£æ–¹å½¢ã«è¦‹ã›ã‚‹ã€= éƒ¨åˆ†çš„ã«æ¬ ã‘ã‚‹

ã‚‚ã—ã€Œã‚«ãƒ¡ãƒ©æ˜ åƒã‚’ã™ã¹ã¦æ˜ ã—ãã‚ŠãŸã„ï¼ˆæ¬ ã‘ã•ã›ãŸããªã„ï¼‰ã€ã€Œæ­ªã¾ã›ãŸããªã„ã€ã€Œãã‚Œã§ã‚‚è¡¨ç¤ºã¯æ­£æ–¹å½¢ã€ã¨ã„ã†è¦æœ›ã‚’ã™ã¹ã¦æº€ãŸãã†ã¨ã™ã‚‹ã¨ã€ã©ã†ã—ã¦ã‚‚**ä¸Šä¸‹ã¾ãŸã¯å·¦å³ã«é»’å¸¯**ãŒå…¥ã‚‹ï¼ˆ`BoxFit.contain`ï¼‰ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚  
ä¸€æ–¹ã€

- **ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’æ­ªã¾ã›ãªã„**  
- **é»’å¸¯ãªã—ã§æ­£æ–¹å½¢ã‚’åŸ‹ã‚ãŸã„**  

ã¨ãªã‚‹ã¨ã€ä»Šå›ã®ã‚ˆã†ã«ã€Œã¯ã¿å‡ºã—éƒ¨åˆ†ã¯ãƒˆãƒªãƒŸãƒ³ã‚°ã€ã—ã‹æ–¹æ³•ãŒãªã„ã“ã¨ã«ã”æ³¨æ„ãã ã•ã„ã€‚

---

### ã¾ã¨ã‚

- æ­£æ–¹å½¢æ ã«å¯¾ã—ã¦ `FittedBox(fit: BoxFit.cover)` ã§ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’æ‹¡å¤§ã—ã¦ä¸€éƒ¨ãƒˆãƒªãƒŸãƒ³ã‚°  
- ãã†ã™ã‚‹ã¨æ­ªã¾ãšã€ã‹ã¤è¦‹ãŸç›®ã®é ˜åŸŸã¯æ­£æ–¹å½¢ã«ãªã‚Šã¾ã™  
- ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ãŒæ­£æ–¹å½¢ã§ãªã„é™ã‚Šã€æ˜ åƒã®ç«¯ã¯åˆ‡ã‚Œã‚‹ã®ãŒé€šå¸¸å‹•ä½œ  

ã“ã®æ–¹æ³•ã§ã€Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é ˜åŸŸãŒå¸¸ã«æ­£æ–¹å½¢ã‹ã¤æ˜ åƒã¯æ¯”ç‡ã‚’ä¿ã£ãŸã¾ã¾è¡¨ç¤ºã€ã•ã‚Œã¾ã™ã®ã§ã€ãœã²ãŠè©¦ã—ãã ã•ã„ã€‚

---
