# コードの記述量を減らす

日付: 2024-03-01

---

## 👤 ユーザー
*2024/3/1 21:29:32*

この記述を繰り返すので記述量を減らしたい。

AppRootRouter(dependency: AppRootRouterDependencyMock.empty)

以下はソースコードである

public struct AppRootRouter&lt;Dependency: AppRootRouterDependency&gt;: AppRootWireframe {
    private let dependency: Dependency

    public init(dependency: Dependency) {
        self.dependency = dependency
    }

    @MainActor
    public func createAppRootView() -&gt; AppRootView&lt;Self, Dependency&gt; {
        AppRootView(router: self, dependency: dependency)
    }

    @MainActor
    public func createHomeTabView() -&gt; HomeTabView&lt;Self&gt; {
        HomeTabView(router: self)
    }

    @MainActor
    public func createLicenseListView() -&gt; LicenseListView&lt;Self, Dependency&gt; {
        LicenseListView(router: self, dependency: dependency)
    }

    @MainActor
    public func createLicenseDetailView(license: License) -&gt; LicenseDetailView {
        LicenseDetailView(license: license)
    }

    @MainActor
    public func createSettingView() -&gt; SettingView&lt;Self, Dependency&gt; {
        SettingView(router: self, dependency: dependency)
    }
}

public final class AppRootRouterDependencyMock: AppRootRouterDependency {
    public init() { }
    public init(libraryLicenseDriver: LibraryLicenseDriverProtocolAT, osLogDriver: OSLogDriverProtocolAT, firebaseSetupDriver: FirebaseSetupDriverProtocolAT) {
        self._libraryLicenseDriver = libraryLicenseDriver
        self._osLogDriver = osLogDriver
        self._firebaseSetupDriver = firebaseSetupDriver
    }

    public typealias LibraryLicenseDriverProtocolAT = LibraryLicenseDriverProtocolMock
    public typealias OSLogDriverProtocolAT = OSLogDriverProtocolMock

    public private(set) var libraryLicenseDriverSetCallCount = 0
    private var _libraryLicenseDriver: LibraryLicenseDriverProtocolAT!  { didSet { libraryLicenseDriverSetCallCount += 1 } }
    public var libraryLicenseDriver: LibraryLicenseDriverProtocolAT {
        get { return _libraryLicenseDriver }
        set { _libraryLicenseDriver = newValue }
    }
    public typealias FirebaseSetupDriverProtocolAT = FirebaseSetupDriverProtocolMock

    public private(set) var osLogDriverSetCallCount = 0
    private var _osLogDriver: OSLogDriverProtocolAT!  { didSet { osLogDriverSetCallCount += 1 } }
    public var osLogDriver: OSLogDriverProtocolAT {
        get { return _osLogDriver }
        set { _osLogDriver = newValue }
    }

    public private(set) var firebaseSetupDriverSetCallCount = 0
    private var _firebaseSetupDriver: FirebaseSetupDriverProtocolAT!  { didSet { firebaseSetupDriverSetCallCount += 1 } }
    public var firebaseSetupDriver: FirebaseSetupDriverProtocolAT {
        get { return _firebaseSetupDriver }
        set { _firebaseSetupDriver = newValue }
    }
}


public extension AppRootRouterDependencyMock {
    /// 生成された init() だと nil が代入されてしまうため、デフォルト引数を設定した create を用意する
    static func create(
        libraryLicenseDriver: some LibraryLicenseDriverProtocolMock = LibraryLicenseDriverProtocolMock(),
        osLogDriver: some OSLogDriverProtocolMock = OSLogDriverProtocolMock(),
        firebaseSetupDriver: some FirebaseSetupDriverProtocolMock = FirebaseSetupDriverProtocolMock()
    ) -&gt; Self {
        .init(
            libraryLicenseDriver: libraryLicenseDriver,
            osLogDriver: osLogDriver,
            firebaseSetupDriver: firebaseSetupDriver
        )
    }

    static var empty: Self {
        .create(
            libraryLicenseDriver: LibraryLicenseDriverProtocolMock()
        )
    }
}

---

## 🤖 アシスタント
*2024/3/1 21:30:45*

コードの記述量を減らすために、いくつかのアプローチを提案します。これらの提案は、コードの重複を減らし、可読性とメンテナンス性を向上させることを目的としています。

### 1. ファクトリーメソッドの利用

`AppRootRouter`の各`create`メソッドが似たような構造をしているため、これらのメソッドで共通している処理をファクトリーメソッドに抽出することができます。ただし、Swiftのジェネリクスとプロトコル指向プログラミングの制約により、直接的なファクトリーメソッドの抽出は難しい場合があります。そのため、この部分は既存の構造を踏襲しつつ、コードの重複を減らすための別のアプローチを検討する必要があります。

### 2. デフォルト引数の利用

`AppRootRouterDependencyMock`の`create`メソッドにおいて、デフォルト引数を利用していますが、これをさらに拡張して、依存関係の注入においてもデフォルト引数を活用することができます。例えば、`AppRootRouter`のイニシャライザにおいて、`dependency`にデフォルト値を設定することで、使用する際の記述量を減らすことが可能です。

### 3. コンポジションの利用

`AppRootRouter`が複数のビューを作成する責務を持っているため、これらの責務を分割して、各ビューの作成を専門とする小さなクラスや構造体に委譲することができます。これにより、`AppRootRouter`の責務をより明確にし、コードの再利用性を高めることができます。

### 4. プロトコルのデフォルト実装の利用

Swiftのプロトコルにはデフォルト実装を提供することができます。`AppRootWireframe`プロトコルにデフォルト実装を追加することで、`AppRootRouter`の実装の一部をプロトコルのデフォルト実装に移動させることができます。これにより、同じプロトコルを採用する他のクラスや構造体でも、これらのデフォルト実装を再利用することが可能になります。

### 5. コード生成ツールの利用

プロジェクトが大きくなると、ボイラープレートコードの量が増加する傾向にあります。この問題に対処するために、Sourceryのようなコード生成ツールを利用することで、テンプレートからコードを自動生成し、記述量を減らすことができます。

これらの提案は、プロジェクトの具体的な要件や制約に応じて適用可能です。最適なアプローチは、プロジェクトの規模、チームの好み、および既存のコードベースの構造によって異なります。

---

## 👤 ユーザー
*2024/3/1 21:32:43*

AppRootRouter(dependency: AppRootRouterDependencyMock.empty) = AppRootRouter.empty のようにできないのか？

---

## 👤 ユーザー
*2024/3/1 21:34:28*

以下のようなエラーになった

Cannot convert return expression of type 'AppRootRouter&lt;Dependency&gt;' to return type 'AppRootRouter&lt;AppRootRouterDependencyMock&gt;'
Cannot convert value of type 'AppRootRouterDependencyMock' to expected argument type 'Dependency'

extension AppRootRouter {
    static var empty: AppRootRouter&lt;AppRootRouterDependencyMock&gt; {
        return AppRootRouter(dependency: AppRootRouterDependencyMock.empty)
    }
}

---

## 🤖 アシスタント
*2024/3/1 21:35:11*

エラーメッセージに基づいて、`AppRootRouter`の`empty`静的プロパティを実装しようとした際に型関連の問題が発生しているようです。`AppRootRouter`はジェネリック型であり、その依存性`Dependency`には`AppRootRouterDependency`プロトコルを満たす任意の型が来ることができます。しかし、`empty`プロパティを追加しようとすると、特定の依存性`AppRootRouterDependencyMock`を持つ`AppRootRouter`インスタンスを返そうとしています。これは、`AppRootRouter`の定義がジェネリックであるため、特定の型に対する静的プロパティを追加する際に型の不一致が発生しています。

この問題を解決するためには、`AppRootRouter`の拡張をジェネリック制約を用いて特定の`Dependency`型に限定する必要があります。しかし、Swiftではジェネリック型の静的プロパティやメソッドに対して、その型パラメータに基づいて条件を指定することはできません。つまり、`AppRootRouter<Dependency>`のようなジェネリック型に対して、`Dependency`が`AppRootRouterDependencyMock`である場合のみ適用される静的プロパティを直接定義することはできません。

しかし、`AppRootRouter`の非ジェネリックなサブタイプを作成することで、この問題を回避できます。このサブタイプは`AppRootRouterDependencyMock`を依存性として使用し、`empty`プロパティを提供します。以下はその一例です：

```swift
// AppRootRouterのための特定のサブタイプを定義
extension AppRootRouter where Dependency == AppRootRouterDependencyMock {
    static var empty: AppRootRouter<AppRootRouterDependencyMock> {
        return AppRootRouter<AppRootRouterDependencyMock>(dependency: .empty)
    }
}
```

この方法では、`AppRootRouter`の拡張内で`Dependency`の型を`AppRootRouterDependencyMock`に限定しています。これにより、`empty`プロパティは`AppRootRouterDependencyMock`を依存性として持つ`AppRootRouter`インスタンスを返すことができます。

このアプローチは、`AppRootRouter`の使用法を柔軟に保ちつつ、特定の依存性を持つインスタンスを簡単に生成できる方法を提供します。ただし、この方法は`AppRootRouter`が`AppRootRouterDependencyMock`に依存する特定のシナリオにのみ適用されることに注意してください。

---
