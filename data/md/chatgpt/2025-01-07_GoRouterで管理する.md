# GoRouterで管理する

日付: 2025-01-07

---

## 👤 ユーザー
*2025/01/07 15:20:50*

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';

class TextEditingPage extends HookWidget {
  const TextEditingPage({
    super.key,
    required this.title,
    required this.initialText,
    required this.onSave,
  });

  final String title;
  final String initialText;
  final void Function(String updatedText) onSave;

  @override
  Widget build(BuildContext context) {
    final textController = useTextEditingController(text: initialText);

    return Scaffold(
      appBar: AppBar(
        title: Text(title),
        actions: [
          ElevatedButton(
            onPressed: () {
              final updatedText = textController.text;
              onSave(updatedText);
              context.pop();
            },
            child: const Text(
              'Save',
            ),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TextField(
          controller: textController,
          decoration: const InputDecoration(
            labelText: 'Edit Text',
            border: UnderlineInputBorder(),
          ),
        ),
      ),
    );
  }
}

これをゴールターで管理したい。

import 'package:go_router/go_router.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/pages/camera_list_page.dart';
import 'package:snpit_guild_app/presentation/pages/debug_menu_page.dart';
import 'package:snpit_guild_app/presentation/pages/debug_utility_page.dart';
import 'package:snpit_guild_app/presentation/pages/deck_detail_page.dart';
import 'package:snpit_guild_app/presentation/pages/guild_code_page.dart';
import 'package:snpit_guild_app/presentation/pages/guild_create_page.dart';
import 'package:snpit_guild_app/presentation/pages/guild_manage_page.dart';
import 'package:snpit_guild_app/presentation/pages/guild_page.dart';
import 'package:snpit_guild_app/presentation/pages/guild_request_page.dart';
import 'package:snpit_guild_app/presentation/pages/login_page.dart';
import 'package:snpit_guild_app/presentation/pages/map_page.dart';
import 'package:snpit_guild_app/presentation/pages/my_page.dart';
import 'package:snpit_guild_app/presentation/pages/notification_list_page.dart';
import 'package:snpit_guild_app/presentation/pages/profile_page.dart';
import 'package:snpit_guild_app/presentation/pages/shootable_spot_detail_page.dart';
import 'package:snpit_guild_app/presentation/pages/shooting_page.dart';
import 'package:snpit_guild_app/presentation/pages/snap_confirm_page.dart';
import 'package:snpit_guild_app/presentation/pages/spot_detail_page.dart';
import 'package:snpit_guild_app/presentation/pages/spot_list_page.dart';
import 'package:snpit_guild_app/presentation/pages/tab_page.dart';
import 'package:snpit_guild_app/presentation/pages/verification_code_page.dart';
import 'package:snpit_guild_app/presentation/pages/wallet_page.dart';

final GoRouter router = GoRouter(
  initialLocation: Screen.login.path,
  routes: [
    GoRoute(
      path: Screen.debugMenu.path,
      builder: (context, state) =&gt; const DebugMenuPage(),
    ),
    GoRoute(
      path: Screen.debugUtility.path,
      builder: (context, state) =&gt; const DebugUtilityPage(),
    ),
    GoRoute(
      path: Screen.login.path,
      builder: (context, state) =&gt; const LoginPage(),
    ),
    GoRoute(
      path: Screen.verificationCode.path,
      builder: (context, state) =&gt; const VerificationCodePage(),
    ),
    GoRoute(
      path: Screen.myPage.path,
      builder: (context, state) =&gt; const MyPage(),
    ),
    GoRoute(
      path: Screen.profile.path,
      builder: (context, state) =&gt; const ProfilePage(),
    ),
    GoRoute(
      path: Screen.deckDetail.path,
      builder: (context, state) =&gt; const DeckDetailPage(),
    ),
    GoRoute(
      path: Screen.cameraList.path,
      builder: (context, state) =&gt; const CameraListPage(),
    ),
    GoRoute(
      path: Screen.notificationList.path,
      builder: (context, state) =&gt; const NotificationListPage(),
    ),
    GoRoute(
      path: Screen.wallet.path,
      builder: (context, state) =&gt; const WalletPage(),
    ),
    GoRoute(
      path: Screen.spotList.path,
      builder: (context, state) =&gt; const SpotListPage(),
    ),
    GoRoute(
      path: Screen.spotDetail.path,
      builder: (context, state) =&gt; const SpotDetailPage(),
    ),
    GoRoute(
      path: Screen.shootableSpotDetail.path,
      builder: (context, state) =&gt; const ShootableSpotDetailPage(),
    ),
    GoRoute(
      path: Screen.shooting.path,
      builder: (context, state) =&gt; const ShootingPage(),
    ),
    GoRoute(
      path: Screen.snapConfirm.path,
      builder: (context, state) =&gt; const SnapConfirmPage(),
    ),
    GoRoute(
      path: Screen.guildCreate.path,
      builder: (context, state) =&gt; const GuildCreatePage(),
    ),
    GoRoute(
      path: Screen.guildCode.path,
      builder: (context, state) =&gt; const GuildCodePage(),
    ),
    GoRoute(
      path: Screen.guildRequest.path,
      builder: (context, state) =&gt; const GuildRequestPage(),
    ),
    GoRoute(
      path: Screen.guildManage.path,
      builder: (context, state) =&gt; const GuildManagePage(),
    ),
    StatefulShellRoute.indexedStack(
      builder: (context, state, navigationShell) =&gt;
          TabPage(navigationShell: navigationShell),
      branches: [
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: Screen.map.path,
              builder: (context, state) =&gt; const MapPage(),
            ),
          ],
        ),
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: Screen.guild.path,
              builder: (context, state) =&gt; const GuildPage(),
            ),
          ],
        ),
      ],
    ),
  ],
);

---

## 🤖 アシスタント
*2025/01/07 15:21:00*

To manage the `TextEditingPage` using `GoRouter`, you need to add a route definition in the router configuration. Additionally, since `TextEditingPage` requires parameters (`title`, `initialText`, and `onSave`), you can pass them through the `GoRoute`'s `state.extra` or as query parameters (if `onSave` can be reconstructed within the target page).

Here’s how to integrate `TextEditingPage`:

### Updated `GoRouter` Configuration

```dart
GoRoute(
  path: Screen.textEditing.path, // Add a new path in Screen enum
  builder: (context, state) {
    final Map<String, dynamic> extra = state.extra as Map<String, dynamic>;
    return TextEditingPage(
      title: extra['title'] as String,
      initialText: extra['initialText'] as String,
      onSave: extra['onSave'] as void Function(String),
    );
  },
),
```

### Example Navigation to `TextEditingPage`

When navigating to the `TextEditingPage`, pass the required parameters through `GoRouter`'s `context.push()` or `context.go()`:

```dart
context.push(
  Screen.textEditing.path,
  extra: {
    'title': 'Edit Profile',
    'initialText': 'Initial content here',
    'onSave': (updatedText) {
      // Handle the save action
      print('Saved text: $updatedText');
    },
  },
);
```

### Adding a Path in the `Screen` Enum

Ensure that you define a path for `TextEditingPage` in your `Screen` enum:

```dart
enum Screen {
  // Other paths
  textEditing('/text-editing'),
  // Add other paths if necessary
}
```

This approach ensures that `TextEditingPage` can be dynamically configured with parameters while remaining managed by `GoRouter`.

---

## 👤 ユーザー
*2025/01/07 15:50:27*

GoRoute(
      path: Screen.textEditing.path,
      builder: (context, state) {
        final extra = state.extra! as Map&lt;String, dynamic&gt;;
        return TextEditingPage(
          title: extra['title'] as String,
          initialText: extra['initialText'] as String,
          onSave: extra['onSave'] as void Function(String),
        );
      },
    ),

これはmapではなく構造体を使うのはダメなのか？

---

## 🤖 アシスタント
*2025/01/07 15:50:40*

構造体を使うことは問題ありませんし、むしろ推奨される場合もあります。構造体を使用することで、渡されるデータの型安全性が向上し、意図しないエラーを防ぐことができます。また、コードの可読性も向上します。

以下は、構造体を使った方法の例です。

### 構造体の定義

```dart
class TextEditingPageArgs {
  final String title;
  final String initialText;
  final void Function(String updatedText) onSave;

  TextEditingPageArgs({
    required this.title,
    required this.initialText,
    required this.onSave,
  });
}
```

### `GoRoute`の定義

`state.extra`で構造体を受け取るようにします。

```dart
GoRoute(
  path: Screen.textEditing.path,
  builder: (context, state) {
    final args = state.extra! as TextEditingPageArgs;
    return TextEditingPage(
      title: args.title,
      initialText: args.initialText,
      onSave: args.onSave,
    );
  },
),
```

### 遷移時の例

以下のように構造体を渡して遷移します。

```dart
context.push(
  Screen.textEditing.path,
  extra: TextEditingPageArgs(
    title: 'Edit Profile',
    initialText: 'Initial content here',
    onSave: (updatedText) {
      print('Saved text: $updatedText');
    },
  ),
);
```

### 構造体を使うメリット

1. **型安全性の向上**  
   `Map<String, dynamic>`を使う場合、キーが間違っていたり、型が一致しなかったりしてもコンパイル時には検出できません。一方で、構造体を使う場合、コンパイル時に型チェックが行われるため、安全性が向上します。

2. **コードの可読性向上**  
   構造体を使うことで、コードから引数の意味が明確になります。`extra['title']`や`extra['onSave']`のようなマジック文字列を避けられます。

3. **変更の柔軟性**  
   構造体に新しいフィールドを追加する場合、変更点が集中しているため、メンテナンスが簡単になります。

### まとめ

構造体を使うのは非常に良い設計であり、FlutterやDartのコードベースではよく使われます。`Map<String, dynamic>`を使うのは短期的には簡便ですが、将来的なスケーラビリティや型安全性を考慮すると構造体の使用を強くお勧めします。

---

## 👤 ユーザー
*2025/01/07 15:51:04*

パラメーターを複数宣言することはできないのか？

---

## 🤖 アシスタント
*2025/01/07 15:51:33*

`GoRouter`では、通常、ルートのパラメーターは以下の方法で渡すことができます：

1. **パスパラメーター**  
   URLに直接埋め込む方法。`GoRoute`の`path`に`:paramName`として定義します。

2. **クエリパラメーター**  
   URLにクエリ文字列として追加する方法。`state.queryParameters`で取得します。

3. **extra**プロパティを使用する方法  
   任意のデータを`extra`として渡す方法。この方法が一番柔軟で、複数のデータもまとめて渡せます。

以下では、それぞれの方法を解説します。

---

### 1. パスパラメーターを使う

**例:**  
`TextEditingPage`で`title`と`initialText`をパスパラメーターとして渡す。

```dart
GoRoute(
  path: '/text-editing/:title/:initialText',
  builder: (context, state) {
    final title = state.params['title']!;
    final initialText = state.params['initialText']!;
    return TextEditingPage(
      title: title,
      initialText: initialText,
      onSave: (updatedText) {
        // 保存処理
      },
    );
  },
),
```

#### 遷移時の例

```dart
context.push('/text-editing/Edit%20Profile/Initial%20content');
```

---

### 2. クエリパラメーターを使う

**例:**  
クエリパラメーターで`title`と`initialText`を渡す。

```dart
GoRoute(
  path: '/text-editing',
  builder: (context, state) {
    final title = state.queryParameters['title']!;
    final initialText = state.queryParameters['initialText']!;
    return TextEditingPage(
      title: title,
      initialText: initialText,
      onSave: (updatedText) {
        // 保存処理
      },
    );
  },
),
```

#### 遷移時の例

```dart
context.push('/text-editing?title=Edit%20Profile&initialText=Initial%20content');
```

---

### 3. `extra`を使う（推奨）

複数のデータを構造体や`Map`で渡す場合は、`extra`を使う方法が柔軟です。

#### 構造体を使った例

```dart
GoRoute(
  path: '/text-editing',
  builder: (context, state) {
    final args = state.extra! as TextEditingPageArgs;
    return TextEditingPage(
      title: args.title,
      initialText: args.initialText,
      onSave: args.onSave,
    );
  },
),
```

#### 構造体の定義

```dart
class TextEditingPageArgs {
  final String title;
  final String initialText;
  final void Function(String updatedText) onSave;

  TextEditingPageArgs({
    required this.title,
    required this.initialText,
    required this.onSave,
  });
}
```

#### 遷移時の例

```dart
context.push(
  '/text-editing',
  extra: TextEditingPageArgs(
    title: 'Edit Profile',
    initialText: 'Initial content here',
    onSave: (updatedText) {
      print('Saved text: $updatedText');
    },
  ),
);
```

---

### パスパラメーター vs クエリパラメーター vs extra

- **パスパラメーター**  
  URLに含めたいデータが少ない場合（例: `id`や`slug`）。URLに意味を持たせたいときに適しています。

- **クエリパラメーター**  
  フィルタリングや検索条件のような追加情報を渡したい場合に適しています。

- **extra**（推奨）  
  オブジェクトや関数など複雑なデータを渡したい場合に最適。型安全にデータをやり取りできます。

---

### 結論

複数のパラメーターを渡す必要がある場合は、状況に応じてこれらの方法を使い分けられます。特に、柔軟性と安全性を考えると`extra`に構造体を渡す方法が最も推奨されます。

---

## 👤 ユーザー
*2025/01/07 15:51:55*

extraは複数取れないのか？ swiftのいうところのタプルみたいな

---

## 🤖 アシスタント
*2025/01/07 15:52:22*

Dart/Flutterの`GoRouter`で渡す`extra`は、単一のオブジェクトのみ渡すことが可能です。しかし、その単一オブジェクトの中に複数のデータを含めることはできます。Swiftのタプルのような形でデータを渡したい場合、Dartでは以下のいずれかの方法で実現可能です。

---

### 方法1: 構造体（クラスやデータクラス）を使用

複数のデータを持つ構造体を作成して、それを`extra`として渡します。

```dart
class TextEditingPageArgs {
  final String title;
  final String initialText;
  final void Function(String updatedText) onSave;

  TextEditingPageArgs({
    required this.title,
    required this.initialText,
    required this.onSave,
  });
}
```

#### `GoRoute`の設定

```dart
GoRoute(
  path: '/text-editing',
  builder: (context, state) {
    final args = state.extra! as TextEditingPageArgs;
    return TextEditingPage(
      title: args.title,
      initialText: args.initialText,
      onSave: args.onSave,
    );
  },
),
```

#### 遷移時のコード

```dart
context.push(
  '/text-editing',
  extra: TextEditingPageArgs(
    title: 'Edit Profile',
    initialText: 'Initial content here',
    onSave: (updatedText) {
      print('Saved text: $updatedText');
    },
  ),
);
```

---

### 方法2: マップ（`Map<String, dynamic>`）を使用

タプルのような簡易的な方法として、マップを使うこともできます。

#### `GoRoute`の設定

```dart
GoRoute(
  path: '/text-editing',
  builder: (context, state) {
    final args = state.extra! as Map<String, dynamic>;
    return TextEditingPage(
      title: args['title'] as String,
      initialText: args['initialText'] as String,
      onSave: args['onSave'] as void Function(String),
    );
  },
),
```

#### 遷移時のコード

```dart
context.push(
  '/text-editing',
  extra: {
    'title': 'Edit Profile',
    'initialText': 'Initial content here',
    'onSave': (String updatedText) {
      print('Saved text: $updatedText');
    },
  },
);
```

---

### 方法3: 無名タプル風（リストなどの代替）

Dartではタプルが直接サポートされていませんが、リストや配列を使って類似の挙動を実現できます。ただし、この方法は型安全性が低下します。

#### `GoRoute`の設定

```dart
GoRoute(
  path: '/text-editing',
  builder: (context, state) {
    final args = state.extra! as List;
    return TextEditingPage(
      title: args[0] as String,
      initialText: args[1] as String,
      onSave: args[2] as void Function(String),
    );
  },
),
```

#### 遷移時のコード

```dart
context.push(
  '/text-editing',
  extra: [
    'Edit Profile',
    'Initial content here',
    (String updatedText) {
      print('Saved text: $updatedText');
    },
  ],
);
```

---

### 比較

| 方法                  | メリット                                                | デメリット                              |
|-----------------------|-------------------------------------------------------|----------------------------------------|
| **構造体（クラス）**   | 型安全で拡張性が高い                                    | 定義が少し冗長                         |
| **マップ**             | 柔軟性が高く簡易的                                     | 型安全性が低く、キーのタイプミスが発生しやすい |
| **リスト**             | 簡易的でSwiftのタプルに近い使い方                       | 型安全性が低く、引数の順序が重要になる  |

---

### 結論

**構造体（クラス）を使う方法が最も推奨されます。**  
理由は型安全性が高く、複雑なデータを扱う際の柔軟性が高いからです。特にプロジェクトが大規模化する場合、メンテナンス性にも優れています。  
ただし、簡易的な用途であればマップやリストを使うのも良い選択肢です。

---

## 👤 ユーザー
*2025/01/07 15:55:00*

構造体を使ってほしい
以下を修正してほしい

ListTile(
                  title: const Text('Name'),
                  subtitle: Text(guildName),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () {
                    // Navigate to the TextEditingScreen for name change
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) =&gt; TextEditingScreen(
                          title: 'Edit Guild Name',
                          initialText: guildName,
                          onSave: (updatedText) async {
                            if (updatedText.isNotEmpty && updatedText != guildName) {
                              // Call the API to update the guild name (mocked as a comment).
                              // await api.updateGuildName(updatedText);

                              // Refresh guild information.
                              await ref
                                  .read(getMyGuildNotifierProvider.notifier)
                                  .executeRequest();
                            }
                          },
                        ),
                      ),
                    );
                  },
                ),

---

## 🤖 アシスタント
*2025/01/07 15:55:20*

以下のように構造体を使ってコードを修正しました。これにより、`TextEditingScreen`の引数を型安全に扱うことができます。

### 構造体の定義

まず、構造体を定義します。

```dart
class TextEditingArgs {
  final String title;
  final String initialText;
  final Future<void> Function(String updatedText) onSave;

  TextEditingArgs({
    required this.title,
    required this.initialText,
    required this.onSave,
  });
}
```

---

### `ListTile`の修正

以下は修正済みの`ListTile`コードです。`TextEditingScreen`は構造体を受け取る形に変更しました。

```dart
ListTile(
  title: const Text('Name'),
  subtitle: Text(guildName),
  trailing: const Icon(Icons.chevron_right),
  onTap: () {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => TextEditingScreen(
          args: TextEditingArgs(
            title: 'Edit Guild Name',
            initialText: guildName,
            onSave: (updatedText) async {
              if (updatedText.isNotEmpty && updatedText != guildName) {
                // Call the API to update the guild name (mocked as a comment).
                // await api.updateGuildName(updatedText);

                // Refresh guild information.
                await ref
                    .read(getMyGuildNotifierProvider.notifier)
                    .executeRequest();
              }
            },
          ),
        ),
      ),
    );
  },
),
```

---

### `TextEditingScreen`の修正

`TextEditingScreen`で構造体を受け取るように変更します。

```dart
class TextEditingScreen extends StatelessWidget {
  const TextEditingScreen({
    super.key,
    required this.args,
  });

  final TextEditingArgs args;

  @override
  Widget build(BuildContext context) {
    final textController = TextEditingController(text: args.initialText);

    return Scaffold(
      appBar: AppBar(
        title: Text(args.title),
        actions: [
          ElevatedButton(
            onPressed: () async {
              final updatedText = textController.text;
              await args.onSave(updatedText);
              Navigator.pop(context);
            },
            child: const Text('Save'),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TextField(
          controller: textController,
          decoration: const InputDecoration(
            labelText: 'Edit Text',
            border: UnderlineInputBorder(),
          ),
        ),
      ),
    );
  }
}
```

---

### 主な変更点

1. **構造体`TextEditingArgs`を導入**  
   型安全かつ柔軟にパラメーターを扱えるようにしました。

2. **`onTap`で構造体を渡す**  
   `TextEditingArgs`を作成し、`Navigator.push`で渡しています。

3. **`TextEditingScreen`で構造体を受け取るよう変更**  
   引数を直接受け取るのではなく、構造体を通して渡すようにしました。

---

この変更により、`TextEditingScreen`の引数管理が簡単になり、型安全性と可読性が向上します。また、将来的にパラメーターを追加する場合も、構造体にフィールドを追加するだけで済みます。

---

## 👤 ユーザー
*2025/01/07 15:56:27*

ゴールータを使って遷移してほしい

---

## 🤖 アシスタント
*2025/01/07 15:56:53*

以下は`GoRouter`を使用して構造体を活用した遷移を実現する修正版です。

---

### 構造体の定義

まず、構造体を定義します。

```dart
class TextEditingArgs {
  final String title;
  final String initialText;
  final Future<void> Function(String updatedText) onSave;

  TextEditingArgs({
    required this.title,
    required this.initialText,
    required this.onSave,
  });
}
```

---

### `GoRouter`のルート設定

`GoRouter`の設定に、新しい`TextEditingScreen`のルートを追加します。

```dart
final GoRouter router = GoRouter(
  initialLocation: '/home', // 必要に応じて変更
  routes: [
    // 他のルート設定...
    GoRoute(
      path: '/text-editing',
      builder: (context, state) {
        final args = state.extra! as TextEditingArgs;
        return TextEditingScreen(args: args);
      },
    ),
  ],
);
```

---

### `ListTile`の修正

`Navigator.push`の代わりに`GoRouter`を使った遷移に変更します。

```dart
ListTile(
  title: const Text('Name'),
  subtitle: Text(guildName),
  trailing: const Icon(Icons.chevron_right),
  onTap: () {
    context.push(
      '/text-editing',
      extra: TextEditingArgs(
        title: 'Edit Guild Name',
        initialText: guildName,
        onSave: (updatedText) async {
          if (updatedText.isNotEmpty && updatedText != guildName) {
            // APIでギルド名を更新（モックとしてコメント）
            // await api.updateGuildName(updatedText);

            // ギルド情報をリフレッシュ
            await ref
                .read(getMyGuildNotifierProvider.notifier)
                .executeRequest();
          }
        },
      ),
    );
  },
),
```

---

### `TextEditingScreen`の実装

`GoRouter`経由で構造体を受け取る`TextEditingScreen`を以下のように実装します。

```dart
class TextEditingScreen extends StatelessWidget {
  const TextEditingScreen({
    super.key,
    required this.args,
  });

  final TextEditingArgs args;

  @override
  Widget build(BuildContext context) {
    final textController = TextEditingController(text: args.initialText);

    return Scaffold(
      appBar: AppBar(
        title: Text(args.title),
        actions: [
          ElevatedButton(
            onPressed: () async {
              final updatedText = textController.text;
              await args.onSave(updatedText);
              context.pop(); // 遷移元に戻る
            },
            child: const Text('Save'),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TextField(
          controller: textController,
          decoration: const InputDecoration(
            labelText: 'Edit Text',
            border: UnderlineInputBorder(),
          ),
        ),
      ),
    );
  }
}
```

---

### 主な変更点

1. **`GoRouter`を利用したルート管理**  
   `/text-editing`というルートを追加し、`extra`を通じて構造体を渡しています。

2. **`context.push`で遷移**  
   `Navigator.push`の代わりに、`GoRouter`の`context.push`を使っています。

3. **構造体で型安全にデータを渡す**  
   `TextEditingArgs`構造体を通じて、`title`、`initialText`、`onSave`を型安全に渡します。

---

### 実行例

1. **リストタイルのタップで遷移**  
   `ListTile`をタップすると、`/text-editing`に遷移します。

2. **データ更新と戻る処理**  
   `TextEditingScreen`でデータを更新後、`context.pop()`で元の画面に戻ります。

---

これにより、`GoRouter`を使用して型安全かつ柔軟な遷移が可能になります。必要に応じて他の画面にも同様の手法を適用できます。

---
