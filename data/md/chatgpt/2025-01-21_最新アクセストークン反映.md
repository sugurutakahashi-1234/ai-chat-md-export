# 最新アクセストークン反映

Date: 2025-01-21

---

## 👤 User
*2025-01-21 19:14:48*

表示するアクセストークンについて、常に最新の値になるように修正してほしい
現在の実装だと、この画面で最新のアクセストークンを設定しようとしても更新されない。

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/presentation/providers/access_token.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/delete_guild.dart';

class DebugUtilityPage extends HookConsumerWidget {
  const DebugUtilityPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentAccessToken = ref.watch(accessTokenNotifierProvider.future);

    Future&lt;void&gt; onTapDeleteGuild() async {
      final result = await showDialog&lt;bool&gt;(
        context: context,
        builder: (context) =&gt; AlertDialog(
          title: const Text('Delete Guild'),
          content: const Text(
            'Are you sure you want to delete this guild?',
          ),
          actions: [
            TextButton(
              onPressed: () {
                context.pop(false);
              },
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                context.pop(true);
              },
              child: const Text('Delete'),
            ),
          ],
        ),
      );

      if (result == true) {
        try {
          await ref.watch(deleteGuildNotifierProvider.notifier).deleteGuild();
          if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Deleting guild...'),
              ),
            );
          }
        } on Exception catch (e) {
          if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Error deleting guild: $e')),
            );
          }
        }
      }
    }

    Future&lt;void&gt; onTapAccessToken(String accessToken) async {
      await Clipboard.setData(
        ClipboardData(text: accessToken),
      );
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Access token copied to clipboard.'),
          ),
        );
      }
    }

    Future&lt;void&gt; onTapDeleteAccessToken() async {
      final result = await showDialog&lt;bool&gt;(
        context: context,
        builder: (context) =&gt; AlertDialog(
          title: const Text('Delete Access Token'),
          content: const Text(
            'Delete the access token?',
          ),
          actions: [
            TextButton(
              onPressed: () {
                context.pop(false);
              },
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                context.pop(true);
              },
              child: const Text('Delete'),
            ),
          ],
        ),
      );

      if (result == true) {
        await ref
            .watch(accessTokenNotifierProvider.notifier)
            .delete();
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Access token deleted successfully.'),
            ),
          );
        }
      }
    }

    Future&lt;void&gt; onTapSetAccessToken() async {
      final result = await showDialog&lt;String&gt;(
        context: context,
        builder: (context) {
          final controller = TextEditingController();
          return AlertDialog(
            title: const Text('Set Access Token'),
            content: TextField(
              controller: controller,
              decoration: const InputDecoration(
                hintText: 'Access Token',
              ),
            ),
            actions: [
              TextButton(
                onPressed: () {
                  context.pop();
                },
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () {
                  context.pop(controller.text);
                },
                child: const Text('Set'),
              ),
            ],
          );
        },
      );

      if (result != null) {
        await ref
            .watch(accessTokenNotifierProvider.notifier)
            .save(result);
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Access token set successfully.'),
            ),
          );
        }
      }
    }

    return Scaffold(
      appBar: AppBar(title: const Text('Debug Utility')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: SingleChildScrollView(
          child: Column(
            children: [
              ElevatedButton(
                onPressed: () async {
                  await onTapDeleteGuild();
                },
                child: const Text('Delete Guild'),
              ),
              const SizedBox(height: 16),
              const Text(
                'Access Token Management',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              FutureBuilder&lt;String?&gt;(
                future: currentAccessToken,
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const CircularProgressIndicator();
                  } else if (snapshot.hasError) {
                    return Text('Error: ${snapshot.error}');
                  } else if (snapshot.hasData) {
                    return GestureDetector(
                      onTap: () async {
                        await onTapAccessToken(snapshot.data ?? '');
                      },
                      child: Text(
                        'Access Token: ${snapshot.data}',
                        style: const TextStyle(
                          fontSize: 16,
                          decoration: TextDecoration.underline,
                        ),
                      ),
                    );
                  } else {
                    return const Text('No Access Token');
                  }
                },
              ),
              const SizedBox(height: 8),
              ElevatedButton(
                onPressed: () async {
                  await onTapDeleteAccessToken();
                },
                child: const Text('Delete Access Token'),
              ),
              const SizedBox(height: 8),
              ElevatedButton(
                onPressed: () async {
                  await onTapSetAccessToken();
                },
                child: const Text('Set Access Token'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

@Riverpod(keepAlive: true)
class AccessTokenNotifier extends _$AccessTokenNotifier {
  @override
  Future&lt;String?&gt; build() async {
    final storage = ref.read(flutterSecureStorageProvider);
    return storage.read(key: SecureStorageKey.accessToken.name);
  }

  Future&lt;void&gt; save(String accessToken) async {
    final storage = ref.read(flutterSecureStorageProvider);
    await storage.write(
      key: SecureStorageKey.accessToken.name,
      value: accessToken,
    );
    state = AsyncData(accessToken);
  }

  Future&lt;void&gt; delete() async {
    final storage = ref.read(flutterSecureStorageProvider);
    await storage.delete(key: SecureStorageKey.accessToken.name);
    state = const AsyncData(null);
  }
}

---

## 🔧 Tool
*2025-01-21 19:15:55*

**Adjusting the approach**

Thinking through how to manage the token state updates. Instead of a static future, I suggest using `ref.watch(accessTokenNotifierProvider)`, which returns an `AsyncValue<String?>`. This way, UI reacts to changes efficiently.

**Switching strategies**

I’m switching from `future` to `AsyncValue<String?>` to ensure the access token stays updated. This change will keep the UI responsive to token status changes.

**Advocating for Riverpod's state management**

OK, I’m emphasizing Riverpod's built-in state management over `FutureBuilder`. By using `ref.watch(accessTokenNotifierProvider)`, the UI updates effortlessly with the latest access token values, ensuring seamless integration.

**Prioritizing simplicity**

I'm opting for `AsyncValue` over `FutureBuilder`. This method ensures seamless UI updates with the latest access token, avoiding re-watching the future or creating new ones.

**Revisiting the approach**

I’m focusing on using `AsyncValue` from Riverpod instead of `FutureBuilder`. This method ensures the UI displays the latest access token reliably and efficiently.

---

## 🤖 Assistant
*2025-01-21 19:15:55*

Riverpod では、`ref.watch(someNotifierProvider)` で取得した値を `AsyncValue` として直接購読することで、常に最新の状態を反映できます。  
現状のコードでは、`ref.watch(accessTokenNotifierProvider.future)` を使って `Future` を取得し、`FutureBuilder` で描画しているため、一度 `Future` が完了したあとの再ビルドで最新の値が取得されず、画面が更新されないという問題が起きています。  

以下のように修正し、`ref.watch(accessTokenNotifierProvider)` を用いて `AsyncValue<String?>` を直接監視する形に変更することで、トークンが更新された際にUIも自動的に再ビルドされ、常に最新の値を表示できます。

## 修正例

```diff
 import 'package:flutter/material.dart';
 import 'package:flutter/services.dart';
 import 'package:go_router/go_router.dart';
 import 'package:hooks_riverpod/hooks_riverpod.dart';
 import 'package:snpit_guild_app/presentation/providers/access_token.dart';
 import 'package:snpit_guild_app/presentation/providers/api_client/guilds/delete_guild.dart';

 class DebugUtilityPage extends HookConsumerWidget {
   const DebugUtilityPage({super.key});

   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    // 変更前: Future<String?> を取得してしまうため、その後の更新で画面に反映されない
-    final currentAccessToken = ref.watch(accessTokenNotifierProvider.future);

+    // 変更後: AsyncValue<String?> を直接監視
+    final currentAccessToken = ref.watch(accessTokenNotifierProvider);

     Future<void> onTapDeleteGuild() async {
       final result = await showDialog<bool>(
         context: context,
         builder: (context) => AlertDialog(
           title: const Text('Delete Guild'),
           content: const Text(
             'Are you sure you want to delete this guild?',
           ),
           actions: [
             TextButton(
               onPressed: () {
                 context.pop(false);
               },
               child: const Text('Cancel'),
             ),
             TextButton(
               onPressed: () {
                 context.pop(true);
               },
               child: const Text('Delete'),
             ),
           ],
         ),
       );

       if (result == true) {
         try {
           await ref.watch(deleteGuildNotifierProvider.notifier).deleteGuild();
           if (context.mounted) {
             ScaffoldMessenger.of(context).showSnackBar(
               const SnackBar(
                 content: Text('Deleting guild...'),
               ),
             );
           }
         } on Exception catch (e) {
           if (context.mounted) {
             ScaffoldMessenger.of(context).showSnackBar(
               SnackBar(content: Text('Error deleting guild: $e')),
             );
           }
         }
       }
     }

     Future<void> onTapAccessToken(String accessToken) async {
       await Clipboard.setData(
         ClipboardData(text: accessToken),
       );
       if (context.mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(
             content: Text('Access token copied to clipboard.'),
           ),
         );
       }
     }

     Future<void> onTapDeleteAccessToken() async {
       final result = await showDialog<bool>(
         context: context,
         builder: (context) => AlertDialog(
           title: const Text('Delete Access Token'),
           content: const Text(
             'Delete the access token?',
           ),
           actions: [
             TextButton(
               onPressed: () {
                 context.pop(false);
               },
               child: const Text('Cancel'),
             ),
             TextButton(
               onPressed: () {
                 context.pop(true);
               },
               child: const Text('Delete'),
             ),
           ],
         ),
       );

       if (result == true) {
         await ref.watch(accessTokenNotifierProvider.notifier).delete();
         if (context.mounted) {
           ScaffoldMessenger.of(context).showSnackBar(
             const SnackBar(
               content: Text('Access token deleted successfully.'),
             ),
           );
         }
       }
     }

     Future<void> onTapSetAccessToken() async {
       final result = await showDialog<String>(
         context: context,
         builder: (context) {
           final controller = TextEditingController();
           return AlertDialog(
             title: const Text('Set Access Token'),
             content: TextField(
               controller: controller,
               decoration: const InputDecoration(
                 hintText: 'Access Token',
               ),
             ),
             actions: [
               TextButton(
                 onPressed: () {
                   context.pop();
                 },
                 child: const Text('Cancel'),
               ),
               TextButton(
                 onPressed: () {
                   context.pop(controller.text);
                 },
                 child: const Text('Set'),
               ),
             ],
           );
         },
       );

       if (result != null) {
         await ref.watch(accessTokenNotifierProvider.notifier).save(result);
         if (context.mounted) {
           ScaffoldMessenger.of(context).showSnackBar(
             const SnackBar(
               content: Text('Access token set successfully.'),
             ),
           );
         }
       }
     }

     return Scaffold(
       appBar: AppBar(title: const Text('Debug Utility')),
       body: Padding(
         padding: const EdgeInsets.all(16),
         child: SingleChildScrollView(
           child: Column(
             children: [
               ElevatedButton(
                 onPressed: () async {
                   await onTapDeleteGuild();
                 },
                 child: const Text('Delete Guild'),
               ),
               const SizedBox(height: 16),
               const Text(
                 'Access Token Management',
                 style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
               ),
               const SizedBox(height: 8),

-              // 変更前: FutureBuilder を使用
-              FutureBuilder<String?>(
-                future: currentAccessToken,
-                builder: (context, snapshot) {
-                  if (snapshot.connectionState == ConnectionState.waiting) {
-                    return const CircularProgressIndicator();
-                  } else if (snapshot.hasError) {
-                    return Text('Error: ${snapshot.error}');
-                  } else if (snapshot.hasData) {
-                    return GestureDetector(
-                      onTap: () async {
-                        await onTapAccessToken(snapshot.data ?? '');
-                      },
-                      child: Text(
-                        'Access Token: ${snapshot.data}',
-                        style: const TextStyle(
-                          fontSize: 16,
-                          decoration: TextDecoration.underline,
-                        ),
-                      ),
-                    );
-                  } else {
-                    return const Text('No Access Token');
-                  }
-                },
-              ),

+              // 変更後: Riverpod の AsyncValue を .when() で処理
+              currentAccessToken.when(
+                loading: () => const CircularProgressIndicator(),
+                error: (error, stack) => Text('Error: $error'),
+                data: (token) {
+                  if (token == null) {
+                    return const Text('No Access Token');
+                  }
+                  return GestureDetector(
+                    onTap: () async {
+                      await onTapAccessToken(token);
+                    },
+                    child: Text(
+                      'Access Token: $token',
+                      style: const TextStyle(
+                        fontSize: 16,
+                        decoration: TextDecoration.underline,
+                      ),
+                    ),
+                  );
+                },
+              ),

               const SizedBox(height: 8),
               ElevatedButton(
                 onPressed: () async {
                   await onTapDeleteAccessToken();
                 },
                 child: const Text('Delete Access Token'),
               ),
               const SizedBox(height: 8),
               ElevatedButton(
                 onPressed: () async {
                   await onTapSetAccessToken();
                 },
                 child: const Text('Set Access Token'),
               ),
             ],
           ),
         ),
       ),
     );
   }
 }

```

ポイントは以下の通りです。  

1. **`future` ではなく `AsyncValue` を直接 `watch` する**  
   `ref.watch(accessTokenNotifierProvider.future)` で `Future` を取得すると、一度完了したあとの再ビルドで最新の値を取得できません。  
   代わりに `ref.watch(accessTokenNotifierProvider)` を使うと、`AsyncValue<String?>` として常に最新の状態を監視できるようになります。

2. **UI での表示は `AsyncValue.when` または `maybeWhen` などを使う**  
   `AsyncValue<T>` は `when(data, loading, error)` などのメソッドを通じて状態に応じた UI を簡単に書き分けられます。

3. **トークンを保存/削除したあとに `state` を更新する**  
   `save` メソッドや `delete` メソッドでは、確実に `state = AsyncData(...)` を呼び出しているため、`watch` している側の UI は再ビルドされて最新の値が反映されます。

以上の修正を行えば、画面上でアクセストークンをセット・削除したとき、常に最新の値が表示されるようになります。

---
