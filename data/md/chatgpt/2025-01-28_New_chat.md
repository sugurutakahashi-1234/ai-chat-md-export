# New chat

日付: 2025-01-28

---

## 👤 ユーザー
*2025/1/28 19:05:55*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-5z9gA2L7sTGQek4DjsdEUb",
  "size_bytes": 36495,
  "width": 294,
  "height": 506,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
添付した画像の画面を実装して欲しい。
与えたコードは実装済みで、WalletPageのみを出力して欲しい。

ExplorerDTOとFlagDTOを抽象化した NFTというクラスを定義して、explorersと flags をそのNFTに変換して、NFTのListを表示するようにしたい。

enum で NftType を定義して、explorerとflag としたい。

NFTというクラスには String nftId, String tokenId, String name, String imageUrl, NftType nftType としたい。
 
 また、NFTというクラスにはもともとのExplorerDTO or FlagDTOを保持するようにしたい。enumで連想値を持ってもいいし、ExplorerDTO? と FlagDTO? を持つようにして、片方だけ null ではないようにしてもいい。見通しがいい方がいい。

タップした時の処理はWidget build(BuildContext context, WidgetRef ref) {に onTapNft() として定義して欲しい。

画像の上部のように stp の値とwallet のidを表示していて、wallet のidをタップしたらクリップボードにコピーするようにして欲しい。その際にスナックバーを表示してほしい。これもタップした時の処理はWidget build(BuildContext context, WidgetRef ref) {に onTapWalletId(String walletId) としてほしい。

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/nfts/get_nfts.dart';

class WalletPage extends HookConsumerWidget {
  const WalletPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final getNftsStateAsyncValue = ref.watch(getNftsNotifierProvider);

    useEffect(
      () {
        Future.microtask(() async {
          await ref.watch(getNftsNotifierProvider.notifier).getNfts();
        });
        return null;
      },
      [],
    );

    return Scaffold(
      appBar: AppBar(title: const Text('Wallet')),
      body: getNftsStateAsyncValue.when(
        data: (nfts) {
          return const Text('hoge');
        },
        loading: () {
          return const Center(
            child: CircularProgressIndicator(),
          );
        },
        error: (error, _) {
          return Center(
            child: Text('Error: $error'),
          );
        },
      ),
    );
  }
}



@freezed
class GetUserNftsResponseDTOData with _$GetUserNftsResponseDTOData {
  factory GetUserNftsResponseDTOData({
    @JsonKey(name: 'wallet') String? wallet,
    @JsonKey(name: 'stp') num? stp,
    @JsonKey(name: 'explorers') required List&lt;ExplorerDTO&gt;? explorers,
    @JsonKey(name: 'flags') required List&lt;FlagDTO&gt;? flags,
  }) = _GetUserNftsResponseDTOData;

  factory GetUserNftsResponseDTOData.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$GetUserNftsResponseDTODataFromJson(jsonMap);
}

@freezed
class ExplorerDTO with _$ExplorerDTO {
  factory ExplorerDTO({
    @JsonKey(name: 'explorerId') required String? explorerId,
    @JsonKey(name: 'tokenId') required String? tokenId,
    @JsonKey(name: 'explorerName') required String? explorerName,
    @JsonKey(name: 'explorerDescription') String? explorerDescription,
    @JsonKey(name: 'explorerImage') required String? explorerImage,
    @JsonKey(name: 'explorerCategory')
    required ExplorerDTOExplorerCategory? explorerCategory,
    @JsonKey(name: 'energy') required num? energy,
    @JsonKey(name: 'rarity') required ExplorerDTORarity? rarity,
    @JsonKey(name: 'energyConsumption') required num? energyConsumption,
    @JsonKey(name: 'range') required num? range,
    @JsonKey(name: 'decoyFinding') required bool? decoyFinding,
    @JsonKey(name: 'totalSearch') required num? totalSearch,
    @JsonKey(name: 'totalSpotFound') required num? totalSpotFound,
  }) = _ExplorerDTO;

  factory ExplorerDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$ExplorerDTOFromJson(jsonMap);
}


@freezed
class FlagDTO with _$FlagDTO {
  factory FlagDTO({
    @JsonKey(name: 'flagId') required String? flagId,
    @JsonKey(name: 'tokenId') required String? tokenId,
    @JsonKey(name: 'flagName') required String? flagName,
    @JsonKey(name: 'flagDescription') String? flagDescription,
    @JsonKey(name: 'flagImage') required String? flagImage,
    @JsonKey(name: 'flagCategory') required FlagDTOFlagCategory? flagCategory,
    @JsonKey(name: 'flagStatus') required FlagDTOFlagStatus? flagStatus,
    @JsonKey(name: 'level') required num? level,
    @JsonKey(name: 'endurance') required num? endurance,
    @JsonKey(name: 'defended') required num? defended,
    @JsonKey(name: 'rarity') required FlagDTORarity? rarity,
    @JsonKey(name: 'flagIncome') required num? flagIncome,
    @JsonKey(name: 'leftHandId') String? leftHandId,
    @JsonKey(name: 'rightHand') String? rightHand,
  }) = _FlagDTO;

  factory FlagDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$FlagDTOFromJson(jsonMap);
}


part 'get_nfts.g.dart';

@Riverpod(keepAlive: true)
class GetNftsNotifier extends _$GetNftsNotifier {
  @override
  Future&lt;GetUserNftsResponseDTOData?&gt; build() async =&gt; null;

  Future&lt;GetUserNftsResponseDTOData&gt; getNfts() async {
    state = const AsyncValue.loading();
    try {
      try {
        final api = await ref.watch(usersApiProvider.future);
        final response = await api.userControllerGetUserNfts();
        debugPrint('Response Body: ${response.data}');
        debugPrint('Response Body.data: ${response.data?.data}');
        checkForApiError(response.data);
        final data = response.data?.data;
        if (data == null) {
          throw Exception('No data found');
        }
        state = AsyncValue.data(data);
        return data;
      } on DioException catch (error) {
        debugPrintDioException(error);
        checkForApiError(error.response?.data);
        rethrow;
      } on Exception {
        rethrow;
      }
    } on ApiError catch (error, stackTrace) {
      debugPrintApiError(error);
      if (error.type.shouldLogout) {
        ref.read(shouldLogoutNotifierProvider.notifier).trigger();
      }
      state = AsyncValue.error(error, stackTrace);
      rethrow;
    } on Exception catch (error, stackTrace) {
      debugPrint('Error: $error');
      state = AsyncValue.error(error, stackTrace);
      rethrow;
    }
  }
}

---

## 🤖 アシスタント
*2025/1/28 19:06:55*

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/nfts/get_nfts.dart';

/// NFTの種類を表すenum
enum NftType {
  explorer,
  flag,
}

/// ExplorerDTO / FlagDTO を抽象化したNFTクラス
class NFT {
  final String nftId;
  final String tokenId;
  final String name;
  final String imageUrl;
  final NftType nftType;

  /// どちらか一方のみが非nullであることを想定
  final ExplorerDTO? explorer;
  final FlagDTO? flag;

  NFT({
    required this.nftId,
    required this.tokenId,
    required this.name,
    required this.imageUrl,
    required this.nftType,
    this.explorer,
    this.flag,
  });
}

class WalletPage extends HookConsumerWidget {
  const WalletPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    /// NFTをタップしたときの処理
    void onTapNft(NFT nft) {
      // TODO: 必要があれば処理を実装
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('NFTをタップ: ${nft.name}')),
      );
    }

    /// WalletIDをタップしたときの処理
    void onTapWalletId(String walletId) {
      Clipboard.setData(ClipboardData(text: walletId));
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('$walletId をコピーしました')),
      );
    }

    final getNftsStateAsyncValue = ref.watch(getNftsNotifierProvider);

    // 初回描画時にAPIをコール
    useEffect(
      () {
        Future.microtask(() async {
          await ref.read(getNftsNotifierProvider.notifier).getNfts();
        });
        return null;
      },
      [],
    );

    return Scaffold(
      appBar: AppBar(title: const Text('Wallet')),
      body: getNftsStateAsyncValue.when(
        data: (data) {
          if (data == null) {
            return const Center(child: Text('データがありません'));
          }

          final stpValue = data.stp ?? 0;
          final walletId = data.wallet ?? '';

          // Explorer と Flag をそれぞれNFTに変換
          final explorers = data.explorers ?? [];
          final flags = data.flags ?? [];

          final explorerNfts = explorers.map((e) {
            return NFT(
              nftId: e.explorerId ?? '',
              tokenId: e.tokenId ?? '',
              name: e.explorerName ?? '',
              imageUrl: e.explorerImage ?? '',
              nftType: NftType.explorer,
              explorer: e,
              flag: null,
            );
          }).toList();

          final flagNfts = flags.map((f) {
            return NFT(
              nftId: f.flagId ?? '',
              tokenId: f.tokenId ?? '',
              name: f.flagName ?? '',
              imageUrl: f.flagImage ?? '',
              nftType: NftType.flag,
              explorer: null,
              flag: f,
            );
          }).toList();

          final allNfts = [...explorerNfts, ...flagNfts];

          return Column(
            children: [
              // 上部にSTP値とウォレットIDを表示
              Container(
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    Text(
                      '${stpValue.toStringAsFixed(6)} STP',
                      style: const TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    GestureDetector(
                      onTap: () => onTapWalletId(walletId),
                      child: Text(
                        walletId,
                        style: TextStyle(
                          color: Theme.of(context).primaryColorDark,
                          decoration: TextDecoration.underline,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 8),
              // NFTリスト
              Expanded(
                child: ListView.builder(
                  itemCount: allNfts.length,
                  itemBuilder: (context, index) {
                    final nft = allNfts[index];
                    return ListTile(
                      leading: nft.imageUrl.isNotEmpty
                          ? Image.network(nft.imageUrl)
                          : const Icon(Icons.image_not_supported),
                      title: Text('${nft.name} #${nft.nftId}'),
                      subtitle: Text('TokenID: ${nft.tokenId}'),
                      onTap: () => onTapNft(nft),
                    );
                  },
                ),
              ),
            ],
          );
        },
        loading: () {
          return const Center(
            child: CircularProgressIndicator(),
          );
        },
        error: (error, _) {
          return Center(
            child: Text('Error: $error'),
          );
        },
      ),
    );
  }
}
```

上記の `WalletPage` では以下のことを行っています:

1. **STPとWalletIDの表示**  
   - `data.stp` および `data.wallet` を利用して上部にSTP値とWalletIDを表示しています。  
   - WalletIDをタップ (`onTapWalletId`) するとクリップボードにコピーし、SnackBarを表示します。

2. **ExplorerDTO と FlagDTO を抽象化したNFTクラスの生成**  
   - `enum NftType { explorer, flag }` を定義し、`explorer` と `flag` の2種類を持つようにしています。  
   - `NFT` クラスでは `explorer` フィールドか `flag` フィールドどちらか片方だけが入る想定となっています。

3. **取得したExplorerDTO・FlagDTOリストをNFTリストに変換**  
   - `explorerNfts` と `flagNfts` に分けて生成し、`allNfts` で合体しています。

4. **ListViewによるNFTリストの表示**  
   - `name`、`nftId`、`tokenId` などを表示。  
   - タップ (`onTapNft`) するとSnackBarでメッセージを出すサンプル実装になっています。  

あとは必要に応じてUIやタップ時の具体的な処理を調整してください。

---
