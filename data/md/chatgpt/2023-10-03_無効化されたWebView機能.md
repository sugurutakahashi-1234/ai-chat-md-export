# 無効化されたWebView機能

日付: 2023-10-03

---

## 👤 ユーザー
*2023/10/03 14:53:05*

SwiftでWebViewの中でShere Web API が呼ばれるOSのシェア機能のViewが立ち上がるがそれを無効化したい

document.documentElement.style.webkitTouchCallout='none';

---

## 🤖 アシスタント
*2023/10/03 14:54:07*

シェア機能のようなものをWebView内で実行する際、iOSのWebViewやWKWebViewでJavaScriptを通じて試みられることがあります。シェア機能の呼び出しや他のネイティブ機能の呼び出しを無効にしたい場合、WKWebViewを使用するとその制御が容易になります。

シェアのような機能を無効化するための一般的な手法として、以下のステップを試してみることができます：

1. **WKNavigationDelegate** の使用: WKWebViewのデリゲートを設定して、特定のURLスキームやリクエストが行われた際の動作を制御します。

2. **JavaScriptの実行をブロック**: WKWebViewの設定を変更して、特定のJavaScriptの実行をブロックすることもできます。

以下は、WKNavigationDelegateを使用して、特定のURLスキームが開かれるのをブロックする例です：

```swift
import UIKit
import WebKit

class ViewController: UIViewController, WKNavigationDelegate {
    
    var webView: WKWebView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let webConfiguration = WKWebViewConfiguration()
        webView = WKWebView(frame: .zero, configuration: webConfiguration)
        webView.navigationDelegate = self
        view = webView
        
        let myURL = URL(string:"https://example.com")
        let myRequest = URLRequest(url: myURL!)
        webView.load(myRequest)
    }
    
    // WKNavigationDelegate
    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        
        if let url = navigationAction.request.url, url.scheme == "YOUR_SCHEME_HERE" {
            // このスキームのURLをブロックする
            decisionHandler(.cancel)
            return
        }
        
        decisionHandler(.allow)
    }
}
```

上記の例では、"YOUR_SCHEME_HERE"に該当するURLスキームが呼び出されると、それをブロックします。この方法を使用して、WebView内の特定の動作やURLの開始を制御することができます。

もし具体的なシェアの動作やURLスキームについての情報があれば、更に具体的なアドバイスやコードの提供が可能です。

---

## 👤 ユーザー
*2023/10/03 14:54:37*

Navigator.share() のようなもので呼ばれているみたい。

https://developer.mozilla.org/ja/docs/Web/API/Navigator/share

---

## 🤖 アシスタント
*2023/10/03 14:55:30*

`Navigator.share()` は、Webページからネイティブの共有ダイアログを呼び出すためのWeb APIです。これをWKWebView内で無効にするには、WKNavigationDelegateのメソッドを使用して、この特定のAPI呼び出しをブロックすることができます。

以下の手順に従って、`Navigator.share()` の呼び出しをブロックできます:

1. WKWebViewを設定し、その`navigationDelegate`を設定します。
2. `decidePolicyFor` メソッド内で、`Navigator.share()` の呼び出しを特定してブロックします。

以下は、Swiftでのサンプル実装です：

```swift
import UIKit
import WebKit

class ViewController: UIViewController, WKNavigationDelegate, WKUIDelegate {
    
    var webView: WKWebView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let webConfiguration = WKWebViewConfiguration()
        webView = WKWebView(frame: .zero, configuration: webConfiguration)
        webView.navigationDelegate = self
        webView.uiDelegate = self
        view = webView
        
        // Navigator.share() を無効化
        let disableShareScript = """
            if (navigator.share) {
                navigator.share = null;
            }
        """
        
        let userScript = WKUserScript(source: disableShareScript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        webView.configuration.userContentController.addUserScript(userScript)
        
        let myURL = URL(string:"https://example.com")
        let myRequest = URLRequest(url: myURL!)
        webView.load(myRequest)
    }
}
```

上記のサンプルコードでは、ページのロードが完了したときに`navigator.share` メソッドをnullに置き換えるJavaScriptを実行しています。これにより、ページ内のスクリプトが `Navigator.share()` を呼び出そうとすると、その機能が存在しないと判断され、共有ダイアログが表示されなくなります。

この方法を使用すると、WKWebView内での `Navigator.share()` の動作を無効化することができます。

---

## 👤 ユーザー
*2023/10/03 14:59:21*

無効化できなかった

---

## 🤖 アシスタント
*2023/10/03 15:00:22*

申し訳ございません。もし `Navigator.share()` が実行されているのであれば、それを完全にブロックするのは難しいかもしれませんが、別のアプローチで対処することができるかもしれません。

以下に、いくつかの追加の方法を提供します:

1. **リクエストを検査してブロック**: `decidePolicyFor` メソッドを使用して、Navigator.share() に関連するリクエストを検査し、それをブロックすることができます。

```swift
func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
    if let urlString = navigationAction.request.url?.absoluteString, urlString.contains("SOME_STRING_RELATED_TO_SHARE") {
        decisionHandler(.cancel)
        return
    }
    decisionHandler(.allow)
}
```

ただし、この方法でどのURLをブロックするかを特定する必要があります。

2. **JavaScriptの特定の呼び出しを検査してブロック**: `WKUserScript` を使用して、ページ上の `Navigator.share()` の呼び出しを特定し、それをオーバーライドすることもできます。

```swift
let disableShareScript = """
    document.addEventListener('DOMContentLoaded', function() {
        if (navigator.share) {
            navigator.share = function() {
                console.log('Navigator.share() was called but has been blocked.');
                return new Promise((_, reject) => {
                    reject(new Error('Navigator.share() is disabled.'));
                });
            };
        }
    });
"""

let userScript = WKUserScript(source: disableShareScript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
webView.configuration.userContentController.addUserScript(userScript)
```

このスクリプトは、ページの `Navigator.share()` の呼び出しをオーバーライドして、エラーメッセージを返すようにします。

もし上記の方法でもうまく行かない場合、具体的なコードや実行環境、問題の詳細を教えていただけると、より具体的な対応策を考えることができます。

---

## 👤 ユーザー
*2023/10/03 15:04:53*

うまくいかなった。そもそもnavigator.shareでアクセスできているのかが不明である

---

## 🤖 アシスタント
*2023/10/03 15:05:44*

`navigator.share` の呼び出しを検知するために、まずそれが呼び出されたときに明確なログやアラートを表示するようにスクリプトを注入してみるのはどうでしょうか。

以下の方法で `navigator.share` の呼び出しを検知して、WebView 内でアラートを表示させることができます:

1. **WKWebViewの設定**:

```swift
let webConfiguration = WKWebViewConfiguration()
webView = WKWebView(frame: .zero, configuration: webConfiguration)
webView.navigationDelegate = self
webView.uiDelegate = self
view = webView
```

2. **navigator.shareの呼び出しを検知してアラート表示のスクリプトを注入**:

```swift
let detectShareScript = """
    if (navigator.share) {
        let originalShare = navigator.share;
        navigator.share = function(data) {
            window.alert('Navigator.share() was called with: ' + JSON.stringify(data));
            return originalShare(data);
        };
    }
"""

let userScript = WKUserScript(source: detectShareScript, injectionTime: .atDocumentStart, forMainFrameOnly: true)
webView.configuration.userContentController.addUserScript(userScript)
```

3. **Webページの読み込み**:

```swift
let myURL = URL(string:"https://example.com")
let myRequest = URLRequest(url: myURL!)
webView.load(myRequest)
```

これにより、WebView内のWebページで `navigator.share` が呼び出された場合、データとともにアラートが表示されます。これによって、`navigator.share` の呼び出しを正確に検知できるか確認できます。

この手法を使用して `navigator.share` の呼び出しがWebView内で行われているかどうかを特定し、次のステップを計画することができます。

---

## 👤 ユーザー
*2023/10/03 15:06:15*

どうして、if (navigator.share) {で呼び出していることが検知できるの？

---

## 🤖 アシスタント
*2023/10/03 15:06:55*

申し訳ございません。おっしゃる通り、説明が不十分でした。

JavaScriptにおいて、`if (navigator.share)` のような文は、`navigator.share` が存在するかどうかをチェックします。もし `navigator.share` がundefinedまたはnullであった場合、条件はfalseとして評価されます。逆に、`navigator.share` が関数として定義されている場合、条件はtrueとして評価され、ブロック内のコードが実行されます。

したがって、このif文を使用することで、`navigator.share` が利用可能かどうかを検出しています。

具体的には、上記のスクリプトは以下の手順で動作します:

1. `navigator.share` の存在をチェック。
2. もし存在していれば、そのオリジナルの関数を `originalShare` に保存。
3. `navigator.share` を新しい関数でオーバーライド。
4. オーバーライドされた関数が呼び出されると、アラートを表示。
5. アラート表示後、オリジナルの `navigator.share` 関数 (`originalShare`) を実行。

この方法により、`navigator.share` が実際にページ内で呼び出されているかどうかを確認することができます。

---
