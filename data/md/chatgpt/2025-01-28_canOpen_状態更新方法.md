# canOpen 状態更新方法

日付: 2025-01-28

---

## 👤 ユーザー
*2025/1/28 15:05:15*

canOpenの更新をuseEffectとかでやりたい

import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:go\_router/go\_router.dart';
import 'package:google\_maps\_flutter/google\_maps\_flutter.dart';
import 'package:hooks\_riverpod/hooks\_riverpod.dart';
import 'package:snpit\_guild\_app/domain/design/color\_pallet.dart';
import 'package:snpit\_guild\_app/infrastructure/snapit\_guild\_api/snapit\_guild\_api.openapi.dart';
import 'package:snpit\_guild\_app/presentation/providers/api\_client/item\_boxes/open\_item\_box.dart';
import 'package:snpit\_guild\_app/presentation/providers/current\_location.dart';
import 'package:snpit\_guild\_app/presentation/widgets/cancel\_button.dart';
import 'package:snpit\_guild\_app/presentation/widgets/dialogs/item\_get\_dialog.dart';
import 'package:snpit\_guild\_app/presentation/widgets/square\_image.dart';
import 'package:snpit\_guild\_app/utils/snack\_bar\_utils.dart';

class ItemBoxDialog extends HookConsumerWidget {
  const ItemBoxDialog({
    super.key,
    required this.itemBox,
  });

  final ItemBoxDTO itemBox;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    double calculateDistance(LatLng start, LatLng end) {
      final distance = Geolocator.distanceBetween(
        start.latitude,
        start.longitude,
        end.latitude,
        end.longitude,
      );

      debugPrint('Distance: $distance');

      return distance;
    }

    final currentLocation = ref.watch(currentLocationNotifierProvider);
    final canOpen = currentLocation.when(
      data: (location) {
        final distance = calculateDistance(
          location,
          LatLng(
            itemBox.itemBoxLatitude?.toDouble() ?? 0,
            itemBox.itemBoxLongitude?.toDouble() ?? 0,
          ),
        );
        return distance &lt;=  100;
      },
      loading: () =&gt; false,
      error: (\_, \_\_) =&gt; false,
    );

    Future&lt;void&gt; onTapOpenBox() async {
      try {
        final currentLocation = await ref
            .watch(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();

        final itemBoxId = itemBox.itemBoxId;
        if (itemBoxId == null) {
          throw Exception('ItemBoxId is null');
        }
        final itemList = await ref
            .read(openItemBoxNotifierProvider.notifier)
            .openItemBox(itemBoxId, currentLocation);

        if (context.mounted) {
          context.pop();
        }

        if (context.mounted) {
          await showDialog&lt;void&gt;(
            context: context,
            builder: (BuildContext context) {
              return ItemGetDialog(
                itemList: itemList,
              );
            },
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    return Dialog(
      backgroundColor: ColorPallet.gray800,
      child: Container(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: \[
            Text(
              itemBox.itemBoxName ?? '',
              style: const TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 20,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 18),
            Text(
              itemBox.itemBoxDescription ?? '',
              style: const TextStyle(
                fontSize: 16,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: SquareImage(
                imageUrl: itemBox.itemBoxImage ?? '',
                size: 160,
              ),
            ),
            const SizedBox(height: 24),
            Container(
              padding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 8,
              ),
              decoration: BoxDecoration(
                color: const Color(0xFF14191A),
                borderRadius: BorderRadius.circular(50),
              ),
              child: const Text(
                // TODO: \[ItemBox\] レアリティーの追加
                'Uncommon',
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            const SizedBox(height: 32),
            ElevatedButton(
              onPressed: canOpen
                  ? () async {
                      await onTapOpenBox();
                    }
                  : null,
              child: const Text(
                'Open Box',
              ),
            ),
            if (!canOpen) ...\[
              const SizedBox(height: 16),
              const Text(
                'You cannot open it unless you get within 100m.',
                textAlign: TextAlign.center,
              ),
            \],
            const SizedBox(height: 32),
            CancelButton(
              onTapCancel: () async {
                context.pop();
              },
            ),
          \],
        ),
      ),
    );
  }
}

---

## 🤖 アシスタント
*2025/1/28 15:05:29*

`canOpen` の状態を `useEffect` のように更新したい場合、Flutterでは `useEffect` の代わりに、`useState` と `useEffect` のような機能を提供する `useEffect` 的なフックとして `useEffect` と状態管理を組み合わせた `useState` フックを利用できます。

以下は、`canOpen` を `useEffect` のように更新する方法の実装例です：

### 実装

```dart
@override
Widget build(BuildContext context, WidgetRef ref) {
  final currentLocation = ref.watch(currentLocationNotifierProvider);
  final canOpenState = useState(false);

  useEffect(() {
    void updateCanOpen() {
      if (currentLocation is AsyncData) {
        final location = currentLocation.value;
        final distance = calculateDistance(
          location,
          LatLng(
            itemBox.itemBoxLatitude?.toDouble() ?? 0,
            itemBox.itemBoxLongitude?.toDouble() ?? 0,
          ),
        );
        canOpenState.value = distance <= 100;
      } else {
        canOpenState.value = false;
      }
    }

    updateCanOpen();

    // currentLocation が変わるたびに再評価
    return ref.listen<AsyncValue<LatLng>>(
      currentLocationNotifierProvider,
      (_, __) => updateCanOpen(),
    ).cancel;
  }, [currentLocation]);

  Future<void> onTapOpenBox() async {
    // ... onTapOpenBoxの内容はそのまま ...
  }

  return Dialog(
    backgroundColor: ColorPallet.gray800,
    child: Container(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            itemBox.itemBoxName ?? '',
            style: const TextStyle(
              fontWeight: FontWeight.bold,
              fontSize: 20,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 18),
          Text(
            itemBox.itemBoxDescription ?? '',
            style: const TextStyle(
              fontSize: 16,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 32),
          ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: SquareImage(
              imageUrl: itemBox.itemBoxImage ?? '',
              size: 160,
            ),
          ),
          const SizedBox(height: 24),
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 8,
            ),
            decoration: BoxDecoration(
              color: const Color(0xFF14191A),
              borderRadius: BorderRadius.circular(50),
            ),
            child: const Text(
              'Uncommon',
              style: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          const SizedBox(height: 32),
          ElevatedButton(
            onPressed: canOpenState.value
                ? () async {
                    await onTapOpenBox();
                  }
                : null,
            child: const Text(
              'Open Box',
            ),
          ),
          if (!canOpenState.value) ...[
            const SizedBox(height: 16),
            const Text(
              'You cannot open it unless you get within 100m.',
              textAlign: TextAlign.center,
            ),
          ],
          const SizedBox(height: 32),
          CancelButton(
            onTapCancel: () async {
              context.pop();
            },
          ),
        ],
      ),
    ),
  );
}
```

### 変更点
1. **`useState` フックを追加**
   - `canOpenState` を管理するために `useState<bool>` を使用しました。

2. **`useEffect` フックの実装**
   - `useEffect` に相当する箇所で `currentLocation` の状態が変更されたときに `canOpen` を再計算し、`canOpenState.value` を更新します。

3. **`canOpen` の計算をリスナーで更新**
   - `ref.listen` を利用して、`currentLocation` が変更された際に `updateCanOpen` を呼び出します。

### メリット
- 状態管理が簡単になり、状態変更の追跡が容易。
- 現在のロジックをシンプルに保ちながら、`canOpen` をリアクティブに更新できます。

---
