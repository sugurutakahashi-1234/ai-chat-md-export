# TS Enum コンピューテッドプロパティ

Date: 2025-05-28

---

## 👤 User
*2025-05-28 10:11:38*

TypeScriptのenumにSwiftのようにコンピューテッドプロパティーを生やすことはできないのか？

---

## 🤖 Assistant
*2025-05-28 10:11:57*

結論から言うと、**Swift の `enum` のように各ケースが “インスタンス” を持ち、そこへ直接コンピューテッドプロパティ（`var title: String { ... }` など）を定義する──という書き方は TypeScript の `enum` ではできません**。  
理由と代替パターンを以下に整理します。  

---

## なぜ出来ないのか？

| Swift | TypeScript |
|-------|------------|
| `enum` は値型だが、各ケースは “値 + 型” を兼ねるオブジェクトで、メソッド／プロパティを持てる | `enum` は **「ただのオブジェクト（連想配列）」** で、メンバーは数値か文字列の **定数**。インスタンス概念がなく、メソッドも置けないciteturn0search0 |
| Swift コンパイラが enum‐specific なシンタックスを持ち、switch exhaustiveness 等も型レベルで保証 | TypeScript は JavaScript 互換の範囲で実装されるため、enum は実行時には静的オブジェクトになるだけ |

そのため **`enum Foo { A }` の `A` は、ただの数値／文字列リテラルであって “A 専用のオブジェクト” ではない**のが本質的な違いです。  

---

## 代替パターン

### 1. **名前空間マージ**でユーティリティ関数を生やす

```ts
export enum Status {
  Idle = 'idle',
  Loading = 'loading',
  Done = 'done',
}

// enum と同名の namespace を置くとマージされる
export namespace Status {
  export function icon(s: Status): string {
    switch (s) {
      case Status.Idle: return '🛑';
      case Status.Loading: return '⏳';
      case Status.Done: return '✅';
    }
  }

  export const isBusy = (s: Status) => s === Status.Loading;
}

// 使い方
Status.icon(Status.Loading); // '⏳'
Status.isBusy(Status.Idle);  // false
```

- コンパイル後は `Status` オブジェクトに `icon`, `isBusy` が静的関数としてぶら下がります。  
- “プロパティ” ではなく **静的メソッド** という形になりますが、IDE 補完も効いて実用的です。  

（computed property 名を直接 enum 内に書こうとすると `TS1164` エラーになります）citeturn0search7

---

### 2. **リテラル型＋マッピングオブジェクト**

Swift の `var title` に相当する “定数プロパティ” なら、単純マップで十分なことが多いです。

```ts
const StatusIcon = {
  idle: '🛑',
  loading: '⏳',
  done: '✅',
} as const;

type Status = keyof typeof StatusIcon;

function icon(s: Status) {
  return StatusIcon[s];
}
```

- `Status` は `"idle" | "loading" | "done"` のユニオンリテラル型。  
- `StatusIcon` は **型安全なマップ** で、プロパティの追加・削除漏れをコンパイラが検知できます。

---

### 3. **判別可能ユニオン（代数的データ型）**に設計を変える

Swift の “associated value” を使いたい場合、TypeScript では tagged union が適していることが多いです。

```ts
type Status =
  | { kind: 'idle';    icon: '🛑' }
  | { kind: 'loading'; icon: '⏳'; progress: number }
  | { kind: 'done';    icon: '✅' };

function icon(s: Status) {
  return s.icon;
}
```

- 各ケースがオブジェクトになるので **プロパティも計算（getter）も定義し放題**。  
- `switch` の網羅性チェックも効き、Swift にかなり近い使用感が得られます。

---

## 近い将来ネイティブで出来る可能性は？

2025 年 4 月の TC39 会議で **ECMAScript ネイティブ enum 提案（Stage 1）** が議論に上がっていますが、現時点では “メソッドやプロパティを enum ケースに持たせられるか” は未確定ですciteturn0search3turn0search8。  
当面は上記パターンで設計するのが現実的です。

---

### まとめ

| やりたいこと | おすすめ実装 |
|--------------|--------------|
| **静的な計算結果を返すだけ** | 「1. namespace マージ」または「2. マッピングオブジェクト」 |
| **ケースごとに複数のプロパティ／動的値を持たせたい** | 「3. 判別可能ユニオン＋オブジェクト」 |
| **Swift 的シンタックスを完全再現したい** | 現状不可。将来の ECMAScript enum 仕様に期待 |

これらを使い分ければ、Swift の “コンピューテッドプロパティ付き enum” に近い体験を TypeScript でも実現できます。

---

## 👤 User
*2025-05-28 10:15:03*

どれがおすすめか？

---

## 🤖 Assistant
*2025-05-28 10:15:04*

### ざっくり結論

| 目的 | 私のおすすめ |
|---|---|
| **ラベルやアイコンなど、シンプルに“定数 → 値”をひも付けたい** | **② リテラル型＋マッピングオブジェクト**&lt;br&gt;— もっとも短く・安全・拡張が楽 |
| **ケースごとに複数プロパティや追加ロジックを持たせたい** | **③ 判別可能ユニオン（tagged union）**&lt;br&gt;— Swift の「associated value & computed property」感を再現 |
| **既存コードが enum で統一されており、とにかく手を入れずに補助関数だけ欲しい** | **① enum＋namespace マージ**&lt;br&gt;— 移行コストゼロで“静的メソッド”を追加 |

---

## なぜ ② がデフォルト推し？

1. **transpile 後が極小**  
   `enum` は JS では双方向マップが生成されて少し膨らみますが、`as const` オブジェクトはそのまま残るだけです。

2. **型と値が 1 行で同期する**  
   ```ts
   export const StatusIcon = { idle: '🛑', loading: '⏳', done: '✅' } as const;
   export type Status = keyof typeof StatusIcon; // "idle" | "loading" | "done"
   ```
   - プロパティを追加/削除すると型も同時に変わるので “抜け漏れ” が即エラーで分かる。  
   - 別ファイルに “テーブル管理” もしやすく、**拡張性** が高い（← enum を別テーブルに管理したいというご要望と相性◎）。

3. **ツリーシェイク＆最小バンドル**  
   参照されないプロパティだけを静的解析で落とせるので、フロント側にも優しいです。

---

## ③ を選ぶ判断基準

- **各ケースがオブジェクト**なので、好きなだけフィールドやゲッターを書ける。  
  ```ts
  type PauseAlert =
    | { kind: 'none' }
    | { kind: 'pause';  title: '一時停止';       icon: '⏸' }
    | { kind: 'quit';   title: '終了しますか？'; icon: '❌' }
    | { kind: 'guide';  guide: GuideType;       title: string; icon: '📖' };

  // 使う側
  function titleOf(a: PauseAlert) {
    switch (a.kind) {
      case 'pause': return a.title;
      // ...
    }
  }
  ```
- `switch` の **網羅性チェック** が効くのでリファクタリング時に安全。
- 逆に「ただアイコン 1 つ返すだけ」の用途にまで使うとボイラープレートが増えるので、**必要になったら昇格**させるイメージで OK です。

---

## ① を選ぶときの注意

- `enum` 自体の落とし穴（数値 enum の逆引き、const enum の transpile 方針など）は残る。  
- 既存コード資産が多い場合の “最小修正” 手段として割り切ると快適。  
  ```ts
  enum Status { Idle = 'idle', Loading = 'loading', Done = 'done' }
  namespace Status {
    export const icon = (s: Status) => ({ idle:'🛑', loading:'⏳', done:'✅' }[s]);
  }
  ```

---

### まとめ

- **新規実装 or enum を増やすたびに拡張したい** → **② リテラル型＋マップ** が最小コスト＆型安全。  
- **複雑な振る舞い / 複数フィールド / Swift 的 enum っぽさ** → **③ 判別可能ユニオン**。  
- **既存 enum を活かしつつ軽く便利に** → **① namespace マージ**。

まずは **② で始めて、要件が増えたら③へ昇格**──がメンテもしやすく、個人的にもよく採るパターンです。

---

## 👤 User
*2025-05-28 10:19:07*

enum Environment {
  Development,
  Production,
  Staging,
  Test,
}


たとえば、以下でアクセスしたい

environment.apiUrl: String
environment.apiKey: String
environment.isDebug: Bool

Environment情報とApiKeyは環境変数から取得したい。
apiUrlやisDebugはハードコーディングしたい。

---

## 🤖 Assistant
*2025-05-28 10:19:08*

以下の実装は **「リテラル型＋マッピングオブジェクト」** パターンをベースに、  
`apiUrl` と `isDebug` はハードコード、`apiKey` と現在の環境は環境変数から取得──という要件を満たすサンプルです。  

```ts
// src/config/environment.ts
// --------------------------------------------
// 1) まず環境を “文字列 enum 風” に定義
export enum Environment {
  Development = 'development',
  Production  = 'production',
  Staging     = 'staging',
  Test        = 'test',
}

// 2) ハードコード分だけを切り出したテーブル
/* prettier-ignore */
const BASE_CONFIG = {
  [Environment.Development]: { apiUrl: 'http://localhost:3000', isDebug: true  },
  [Environment.Production] : { apiUrl: 'https://api.example.com', isDebug: false },
  [Environment.Staging]    : { apiUrl: 'https://stg.api.example.com', isDebug: true  },
  [Environment.Test]       : { apiUrl: 'http://localhost:4000', isDebug: true  },
} as const;

// 3) 便利な型
export type BaseConfig = typeof BASE_CONFIG[Environment];

// 4) 実際に “動的” な値（env 変数）を合成して 1 つの設定オブジェクトに
function buildConfig(): BaseConfig & { apiKey: string; env: Environment } {
  // ★ 実行環境を決定（未設定なら development 扱い）
  const env = (process.env.APP_ENV as Environment) ?? Environment.Development;

  // ★ APIキーは環境ごとに変数名を分けても良いし、共通でも良い
  //    例では `API_KEY_<ENV>` という形式を採用
  const apiKey =
    process.env[`API_KEY_${env.toUpperCase()}`] ??
    process.env.API_KEY ?? //  fallback
    '';

  return { ...BASE_CONFIG[env], apiKey, env };
}

/**
 * アプリ全体で使い回すシングルトン設定
 *
 * ```ts
 * import { environment } from './config/environment';
 *
 * fetch(`${environment.apiUrl}/v1/users`, { headers:{ 'x-api-key': environment.apiKey } })
 * ```
 */
export const environment = buildConfig();
```

### 使い方

```ts
import { environment } from '@/config/environment';

console.log(environment.env);      // "development" など
console.log(environment.apiUrl);   // "http://localhost:3000"
console.log(environment.apiKey);   // 環境変数から取得
console.log(environment.isDebug);  // true
```

---

## 実装ポイント解説

| ポイント | 解説 |
|---|---|
| **1. 文字列 enum** | 文字列値にしておくと `.toUpperCase()` などで環境変数名を動的に組み立てるとき便利。 |
| **2. `BASE_CONFIG` を `as const`** | プロパティがリテラル型になり、`BASE_CONFIG[env]` を取り出すだけで強力な型推論が効く。 |
| **3. `buildConfig` を 1 回だけ実行** | モジュール初期化時に評価→以降は同一インスタンスを再利用。DI やテストで差し替えたい場合は工夫。 |
| **4. API キーの名前付け** | 例では `API_KEY_DEVELOPMENT` のように環境ごとに変数を分け、存在しなければ共通 `API_KEY` を見るフォールバック方式に。 |

---

## フロントエンド（Vite/Next.js 等）で使う場合の注意

- **`process.env` はそのままではブラウザにバンドルされない**。  
  - Vite なら `import.meta.env.VITE_API_KEY_DEVELOPMENT` のように `VITE_` 接頭辞付きで注入。  
  - Next.js なら `NEXT_PUBLIC_` 接頭辞を付けるか、`server-only` と `client-only` で分離。  
- それでもパターン自体は同じで、`buildConfig()` 内で `import.meta.env` 系を参照するだけです。

---

## もっと “Swift っぽく” したい場合

```ts
class EnvConfig {
  constructor(private readonly env: Environment) {}
  get apiUrl()  { return BASE_CONFIG[this.env].apiUrl; }
  get isDebug() { return BASE_CONFIG[this.env].isDebug; }
  get apiKey()  { return process.env[`API_KEY_${this.env.toUpperCase()}`] ?? ''; }
}

export const environment = new EnvConfig(
  (process.env.APP_ENV as Environment) ?? Environment.Development,
);
```

- **getter を持つラッパークラス**で `environment.apiUrl` のシンタックスをそのまま再現。  
- ただしオブジェクト生成コスト・テストダブル作成コストが上がるので、小～中規模なら前述の「関数で合成 → シングルトン」方式が手軽です。

---

### まとめ

1. **実務的に最もシンプル**かつ**型安全**なのは「リテラル enum + マッピングオブジェクト」。  
2. **環境変数は buildConfig() の中で注入**すると一箇所に閉じ込められ、テスト・ビルド時も扱いやすい。  
3. より Swift ライクな書き味を求めるなら **getter 付きクラス**で包む方法もあるが、メリットと手間を天秤に。

---

## 👤 User
*2025-05-28 10:21:52*

全然enumの恩恵を受け入れてないように思える。

---
