# SwiftUI エレベーション定義

日付: 2023-05-24

---

## 👤 ユーザー
*2023/05/24 15:06:35*

SwiftUI で 5段階のエレベーションの定義を作成したい

---

## 🤖 アシスタント
*2023/05/24 15:07:13*

SwiftUIではMaterial Designのようなエレベーションの概念が直接的に存在しませんが、shadowメソッドを使ってエレベーションを模倣することが可能です。

以下に、5段階のエレベーションを定義するためのコードスニペットを示します:

```swift
import SwiftUI

struct ElevationViewModifier: ViewModifier {
    var level: Int

    private func shadowRadius(forLevel level: Int) -> CGFloat {
        switch level {
        case 1:
            return 2
        case 2:
            return 4
        case 3:
            return 8
        case 4:
            return 16
        case 5:
            return 32
        default:
            return 0
        }
    }

    func body(content: Content) -> some View {
        content
            .shadow(color: Color.black.opacity(0.2), radius: shadowRadius(forLevel: level), x: 0, y: shadowRadius(forLevel: level))
    }
}

extension View {
    func elevation(_ level: Int) -> some View {
        self.modifier(ElevationViewModifier(level: level))
    }
}
```

このコードでは、エレベーションレベルに対応する影の半径を返すヘルパー関数を定義し、それを基にshadowメソッドを設定します。エレベーションレベルによって、それぞれ異なる影を生成します。そして、`elevation`関数を定義してViewに適用できるようにします。

これを使ってViewにエレベーションを適用するには、以下のようにします:

```swift
Text("Hello, World!")
    .elevation(3)
```

このコードでは、"Hello, World!"というテキストにレベル3のエレベーションが適用されます。

---

## 👤 ユーザー
*2023/05/24 15:07:41*

enum の定義は case elevation1, elevation2, elevation3, elevation4, elevation5 にしてほしい

---

## 🤖 アシスタント
*2023/05/24 15:08:21*

指定いただいたenumを使ってエレベーションのレベルを定義すると次のようになります。

```swift
import SwiftUI

enum ElevationLevel {
    case elevation1
    case elevation2
    case elevation3
    case elevation4
    case elevation5
}

struct ElevationViewModifier: ViewModifier {
    var level: ElevationLevel

    private func shadowRadius(forLevel level: ElevationLevel) -> CGFloat {
        switch level {
        case .elevation1:
            return 2
        case .elevation2:
            return 4
        case .elevation3:
            return 8
        case .elevation4:
            return 16
        case .elevation5:
            return 32
        }
    }

    func body(content: Content) -> some View {
        content
            .shadow(color: Color.black.opacity(0.2), radius: shadowRadius(forLevel: level), x: 0, y: shadowRadius(forLevel: level))
    }
}

extension View {
    func elevation(_ level: ElevationLevel) -> some View {
        self.modifier(ElevationViewModifier(level: level))
    }
}
```

このように書き換えることで、エレベーションのレベルは `ElevationLevel` のenumにより明確に制御され、コードの可読性も向上します。

使用するときは以下のようにします:

```swift
Text("Hello, World!")
    .elevation(.elevation3)
```

これにより、"Hello, World!"のテキストにレベル3のエレベーションが適用されます。

---

## 👤 ユーザー
*2023/05/24 15:08:32*

ViewModifier は使いたくなくて、Viewのエクステンションにしたい

---

## 🤖 アシスタント
*2023/05/24 15:09:05*

もちろん、ViewModifierを使用せずに直接Viewのextensionとして定義することも可能です。

ここでは、各エレベーションレベルに対応するshadowメソッドを直接Viewのextensionとして定義します。

```swift
import SwiftUI

enum ElevationLevel {
    case elevation1
    case elevation2
    case elevation3
    case elevation4
    case elevation5
}

extension View {
    func elevation(_ level: ElevationLevel) -> some View {
        let shadowRadius: CGFloat
        switch level {
        case .elevation1:
            shadowRadius = 2
        case .elevation2:
            shadowRadius = 4
        case .elevation3:
            shadowRadius = 8
        case .elevation4:
            shadowRadius = 16
        case .elevation5:
            shadowRadius = 32
        }
        return self.shadow(color: Color.black.opacity(0.2), radius: shadowRadius, x: 0, y: shadowRadius)
    }
}
```

このコードでは、エレベーションレベルに対応するshadowメソッドを直接Viewのextensionとして定義します。この関数を使ってViewにエレベーションを適用するときは以下のようにします:

```swift
Text("Hello, World!")
    .elevation(.elevation3)
```

これにより、"Hello, World!"のテキストにレベル3のエレベーションが適用されます。

---

## 👤 ユーザー
*2023/05/24 16:30:37*

elevationごとにブラーをかけたい場合はどうすればいい？

---

## 🤖 アシスタント
*2023/05/24 16:31:31*

影のエレベーションとともにビューにブラーを追加する場合、blurメソッドを使うことができます。blurメソッドはビュー全体にぼかし効果を適用します。

エレベーションレベルによってブラーの強度を変えるためのエクステンションを以下に示します：

```swift
import SwiftUI

enum ElevationLevel {
    case elevation1
    case elevation2
    case elevation3
    case elevation4
    case elevation5
}

extension View {
    func elevation(_ level: ElevationLevel) -> some View {
        let shadowRadius: CGFloat
        let blurRadius: CGFloat
        switch level {
        case .elevation1:
            shadowRadius = 2
            blurRadius = 1
        case .elevation2:
            shadowRadius = 4
            blurRadius = 2
        case .elevation3:
            shadowRadius = 8
            blurRadius = 4
        case .elevation4:
            shadowRadius = 16
            blurRadius = 8
        case .elevation5:
            shadowRadius = 32
            blurRadius = 16
        }
        return self
            .shadow(color: Color.black.opacity(0.2), radius: shadowRadius, x: 0, y: shadowRadius)
            .blur(radius: blurRadius)
    }
}
```

このコードでは、エレベーションレベルに応じて適切なブラー半径を設定します。これにより、エレベーションの高いビューはより多くのブラーを持つようになります。

この関数を使ってViewにエレベーションを適用するときは以下のようにします:

```swift
Text("Hello, World!")
    .elevation(.elevation3)
```

これにより、"Hello, World!"のテキストにレベル3のエレベーションとそれに対応するブラーが適用されます。

---

## 👤 ユーザー
*2023/05/24 16:31:43*

func elevation(_ level: ElevationLevel) -&gt; some View の中にわざわざ変数をつかわなくても大丈夫です

---

## 🤖 アシスタント
*2023/05/24 16:32:24*

もちろんです、その場でshadowの半径とblurの半径を定義することも可能です。以下にそのように書き換えたコードを示します:

```swift
import SwiftUI

enum ElevationLevel {
    case elevation1
    case elevation2
    case elevation3
    case elevation4
    case elevation5
}

extension View {
    func elevation(_ level: ElevationLevel) -> some View {
        switch level {
        case .elevation1:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 2, x: 0, y: 2)
                .blur(radius: 1)
        case .elevation2:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 4, x: 0, y: 4)
                .blur(radius: 2)
        case .elevation3:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 8, x: 0, y: 8)
                .blur(radius: 4)
        case .elevation4:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 16, x: 0, y: 16)
                .blur(radius: 8)
        case .elevation5:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 32, x: 0, y: 32)
                .blur(radius: 16)
        }
    }
}
```

このコードでは、各caseで直接shadowとblurの値を設定しています。この方法であれば、各レベルでどのようなスタイルが適用されるのかが一目瞭然で、場合によってはより直感的になるかもしれません。ただし、大規模なプロジェクトでは一貫性と可読性を保つために、可能な限り定数や変数を利用することをお勧めします。

---

## 👤 ユーザー
*2023/05/24 16:35:24*

ちなみにどうしてshadowRadiusを定義して、radiusとyの値が一致するようにしているの？メリットがあれば教えて欲しい

---

## 🤖 アシスタント
*2023/05/24 16:36:04*

このパターンを使用する主な理由は、シャドウが視覚的にどのように見えるかを制御するためです。

特に、単一の光源からのシャドウを模擬するとき、shadowの半径(radius)とオフセット(y)が同じになると、光源がビューの真上にあり、光が直下に当たっているという印象を与えます。その結果、ビューに適用される影は均一に広がり、一貫性のある視覚効果を提供します。

このパターンを使用しない場合、例えばshadowの半径とオフセットが異なる場合、シャドウは一方向により強く、または広がりすぎる可能性があります。これは、光源が斜め上、またはビューの側面から来ているという印象を与えます。これは一部の設計シナリオでは望ましいかもしれませんが、多くの場合、一貫した「直下の」シャドウの方が自然に見えるため、より一般的に使用されます。

ただし、これはあくまで一つの規則であり、デザインのニーズによって変えることができます。shadowの半径とオフセットを変えることで、さまざまな光源の位置とシャドウの広がりを表現することが可能です。

---

## 👤 ユーザー
*2023/05/24 16:40:26*

それぞれ5パターンをけんしょうするこーどもかいてほしい

---

## 🤖 アシスタント
*2023/05/24 16:41:28*

以下に、指定された5つのエレベーションレベルを全て視覚化するコードスニペットを提供します。各レベルのエレベーションが適用された同じテキストが表示されます。

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack(spacing: 20) {
            Text("Elevation 1")
                .elevation(.elevation1)
            
            Text("Elevation 2")
                .elevation(.elevation2)
            
            Text("Elevation 3")
                .elevation(.elevation3)
            
            Text("Elevation 4")
                .elevation(.elevation4)
            
            Text("Elevation 5")
                .elevation(.elevation5)
        }
        .padding()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

enum ElevationLevel {
    case elevation1
    case elevation2
    case elevation3
    case elevation4
    case elevation5
}

extension View {
    func elevation(_ level: ElevationLevel) -> some View {
        switch level {
        case .elevation1:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 2, x: 0, y: 2)
                .blur(radius: 1)
        case .elevation2:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 4, x: 0, y: 4)
                .blur(radius: 2)
        case .elevation3:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 8, x: 0, y: 8)
                .blur(radius: 4)
        case .elevation4:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 16, x: 0, y: 16)
                .blur(radius: 8)
        case .elevation5:
            return self
                .shadow(color: Color.black.opacity(0.2), radius: 32, x: 0, y: 32)
                .blur(radius: 16)
        }
    }
}
```

このコードは、`ContentView`で5つのテキストビューを作成し、各ビューに異なるエレベーションレベルを適用しています。これにより、各エレベーションレベルがどのように見えるかを比較することができます。これらのビューは縦にスタックされ、間隔が開けられています。

注意: 上記のコードはiOS 13.0以降で動作します。また、このコードはプレビュープロバイダを使用しており、Xcodeのプレビューパネルで結果を視覚化することができます。

---

## 👤 ユーザー
*2023/05/24 17:58:57*

以下のコードって、ElevationLevel 側にoffsetYやblurRadiusの値をコンピュテッドプロパティーに持った方が良い気がしない？

```swift
public enum ElevationLevel {
    case elevation1
    case elevation2
    case elevation3
    case elevation4
    case elevation5
}

extension ElevationLevel: CaseIterable {}

extension View {
    public func elevation(_ level: ElevationLevel) -> some View {
        let offsetY: CGFloat
        let blurRadius: CGFloat
        switch level {
        case .elevation1:
            offsetY = 1
            blurRadius = 5
        case .elevation2:
            offsetY = 3
            blurRadius = 12
        case .elevation3:
            offsetY = 8
            blurRadius = 16
        case .elevation4:
            offsetY = 12
            blurRadius = 24
        case .elevation5:
            offsetY = 16
            blurRadius = 32
        }
        return shadow(color: CoreAssets.Color.Shadow.shadow10.swiftUIColor, radius: blurRadius, x: 0, y: offsetY)
    }
}
```

---

## 🤖 アシスタント
*2023/05/24 17:59:51*

はい、ご指摘の通り、各値をElevationLevel enumの中に持つことで、コードの整理と管理がより容易になります。各レベルの属性を直接enumに関連付けることで、ElevationLevelの使用が一貫性を持ち、エレベーションの各レベルを変更または拡張する際の柔軟性も向上します。以下に改善したコードを示します：

```swift
public enum ElevationLevel {
    case elevation1
    case elevation2
    case elevation3
    case elevation4
    case elevation5

    var offsetY: CGFloat {
        switch self {
        case .elevation1: return 1
        case .elevation2: return 3
        case .elevation3: return 8
        case .elevation4: return 12
        case .elevation5: return 16
        }
    }

    var blurRadius: CGFloat {
        switch self {
        case .elevation1: return 5
        case .elevation2: return 12
        case .elevation3: return 16
        case .elevation4: return 24
        case .elevation5: return 32
        }
    }
}

extension ElevationLevel: CaseIterable {}

extension View {
    public func elevation(_ level: ElevationLevel) -> some View {
        return shadow(color: CoreAssets.Color.Shadow.shadow10.swiftUIColor, radius: level.blurRadius, x: 0, y: level.offsetY)
    }
}
```

この変更により、`elevation(_ level: ElevationLevel)`メソッドは簡潔になり、それぞれのElevationLevelが持つプロパティを直接アクセスできます。コードの可読性と維持管理性が向上します。

---

## 👤 ユーザー
*2023/05/24 18:06:35*

Figmaのドロップシャドウというものを表現できていない気がするのだけれども気のせいでしょうか？

---

## 🤖 アシスタント
*2023/05/24 18:07:19*

Figmaにおけるドロップシャドウは、デザインに影を加えて立体感を出すためのツールです。Figmaのドロップシャドウは、影の色、ぼかし（blur）、拡散（spread）、そしてXおよびY軸の位置オフセットを調整できます。この設定により、デザイナーは特定の光源からの影を具体的に表現することが可能です。

SwiftUIにおけるshadowメソッドは、シャドウを作成するための基本的なツールを提供しますが、Figmaの全てのオプションを直接サポートしているわけではありません。具体的には、SwiftUIでは「拡散」パラメータが直接サポートされていません。

しかし、ある程度まで拡散効果を模倣することは可能です。例えば、blurメソッドを利用して全体的なぼかし効果を追加したり、複数のshadowメソッドをチェーンさせて複数の影を重ねることで影の拡がりを増すことができます。ただし、これらのアプローチは完全な解決策ではなく、デザイン要件によっては十分な結果を得られないかもしれません。

Figmaで作成したデザインをSwiftUIで完全に再現するには、これらの制限を理解し、可能な限り最適なアプローチを選ぶことが重要です。

---
