# ジェネリック型の解決策

日付: 2024-04-30

---

## 👤 ユーザー
*2024/4/30 19:34:56*

以下のコードで、

@MainActor @ViewBuilder
    var testCaseListView: some View {
        TestCaseListView&lt;self.testCaseType&gt;()
    }
の箇所でAdjacent operators are in non-associative precedence group 'ComparisonPrecedence'というエラーになる。

    @MainActor @ViewBuilder
    var testCaseListView: some View {
        TestCaseListView&lt;LicenseListViewTestCase&gt;()
    }であればエラーにならない。

なぜか？


public enum DebugShortcutViewType {
    case deviceInfo
    case onboarding
    case licenseList
    case licenseDetail
    case taskList
}

// MARK: - Extension DebugShortcutViewType

/// for ForEach
extension DebugShortcutViewType: CaseIterable, Identifiable {
    public var id: String {
        "\\(self)"
    }
}

public extension DebugShortcutViewType {
    var name: String {
        switch self {
        case .deviceInfo:
            String(localized: "デバイス情報", bundle: .module)
        case .onboarding:
            String(localized: "オンボーディング", bundle: .module)
        case .licenseList:
            String(localized: "ライセンス一覧", bundle: .module)
        case .licenseDetail:
            String(localized: "ライセンス詳細", bundle: .module)
        case .taskList:
            String(localized: "タスク一覧", bundle: .module)
        }
    }
    
    var image: some View {
        switch self {
        case .deviceInfo:
            SFSymbols.iphoneGen3.image
        case .onboarding:
            SFSymbols.book.image
        case .licenseList:
            SFSymbols.licenseplate.image
        case .licenseDetail:
            SFSymbols.licenseplateFill.image
        case .taskList:
            SFSymbols.pencilAndListClipboard.image
        }
    }
    
    var label: some View {
        Label(
            title: { Text(name) },
            icon: { self.image }
        )
    }

    var testCaseType: any ViewTestCaseProvider.Type {
        switch self {
        case .deviceInfo:
            LicenseListViewTestCase.self
        case .onboarding:
            LicenseListViewTestCase.self
        case .licenseList:
            LicenseListViewTestCase.self
        case .licenseDetail:
            LicenseListViewTestCase.self
        case .taskList:
            LicenseListViewTestCase.self
        }
    }
    
    @MainActor @ViewBuilder
    var testCaseListView: some View {
        TestCaseListView&lt;self.testCaseType&gt;()
    }
}

public enum LicenseListViewTestCase: ViewTestCaseProvider {
    case normal
    case empty
    
    @MainActor @ViewBuilder
    public var testCaseView: some View {
        switch self {
        case .normal:
            LicenseListView(dependency: AppRootDIContainerDependencyMock.placeholder)
        case .empty:
            LicenseListView(dependency: AppRootDIContainerDependencyMock.empty)
        }
    }
}

public protocol ViewTestCaseProvider: Identifiable, CaseIterable, Hashable {
    associatedtype T: View
    
    @MainActor @ViewBuilder
    var testCaseView: T { get }
}

public extension ViewTestCaseProvider {
    var id: String {
        name
    }
    
    var name: String {
        "\\(self)"
    }
}

struct TestCaseListView&lt;ViewTestCase: ViewTestCaseProvider&gt;: View {
    var body: some View {
        List {
            Section("") {
                ForEach(Array(ViewTestCase.allCases)) { testCase in
                    NavigationLink {
                        testCase.testCaseView
                    } label: {
                        Text("\\(testCase)")
                    }
                }
            }
        }
    }
}

---

## 🤖 アシスタント
*2024/4/30 19:35:25*

この問題は、Swiftのジェネリックとメタタイプ(`Type`)の取り扱いに関連しています。`TestCaseListView&lt;self.testCaseType&gt;()`において、`self.testCaseType`は、プロパティとして`DebugShortcutViewType`の各ケースに紐づく型（例：`LicenseListViewTestCase.self`）を返します。しかし、このコードの書き方には問題があります。

`self.testCaseType`は、実行時に決定される値ですが、`TestCaseListView&lt;self.testCaseType&gt;()`のようにジェネリック型の型パラメータとして使用する場合、コンパイル時に具体的な型が必要です。つまり、`self.testCaseType`がプロパティとして動的に決定されるため、その時点で具体的な型がコンパイラによって知られていないためエラーが発生します。

具体的な型を直接指定した場合、例えば`TestCaseListView&lt;LicenseListViewTestCase&gt;()`のように書くと、コンパイラは`LicenseListViewTestCase`が`ViewTestCaseProvider`プロトコルを満たしている具体的な型であると認識できるため、エラーは発生しません。

この問題を解決するには、実行時に動的にジェネリック型を扱うのではなく、各ケースで具体的な型を明示的に指定する方法を採用するか、またはジェネリック型を使わない設計に変更する必要があります。例えば、`ViewTestCaseProvider`プロトコルを利用して、型安全を保ちつつ動的なビュー生成が可能な設計を検討することができます。

もう一つのアプローチとしては、`testCaseType`を返すのではなく、直接`testCaseListView`を提供するファクトリメソッドまたはプロパティを各ケースに定義することも考えられます。この方法では、ジェネリックの問題を回避しつつ、各ケースに応じたビューを動的に生成することができます。

---

## 👤 ユーザー
*2024/4/30 19:35:42*

2つのアプローチで具体的な実装をしてほしい

---

## 🤖 アシスタント
*2024/4/30 19:36:22*

こちらでは、Swiftにおけるジェネリック型の動的な扱いに関する問題を解決するための2つのアプローチを具体的な実装例として説明します。

### アプローチ1: ファクトリメソッドを使用する

`DebugShortcutViewType` の各ケースに対して、直接適切なビューを生成するファクトリメソッドを提供する方法です。これにより、各ケースでどのようなビューが必要かを明確に定義でき、ジェネリック型パラメータの動的な扱いを避けることができます。

```swift
public extension DebugShortcutViewType {
    @MainActor @ViewBuilder
    var testCaseListView: some View {
        switch self {
        case .deviceInfo, .onboarding, .licenseList, .licenseDetail, .taskList:
            TestCaseListView<LicenseListViewTestCase>()
        }
    }
}

struct TestCaseListView<ViewTestCase: ViewTestCaseProvider>: View {
    var body: some View {
        List {
            Section("") {
                ForEach(Array(ViewTestCase.allCases)) { testCase in
                    NavigationLink {
                        testCase.testCaseView
                    } label: {
                        Text("\(testCase)")
                    }
                }
            }
        }
    }
}
```

この例では、すべてのケースで`LicenseListViewTestCase`を使用していますが、必要に応じて各ケースで異なる`ViewTestCaseProvider`を使用するように変更できます。

### アプローチ2: プロトコルとポリモーフィズムを活用する

プロトコル`ViewTestCaseProvider`を利用して、動的にビューを生成するための共通インターフェースを提供します。これにより、具体的なジェネリック型を明示する必要がなく、より柔軟にコードを記述できます。

```swift
public protocol ViewTestCaseListViewProvider {
    var testCaseListView: AnyView { get }
}

public extension DebugShortcutViewType: ViewTestCaseListViewProvider {
    var testCaseListView: AnyView {
        switch self {
        case .deviceInfo, .onboarding, .licenseList, .licenseDetail, .taskList:
            AnyView(TestCaseListView<LicenseListViewTestCase>())
        }
    }
}

struct TestCaseListView<ViewTestCase: ViewTestCaseProvider>: View {
    var body: some View {
        List {
            Section("") {
                ForEach(Array(ViewTestCase.allCases)) { testCase in
                    NavigationLink {
                        testCase.testCaseView
                    } label: {
                        Text("\(testCase)")
                    }
                }
            }
        }
    }
}
```

このアプローチでは、`AnyView`を使用して具体的なビュー型を抽象化し、`DebugShortcutViewType`が`ViewTestCaseListViewProvider`プロトコルを満たすようにしています。これにより、各ケースごとに異なる`ViewTestCaseProvider`を返すように拡張することも可能です。

どちらのアプローチも、ジェネリック型の動的な指定に関連する問題を解決し、より安全でメンテナンスしやすいコードを実現します。適用するアプローチは、プロジェクトの要件や既存のアーキテクチャによって異なるかもしれません。

---
