# Xcodeからシェルスクリプトを実行

Date: 2024-03-03

---

## 👤 User
*2024-03-03 17:29:50*

Swift packageマネージャーからシェルスクリプトの実行をXcodeからじっこうしたい

---

## 🤖 Assistant
*2024-03-03 17:30:16*

Swift Package Manager (SPM) を使って、Xcodeからシェルスクリプトを実行するには、いくつかの方法があります。ここでは、一般的なアプローチを紹介します：

### Xcode Build Phaseを使用する

1. **Xcodeプロジェクトを開く**: Xcodeであなたのプロジェクトを開きます。
2. **Build Phasesを開く**: プロジェクトナビゲータで対象のプロジェクトを選択し、「Build Phases」タブを開きます。
3. **New Run Script Phaseを追加**: 左下の`+`ボタンをクリックして、「New Run Script Phase」を選択します。これにより、新しいスクリプトフェーズがプロジェクトのビルドプロセスに追加されます。
4. **シェルスクリプトを追加**: 新しく作成されたRun Scriptセクションに、実行したいシェルスクリプトを直接入力するか、外部スクリプトファイルを呼び出すコマンドを入力します。例えば、`sh ./path/to/your/script.sh` のように書きます。
5. **ビルドしてテストする**: 変更を保存し、ビルドを実行してスクリプトが期待通りに動作するかをテストします。

### 注意点

- **セキュリティ**: Xcodeから外部スクリプトを実行する場合は、セキュリティを考慮してください。信頼できるスクリプトのみを使用し、不必要に広い権限をスクリプトに与えないようにしてください。
- **パスの問題**: スクリプト内で他のファイルやコマンドを参照する場合、相対パスではなく絶対パスを使用するか、適切にパスを設定する必要があります。

この方法は、Xcodeプロジェクトのビルドプロセスにシームレスにスクリプトを組み込むことができるため、非常に便利です。ただし、スクリプトの実行タイミングや条件を細かく制御したい場合は、スクリプトやXcodeプロジェクトの設定をさらに調整する必要があるかもしれません。

---

## 👤 User
*2024-03-03 17:31:42*

ビルドフェーズを修正するのではなくSwiftを実行することでシェルスクリプトを実行したい

---

## 🤖 Assistant
*2024-03-03 17:32:05*

Swiftコードからシェルスクリプトを実行するには、`Process` (または`NSTask`としても知られている) と `Pipe` クラスを使用します。この方法は、アプリケーションのランタイム中にプログラム的にシェルスクリプトを実行する場合に適しています。以下は、Swiftでシェルスクリプトを実行する簡単な例です：

### Swiftによるシェルスクリプトの実行

```swift
import Foundation

func runShellCommand(command: String) {
    let process = Process()
    let pipe = Pipe()
    
    process.standardOutput = pipe
    process.standardError = pipe
    process.arguments = ["-c", command]
    process.launchPath = "/bin/zsh" // または "/bin/bash" にする
    process.launch()
    
    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    if let output = String(data: data, encoding: .utf8) {
        print(output)
    }
}

// 例: lsコマンドを実行する
runShellCommand(command: "ls")
```

この例では、`Process` クラスを使用して新しいプロセスを作成し、`/bin/zsh` (または `/bin/bash` にすることもできます) をその実行ファイルとして指定しています。`arguments` プロパティには、実行したいシェルコマンドを `-c` オプションとともに指定します。

`standardOutput` と `standardError` には、`Pipe` オブジェクトが割り当てられており、これによってプロセスの標準出力と標準エラー出力をキャプチャできます。プロセスが起動されると、`readDataToEndOfFile` メソッドを使用して出力を読み取り、結果をコンソールに表示しています。

### 注意点

- `launchPath` にはシェルのパスを指定しますが、システムや環境によって異なる場合があるので適宜変更してください。
- 実行したいシェルスクリプトが外部ファイルにある場合は、`command` 引数にそのファイルへのパスを指定するか、ファイルを直接実行するコマンドを指定します。
- Swiftからシェルスクリプトを実行する際は、セキュリティリスクを考慮し、信頼できるスクリプトのみを実行してください。

この方法は、Swiftコード内で直接シェルスクリプトを実行する必要がある場合、特に便利です。

---

## 👤 User
*2024-03-03 17:32:58*

途中経過も随時プリントしてほしい

---

## 🤖 Assistant
*2024-03-03 17:33:48*

途中経過も随時プリントしたい場合、`Process`の標準出力と標準エラー出力を`Pipe`ではなく、`FileHandle`の通知を使って非同期に読み取る方法を採用することができます。これにより、プロセスが出力する度に即座に結果を得ることができます。

以下の例では、`Process`からの出力をリアルタイムで受け取り、コンソールにプリントする方法を示します。

### Swiftによるシェルスクリプトの実行とリアルタイム出力

```swift
import Foundation

func runShellCommand(command: String) {
    let process = Process()
    let outputPipe = Pipe()
    let errorPipe = Pipe()

    process.standardOutput = outputPipe
    process.standardError = errorPipe
    process.arguments = ["-c", command]
    process.launchPath = "/bin/zsh" // または "/bin/bash" にする

    let outputHandle = outputPipe.fileHandleForReading
    outputHandle.waitForDataInBackgroundAndNotify()

    var outputObserver: NSObjectProtocol!
    outputObserver = NotificationCenter.default.addObserver(forName: NSNotification.Name.NSFileHandleDataAvailable, object: outputHandle, queue: nil) { notification -> Void in
        let data = outputHandle.availableData
        if data.count > 0 {
            if let str = String(data: data, encoding: .utf8) {
                print(str, terminator: "")
            }
            outputHandle.waitForDataInBackgroundAndNotify()
        } else {
            NotificationCenter.default.removeObserver(outputObserver)
        }
    }

    process.launch()
    process.waitUntilExit()
}

// 例: ファイルのリストを取得し、途中経過をプリントする
runShellCommand(command: "ls -l")
```

このコードは、`Process`の`standardOutput`と`standardError`に`Pipe`を接続し、`FileHandle`の`waitForDataInBackgroundAndNotify`メソッドを使ってデータの準備ができたときに通知を受け取るように設定します。データが利用可能になると、`NotificationCenter`が`NSFileHandleDataAvailable`通知を発行し、その通知を受け取ってデータを読み込み、コンソールに出力します。

注意点として、この方法ではプロセスが出力を生成するたびに通知が発行され、出力をリアルタイムで処理できますが、多量の出力が迅速に生成される場合、出力の処理が追いつかない可能性があります。また、`process.waitUntilExit()`を呼び出してプロセスが終了するまで待機することで、プロセスの完了を確実に捉えることができます。

---

## 👤 User
*2024-03-03 17:34:08*

もう少し新しい書き方はないのか？

---

## 🤖 Assistant
*2024-03-03 17:34:31*

Swift 5以降、特にSwift Concurrencyの導入により、より現代的かつ簡潔な方法で非同期処理を行うことができます。`Process`からの出力をリアルタイムで処理する場合、`async`/`await`を使用して、より読みやすく効率的なコードを書くことが可能です。

以下は、Swift Concurrencyを使用してシェルコマンドを非同期に実行し、途中経過をリアルタイムで処理する方法の例です。

### Swift Concurrencyを使った例

```swift
import Foundation

func runShellCommand(command: String) async throws {
    let process = Process()
    let outputPipe = Pipe()

    process.standardOutput = outputPipe
    process.standardError = outputPipe
    process.arguments = ["-c", command]
    process.launchPath = "/bin/zsh" // または "/bin/bash"

    try process.run()
    
    let outputHandle = outputPipe.fileHandleForReading
    
    // 出力の非同期読み取り
    let output = try await readAsync(fileHandle: outputHandle)
    print(output)
}

func readAsync(fileHandle: FileHandle) async throws -> String {
    let data = try await fileHandle.readToEnd() ?? Data()
    return String(decoding: data, as: UTF8.self)
}

// 非同期関数の呼び出し
Task {
    do {
        try await runShellCommand(command: "ls -l")
    } catch {
        print("An error occurred: \(error)")
    }
}
```

この例では、`runShellCommand`関数を`async`関数として定義し、`Process`の実行と出力の読み取りを非同期で行います。`readAsync`関数を使用して`FileHandle`からデータを非同期に読み取り、最終的に文字列として返します。

Swift Concurrencyを使用することで、コールバックやデリゲートベースのアプローチに比べて、非同期コードの読みやすさと保守性が大幅に向上します。ただし、このコードを実行するには、Xcodeの対応するバージョンと、Swift 5.5以降の環境が必要です。

`Task`を使用して非同期関数を呼び出すことで、メインスレッドをブロックせずにバックグラウンドでシェルコマンドを実行し、出力を処理することができます。この方法は、最新のSwift Concurrency機能を活用しているため、Swiftの新しいバージョンでの開発に適しています。

---

## 👤 User
*2024-03-03 17:37:43*

この機構をCoreとして依存させる形で複数のシェルスクリプト実行ターゲットをPackage.swiftで表現してほしい

---

## 🤖 Assistant
*2024-03-03 17:38:39*

Swift Package Manager (SPM) を使用して、複数のシェルスクリプト実行ターゲットを含むパッケージを構成する場合、`Package.swift` ファイルにターゲットを追加し、それらが共通のコア機構（この場合は非同期でシェルスクリプトを実行する機能）に依存するように設定することができます。

以下は、`Core` モジュールを依存させる形で、複数のシェルスクリプト実行ターゲットを `Package.swift` で表現する例です。この構成では、`Core` モジュールがシェルスクリプト実行のための共通機能を提供し、他のターゲット（例えば `ScriptRunner1` と `ScriptRunner2`）がこの `Core` モジュールに依存して、特定のスクリプトを実行します。

### Package.swift の例

```swift
// swift-tools-version:5.5
import PackageDescription

let package = Package(
    name: "ShellScriptRunners",
    products: [
        // プロダクトの定義: ライブラリまたは実行可能ファイル
        .library(
            name: "Core",
            targets: ["Core"]),
        .executable(
            name: "ScriptRunner1",
            targets: ["ScriptRunner1"]),
        .executable(
            name: "ScriptRunner2",
            targets: ["ScriptRunner2"]),
    ],
    dependencies: [
        // 外部依存性の定義
    ],
    targets: [
        // ターゲットの定義
        .target(
            name: "Core",
            dependencies: []),
        .executableTarget(
            name: "ScriptRunner1",
            dependencies: ["Core"]),
        .executableTarget(
            name: "ScriptRunner2",
            dependencies: ["Core"]),
        .testTarget(
            name: "CoreTests",
            dependencies: ["Core"]),
    ]
)
```

### ターゲットの説明

- `Core`: 非同期でシェルスクリプトを実行するための共通機能を提供するライブラリターゲットです。先ほどの `runShellCommand` 関数などをこのモジュール内に配置します。
- `ScriptRunner1`, `ScriptRunner2`: `Core` モジュールに依存し、特定のシェルスクリプトを実行する実行可能ファイルターゲットです。それぞれ異なるスクリプトを実行するためのコードを含みます。

### 実装のポイント

- `Core` ターゲットには、シェルスクリプトを実行する共通の機能（例: 非同期実行のための `runShellCommand` 関数）を実装します。
- `ScriptRunner1` と `ScriptRunner2` ターゲットは、`Core` から提供される機能を使用して、特定のスクリプト実行ロジックを実装します。
- この構成では、共通機能の変更が必要な場合、`Core` モジュールのみを更新すればよく、各スクリプト実行ターゲットのコードは変更不要であることが多いです。

この構造により、Swift Package Managerを使用して、複数のシェルスクリプト実行ターゲットを含む、整理されたプロジェクトを構築できます。各ターゲットは特定のタスクに特化しており、`Core` ターゲットが共通の機能を提供する形で依存関係が設定されています。

---

## 👤 User
*2024-03-03 17:39:13*

スクリプトの実行するディレクトリをxcwork spaceのルートディレクトリにしたい。

---

## 🤖 Assistant
*2024-03-03 17:39:56*

Xcodeプロジェクトやワークスペースでスクリプトを実行する際、実行ディレクトリをXcodeのワークスペースのルートディレクトリに設定するには、スクリプト実行時にカレントディレクトリを動的に変更する必要があります。Swiftの`Process`クラスを使用している場合、`currentDirectoryURL`プロパティを設定することで実行ディレクトリを指定できます。

しかし、Xcodeのビルドプロセスから直接ワークスペースのルートディレクトリのパスを取得する簡単な方法は提供されていません。代わりに、環境変数を利用することで、関連するディレクトリのパスを推測することができます。

### Swiftでの実装例

以下のSwiftコードは、`Process`を使用してシェルスクリプトを実行する際に、カレントディレクトリをXcodeのワークスペースのルートディレクトリに設定する方法の例です。この例では、`PROJECT_DIR`環境変数を使用していますが、実際にはこの変数がビルドスクリプトのコンテキストで設定されている必要があります。

```swift
import Foundation

func runShellCommand(command: String, workingDirectory: URL) async throws {
    let process = Process()
    let pipe = Pipe()

    process.standardOutput = pipe
    process.standardError = pipe
    process.arguments = ["-c", command]
    process.launchPath = "/bin/zsh" // または "/bin/bash"
    process.currentDirectoryURL = workingDirectory

    try process.run()
    
    let outputData = try await pipe.fileHandleForReading.readToEnd() ?? Data()
    if let output = String(data: outputData, encoding: .utf8) {
        print(output)
    }
}

// Xcodeのプロジェクトディレクトリを取得する
if let projectDirectory = ProcessInfo.processInfo.environment["PROJECT_DIR"] {
    let workingDirectory = URL(fileURLWithPath: projectDirectory)
    Task {
        do {
            try await runShellCommand(command: "ls -l", workingDirectory: workingDirectory)
        } catch {
            print("An error occurred: \(error)")
        }
    }
} else {
    print("PROJECT_DIR environment variable is not set.")
}
```

### Xcodeプロジェクトでの設定

- Xcodeの`Run Script Phase`でスクリプトを実行する場合、`PROJECT_DIR`や他の環境変数は自動的に設定されます。
- Swiftファイルをコマンドラインから実行する場合や、Xcode外で実行する場合は、`PROJECT_DIR`環境変数を手動で設定する必要があります。これは、シェルからSwiftスクリプトを実行する際に、環境変数を渡すことで行えます。

この方法を使用することで、Swiftで書かれたスクリプトやXcodeのビルドスクリプトから、Xcodeワークスペースのルートディレクトリを基準にシェルスクリプトを実行することが可能になります。

---

## 👤 User
*2024-03-03 17:40:24*

workspaceのルートディレクトリのパスはすでに予約されている変数はないのか？

---

## 🤖 Assistant
*2024-03-03 17:41:10*

Xcodeビルドプロセス中に利用可能な環境変数の中には、ワークスペースやプロジェクトのルートディレクトリを指し示すものがいくつかあります。ただし、ワークスペースのルートディレクトリを直接示す専用の環境変数はありませんが、関連する変数を使用して間接的に求めることができます。

Xcodeのビルド環境変数でよく使用されるものには以下のようなものがあります:

- `SRCROOT`: ソースファイルのルートディレクトリを指します。これは通常、プロジェクトのルートディレクトリに相当します。
- `PROJECT_DIR`: プロジェクトファイル（`.xcodeproj`）が存在するディレクトリです。これもプロジェクトのルートディレクトリに相当します。
- `WORKSPACE_DIR`: Xcode 12以降では使用されていない可能性があり、公式の文書にも明確には記載されていませんが、以前はワークスペースのディレクトリを指すのに使用されていました。

これらの変数の中で、`SRCROOT`や`PROJECT_DIR`は、ワークスペース内でのプロジェクトのルートディレクトリを示すのに非常に役立ちます。プロジェクトがワークスペース内にある場合、これらのディレクトリはワークスペースのルートディレクトリと同じか、あるいはそのサブディレクトリになります。

### Xcodeプロジェクトやスクリプトでの使用例

ビルドスクリプトやカスタムスクリプト内でこれらの環境変数を使用する場合、直接参照することで、実行時に動的にパスを解決できます。例えば、`SRCROOT`を使用してカレントディレクトリを設定するシェルスクリプトの例は以下のようになります。

```sh
cd $SRCROOT
# ここで任意のコマンドを実行
```

Swiftで`Process`を使用してこれらの環境変数にアクセスする場合は、`ProcessInfo.processInfo.environment`から取得可能です。

```swift
if let srcRoot = ProcessInfo.processInfo.environment["SRCROOT"] {
    print("SRCROOT is \(srcRoot)")
}
```

これらの変数を利用することで、Xcodeのビルドプロセスやカスタムスクリプトから、プロジェクトやワークスペースのルートディレクトリを基準に操作を行うことが可能になります。

---

## 👤 User
*2024-03-05 13:50:39*

executableTarget の定義ところで引数を設定することは可能か？

---

## 🤖 Assistant
*2024-03-05 13:51:26*

Swift Package Manager (SPM) を使用している際、`Package.swift`ファイル内で`executableTarget`を定義することはできますが、実行時にコマンドライン引数を直接設定する機能は提供していません。`executableTarget`の定義は、ターゲットのソースファイル、依存関係などを指定するために使われますが、実行時の挙動（特にコマンドライン引数を含む）を直接指定する仕組みは含まれていません。

### 実行時の引数の扱い

実行可能ファイルに引数を渡す必要がある場合、その引数はコマンドラインを通じて実行時に提供されます。例えば、ビルドした実行ファイルをターミナルから実行する際、以下のように引数を指定できます：

```sh
./.build/debug/ExecutableName arg1 arg2 arg3
```

ここで、`ExecutableName`はビルドした実行可能ファイルの名前であり、`arg1 arg2 arg3`はその実行可能ファイルに渡す引数です。

### Swiftコード内での引数の扱い

Swiftプログラム内で、コマンドライン引数にアクセスするには、`CommandLine`クラスを使用します。例えば、以下のように引数を取得できます：

```swift
let arguments = CommandLine.arguments
print(arguments)
```

### まとめ

- SPMの`Package.swift`において、`executableTarget`の定義時に実行時の引数を直接設定することはできません。
- 実行時の引数は、ビルドした実行ファイルをコマンドラインから実行する際に指定します。
- Swiftコード内で、`CommandLine.arguments`を使用してコマンドライン引数にアクセスします。

このように、SPMはビルド設定に焦点を当てており、実行時の引数の設定は実行環境（例えば、ターミナルやスクリプト）に委ねられています。

---
