# SelectedTalkThread Not Updating

Date: 2024-08-01

---

## üë§ User
*2024-08-01 16:43:40*

selectedTalkThread „Åå„Çπ„ÉØ„Ç§„Éó„Å´„Çà„Å£„Å¶Ê†ºÁ¥ç„Åß„Åç„Å¶„ÅÑ„Å™„ÅÑ„ÄÇ„Å©„ÅÜ„Åó„Å¶„Å†„Çç„ÅÜ„ÄÇ

final class ThreadListPresenter&lt;Dependency: ThreadListPresenterDependency&gt;: ObservableObject {
    @Published private(set) var talkThreads: [TalkThread] = []
    @Published var selectedTalkThread: TalkThread?
}

public struct ThreadListView&lt;Dependency: RootDIContainerDependency&gt;: View {
    private let dependency: Dependency
    @StateObject private var presenter: ThreadListPresenter&lt;Dependency&gt;

    public init(dependency: Dependency, talkBox: TalkBox) {
        self.dependency = dependency
        _presenter = .init(wrappedValue: ThreadListPresenter(dependency: dependency, talkBox: talkBox))
    }

    public var body: some View {
        VStack {
            // iOS 16 „Åß„ÅØ pageing „Åå„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ iOS 16 ÂØæÂøú„Åô„Çã„ÅÆ„Åß„ÅÇ„Çå„Å∞ Âà•ÈÄîÂØæÂøú„Åô„Çã
            if #available(iOS 17.0, *) {
                ThreadListScrollView(
                    selectedTalkThread: $presenter.selectedTalkThread,
                    talkThreads: presenter.talkThreads,
                    spacing: 16,
                    padding: 32,
                    onTapTalkThread: presenter.onTapTalkThread,
                    onTapStampReaction: presenter.onTapStampReaction,
                    onDownSwipe: presenter.onDownSwipe,
                    onUpSwipe: presenter.onUpSwipe,
                    volumeLevels: presenter.audioVolumeLevels,
                    volumeLevelColumns: ThreadListPresenter&lt;Dependency&gt;.volumeLevelColumns,
                    isPlaying: presenter.isPlaying
                )
                .padding(.vertical)

                Button {
                    presenter.onTapNewPost()
                } label: {
                    Label {
                        Text("Êñ∞Ë¶èÊäïÁ®ø")
                    } icon: {
                        SFSymbols.mic.image
                    }
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .tint(.black)
            }
        }
        .navigationTitle(presenter.talkBox.name)
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: true)
        .overlayToast(toastType: $presenter.toastType)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError)
        .sheet(isPresented: $presenter.showThreadPostView) {
            ThreadPostView(dependency: dependency)
                .navigationStacked()
        }
        .sheet(isPresented: $presenter.showVoicePostView) {
            VoicePostView(dependency: dependency)
                .navigationStacked()
        }
        .sheet(isPresented: $presenter.showStampListView) {
            if let talkThread = presenter.selectedTalkThread {
                if #available(iOS 16.4, *) {
                    StampListView(dependency: dependency, talkThread: talkThread)
                        .ignoresSafeArea(edges: .bottom)
                        .navigationStacked()
                        .presentationDetents([.fraction(0.8)])
                        .presentationBackground(.clear) // @available(iOS 16.4, *)
                } else {
                    StampListView(dependency: dependency, talkThread: talkThread)
                        .ignoresSafeArea(edges: .bottom)
                        .navigationStacked()
                        .presentationDetents([.fraction(0.8)])
                }
            }
        }
        .sheet(isPresented: $presenter.showTalkThreadDetailView) {
            if let talkThread = presenter.selectedTalkThread {
                ThreadDetailView(dependency: dependency, talkThread: talkThread)
                    .navigationStacked()
            }
        }
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}

@available(iOS 17.0, *)
struct ThreadListScrollView: View {
    @Binding var selectedTalkThread: TalkThread?
    let talkThreads: [TalkThread]
    let spacing: CGFloat
    let padding: CGFloat
    let onTapTalkThread: () -&gt; Void
    let onTapStampReaction: () -&gt; Void
    let onDownSwipe: () -&gt; Void
    let onUpSwipe: () -&gt; Void
    let volumeLevels: [Double]
    let volumeLevelColumns: Int
    let isPlaying: Bool

    @State private var activeOffsetY: [String: CGFloat] = [:]

    var body: some View {
        GeometryReader { geometry in
            ScrollView(.horizontal) {
                LazyHStack(spacing: spacing) {
                    ForEach(talkThreads, id: \.id) { talkThread in
                        ZStack {
                            VStack {
                                Text("‚Üì„Çπ„ÉØ„Ç§„Éó„Åß„Ç≥„É°„É≥„Éà")
                                    .foregroundStyle(.white)
                                    .font(.headline)
                                    .padding()
                                Spacer()
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .background(Color.accentColor)

                            ZStack {
                                // Ë£è„ÅÆÁîªÂÉè
                                CachedAsyncImageView(imageUrl: talkThread.imageUrl)

                                // ‰∏ãÂÅ¥„ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ
                                VStack {
                                    Spacer()
                                    HStack {
                                        CachedAsyncImageView(imageUrl: talkThread.imageUrl)
                                            .frame(width: 40, height: 40)
                                            .clipShape(.circle)

                                        VStack(alignment: .leading) {
                                            Text(talkThread.postedBy.name)
                                                .foregroundColor(.primary)

                                            Text(talkThread.updatedAt.relativeDateTime)
                                                .foregroundColor(.secondary)
                                                .font(.subheadline)
                                        }
                                        .lineLimit(1)
                                        .padding(.leading, 8)

                                        Spacer()

                                        HStack(spacing: -8) {
                                            ForEach(talkThread.posts.prefix(3)) { post in
                                                ZStack(alignment: .topLeading) { // rightToLeft „Å´Âêà„Çè„Åõ„Å¶ leading „Å´„Å™„Å£„Å¶„ÅÑ„Çã
                                                    CachedAsyncImageView(imageUrl: post.postedBy.imageUrl)
                                                        .frame(width: 32, height: 32)
                                                        .clipShape(.circle)

                                                    if let imageUrl = post.postType.imageUrl {
                                                        CachedAsyncImageView(imageUrl: imageUrl)
                                                            .frame(width: 16, height: 16)
                                                            .clipShape(.circle)
                                                            .offset(x: -4, y: -4) // rightToLeft „Å´Âêà„Çè„Åõ„Å¶ x „ÅåË≤†„Å´„Å™„Å£„Å¶„ÅÑ„Çã
                                                    }
                                                }
                                            }
                                        }
                                        .environment(\.layoutDirection, .rightToLeft)
                                    }
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .frame(height: 80)
                                    .padding(.horizontal)
                                    .background(.ultraThinMaterial)
                                }

                                // Èü≥Â£∞„ÅÆÊ≥¢
                                GeometryReader { geometry in
                                    if isPlaying, talkThread == selectedTalkThread {
                                        WaveformView(volumeLevels: volumeLevels, maxColumnCount: volumeLevelColumns)
                                            .frame(width: geometry.size.width - 16, height: 100)
                                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                                            .transition(.opacity)
                                    }
                                }
                                .animation(.easeInOut, value: isPlaying)
                            }
                            .offset(y: activeOffsetY[talkThread.id] ?? 0)
                            // ÊôÆÈÄö„ÅÆ .gesture „Å†„Å®„Çπ„ÇØ„É≠„Éº„É´„Å®Âπ≤Ê∏â„Åó„Å¶„Çπ„ÇØ„É≠„Éº„É´„Åß„Åç„Å™„Åè„Å™„Çã
                            .simultaneousGesture(
                                DragGesture()
                                    .onChanged { value in
                                        let newOffset = value.translation.height

                                        // ‰∏ã„Çπ„ÉØ„Ç§„Éó„ÅÆ„ÅøË®±ÂèØ
                                        if newOffset &gt; 0 {
                                            activeOffsetY[talkThread.id] = newOffset
                                        }

                                        // ‰∏ä„Çπ„ÉØ„Ç§„Éó„ÅØË®±ÂèØ„Åó„Å™„ÅÑ„Åå onUpSwipe „ÇíÂÆüË°å
                                        if newOffset &lt; -100 {
                                            onUpSwipe()
                                        }

                                        // ‰∏ã„Çπ„ÉØ„Ç§„Éó
                                        if newOffset &gt; 100 {
                                            activeOffsetY[talkThread.id] = 0
                                            onDownSwipe()
                                        }
                                    }
                                    .onEnded { _ in
                                        activeOffsetY[talkThread.id] = 0
                                    }
                            )
                            .onTapGesture {
                                onTapTalkThread()
                            }
                            // offsetY = 0 „Å®„Åó„Åü„Å®„Åç„Å´„Å™„ÇÅ„Çâ„Åã„Å´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Åô„Çã„Çà„ÅÜ„Å´
                            .animation(.default, value: activeOffsetY[talkThread.id])
                        }
                        .frame(width: geometry.size.width - padding * 2)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        // „Åì„Çå„Åå„Å™„ÅÑ„Å®Èï∑Êäº„Åó„ÅÆ„Çø„ÉÉ„ÉóÈ†òÂüü„ÅåÊ≠£„Åó„ÅèÂèçÊò†„Åï„Çå„Å™„ÅÑ
                        // Ref: „ÄêSwiftUI„ÄëcontentShape„ÅßTapÈ†òÂüü„ÇíÂ∫É„Åí„Çã - https://qiita.com/shiz/items/96585bddbc442683b78c
                        .contentShape(RoundedRectangle(cornerRadius: 8))
                        // Ref: [SwiftUI] contextMenu modifier „Çø„ÉÉ„Éó„Åó„ÅüView„ÅÆËÉåÊôØËâ≤„ÇíÊ∂à„ÅôÊñπÊ≥ï - https://zenn.dev/your3i/articles/f03210a0270a5b
                        .contextMenu {
                            Button {
                                onTapStampReaction()
                            } label: {
                                Label {
                                    Text("„Çπ„Çø„É≥„ÉóËøî‰ø°")
                                } icon: {
                                    SFSymbols.faceSmiling.image
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal, padding)
                .padding(.vertical)
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned) // paging „Å†„Å®‰∏äÊâã„Åè„ÅÑ„Åã„Å™„ÅÑ„ÅÆ„ÅßÊ≥®ÊÑè
            // iOS 18.0 „Åß„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂÜçÁîü„Åó„Å¶Ëá™Âãï„Çπ„ÇØ„É≠„Éº„É´„Åó„ÅüÊôÇ„Å´„Åô„Åì„Åó„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„Åå„Åö„Çå„Å¶„Åó„Åæ„ÅÜÔºà„Åä„Åù„Çâ„Åè OS „Éê„Ç∞Ôºâ
            .scrollPosition(id: $selectedTalkThread) // scrollTargetLayout() „ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆ id „ÅÆÂÄ§„Å®„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞„Åô„Çã
            .scrollIndicators(.hidden)
        }
    }
}

---

## ü§ñ Assistant
*2024-08-01 16:43:50*

`selectedTalkThread`„Åå„Çπ„ÉØ„Ç§„Éó„Å´„Çà„Å£„Å¶Ë®≠ÂÆö„Åï„Çå„Å™„ÅÑÂéüÂõ†„ÅØ„ÅÑ„Åè„Å§„ÅãËÄÉ„Åà„Çâ„Çå„Åæ„Åô„ÄÇ‰ª•‰∏ã„ÅÆÁÇπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑÔºö

1. **`onTapTalkThread`„ÅÆÂÆüË£Ö„ÇíÁ¢∫Ë™ç„Åô„Çã**:
   `onTapTalkThread`„É°„ÇΩ„ÉÉ„Éâ„ÅåÂÆüÈöõ„Å´`selectedTalkThread`„ÇíÊõ¥Êñ∞„Åó„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ„ÅãÁ¢∫Ë™ç„Åó„Åæ„Åô„ÄÇ

2. **`ThreadListPresenter`ÂÜÖ„ÅÆ`onDownSwipe`„Å®`onUpSwipe`„ÅÆÂÆüË£Ö„ÇíÁ¢∫Ë™ç„Åô„Çã**:
   `onDownSwipe`„Åæ„Åü„ÅØ`onUpSwipe`„É°„ÇΩ„ÉÉ„Éâ„Åå`selectedTalkThread`„ÇíÊ≠£„Åó„ÅèÊõ¥Êñ∞„Åó„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç„Åó„Åæ„Åô„ÄÇ

3. **`simultaneousGesture`„ÅÆÁ´∂Âêà„ÇíÁ¢∫Ë™ç„Åô„Çã**:
   „Çπ„ÇØ„É≠„Éº„É´„Å®„Çπ„ÉØ„Ç§„Éó„Ç∏„Çß„Çπ„ÉÅ„É£„ÅåÁ´∂Âêà„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÅãÁ¢∫Ë™ç„Åó„Åæ„Åô„ÄÇÁâπ„Å´„ÄÅ„Çπ„ÉØ„Ç§„Éó„Ç∏„Çß„Çπ„ÉÅ„É£„ÅÆ`onChanged`„ÇÑ`onEnded`„ÅÆ‰∏≠„ÅßÈÅ©Âàá„Å´`selectedTalkThread`„ÅåÊõ¥Êñ∞„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç„Åó„Åæ„Åô„ÄÇ

4. **`selectedTalkThread`„ÅÆ„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞„ÅÆÂïèÈ°å„ÇíÁ¢∫Ë™ç„Åô„Çã**:
   `ThreadListScrollView`„Åß`selectedTalkThread`„ÅåÊ≠£„Åó„Åè„Éê„Ç§„É≥„Éâ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÄÅ„Åæ„Åü„Åù„ÅÆ„Éê„Ç§„É≥„Éâ„ÅåÂàá„Çå„Å¶„ÅÑ„Å™„ÅÑ„ÅãÁ¢∫Ë™ç„Åó„Åæ„Åô„ÄÇ

‰ª•‰∏ã„ÅÆ„Ç≥„Éº„Éâ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö

### `ThreadListPresenter`

```swift
final class ThreadListPresenter<Dependency: ThreadListPresenterDependency>: ObservableObject {
    @Published private(set) var talkThreads: [TalkThread] = []
    @Published var selectedTalkThread: TalkThread?

    func onTapTalkThread(talkThread: TalkThread) {
        selectedTalkThread = talkThread
    }

    func onDownSwipe() {
        // Implementation of what should happen on down swipe
    }

    func onUpSwipe() {
        // Implementation of what should happen on up swipe
    }
}
```

### `ThreadListView`

```swift
public struct ThreadListView<Dependency: RootDIContainerDependency>: View {
    private let dependency: Dependency
    @StateObject private var presenter: ThreadListPresenter<Dependency>

    public init(dependency: Dependency, talkBox: TalkBox) {
        self.dependency = dependency
        _presenter = .init(wrappedValue: ThreadListPresenter(dependency: dependency, talkBox: talkBox))
    }

    public var body: some View {
        VStack {
            if #available(iOS 17.0, *) {
                ThreadListScrollView(
                    selectedTalkThread: $presenter.selectedTalkThread,
                    talkThreads: presenter.talkThreads,
                    spacing: 16,
                    padding: 32,
                    onTapTalkThread: { talkThread in
                        presenter.onTapTalkThread(talkThread: talkThread)
                    },
                    onTapStampReaction: presenter.onTapStampReaction,
                    onDownSwipe: presenter.onDownSwipe,
                    onUpSwipe: presenter.onUpSwipe,
                    volumeLevels: presenter.audioVolumeLevels,
                    volumeLevelColumns: ThreadListPresenter<Dependency>.volumeLevelColumns,
                    isPlaying: presenter.isPlaying
                )
                .padding(.vertical)

                Button {
                    presenter.onTapNewPost()
                } label: {
                    Label {
                        Text("Êñ∞Ë¶èÊäïÁ®ø")
                    } icon: {
                        SFSymbols.mic.image
                    }
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .tint(.black)
            }
        }
        .navigationTitle(presenter.talkBox.name)
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: true)
        .overlayToast(toastType: $presenter.toastType)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError)
        .sheet(isPresented: $presenter.showThreadPostView) {
            ThreadPostView(dependency: dependency)
                .navigationStacked()
        }
        .sheet(isPresented: $presenter.showVoicePostView) {
            VoicePostView(dependency: dependency)
                .navigationStacked()
        }
        .sheet(isPresented: $presenter.showStampListView) {
            if let talkThread = presenter.selectedTalkThread {
                if #available(iOS 16.4, *) {
                    StampListView(dependency: dependency, talkThread: talkThread)
                        .ignoresSafeArea(edges: .bottom)
                        .navigationStacked()
                        .presentationDetents([.fraction(0.8)])
                        .presentationBackground(.clear)
                } else {
                    StampListView(dependency: dependency, talkThread: talkThread)
                        .ignoresSafeArea(edges: .bottom)
                        .navigationStacked()
                        .presentationDetents([.fraction(0.8)])
                }
            }
        }
        .sheet(isPresented: $presenter.showTalkThreadDetailView) {
            if let talkThread = presenter.selectedTalkThread {
                ThreadDetailView(dependency: dependency, talkThread: talkThread)
                    .navigationStacked()
            }
        }
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}
```

### `ThreadListScrollView`

```swift
@available(iOS 17.0, *)
struct ThreadListScrollView: View {
    @Binding var selectedTalkThread: TalkThread?
    let talkThreads: [TalkThread]
    let spacing: CGFloat
    let padding: CGFloat
    let onTapTalkThread: (TalkThread) -&gt; Void
    let onTapStampReaction: () -&gt; Void
    let onDownSwipe: () -&gt; Void
    let onUpSwipe: () -&gt; Void
    let volumeLevels: [Double]
    let volumeLevelColumns: Int
    let isPlaying: Bool

    @State private var activeOffsetY: [String: CGFloat] = [:]

    var body: some View {
        GeometryReader { geometry in
            ScrollView(.horizontal) {
                LazyHStack(spacing: spacing) {
                    ForEach(talkThreads, id: \.id) { talkThread in
                        ZStack {
                            VStack {
                                Text("‚Üì„Çπ„ÉØ„Ç§„Éó„Åß„Ç≥„É°„É≥„Éà")
                                    .foregroundStyle(.white)
                                    .font(.headline)
                                    .padding()
                                Spacer()
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .background(Color.accentColor)

                            ZStack {
                                // Ë£è„ÅÆÁîªÂÉè
                                CachedAsyncImageView(imageUrl: talkThread.imageUrl)

                                // ‰∏ãÂÅ¥„ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ
                                VStack {
                                    Spacer()
                                    HStack {
                                        CachedAsyncImageView(imageUrl: talkThread.imageUrl)
                                            .frame(width: 40, height: 40)
                                            .clipShape(.circle)

                                        VStack(alignment: .leading) {
                                            Text(talkThread.postedBy.name)
                                                .foregroundColor(.primary)

                                            Text(talkThread.updatedAt.relativeDateTime)
                                                .foregroundColor(.secondary)
                                                .font(.subheadline)
                                        }
                                        .lineLimit(1)
                                        .padding(.leading, 8)

                                        Spacer()

                                        HStack(spacing: -8) {
                                            ForEach(talkThread.posts.prefix(3)) { post in
                                                ZStack(alignment: .topLeading) {
                                                    CachedAsyncImageView(imageUrl: post.postedBy.imageUrl)
                                                        .frame(width: 32, height: 32)
                                                        .clipShape(.circle)

                                                    if let imageUrl = post.postType.imageUrl {
                                                        CachedAsyncImageView(imageUrl: imageUrl)
                                                            .frame(width: 16, height: 16)
                                                            .clipShape(.circle)
                                                            .offset(x: -4, y: -4)
                                                    }
                                                }
                                            }
                                        }
                                        .environment(\.layoutDirection, .rightToLeft)
                                    }
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .frame(height: 80)
                                    .padding(.horizontal)
                                    .background(.ultraThinMaterial)
                                }

                                // Èü≥Â£∞„ÅÆÊ≥¢
                                GeometryReader { geometry in
                                    if isPlaying, talkThread == selectedTalkThread {
                                        WaveformView(volumeLevels: volumeLevels, maxColumnCount: volumeLevelColumns)
                                            .frame(width: geometry.size.width - 16, height: 100)
                                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                                            .transition(.opacity)
                                    }
                                }
                                .animation(.easeInOut, value: isPlaying)
                            }
                            .offset(y: activeOffsetY[talkThread.id] ?? 0)
                            .simultaneousGesture(
                                DragGesture()
                                    .onChanged { value in
                                        let newOffset = value.translation.height

                                        if newOffset &gt; 0 {
                                            activeOffsetY[talkThread.id] = newOffset
                                        }

                                        if newOffset &lt; -100 {
                                            onUpSwipe()
                                        }

                                        if newOffset &gt; 100 {
                                            activeOffsetY[talkThread.id] = 0
                                            onDownSwipe()
                                        }
                                    }
                                    .onEnded { _ in
                                        activeOffsetY[talkThread.id] = 0
                                    }
                            )
                            .onTapGesture {
                                onTapTalkThread(talkThread)
                            }
                            .animation(.default, value: activeOffsetY[talkThread.id])
                        }
                        .frame(width: geometry.size.width - padding * 2)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        .contentShape(RoundedRectangle(cornerRadius: 8))
                        .contextMenu {
                            Button {
                                onTapStampReaction()
                            } label: {
                                Label {
                                    Text("„Çπ„Çø„É≥„ÉóËøî‰ø°")
                                } icon: {
                                    SFSymbol

---

## ü§ñ Assistant
*2024-08-01 16:46:56*

s.faceSmiling.image
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal, padding)
                .padding(.vertical)
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned)
            .scrollPosition(id: $selectedTalkThread)
            .scrollIndicators(.hidden)
        }
    }
}
```

‰∏äË®ò„ÅÆ„Ç≥„Éº„Éâ„ÇíÁ¢∫Ë™ç„Åó„Å¶„ÇÇÂïèÈ°å„ÅåËß£Ê±∫„Åó„Å™„ÅÑÂ†¥Âêà„ÄÅËøΩÂä†„ÅÆË©≥Á¥∞ÊÉÖÂ†±„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åü„Å†„Åë„Çå„Å∞„ÄÅ„Åï„Çâ„Å´ÂÖ∑‰ΩìÁöÑ„Å™„Ç¢„Éâ„Éê„Ç§„Çπ„ÇíÊèê‰æõ„Åß„Åç„Åæ„Åô„ÄÇ

---

## üë§ User
*2024-08-01 16:48:01*

simultaneousGesture „Çí gesture „Å´Â§â„Åà„Åü„ÇâÊ®™„Çπ„ÇØ„É≠„Éº„É´„Åå„Åß„Åç„Å™„Åè„Å™„Å£„Åü„ÄÇ
Ê®™„Çπ„ÇØ„É≠„Éº„É´„Å®.scrollPosition(id: $selectedTalkThread)„ÇíÂÖ±Â≠ò„Åï„Åõ„Åü„ÅÑ

import DomainLayer
import SwiftUI

// MARK: - View

public struct ThreadListView&lt;Dependency: RootDIContainerDependency&gt;: View {
    private let dependency: Dependency
    @StateObject private var presenter: ThreadListPresenter&lt;Dependency&gt;

    public init(dependency: Dependency, talkBox: TalkBox) {
        self.dependency = dependency
        _presenter = .init(wrappedValue: ThreadListPresenter(dependency: dependency, talkBox: talkBox))
    }

    public var body: some View {
        VStack {
            // iOS 16 „Åß„ÅØ pageing „Åå„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ iOS 16 ÂØæÂøú„Åô„Çã„ÅÆ„Åß„ÅÇ„Çå„Å∞ Âà•ÈÄîÂØæÂøú„Åô„Çã
            if #available(iOS 17.0, *) {
                ThreadListScrollView(
                    selectedTalkThread: $presenter.selectedTalkThread,
                    talkThreads: presenter.talkThreads,
                    spacing: 16,
                    padding: 32,
                    onTapTalkThread: presenter.onTapTalkThread,
                    onTapStampReaction: presenter.onTapStampReaction,
                    onDownSwipe: presenter.onDownSwipe,
                    onUpSwipe: presenter.onUpSwipe,
                    volumeLevels: presenter.audioVolumeLevels,
                    volumeLevelColumns: ThreadListPresenter&lt;Dependency&gt;.volumeLevelColumns,
                    isPlaying: presenter.isPlaying
                )
                .padding(.vertical)

                Button {
                    presenter.onTapNewPost()
                } label: {
                    Label {
                        Text("Êñ∞Ë¶èÊäïÁ®ø")
                    } icon: {
                        SFSymbols.mic.image
                    }
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .tint(.black)
            }
        }
        .navigationTitle(presenter.talkBox.name)
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: true)
        .overlayToast(toastType: $presenter.toastType)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError)
        .sheet(isPresented: $presenter.showThreadPostView) {
            ThreadPostView(dependency: dependency)
                .navigationStacked()
        }
        .sheet(isPresented: $presenter.showVoicePostView) {
            VoicePostView(dependency: dependency)
                .navigationStacked()
        }
        .sheet(isPresented: $presenter.showStampListView) {
            if let talkThread = presenter.selectedTalkThread {
                if #available(iOS 16.4, *) {
                    StampListView(dependency: dependency, talkThread: talkThread)
                        .ignoresSafeArea(edges: .bottom)
                        .navigationStacked()
                        .presentationDetents([.fraction(0.8)])
                        .presentationBackground(.clear) // @available(iOS 16.4, *)
                } else {
                    StampListView(dependency: dependency, talkThread: talkThread)
                        .ignoresSafeArea(edges: .bottom)
                        .navigationStacked()
                        .presentationDetents([.fraction(0.8)])
                }
            }
        }
        .sheet(isPresented: $presenter.showTalkThreadDetailView) {
            if let talkThread = presenter.selectedTalkThread {
                ThreadDetailView(dependency: dependency, talkThread: talkThread)
                    .navigationStacked()
            }
        }
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}

@available(iOS 17.0, *)
struct ThreadListScrollView: View {
    @Binding var selectedTalkThread: TalkThread?
    let talkThreads: [TalkThread]
    let spacing: CGFloat
    let padding: CGFloat
    let onTapTalkThread: () -&gt; Void
    let onTapStampReaction: () -&gt; Void
    let onDownSwipe: () -&gt; Void
    let onUpSwipe: () -&gt; Void
    let volumeLevels: [Double]
    let volumeLevelColumns: Int
    let isPlaying: Bool

    @State private var activeOffsetY: [String: CGFloat] = [:]

    var body: some View {
        GeometryReader { geometry in
            ScrollView(.horizontal) {
                LazyHStack(spacing: spacing) {
                    ForEach(talkThreads, id: \.id) { talkThread in
                        ZStack {
                            VStack {
                                Text("‚Üì„Çπ„ÉØ„Ç§„Éó„Åß„Ç≥„É°„É≥„Éà")
                                    .foregroundStyle(.white)
                                    .font(.headline)
                                    .padding()
                                Spacer()
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .background(Color.accentColor)

                            ZStack {
                                // Ë£è„ÅÆÁîªÂÉè
                                CachedAsyncImageView(imageUrl: talkThread.imageUrl)

                                // ‰∏ãÂÅ¥„ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ
                                VStack {
                                    Spacer()
                                    HStack {
                                        CachedAsyncImageView(imageUrl: talkThread.imageUrl)
                                            .frame(width: 40, height: 40)
                                            .clipShape(.circle)

                                        VStack(alignment: .leading) {
                                            Text(talkThread.postedBy.name)
                                                .foregroundColor(.primary)

                                            Text(talkThread.updatedAt.relativeDateTime)
                                                .foregroundColor(.secondary)
                                                .font(.subheadline)
                                        }
                                        .lineLimit(1)
                                        .padding(.leading, 8)

                                        Spacer()

                                        HStack(spacing: -8) {
                                            ForEach(talkThread.posts.prefix(3)) { post in
                                                ZStack(alignment: .topLeading) { // rightToLeft „Å´Âêà„Çè„Åõ„Å¶ leading „Å´„Å™„Å£„Å¶„ÅÑ„Çã
                                                    CachedAsyncImageView(imageUrl: post.postedBy.imageUrl)
                                                        .frame(width: 32, height: 32)
                                                        .clipShape(.circle)

                                                    if let imageUrl = post.postType.imageUrl {
                                                        CachedAsyncImageView(imageUrl: imageUrl)
                                                            .frame(width: 16, height: 16)
                                                            .clipShape(.circle)
                                                            .offset(x: -4, y: -4) // rightToLeft „Å´Âêà„Çè„Åõ„Å¶ x „ÅåË≤†„Å´„Å™„Å£„Å¶„ÅÑ„Çã
                                                    }
                                                }
                                            }
                                        }
                                        .environment(\.layoutDirection, .rightToLeft)
                                    }
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .frame(height: 80)
                                    .padding(.horizontal)
                                    .background(.ultraThinMaterial)
                                }

                                // Èü≥Â£∞„ÅÆÊ≥¢
                                GeometryReader { geometry in
                                    if isPlaying, talkThread == selectedTalkThread {
                                        WaveformView(volumeLevels: volumeLevels, maxColumnCount: volumeLevelColumns)
                                            .frame(width: geometry.size.width - 16, height: 100)
                                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                                            .transition(.opacity)
                                    }
                                }
                                .animation(.easeInOut, value: isPlaying)
                            }
                            .offset(y: activeOffsetY[talkThread.id] ?? 0)
                            // ÊôÆÈÄö„ÅÆ .gesture „Å†„Å®„Çπ„ÇØ„É≠„Éº„É´„Å®Âπ≤Ê∏â„Åó„Å¶„Çπ„ÇØ„É≠„Éº„É´„Åß„Åç„Å™„Åè„Å™„Çã
                            .gesture(
                                DragGesture()
                                    .onChanged { value in
                                        let newOffset = value.translation.height

                                        // ‰∏ã„Çπ„ÉØ„Ç§„Éó„ÅÆ„ÅøË®±ÂèØ
                                        if newOffset &gt; 0 {
                                            activeOffsetY[talkThread.id] = newOffset
                                        }

                                        // ‰∏ä„Çπ„ÉØ„Ç§„Éó„ÅØË®±ÂèØ„Åó„Å™„ÅÑ„Åå onUpSwipe „ÇíÂÆüË°å
                                        if newOffset &lt; -100 {
                                            onUpSwipe()
                                        }

                                        // ‰∏ã„Çπ„ÉØ„Ç§„Éó
                                        if newOffset &gt; 100 {
                                            activeOffsetY[talkThread.id] = 0
                                            onDownSwipe()
                                        }
                                    }
                                    .onEnded { _ in
                                        activeOffsetY[talkThread.id] = 0
                                    }
                            )
                            .onTapGesture {
                                onTapTalkThread()
                            }
                            // offsetY = 0 „Å®„Åó„Åü„Å®„Åç„Å´„Å™„ÇÅ„Çâ„Åã„Å´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Åô„Çã„Çà„ÅÜ„Å´
                            .animation(.default, value: activeOffsetY[talkThread.id])
                        }
                        .frame(width: geometry.size.width - padding * 2)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        // „Åì„Çå„Åå„Å™„ÅÑ„Å®Èï∑Êäº„Åó„ÅÆ„Çø„ÉÉ„ÉóÈ†òÂüü„ÅåÊ≠£„Åó„ÅèÂèçÊò†„Åï„Çå„Å™„ÅÑ
                        // Ref: „ÄêSwiftUI„ÄëcontentShape„ÅßTapÈ†òÂüü„ÇíÂ∫É„Åí„Çã - https://qiita.com/shiz/items/96585bddbc442683b78c
                        .contentShape(RoundedRectangle(cornerRadius: 8))
                        // Ref: [SwiftUI] contextMenu modifier „Çø„ÉÉ„Éó„Åó„ÅüView„ÅÆËÉåÊôØËâ≤„ÇíÊ∂à„ÅôÊñπÊ≥ï - https://zenn.dev/your3i/articles/f03210a0270a5b
                        .contextMenu {
                            Button {
                                onTapStampReaction()
                            } label: {
                                Label {
                                    Text("„Çπ„Çø„É≥„ÉóËøî‰ø°")
                                } icon: {
                                    SFSymbols.faceSmiling.image
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal, padding)
                .padding(.vertical)
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned) // paging „Å†„Å®‰∏äÊâã„Åè„ÅÑ„Åã„Å™„ÅÑ„ÅÆ„ÅßÊ≥®ÊÑè
            // iOS 18.0 „Åß„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂÜçÁîü„Åó„Å¶Ëá™Âãï„Çπ„ÇØ„É≠„Éº„É´„Åó„ÅüÊôÇ„Å´„Åô„Åì„Åó„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„Åå„Åö„Çå„Å¶„Åó„Åæ„ÅÜÔºà„Åä„Åù„Çâ„Åè OS „Éê„Ç∞Ôºâ
            .scrollPosition(id: $selectedTalkThread) // scrollTargetLayout() „ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆ id „ÅÆÂÄ§„Å®„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞„Åô„Çã
            .scrollIndicators(.hidden)
        }
    }
}

---

## ü§ñ Assistant
*2024-08-01 16:48:51*

`simultaneousGesture`„Çí`gesture`„Å´Â§âÊõ¥„Åô„Çã„Å®„ÄÅÊ®™„Çπ„ÇØ„É≠„Éº„É´„Åå„Åß„Åç„Å™„Åè„Å™„ÇãÂïèÈ°å„ÅØ„ÄÅ„Ç∏„Çß„Çπ„ÉÅ„É£„Åå„Çπ„ÇØ„É≠„Éº„É´„Å®Á´∂Âêà„Åô„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ„Åì„Çå„ÇíËß£Ê±∫„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ„Çπ„ÉØ„Ç§„Éó„Å®„Çπ„ÇØ„É≠„Éº„É´„ÇíÂÖ±Â≠ò„Åï„Åõ„ÇãÊñπÊ≥ï„Å®„Åó„Å¶„ÄÅ„Ç´„Çπ„Çø„É†„Ç∏„Çß„Çπ„ÉÅ„É£„Éº„Çí‰ΩøÁî®„Åó„Å¶Ê®™„Çπ„ÇØ„É≠„Éº„É´„Çí‰øùÊåÅ„Åó„Å§„Å§„ÄÅ„Çπ„ÉØ„Ç§„Éó„ÇíÂá¶ÁêÜ„Åô„ÇãÊñπÊ≥ï„ÇíÊ§úË®é„Åó„Åæ„Åô„ÄÇ

‰ª•‰∏ã„ÅØ„Åù„ÅÆÂÆüË£Ö‰æã„Åß„ÅôÔºö

```swift
@available(iOS 17.0, *)
struct ThreadListScrollView: View {
    @Binding var selectedTalkThread: TalkThread?
    let talkThreads: [TalkThread]
    let spacing: CGFloat
    let padding: CGFloat
    let onTapTalkThread: (TalkThread) -> Void
    let onTapStampReaction: () -> Void
    let onDownSwipe: () -> Void
    let onUpSwipe: () -> Void
    let volumeLevels: [Double]
    let volumeLevelColumns: Int
    let isPlaying: Bool

    @State private var activeOffsetY: [String: CGFloat] = [:]
    @State private var dragStartLocation: CGPoint? = nil

    var body: some View {
        GeometryReader { geometry in
            ScrollView(.horizontal) {
                LazyHStack(spacing: spacing) {
                    ForEach(talkThreads, id: \.id) { talkThread in
                        ZStack {
                            VStack {
                                Text("‚Üì„Çπ„ÉØ„Ç§„Éó„Åß„Ç≥„É°„É≥„Éà")
                                    .foregroundStyle(.white)
                                    .font(.headline)
                                    .padding()
                                Spacer()
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .background(Color.accentColor)

                            ZStack {
                                // Ë£è„ÅÆÁîªÂÉè
                                CachedAsyncImageView(imageUrl: talkThread.imageUrl)

                                // ‰∏ãÂÅ¥„ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ
                                VStack {
                                    Spacer()
                                    HStack {
                                        CachedAsyncImageView(imageUrl: talkThread.imageUrl)
                                            .frame(width: 40, height: 40)
                                            .clipShape(.circle)

                                        VStack(alignment: .leading) {
                                            Text(talkThread.postedBy.name)
                                                .foregroundColor(.primary)

                                            Text(talkThread.updatedAt.relativeDateTime)
                                                .foregroundColor(.secondary)
                                                .font(.subheadline)
                                        }
                                        .lineLimit(1)
                                        .padding(.leading, 8)

                                        Spacer()

                                        HStack(spacing: -8) {
                                            ForEach(talkThread.posts.prefix(3)) { post in
                                                ZStack(alignment: .topLeading) { // rightToLeft „Å´Âêà„Çè„Åõ„Å¶ leading „Å´„Å™„Å£„Å¶„ÅÑ„Çã
                                                    CachedAsyncImageView(imageUrl: post.postedBy.imageUrl)
                                                        .frame(width: 32, height: 32)
                                                        .clipShape(.circle)

                                                    if let imageUrl = post.postType.imageUrl {
                                                        CachedAsyncImageView(imageUrl: imageUrl)
                                                            .frame(width: 16, height: 16)
                                                            .clipShape(.circle)
                                                            .offset(x: -4, y: -4) // rightToLeft „Å´Âêà„Çè„Åõ„Å¶ x „ÅåË≤†„Å´„Å™„Å£„Å¶„ÅÑ„Çã
                                                    }
                                                }
                                            }
                                        }
                                        .environment(\.layoutDirection, .rightToLeft)
                                    }
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .frame(height: 80)
                                    .padding(.horizontal)
                                    .background(.ultraThinMaterial)
                                }

                                // Èü≥Â£∞„ÅÆÊ≥¢
                                GeometryReader { geometry in
                                    if isPlaying, talkThread == selectedTalkThread {
                                        WaveformView(volumeLevels: volumeLevels, maxColumnCount: volumeLevelColumns)
                                            .frame(width: geometry.size.width - 16, height: 100)
                                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                                            .transition(.opacity)
                                    }
                                }
                                .animation(.easeInOut, value: isPlaying)
                            }
                            .offset(y: activeOffsetY[talkThread.id] ?? 0)
                            .gesture(
                                DragGesture()
                                    .onChanged { value in
                                        let newOffset = value.translation.height

                                        // ‰∏ã„Çπ„ÉØ„Ç§„Éó„ÅÆ„ÅøË®±ÂèØ
                                        if newOffset > 0 {
                                            activeOffsetY[talkThread.id] = newOffset
                                        }

                                        // ‰∏ä„Çπ„ÉØ„Ç§„Éó„ÅØË®±ÂèØ„Åó„Å™„ÅÑ„Åå onUpSwipe „ÇíÂÆüË°å
                                        if newOffset < -100 {
                                            onUpSwipe()
                                        }

                                        // ‰∏ã„Çπ„ÉØ„Ç§„Éó
                                        if newOffset > 100 {
                                            activeOffsetY[talkThread.id] = 0
                                            onDownSwipe()
                                        }
                                    }
                                    .onEnded { _ in
                                        activeOffsetY[talkThread.id] = 0
                                    }
                            )
                            .highPriorityGesture(
                                DragGesture(minimumDistance: 30, coordinateSpace: .local)
                                    .onChanged { value in
                                        dragStartLocation = value.startLocation
                                    }
                                    .onEnded { value in
                                        guard let startLocation = dragStartLocation else { return }
                                        let endLocation = value.location
                                        let verticalDistance = abs(startLocation.y - endLocation.y)
                                        let horizontalDistance = abs(startLocation.x - endLocation.x)

                                        if verticalDistance > horizontalDistance {
                                            if endLocation.y > startLocation.y {
                                                onDownSwipe()
                                            } else {
                                                onUpSwipe()
                                            }
                                        }
                                        dragStartLocation = nil
                                    }
                            )
                            .onTapGesture {
                                onTapTalkThread(talkThread)
                            }
                            .animation(.default, value: activeOffsetY[talkThread.id])
                        }
                        .frame(width: geometry.size.width - padding * 2)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        .contentShape(RoundedRectangle(cornerRadius: 8))
                        .contextMenu {
                            Button {
                                onTapStampReaction()
                            } label: {
                                Label {
                                    Text("„Çπ„Çø„É≥„ÉóËøî‰ø°")
                                } icon: {
                                    SFSymbols.faceSmiling.image
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal, padding)
                .padding(.vertical)
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned)
            .scrollPosition(id: $selectedTalkThread)
            .scrollIndicators(.hidden)
        }
    }
}
```

„Åì„ÅÆÂÆüË£Ö„Åß„ÅØ„ÄÅ`highPriorityGesture`„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ„Éâ„É©„ÉÉ„Ç∞„Ç∏„Çß„Çπ„ÉÅ„É£„ÇíÈ´òÂÑ™ÂÖàÂ∫¶„ÅßÂá¶ÁêÜ„Åó„ÄÅÁ∏¶ÊñπÂêë„ÅÆ„Çπ„ÉØ„Ç§„Éó„Å®Ê®™ÊñπÂêë„ÅÆ„Çπ„ÇØ„É≠„Éº„É´„ÇíÂå∫Âà•„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆÊñπÊ≥ï„Åß„ÄÅ„Çπ„ÇØ„É≠„Éº„É´„Å®„Çπ„ÉØ„Ç§„Éó„ÅÆ‰∏°Êñπ„ÇíÈÅ©Âàá„Å´Âãï‰Ωú„Åï„Åõ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ

---

## üë§ User
*2024-08-01 16:50:55*

.scrollPosition(id: $selectedTalkThread) „ÅßÂá¶ÁêÜ„Åô„Çã„ÅÆ„ÅØË´¶„ÇÅ„Å¶„ÄÅ„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„ÅßÂà§ÂÆö„Åô„Çã„ÅÆ„ÅØ„Å©„ÅÜ„Åß„Åô„ÅãÔºü

public struct ThreadListView&lt;Dependency: RootDIContainerDependency&gt;: View {
    private let dependency: Dependency
    @StateObject private var presenter: ThreadListPresenter&lt;Dependency&gt;

    public init(dependency: Dependency, talkBox: TalkBox) {
        self.dependency = dependency
        _presenter = .init(wrappedValue: ThreadListPresenter(dependency: dependency, talkBox: talkBox))
    }

    public var body: some View {
        VStack {
            // iOS 16 „Åß„ÅØ pageing „Åå„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ iOS 16 ÂØæÂøú„Åô„Çã„ÅÆ„Åß„ÅÇ„Çå„Å∞ Âà•ÈÄîÂØæÂøú„Åô„Çã
            if #available(iOS 17.0, *) {
                ThreadListScrollView(
                    selectedTalkThread: $presenter.selectedTalkThread,
                    talkThreads: presenter.talkThreads,
                    spacing: 16,
                    padding: 32,
                    onTapTalkThread: presenter.onTapTalkThread,
                    onTapStampReaction: presenter.onTapStampReaction,
                    onDownSwipe: presenter.onDownSwipe,
                    onUpSwipe: presenter.onUpSwipe,
                    volumeLevels: presenter.audioVolumeLevels,
                    volumeLevelColumns: ThreadListPresenter&lt;Dependency&gt;.volumeLevelColumns,
                    isPlaying: presenter.isPlaying
                )
                .padding(.vertical)

                Button {
                    presenter.onTapNewPost()
                } label: {
                    Label {
                        Text("Êñ∞Ë¶èÊäïÁ®ø")
                    } icon: {
                        SFSymbols.mic.image
                    }
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .tint(.black)
            }
        }
        .navigationTitle(presenter.talkBox.name)
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: true)
        .overlayToast(toastType: $presenter.toastType)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError)
        .sheet(isPresented: $presenter.showThreadPostView) {
            ThreadPostView(dependency: dependency)
                .navigationStacked()
        }
        .sheet(isPresented: $presenter.showVoicePostView) {
            VoicePostView(dependency: dependency)
                .navigationStacked()
        }
        .sheet(isPresented: $presenter.showStampListView) {
            if let talkThread = presenter.selectedTalkThread {
                if #available(iOS 16.4, *) {
                    StampListView(dependency: dependency, talkThread: talkThread)
                        .ignoresSafeArea(edges: .bottom)
                        .navigationStacked()
                        .presentationDetents([.fraction(0.8)])
                        .presentationBackground(.clear) // @available(iOS 16.4, *)
                } else {
                    StampListView(dependency: dependency, talkThread: talkThread)
                        .ignoresSafeArea(edges: .bottom)
                        .navigationStacked()
                        .presentationDetents([.fraction(0.8)])
                }
            }
        }
        .sheet(isPresented: $presenter.showTalkThreadDetailView) {
            if let talkThread = presenter.selectedTalkThread {
                ThreadDetailView(dependency: dependency, talkThread: talkThread)
                    .navigationStacked()
            }
        }
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}

@available(iOS 17.0, *)
struct ThreadListScrollView: View {
    @Binding var selectedTalkThread: TalkThread?
    let talkThreads: [TalkThread]
    let spacing: CGFloat
    let padding: CGFloat
    let onTapTalkThread: () -&gt; Void
    let onTapStampReaction: () -&gt; Void
    let onDownSwipe: () -&gt; Void
    let onUpSwipe: () -&gt; Void
    let volumeLevels: [Double]
    let volumeLevelColumns: Int
    let isPlaying: Bool

    @State private var activeOffsetY: [String: CGFloat] = [:]

    var body: some View {
        GeometryReader { geometry in
            ScrollView(.horizontal) {
                LazyHStack(spacing: spacing) {
                    ForEach(talkThreads, id: \.id) { talkThread in
                        ZStack {
                            VStack {
                                Text("‚Üì„Çπ„ÉØ„Ç§„Éó„Åß„Ç≥„É°„É≥„Éà")
                                    .foregroundStyle(.white)
                                    .font(.headline)
                                    .padding()
                                Spacer()
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .background(Color.accentColor)

                            ZStack {
                                // Ë£è„ÅÆÁîªÂÉè
                                CachedAsyncImageView(imageUrl: talkThread.imageUrl)

                                // ‰∏ãÂÅ¥„ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ
                                VStack {
                                    Spacer()
                                    HStack {
                                        CachedAsyncImageView(imageUrl: talkThread.imageUrl)
                                            .frame(width: 40, height: 40)
                                            .clipShape(.circle)

                                        VStack(alignment: .leading) {
                                            Text(talkThread.postedBy.name)
                                                .foregroundColor(.primary)

                                            Text(talkThread.updatedAt.relativeDateTime)
                                                .foregroundColor(.secondary)
                                                .font(.subheadline)
                                        }
                                        .lineLimit(1)
                                        .padding(.leading, 8)

                                        Spacer()

                                        HStack(spacing: -8) {
                                            ForEach(talkThread.posts.prefix(3)) { post in
                                                ZStack(alignment: .topLeading) { // rightToLeft „Å´Âêà„Çè„Åõ„Å¶ leading „Å´„Å™„Å£„Å¶„ÅÑ„Çã
                                                    CachedAsyncImageView(imageUrl: post.postedBy.imageUrl)
                                                        .frame(width: 32, height: 32)
                                                        .clipShape(.circle)

                                                    if let imageUrl = post.postType.imageUrl {
                                                        CachedAsyncImageView(imageUrl: imageUrl)
                                                            .frame(width: 16, height: 16)
                                                            .clipShape(.circle)
                                                            .offset(x: -4, y: -4) // rightToLeft „Å´Âêà„Çè„Åõ„Å¶ x „ÅåË≤†„Å´„Å™„Å£„Å¶„ÅÑ„Çã
                                                    }
                                                }
                                            }
                                        }
                                        .environment(\.layoutDirection, .rightToLeft)
                                    }
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .frame(height: 80)
                                    .padding(.horizontal)
                                    .background(.ultraThinMaterial)
                                }

                                // Èü≥Â£∞„ÅÆÊ≥¢
                                GeometryReader { geometry in
                                    if isPlaying, talkThread == selectedTalkThread {
                                        WaveformView(volumeLevels: volumeLevels, maxColumnCount: volumeLevelColumns)
                                            .frame(width: geometry.size.width - 16, height: 100)
                                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                                            .transition(.opacity)
                                    }
                                }
                                .animation(.easeInOut, value: isPlaying)
                            }
                            .offset(y: activeOffsetY[talkThread.id] ?? 0)
                            // ÊôÆÈÄö„ÅÆ .gesture „Å†„Å®„Çπ„ÇØ„É≠„Éº„É´„Å®Âπ≤Ê∏â„Åó„Å¶„Çπ„ÇØ„É≠„Éº„É´„Åß„Åç„Å™„Åè„Å™„Çã
                            .simultaneousGesture(
                                DragGesture()
                                    .onChanged { value in
                                        let newOffset = value.translation.height

                                        // ‰∏ã„Çπ„ÉØ„Ç§„Éó„ÅÆ„ÅøË®±ÂèØ
                                        if newOffset &gt; 0 {
                                            activeOffsetY[talkThread.id] = newOffset
                                        }

                                        // ‰∏ä„Çπ„ÉØ„Ç§„Éó„ÅØË®±ÂèØ„Åó„Å™„ÅÑ„Åå onUpSwipe „ÇíÂÆüË°å
                                        if newOffset &lt; -100 {
                                            onUpSwipe()
                                        }

                                        // ‰∏ã„Çπ„ÉØ„Ç§„Éó
                                        if newOffset &gt; 100 {
                                            activeOffsetY[talkThread.id] = 0
                                            onDownSwipe()
                                        }
                                    }
                                    .onEnded { _ in
                                        activeOffsetY[talkThread.id] = 0
                                    }
                            )
                            .onTapGesture {
                                onTapTalkThread()
                            }
                            // offsetY = 0 „Å®„Åó„Åü„Å®„Åç„Å´„Å™„ÇÅ„Çâ„Åã„Å´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Åô„Çã„Çà„ÅÜ„Å´
                            .animation(.default, value: activeOffsetY[talkThread.id])
                        }
                        .frame(width: geometry.size.width - padding * 2)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        // „Åì„Çå„Åå„Å™„ÅÑ„Å®Èï∑Êäº„Åó„ÅÆ„Çø„ÉÉ„ÉóÈ†òÂüü„ÅåÊ≠£„Åó„ÅèÂèçÊò†„Åï„Çå„Å™„ÅÑ
                        // Ref: „ÄêSwiftUI„ÄëcontentShape„ÅßTapÈ†òÂüü„ÇíÂ∫É„Åí„Çã - https://qiita.com/shiz/items/96585bddbc442683b78c
                        .contentShape(RoundedRectangle(cornerRadius: 8))
                        // Ref: [SwiftUI] contextMenu modifier „Çø„ÉÉ„Éó„Åó„ÅüView„ÅÆËÉåÊôØËâ≤„ÇíÊ∂à„ÅôÊñπÊ≥ï - https://zenn.dev/your3i/articles/f03210a0270a5b
                        .contextMenu {
                            Button {
                                onTapStampReaction()
                            } label: {
                                Label {
                                    Text("„Çπ„Çø„É≥„ÉóËøî‰ø°")
                                } icon: {
                                    SFSymbols.faceSmiling.image
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal, padding)
                .padding(.vertical)
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned) // paging „Å†„Å®‰∏äÊâã„Åè„ÅÑ„Åã„Å™„ÅÑ„ÅÆ„ÅßÊ≥®ÊÑè
            // iOS 18.0 „Åß„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂÜçÁîü„Åó„Å¶Ëá™Âãï„Çπ„ÇØ„É≠„Éº„É´„Åó„ÅüÊôÇ„Å´„Åô„Åì„Åó„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„Åå„Åö„Çå„Å¶„Åó„Åæ„ÅÜÔºà„Åä„Åù„Çâ„Åè OS „Éê„Ç∞Ôºâ
            .scrollPosition(id: $selectedTalkThread) // scrollTargetLayout() „ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆ id „ÅÆÂÄ§„Å®„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞„Åô„Çã
            .scrollIndicators(.hidden)
        }
    }
}

---
