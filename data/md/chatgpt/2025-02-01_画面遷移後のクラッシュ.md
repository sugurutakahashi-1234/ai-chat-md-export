# ç”»é¢é·ç§»å¾Œã®ã‚¯ãƒ©ãƒƒã‚·ãƒ¥

æ—¥ä»˜: 2025-02-01

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/02/01 14:52:20*

ã“ã®ç”»é¢ã‹ã‚‰åˆ¥ã®ç”»é¢ã«context.go(Screen.login.path); ã§é·ç§»ã™ã‚‹ã¨ä»¥ä¸‹ã®å†…å®¹ã§ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹

FlutterError (A ValueNotifier&lt;Set&lt;Marker&gt;&gt; was used after being disposed.
Once you have called dispose() on a ValueNotifier&lt;Set&lt;Marker&gt;&gt;, it can no longer be used.)


import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

enum SpotType {
  noneGuild, // spotGuildId == null
  myGuild, // spotGuildId == myGuildId
  enemyGuild // spotGuildId != myGuildId
}

/// é€†ä¸‰è§’å½¢ã‚’æç”»ã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãª Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // å·¦ä¸Š
      ..lineTo(size.width, 0) // å³ä¸Š
      ..lineTo(size.width / 2, size.height) // åº•è¾ºã®ä¸­å¤®
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isMarkersBuildingState = useState(false);

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);
      final photoUrl = spot.photoUrl;
      Widget content;

      switch (spotType) {
        case SpotType.noneGuild:
          content = DecoratedBox(
            decoration: BoxDecoration(
              border: Border.all(
                color: ColorPallet.white,
                width: 4,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: ColoredBox(
                color: ColorToken.bgWhite,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: (photoUrl != null && photoUrl.isNotEmpty)
                      ? CachedNetworkImage(
                          imageUrl: photoUrl,
                          fit: BoxFit.cover,
                          width: 64,
                          height: 64,
                          errorWidget: (context, url, error) {
                            return Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.broken_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            );
                          },
                        )
                      : Container(
                          width: 64,
                          height: 64,
                          color: ColorToken.bgDark,
                          child: const Icon(
                            Icons.hide_image_outlined,
                            size: 48,
                            color: ColorToken.text,
                          ),
                        ),
                ),
              ),
            ),
          );

        case SpotType.myGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorPallet.green500,
              child: Icon(
                Icons.flag,
                color: ColorPallet.green100,
                size: 24,
              ),
            ),
          );

        case SpotType.enemyGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorToken.bgEnemy,
              child: Icon(
                Icons.flag,
                color: ColorToken.enemy,
                size: 24,
              ),
            ),
          );
      }

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              content,
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final photoUrl = itemBox.itemBoxImage;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: (photoUrl != null && photoUrl.isNotEmpty)
                          ? CachedNetworkImage(
                              imageUrl: photoUrl,
                              fit: BoxFit.cover,
                              width: 64,
                              height: 64,
                              errorWidget: (context, url, error) {
                                return Container(
                                  width: 64,
                                  height: 64,
                                  color: ColorToken.bgDark,
                                  child: const Icon(
                                    Icons.broken_image_outlined,
                                    size: 48,
                                    color: ColorToken.text,
                                  ),
                                );
                              },
                            )
                          : Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.hide_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: spotType == SpotType.noneGuild
            ? const Size(198, 225)
            : const Size(242, 275),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    Future&lt;void&gt; refreshAllMarkers({
      required List&lt;GuildSpotDTO&gt; newSpotList,
      required List&lt;ItemBoxDTO&gt; newItemBoxList,
      required String? myGuildId,
    }) async {
      final currentMarkers = markersState.value.toSet();

      final neededMarkerIds = &lt;String&gt;{};
      for (final spot in newSpotList) {
        final spotId = spot.spotId ?? '';
        neededMarkerIds.add('spot_$spotId');
      }
      for (final box in newItemBoxList) {
        final boxId = box.itemBoxId ?? '';
        neededMarkerIds.add('itemBox_$boxId');
      }

      // æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ã€Œä¸è¦ã«ãªã£ãŸã‚‚ã®ã€ã‚’å‰Šé™¤ã™ã‚‹
      currentMarkers.removeWhere(
        (marker) =&gt; !neededMarkerIds.contains(marker.markerId.value),
      );

      // ã„ã£ãŸã‚“å‰Šé™¤çµæœã‚’åæ˜ (ä¸è¦ãƒãƒ¼ã‚«ãƒ¼ãŒæ¶ˆãˆã‚‹)
      markersState.value = {...currentMarkers};

      // Spot ã®ãƒªã‚¹ãƒˆã‚’é †ã«å‡¦ç†ã—ã€1ã¤ãšã¤å†æç”»ã—ã¦åæ˜ 
      for (final spot in newSpotList) {
        final markerId = MarkerId('spot_${spot.spotId}');
        // buildSpotMarker (å¿…ãšå†ç”Ÿæˆã—ã¦å†æç”»ã™ã‚‹)
        final newMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // æ—¢å­˜ã«åŒã˜ ID ã®ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        // æ–°ãŸã«è¿½åŠ ã•ã‚Œã‚‹ or æ›´æ–°ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼ã‚’ã™ãåæ˜ 
        markersState.value = {...currentMarkers};

        // UI ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã«ããã™ã‚‹ãŸã‚ã«å°‘ã—å¾…æ©Ÿ
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox ã‚‚åŒæ§˜ã«å‡¦ç†
      for (final itemBox in newItemBoxList) {
        final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
        final newMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (box) async {
            await onTapItemBoxMarker(box);
          },
        );

        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        markersState.value = {...currentMarkers};

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

    Future&lt;void&gt; onTanNearMe() async {
      try {
        final refreshedLocation = await ref
            .read(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();
        final controller = googleMapControllerState.value;
        if (controller != null) {
          await controller.animateCamera(
            CameraUpdate.newLatLng(refreshedLocation),
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; initializeMarkers() async {
      try {
        isMarkersBuildingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshAllMarkers(
            newSpotList: spotList,
            newItemBoxList: itemBoxList,
            myGuildId: myGuildId,
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        isMarkersBuildingState.value = false;
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await initializeMarkers();
        });
        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!isMarkersBuildingState.value) {
          // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°
          await initializeMarkers();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          try {
            final currentLocation = await ref
                .watch(currentLocationNotifierProvider.notifier)
                .getCurrentLocation();

            // range ã¯ km å˜ä½ãªã®ã§ã€ãƒ¡ãƒ¼ãƒˆãƒ«ã«æ›ç®—ï¼ˆÃ—1000ï¼‰
            final explorerRangeKm = next.explorer?.range ?? 0;
            final rangeInMeters = explorerRangeKm * 1000.0;

            final circle = Circle(
              circleId: const CircleId('explorerCircle'),
              center: currentLocation,
              radius: rangeInMeters,
              strokeColor: const Color(0xFF004DFF), // ãƒ–ãƒ«ãƒ¼
              strokeWidth: 1,
              fillColor: const Color(0x40004DFF), // 25%ãã‚‰ã„é€éã®ãƒ–ãƒ«ãƒ¼
            );

            circlesState.value = {circle};

            await googleMapControllerState.value?.animateCamera(
              CameraUpdate.newLatLng(currentLocation),
            );
          } on Exception catch (error) {
            if (context.mounted) {
              showErrorSnackBar(context, error);
            }
          }
        } else {
          circlesState.value = {};
          final explodedSpotList = ref.read(explodedSpotListNotifierProvider);

          final spotPhotoItems = explodedSpotList
                  ?.where((spot) =&gt; spot.photoUrl != null)
                  .map(
                    (spot) =&gt; SpotPhotoItem(
                      photoId: spot.photoId ?? '',
                      spotPhotoUrl: spot.photoUrl ?? '',
                      spotOwnership: spot.guildId == null
                          ? SpotOwnership.neutral
                          : spot.guildId == myGuildIdState.value
                              ? SpotOwnership.owner
                              : SpotOwnership.enemy,
                    ),
                  )
                  .toList() ??
              [];

          ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

          await showDialog&lt;void&gt;(
            context: context,
            builder: (_) =&gt; ExploredResultDialog(
              spotPhotoItemList: spotPhotoItems,
            ),
          );

          ref.read(explodedSpotListNotifierProvider.notifier).clear();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapControllerState.value = controller;
              },
              markers: markersState.value,
              circles: circlesState.value,
            ),
            if (isMarkersBuildingState.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTanNearMe();
                        },
                        child: const Icon(
                          Icons.near_me,
                          size: 24,
                          color: ColorToken.secondaryDark,
                        ),
                      ),
                    ),
                    // Explore ãƒªã‚¹ãƒˆ
                    SizedBox(
                      width: 138,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: onExploringStateValue.isExploring
                            ? null
                            : () async {
                                await onTapExplorer();
                              },
                        backgroundColor: onExploringStateValue.isExploring
                            ? ColorPallet.gray800.withValues(alpha: 0.8)
                            : Theme.of(context)
                                .floatingActionButtonTheme
                                .backgroundColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: BorderSide(
                            color: onExploringStateValue.isExploring
                                ? Colors.transparent
                                : ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(left: 4),
                              child: onExploringStateValue.isExploring
                                  ? Transform.translate(
                                      offset: const Offset(4, 0),
                                      child: const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        ),
                                      ),
                                    )
                                  : Image.asset(
                                      Assets.images.explorerIconFig.path,
                                      width: 40,
                                      height: 40,
                                    ),
                            ),
                            const Spacer(),
                            Text(
                              onExploringStateValue.isExploring
                                  ? 'Exploring...'
                                  : 'Explore',
                              style: TextStyle(
                                fontSize: 16,
                                color: onExploringStateValue.isExploring
                                    ? ColorToken.text
                                    : ColorToken.secondaryDark,
                              ),
                            ),
                            const Spacer(),
                          ],
                        ),
                      ),
                    ),
                    // Spot ãƒªã‚¹ãƒˆ
                    spotListAsyncValue.when(
                      data: (spotList) {
                        // ä¸Šä½2ã¤ã‚’å–ã‚Šå‡ºã—ã€é †åºã‚’é€†ã«ã™ã‚‹
                        final displaySpotList =
                            (spotList?.take(2).toList() ?? [])
                                .reversed
                                .toList();
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            backgroundColor: Colors.transparent,
                            shape: const RoundedRectangleBorder(
                              side: BorderSide(
                                color: Colors.transparent,
                              ),
                            ),
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: Transform.translate(
                              offset: const Offset(4, 4),
                              child: Stack(
                                clipBehavior: Clip.none,
                                alignment: Alignment.bottomRight,
                                children: [
                                  for (var i = 0; i &lt; 2; i++)
                                    if (i &lt; displaySpotList.length)
                                      Positioned(
                                        left: i * -4.0,
                                        top: i * -4.0,
                                        child: SizedBox(
                                          width: 44,
                                          height: 44,
                                          child: DecoratedBox(
                                            decoration: BoxDecoration(
                                              border: Border.all(
                                                color: ColorToken.bgWhite,
                                                width: 2,
                                              ),
                                              borderRadius:
                                                  BorderRadius.circular(4),
                                            ),
                                            child: Padding(
                                              padding: const EdgeInsets.all(2),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: SquareImage(
                                                  imageUrl: displaySpotList[i]
                                                      .photoUrl,
                                                  size: 44,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                      loading: () {
                        return const SizedBox.shrink();
                      },
                      error: (error, _) {
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            heroTag: 'ErrorShowSpotListButton',
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: const Icon(
                              Icons.photo,
                              size: 24,
                              color: ColorToken.secondaryDark,
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Center(
            child: ElevatedButton(
              onPressed: () async {
                await openAppSettings();
              },
              child: const Text(
                'Please enable location access in the Settings App',
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/02/01 14:53:03*

**Investigation in motion**

The user encounters a crash due to a disposed `ValueNotifier` being accessed after `dispose()` is called. Potential causes include asynchronous calls or direct references after widget disposal.

**Addressing asynchronous challenges**

The problem might stem from `widget.toBitmapDescriptor` being asynchronous and updating the marker set state post-disposal. Ensuring the widget's status or using a persistent provider could resolve this.

**Addressing state management**

The code error might be due to updating a disposed Hook state variable asynchronously. Setting a `_disposed` flag or using `useEffect` to cancel updates can resolve this.

**Ensuring safe updates**

To avoid updating a disposed widget, wrapping asynchronous calls with `tryCatch` or validating the widget's status with `if (!mounted)` is essential before invoking `setState`.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/02/01 14:53:03*

ã“ã®ã‚¨ãƒ©ãƒ¼

```
FlutterError (A ValueNotifier<Set<Marker>> was used after being disposed.
Once you have called dispose() on a ValueNotifier<Set<Marker>>, it can no longer be used.)
```

ã¯ã€**ç”»é¢ãŒDispose**(ç ´æ£„)ã•ã‚ŒãŸå¾Œã‚‚ `markersState` (ã‚„ãã®ä»–ã® Hook ã® State) ã‚’æ›´æ–°ã—ã‚ˆã†ã¨ã—ã¦ã—ã¾ã†ã“ã¨ã§èµ·ã“ã£ã¦ã„ã¾ã™ã€‚  
ãŸã¨ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ•ãƒ­ãƒ¼ãŒå…¸å‹çš„ãªåŸå› ã«ãªã‚Šã¾ã™ã€‚

1. ç”»é¢ (`MapPage`) ã§éåŒæœŸå‡¦ç†ã‚’èµ°ã‚‰ã›ã¦ã€ãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ ãƒ»å‰Šé™¤ã™ã‚‹ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹  
2. ãã®æœ€ä¸­ã« `context.go(...)` ãªã©ã§åˆ¥ç”»é¢ã¸é·ç§»ã—ã¦ `MapPage` ãŒ dispose ã•ã‚Œã‚‹  
3. éåŒæœŸå‡¦ç†ãŒå®Œäº†ã—ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ `markersState.value = ...` ã‚’å‘¼ã³å‡ºã™  
4. ã—ã‹ã—ã™ã§ã« `MapPage` ã¯ç ´æ£„ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ã€Œç ´æ£„å¾Œã«å¤‰æ›´ã—ã‚ˆã†ã¨ã—ãŸã€ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ

## è§£æ±ºç­–

### 1. `useIsMounted` ã§ç”»é¢ãŒç ´æ£„ã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹

`flutter_hooks` ã® `useIsMounted` ãƒ•ãƒƒã‚¯ã‚’ä½¿ã†ã“ã¨ã§ã€

- ã€Œã“ã®ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆãŒã¾ã ç”»é¢ã«å­˜åœ¨ã—ã¦ã„ã‚‹ã‹ (mounted çŠ¶æ…‹ã‹)ã€ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
- ç ´æ£„ã•ã‚ŒãŸã‚ã¨ã® State æ›´æ–°ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹

ã¨ã„ã†æ–¹æ³•ãŒç°¡å˜ã«å®Ÿè£…ã§ãã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚ˆã†ã«ã€ã¾ãš `build` ãƒ¡ã‚½ãƒƒãƒ‰å†…ãªã©ã§

```dart
final isMounted = useIsMounted();
```

ã‚’ç”¨æ„ã—ã¦ãŠãã¾ã™ã€‚ãã—ã¦ã€

```dart
Future<void> refreshAllMarkers(...) async {
  // ...ä¸­ç•¥...

  // buildSpotMarker / buildItemBoxMarker å†…ã§
  // ã‚¢ã‚¤ã‚³ãƒ³ç”Ÿæˆ â†’ markersState ã‚’æ›´æ–°ã—ã¦ã„ãå‡¦ç†ã®ã‚ã¨
  // ã‚ã‚‹ã„ã¯æ›´æ–°ç›´å‰ã«

  if (!isMounted()) {
    // ç”»é¢ãŒã™ã§ã«ç ´æ£„ã•ã‚Œã¦ã„ã‚‹ãªã‚‰æ›´æ–°ã¯ã‚„ã‚ã‚‹
    return;
  }
  // å•é¡Œãªã„ãªã‚‰ç¶šè¡Œ
  markersState.value = {...currentMarkers};

  // ...ä¸­ç•¥...
}
```

ã¨ã„ã£ãŸå½¢ã§ã€**State æ›´æ–°å‰ã«** ã€Œã¾ã ç”»é¢ãŒ mounted ã•ã‚Œã¦ã„ã‚‹ã‹ (`isMounted() == true`)ã€ã‚’å¿…ãšãƒã‚§ãƒƒã‚¯ã—ã¦ãŠãã‚ˆã†ã«ã—ã¾ã™ã€‚

### 2. `context.mounted` / `ref.mounted` ã§ãƒã‚§ãƒƒã‚¯ã™ã‚‹

Riverpod ã® `WidgetRef` ã«ã¯ `ref.mounted` ãŒã€  
Flutter ã® `BuildContext` ã«ã¯ `context.mounted` (Flutter 3.7 ä»¥é™) ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚

Hook ã‚’ä½¿ã‚ãªã„å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã€

```dart
if (!context.mounted) return;
```

ã§ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ãŒå…¬å¼æ¨å¥¨ã§ã™ãŒã€**Hook ã‚’ç”¨ã„ã¦ã„ã‚‹å ´åˆã¯** `useIsMounted` ã‚’ä½¿ã†ã»ã†ãŒæ‰‹è»½ã§ã™ã€‚  
(`context.mounted` ã‚„ `ref.mounted` ã‚’åŒæ§˜ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒã‚§ãƒƒã‚¯ã—ã¦ã‚‚è§£æ±ºã¯å¯èƒ½)

### 3. éåŒæœŸé–¢æ•°ã®é€”ä¸­ã§ `dispose` å¾Œã«å‘¼ã³å‡ºã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹

åŸºæœ¬çš„ã«ã¯ä¸Šè¨˜ã®ã€Œãƒã‚¦ãƒ³ãƒˆçŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã€ãŒæœ€ã‚‚ç°¡å˜ã§ç¢ºå®Ÿã§ã™ãŒã€

- ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ãã‚‹ä»•çµ„ã¿ã‚’çµ„ã¿è¾¼ã‚€
- `Future` ã®å®Œäº†ã‚’å¾…ãŸãšã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãŒè¡Œã‚ã‚ŒãŸéš›ã«ã€å¾Œç¶šã®å‡¦ç†ã‚’ cancel ã™ã‚‹

ãªã©ã®æ‰‹æ®µã‚’ä½¿ã†ã®ã‚‚æ‰‹ã§ã™ã€‚  
ãŸã ã—ã€ãã®å ´åˆã§ã‚‚**ã€Œdispose å¾Œã« marker ã® State ã‚’æ›´æ–°ã—ãªã„ã€**ã¨ã„ã†å¯¾ç­–ã¯å¿…è¦ã«ãªã‚Šã¾ã™ã€‚

---

## ã¾ã¨ã‚

- ç”»é¢ã‹ã‚‰é›¢è„±ã—ãŸã‚ã¨ï¼ˆWidget ãŒ dispose ã•ã‚ŒãŸã‚ã¨ï¼‰ã« `markersState` ã®æ›´æ–°ãŒèµ°ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹  
- `useIsMounted()` / `context.mounted` / `ref.mounted` ãªã©ã‚’æ´»ç”¨ã—ã€**ã€Œç ´æ£„ã•ã‚ŒãŸã‚‰æ›´æ–°ã—ãªã„ã€**ã‚’å¾¹åº•ã™ã‚‹  
- éåŒæœŸå‡¦ç†ãŒè¤‡æ•°ã‚¹ãƒ†ãƒƒãƒ—ã«åˆ†ã‹ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®é–“ã«ã‚‚ãƒã‚¦ãƒ³ãƒˆçŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹

ã“ã‚Œã‚‰ã‚’å®ˆã‚Œã°ã€`ValueNotifier` ãŒ dispose å¾Œã«æ›´æ–°ã•ã‚Œã¦ã—ã¾ã†å•é¡Œã‚’å›é¿ã§ãã¾ã™ã€‚

---
