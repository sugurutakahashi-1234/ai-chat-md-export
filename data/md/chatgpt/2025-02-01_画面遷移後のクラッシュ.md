# ÁîªÈù¢ÈÅ∑ÁßªÂæå„ÅÆ„ÇØ„É©„ÉÉ„Ç∑„É•

Êó•‰ªò: 2025-02-01

---

## üë§ „É¶„Éº„Ç∂„Éº
*2025/02/01 14:52:20*

„Åì„ÅÆÁîªÈù¢„Åã„ÇâÂà•„ÅÆÁîªÈù¢„Å´context.go(Screen.login.path); „ÅßÈÅ∑Áßª„Åô„Çã„Å®‰ª•‰∏ã„ÅÆÂÜÖÂÆπ„Åß„ÇØ„É©„ÉÉ„Ç∑„É•„Åô„Çã

FlutterError (A ValueNotifier&lt;Set&lt;Marker&gt;&gt; was used after being disposed.
Once you have called dispose() on a ValueNotifier&lt;Set&lt;Marker&gt;&gt;, it can no longer be used.)


import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

enum SpotType {
  noneGuild, // spotGuildId == null
  myGuild, // spotGuildId == myGuildId
  enemyGuild // spotGuildId != myGuildId
}

/// ÈÄÜ‰∏âËßíÂΩ¢„ÇíÊèèÁîª„Åô„Çã„Ç∑„É≥„Éó„É´„Å™ Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // Â∑¶‰∏ä
      ..lineTo(size.width, 0) // Âè≥‰∏ä
      ..lineTo(size.width / 2, size.height) // Â∫ïËæ∫„ÅÆ‰∏≠Â§Æ
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isMarkersBuildingState = useState(false);

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);
      final photoUrl = spot.photoUrl;
      Widget content;

      switch (spotType) {
        case SpotType.noneGuild:
          content = DecoratedBox(
            decoration: BoxDecoration(
              border: Border.all(
                color: ColorPallet.white,
                width: 4,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: ColoredBox(
                color: ColorToken.bgWhite,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: (photoUrl != null && photoUrl.isNotEmpty)
                      ? CachedNetworkImage(
                          imageUrl: photoUrl,
                          fit: BoxFit.cover,
                          width: 64,
                          height: 64,
                          errorWidget: (context, url, error) {
                            return Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.broken_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            );
                          },
                        )
                      : Container(
                          width: 64,
                          height: 64,
                          color: ColorToken.bgDark,
                          child: const Icon(
                            Icons.hide_image_outlined,
                            size: 48,
                            color: ColorToken.text,
                          ),
                        ),
                ),
              ),
            ),
          );

        case SpotType.myGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorPallet.green500,
              child: Icon(
                Icons.flag,
                color: ColorPallet.green100,
                size: 24,
              ),
            ),
          );

        case SpotType.enemyGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorToken.bgEnemy,
              child: Icon(
                Icons.flag,
                color: ColorToken.enemy,
                size: 24,
              ),
            ),
          );
      }

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              content,
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final photoUrl = itemBox.itemBoxImage;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: (photoUrl != null && photoUrl.isNotEmpty)
                          ? CachedNetworkImage(
                              imageUrl: photoUrl,
                              fit: BoxFit.cover,
                              width: 64,
                              height: 64,
                              errorWidget: (context, url, error) {
                                return Container(
                                  width: 64,
                                  height: 64,
                                  color: ColorToken.bgDark,
                                  child: const Icon(
                                    Icons.broken_image_outlined,
                                    size: 48,
                                    color: ColorToken.text,
                                  ),
                                );
                              },
                            )
                          : Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.hide_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: spotType == SpotType.noneGuild
            ? const Size(198, 225)
            : const Size(242, 275),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    Future&lt;void&gt; refreshAllMarkers({
      required List&lt;GuildSpotDTO&gt; newSpotList,
      required List&lt;ItemBoxDTO&gt; newItemBoxList,
      required String? myGuildId,
    }) async {
      final currentMarkers = markersState.value.toSet();

      final neededMarkerIds = &lt;String&gt;{};
      for (final spot in newSpotList) {
        final spotId = spot.spotId ?? '';
        neededMarkerIds.add('spot_$spotId');
      }
      for (final box in newItemBoxList) {
        final boxId = box.itemBoxId ?? '';
        neededMarkerIds.add('itemBox_$boxId');
      }

      // Êó¢Â≠ò„Éû„Éº„Ç´„Éº„Åã„Çâ„Äå‰∏çË¶Å„Å´„Å™„Å£„Åü„ÇÇ„ÅÆ„Äç„ÇíÂâäÈô§„Åô„Çã
      currentMarkers.removeWhere(
        (marker) =&gt; !neededMarkerIds.contains(marker.markerId.value),
      );

      // „ÅÑ„Å£„Åü„ÇìÂâäÈô§ÁµêÊûú„ÇíÂèçÊò†(‰∏çË¶Å„Éû„Éº„Ç´„Éº„ÅåÊ∂à„Åà„Çã)
      markersState.value = {...currentMarkers};

      // Spot „ÅÆ„É™„Çπ„Éà„ÇíÈ†Ü„Å´Âá¶ÁêÜ„Åó„ÄÅ1„Å§„Åö„Å§ÂÜçÊèèÁîª„Åó„Å¶ÂèçÊò†
      for (final spot in newSpotList) {
        final markerId = MarkerId('spot_${spot.spotId}');
        // buildSpotMarker (ÂøÖ„ÅöÂÜçÁîüÊàê„Åó„Å¶ÂÜçÊèèÁîª„Åô„Çã)
        final newMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // Êó¢Â≠ò„Å´Âêå„Åò ID „ÅÆ„Éû„Éº„Ç´„Éº„Åå„ÅÇ„Çå„Å∞ÂâäÈô§„Åó„Å¶„Åã„ÇâËøΩÂä†
        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        // Êñ∞„Åü„Å´ËøΩÂä†„Åï„Çå„Çã or Êõ¥Êñ∞„Åï„Çå„Åü„Éû„Éº„Ç´„Éº„Çí„Åô„ÅêÂèçÊò†
        markersState.value = {...currentMarkers};

        // UI „Çí„Éñ„É≠„ÉÉ„ÇØ„Åó„Å´„Åè„Åè„Åô„Çã„Åü„ÇÅ„Å´Â∞ë„ÅóÂæÖÊ©ü
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox „ÇÇÂêåÊßò„Å´Âá¶ÁêÜ
      for (final itemBox in newItemBoxList) {
        final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
        final newMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (box) async {
            await onTapItemBoxMarker(box);
          },
        );

        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        markersState.value = {...currentMarkers};

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

    Future&lt;void&gt; onTanNearMe() async {
      try {
        final refreshedLocation = await ref
            .read(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();
        final controller = googleMapControllerState.value;
        if (controller != null) {
          await controller.animateCamera(
            CameraUpdate.newLatLng(refreshedLocation),
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; initializeMarkers() async {
      try {
        isMarkersBuildingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshAllMarkers(
            newSpotList: spotList,
            newItemBoxList: itemBoxList,
            myGuildId: myGuildId,
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        isMarkersBuildingState.value = false;
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await initializeMarkers();
        });
        // „Éï„Ç©„Ç¢„Ç∞„É©„Ç¶„É≥„ÉâÂæ©Â∏∞„Åß‰ΩçÁΩÆÊÉÖÂ†±ÂÜçÂèñÂæó
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // „Éû„Éº„Ç´„Éº„ÅÆÊõ¥Êñ∞‰∏≠„ÅØ„Çπ„Ç≠„ÉÉ„Éó
        if (!isMarkersBuildingState.value) {
          // „Éû„Éº„Ç´„Éº„ÅÆÊõ¥Êñ∞
          await initializeMarkers();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          try {
            final currentLocation = await ref
                .watch(currentLocationNotifierProvider.notifier)
                .getCurrentLocation();

            // range „ÅØ km Âçò‰Ωç„Å™„ÅÆ„Åß„ÄÅ„É°„Éº„Éà„É´„Å´ÊèõÁÆóÔºà√ó1000Ôºâ
            final explorerRangeKm = next.explorer?.range ?? 0;
            final rangeInMeters = explorerRangeKm * 1000.0;

            final circle = Circle(
              circleId: const CircleId('explorerCircle'),
              center: currentLocation,
              radius: rangeInMeters,
              strokeColor: const Color(0xFF004DFF), // „Éñ„É´„Éº
              strokeWidth: 1,
              fillColor: const Color(0x40004DFF), // 25%„Åê„Çâ„ÅÑÈÄèÈÅé„ÅÆ„Éñ„É´„Éº
            );

            circlesState.value = {circle};

            await googleMapControllerState.value?.animateCamera(
              CameraUpdate.newLatLng(currentLocation),
            );
          } on Exception catch (error) {
            if (context.mounted) {
              showErrorSnackBar(context, error);
            }
          }
        } else {
          circlesState.value = {};
          final explodedSpotList = ref.read(explodedSpotListNotifierProvider);

          final spotPhotoItems = explodedSpotList
                  ?.where((spot) =&gt; spot.photoUrl != null)
                  .map(
                    (spot) =&gt; SpotPhotoItem(
                      photoId: spot.photoId ?? '',
                      spotPhotoUrl: spot.photoUrl ?? '',
                      spotOwnership: spot.guildId == null
                          ? SpotOwnership.neutral
                          : spot.guildId == myGuildIdState.value
                              ? SpotOwnership.owner
                              : SpotOwnership.enemy,
                    ),
                  )
                  .toList() ??
              [];

          ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

          await showDialog&lt;void&gt;(
            context: context,
            builder: (_) =&gt; ExploredResultDialog(
              spotPhotoItemList: spotPhotoItems,
            ),
          );

          ref.read(explodedSpotListNotifierProvider.notifier).clear();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapControllerState.value = controller;
              },
              markers: markersState.value,
              circles: circlesState.value,
            ),
            if (isMarkersBuildingState.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // ÁèæÂú®Âú∞„Å∏Êàª„Çã„Éú„Çø„É≥
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTanNearMe();
                        },
                        child: const Icon(
                          Icons.near_me,
                          size: 24,
                          color: ColorToken.secondaryDark,
                        ),
                      ),
                    ),
                    // Explore „É™„Çπ„Éà
                    SizedBox(
                      width: 138,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: onExploringStateValue.isExploring
                            ? null
                            : () async {
                                await onTapExplorer();
                              },
                        backgroundColor: onExploringStateValue.isExploring
                            ? ColorPallet.gray800.withValues(alpha: 0.8)
                            : Theme.of(context)
                                .floatingActionButtonTheme
                                .backgroundColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: BorderSide(
                            color: onExploringStateValue.isExploring
                                ? Colors.transparent
                                : ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(left: 4),
                              child: onExploringStateValue.isExploring
                                  ? Transform.translate(
                                      offset: const Offset(4, 0),
                                      child: const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        ),
                                      ),
                                    )
                                  : Image.asset(
                                      Assets.images.explorerIconFig.path,
                                      width: 40,
                                      height: 40,
                                    ),
                            ),
                            const Spacer(),
                            Text(
                              onExploringStateValue.isExploring
                                  ? 'Exploring...'
                                  : 'Explore',
                              style: TextStyle(
                                fontSize: 16,
                                color: onExploringStateValue.isExploring
                                    ? ColorToken.text
                                    : ColorToken.secondaryDark,
                              ),
                            ),
                            const Spacer(),
                          ],
                        ),
                      ),
                    ),
                    // Spot „É™„Çπ„Éà
                    spotListAsyncValue.when(
                      data: (spotList) {
                        // ‰∏ä‰Ωç2„Å§„ÇíÂèñ„ÇäÂá∫„Åó„ÄÅÈ†ÜÂ∫è„ÇíÈÄÜ„Å´„Åô„Çã
                        final displaySpotList =
                            (spotList?.take(2).toList() ?? [])
                                .reversed
                                .toList();
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            backgroundColor: Colors.transparent,
                            shape: const RoundedRectangleBorder(
                              side: BorderSide(
                                color: Colors.transparent,
                              ),
                            ),
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: Transform.translate(
                              offset: const Offset(4, 4),
                              child: Stack(
                                clipBehavior: Clip.none,
                                alignment: Alignment.bottomRight,
                                children: [
                                  for (var i = 0; i &lt; 2; i++)
                                    if (i &lt; displaySpotList.length)
                                      Positioned(
                                        left: i * -4.0,
                                        top: i * -4.0,
                                        child: SizedBox(
                                          width: 44,
                                          height: 44,
                                          child: DecoratedBox(
                                            decoration: BoxDecoration(
                                              border: Border.all(
                                                color: ColorToken.bgWhite,
                                                width: 2,
                                              ),
                                              borderRadius:
                                                  BorderRadius.circular(4),
                                            ),
                                            child: Padding(
                                              padding: const EdgeInsets.all(2),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: SquareImage(
                                                  imageUrl: displaySpotList[i]
                                                      .photoUrl,
                                                  size: 44,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                      loading: () {
                        return const SizedBox.shrink();
                      },
                      error: (error, _) {
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            heroTag: 'ErrorShowSpotListButton',
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: const Icon(
                              Icons.photo,
                              size: 24,
                              color: ColorToken.secondaryDark,
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Center(
            child: ElevatedButton(
              onPressed: () async {
                await openAppSettings();
              },
              child: const Text(
                'Please enable location access in the Settings App',
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## üîß „ÉÑ„Éº„É´
*2025/02/01 14:53:03*

**Investigation in motion**

The user encounters a crash due to a disposed `ValueNotifier` being accessed after `dispose()` is called. Potential causes include asynchronous calls or direct references after widget disposal.

**Addressing asynchronous challenges**

The problem might stem from `widget.toBitmapDescriptor` being asynchronous and updating the marker set state post-disposal. Ensuring the widget's status or using a persistent provider could resolve this.

**Addressing state management**

The code error might be due to updating a disposed Hook state variable asynchronously. Setting a `_disposed` flag or using `useEffect` to cancel updates can resolve this.

**Ensuring safe updates**

To avoid updating a disposed widget, wrapping asynchronous calls with `tryCatch` or validating the widget's status with `if (!mounted)` is essential before invoking `setState`.

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2025/02/01 14:53:03*

„Åì„ÅÆ„Ç®„É©„Éº

```
FlutterError (A ValueNotifier<Set<Marker>> was used after being disposed.
Once you have called dispose() on a ValueNotifier<Set<Marker>>, it can no longer be used.)
```

„ÅØ„ÄÅ**ÁîªÈù¢„ÅåDispose**(Á†¥Ê£Ñ)„Åï„Çå„ÅüÂæå„ÇÇ `markersState` („ÇÑ„Åù„ÅÆ‰ªñ„ÅÆ Hook „ÅÆ State) „ÇíÊõ¥Êñ∞„Åó„Çà„ÅÜ„Å®„Åó„Å¶„Åó„Åæ„ÅÜ„Åì„Å®„ÅßËµ∑„Åì„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ  
„Åü„Å®„Åà„Å∞‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™„Éï„É≠„Éº„ÅåÂÖ∏ÂûãÁöÑ„Å™ÂéüÂõ†„Å´„Å™„Çä„Åæ„Åô„ÄÇ

1. ÁîªÈù¢ (`MapPage`) „ÅßÈùûÂêåÊúüÂá¶ÁêÜ„ÇíËµ∞„Çâ„Åõ„Å¶„ÄÅ„Éû„Éº„Ç´„Éº„ÇíËøΩÂä†„ÉªÂâäÈô§„Åô„Çã„Çà„ÅÜ„Å™„Ç≥„Éº„Éâ„ÇíÂÆüË°å„Åô„Çã  
2. „Åù„ÅÆÊúÄ‰∏≠„Å´ `context.go(...)` „Å™„Å©„ÅßÂà•ÁîªÈù¢„Å∏ÈÅ∑Áßª„Åó„Å¶ `MapPage` „Åå dispose „Åï„Çå„Çã  
3. ÈùûÂêåÊúüÂá¶ÁêÜ„ÅåÂÆå‰∫Ü„Åó„Åü„Çø„Ç§„Éü„É≥„Ç∞„Åß `markersState.value = ...` „ÇíÂëº„Å≥Âá∫„Åô  
4. „Åó„Åã„Åó„Åô„Åß„Å´ `MapPage` „ÅØÁ†¥Ê£Ñ„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ„ÄåÁ†¥Ê£ÑÂæå„Å´Â§âÊõ¥„Åó„Çà„ÅÜ„Å®„Åó„Åü„Äç„Å®„ÅÑ„ÅÜ„Ç®„É©„Éº„ÅåÁô∫Áîü

## Ëß£Ê±∫Á≠ñ

### 1. `useIsMounted` „ÅßÁîªÈù¢„ÅåÁ†¥Ê£Ñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã

`flutter_hooks` „ÅÆ `useIsMounted` „Éï„ÉÉ„ÇØ„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„ÄÅ

- „Äå„Åì„ÅÆ„Ç¶„Ç£„Ç∏„Çß„ÉÉ„Éà„Åå„Åæ„Å†ÁîªÈù¢„Å´Â≠òÂú®„Åó„Å¶„ÅÑ„Çã„Åã (mounted Áä∂ÊÖã„Åã)„Äç„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã
- Á†¥Ê£Ñ„Åï„Çå„Åü„ÅÇ„Å®„ÅÆ State Êõ¥Êñ∞„Çí„Çπ„Ç≠„ÉÉ„Éó„Åô„Çã

„Å®„ÅÑ„ÅÜÊñπÊ≥ï„ÅåÁ∞°Âçò„Å´ÂÆüË£Ö„Åß„Åç„Åæ„Åô„ÄÇ

‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„ÄÅ„Åæ„Åö `build` „É°„ÇΩ„ÉÉ„ÉâÂÜÖ„Å™„Å©„Åß

```dart
final isMounted = useIsMounted();
```

„ÇíÁî®ÊÑè„Åó„Å¶„Åä„Åç„Åæ„Åô„ÄÇ„Åù„Åó„Å¶„ÄÅ

```dart
Future<void> refreshAllMarkers(...) async {
  // ...‰∏≠Áï•...

  // buildSpotMarker / buildItemBoxMarker ÂÜÖ„Åß
  // „Ç¢„Ç§„Ç≥„É≥ÁîüÊàê ‚Üí markersState „ÇíÊõ¥Êñ∞„Åó„Å¶„ÅÑ„ÅèÂá¶ÁêÜ„ÅÆ„ÅÇ„Å®
  // „ÅÇ„Çã„ÅÑ„ÅØÊõ¥Êñ∞Áõ¥Ââç„Å´

  if (!isMounted()) {
    // ÁîªÈù¢„Åå„Åô„Åß„Å´Á†¥Ê£Ñ„Åï„Çå„Å¶„ÅÑ„Çã„Å™„ÇâÊõ¥Êñ∞„ÅØ„ÇÑ„ÇÅ„Çã
    return;
  }
  // ÂïèÈ°å„Å™„ÅÑ„Å™„ÇâÁ∂öË°å
  markersState.value = {...currentMarkers};

  // ...‰∏≠Áï•...
}
```

„Å®„ÅÑ„Å£„ÅüÂΩ¢„Åß„ÄÅ**State Êõ¥Êñ∞Ââç„Å´** „Äå„Åæ„Å†ÁîªÈù¢„Åå mounted „Åï„Çå„Å¶„ÅÑ„Çã„Åã (`isMounted() == true`)„Äç„ÇíÂøÖ„Åö„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Å¶„Åä„Åè„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ

### 2. `context.mounted` / `ref.mounted` „Åß„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã

Riverpod „ÅÆ `WidgetRef` „Å´„ÅØ `ref.mounted` „Åå„ÄÅ  
Flutter „ÅÆ `BuildContext` „Å´„ÅØ `context.mounted` (Flutter 3.7 ‰ª•Èôç) „ÅåÁî®ÊÑè„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ

Hook „Çí‰Ωø„Çè„Å™„ÅÑÂ†¥Âêà„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„ÄÅ

```dart
if (!context.mounted) return;
```

„Åß„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã„ÅÆ„ÅåÂÖ¨ÂºèÊé®Â•®„Åß„Åô„Åå„ÄÅ**Hook „ÇíÁî®„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ** `useIsMounted` „Çí‰Ωø„ÅÜ„Åª„ÅÜ„ÅåÊâãËªΩ„Åß„Åô„ÄÇ  
(`context.mounted` „ÇÑ `ref.mounted` „ÇíÂêåÊßò„ÅÆ„Çø„Ç§„Éü„É≥„Ç∞„Åß„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Å¶„ÇÇËß£Ê±∫„ÅØÂèØËÉΩ)

### 3. ÈùûÂêåÊúüÈñ¢Êï∞„ÅÆÈÄî‰∏≠„Åß `dispose` Âæå„Å´Âëº„Å≥Âá∫„Åï„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã

Âü∫Êú¨ÁöÑ„Å´„ÅØ‰∏äË®ò„ÅÆ„Äå„Éû„Ç¶„É≥„ÉàÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã„Äç„ÅåÊúÄ„ÇÇÁ∞°Âçò„ÅßÁ¢∫ÂÆü„Åß„Åô„Åå„ÄÅ

- „Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„Çí„Ç≠„É£„É≥„Çª„É´„Åß„Åç„Çã‰ªïÁµÑ„Åø„ÇíÁµÑ„ÅøËæº„ÇÄ
- `Future` „ÅÆÂÆå‰∫Ü„ÇíÂæÖ„Åü„Åö„Å´„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥„ÅåË°å„Çè„Çå„ÅüÈöõ„Å´„ÄÅÂæåÁ∂ö„ÅÆÂá¶ÁêÜ„Çí cancel „Åô„Çã

„Å™„Å©„ÅÆÊâãÊÆµ„Çí‰Ωø„ÅÜ„ÅÆ„ÇÇÊâã„Åß„Åô„ÄÇ  
„Åü„Å†„Åó„ÄÅ„Åù„ÅÆÂ†¥Âêà„Åß„ÇÇ**„Äådispose Âæå„Å´ marker „ÅÆ State „ÇíÊõ¥Êñ∞„Åó„Å™„ÅÑ„Äç**„Å®„ÅÑ„ÅÜÂØæÁ≠ñ„ÅØÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„ÄÇ

---

## „Åæ„Å®„ÇÅ

- ÁîªÈù¢„Åã„ÇâÈõ¢ËÑ±„Åó„Åü„ÅÇ„Å®ÔºàWidget „Åå dispose „Åï„Çå„Åü„ÅÇ„Å®Ôºâ„Å´ `markersState` „ÅÆÊõ¥Êñ∞„ÅåËµ∞„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã  
- `useIsMounted()` / `context.mounted` / `ref.mounted` „Å™„Å©„ÇíÊ¥ªÁî®„Åó„ÄÅ**„ÄåÁ†¥Ê£Ñ„Åï„Çå„Åü„ÇâÊõ¥Êñ∞„Åó„Å™„ÅÑ„Äç**„ÇíÂæπÂ∫ï„Åô„Çã  
- ÈùûÂêåÊúüÂá¶ÁêÜ„ÅåË§áÊï∞„Çπ„ÉÜ„ÉÉ„Éó„Å´ÂàÜ„Åã„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åù„ÅÆÈñì„Å´„ÇÇ„Éû„Ç¶„É≥„ÉàÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã

„Åì„Çå„Çâ„ÇíÂÆà„Çå„Å∞„ÄÅ`ValueNotifier` „Åå dispose Âæå„Å´Êõ¥Êñ∞„Åï„Çå„Å¶„Åó„Åæ„ÅÜÂïèÈ°å„ÇíÂõûÈÅø„Åß„Åç„Åæ„Åô„ÄÇ

---
