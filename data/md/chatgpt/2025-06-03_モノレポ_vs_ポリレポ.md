# モノレポ vs ポリレポ

日付: 2025-06-03

---

## 👤 ユーザー
*2025/6/3 16:11:27*

今の世の中的にモノレポで開発した方がいいのか？またはサーバーとクライアントサイドはリポジトリごと分けるべきなのかその辺を教えて欲しい

---

## 🤖 アシスタント
*2025/6/3 16:11:49*

### 結論を先に  
- \*\*TypeScript で型を共有したい／変更を 1 コミットに閉じ込めたいならモノレポが圧倒的に楽\*\*。  
- \*\*サービスごとに独立したリリースサイクルや権限管理が欲しいなら分割レポ (poly-repo) の方が運用コストが低い\*\*。  
- どちらも万能ではないので、\*\*「最小限のモノレポ + 周辺サービスは別レポ」というハイブリッド\*\*を取るチームも増えている。  

---

## モノレポが選ばれる理由  

| 典型的メリット | ユースケース例 |
| --- | --- |
| \*\*型／UI コンポーネント／ユーティリティの即時共有\*\* | サーバーで定義した DTO をフロント・モバイルでそのまま import (tRPC, Zod など) citeturn0search8 |
| \*\*原子性のあるリファクタリング\*\* | DB スキーマ変更と全フロント修正を 1 PR で完了 |
| \*\*単一 CI パイプラインで全体品質を担保\*\* | E2E テストを 1 回回せば全プロジェクトに効く |
| \*\*ツールチェーンの成熟\*\* | 2025 年は Nx/Turborepo + pnpm が主流 citeturn0search6turn2search4 |

&gt; 2024 State of JS では回答者の \*\*24 %\*\* がモノレポツールを利用しており、前年比で伸び続けています。pnpm ワークスペースが最も採用率が高いとのこと。 citeturn2search4  

### つまずきポイント
- リポジトリサイズ肥大で `git clone` が重い  
- CI/CD の分岐設定が複雑化  
- ライブラリ間の依存地獄 (全体ビルドでしか壊れに気付けない) citeturn0search5  

これらは \*\*Nx/Turborepo の “affected” ビルド\*\* や \*\*remote cache\*\* を入れるとかなり緩和できます。  

---

## 分割レポ (poly-repo) が向く場面  

| 適している状況 | 理由 |
| --- | --- |
| \*\*マイクロサービスが言語混在\*\* (Go, Rust, Node…) | モノレポではビルドツール/リンター設定が発散しやすい |
| \*\*チームが縦割り (フロント VS サーバー)\*\* | レビューやリリース権限を分けたい |
| \*\*OSS とクローズドを分けたい\*\* | 例: クライアント SDK だけ OSS 公開 |
| \*\*サービスごと完全に独立デリバリー\*\* | サーバーだけ毎日デプロイ、アプリは月 1 など |

Stack Exchange では「\*\*後からマージは簡単だが、分割は地獄\*\*」なので迷うならまず分けろ、という声も根強いです。 citeturn1search4  

---

## サーバー / クライアントをどう配置するか – 判断フレーム

| チェック項目 | YES → モノレポ寄り | NO → 分割寄り |
| --- | --- | --- |
| DTO/型定義を 1 箇所に置きたいか | ✔ | |
| リリースは常にセットで行うか | ✔ | |
| 同じ CI で統合テストを走らせたいか | ✔ | |
| 将来、別言語サービスを増やすか | | ✔ |
| 特定レイヤーだけ OSS にしたいか | | ✔ |
| チーム・部署をまたいで権限を分けるか | | ✔ |

---

## Mansoor さんの現状への具体アドバイス  

1. \*\*今の pnpm モノレポを保ちつつ、Nx か Turborepo を導入\*\*  
   - `pnpm dlx @nx/workspace init` で既存ワークスペースをそのまま Nx 管理に移行可。  
   - `nx affected --target=build` を GitHub Actions で使えば “変更があるパッケージだけビルド・テスト” できます。  

2. \*\*パッケージ単位のバージョン管理\*\*  
   - `changesets` + `release-it` を組み合わせると \*\*個別 SemVer\*\* がモノレポ内でも自動化でき、GitHub Releases と `CHANGELOG.md` を同時生成可。  

3. \*\*モバイル (React Native) が入るタイミングで再検討\*\*  
   - iOS/Android のネイティブコードが増えて Git 履歴が重くなりそうなら、`mobile/` だけサブモジュール or 別レポに切り出す \*\*“core モノレポ + 衛星レポ”\*\* パターンを採る企業が多い。 citeturn0search7  

4. \*\*分割へ舵を切る場合の注意\*\*  
   - API 契約は \*\*OpenAPI → GitHub Package Registry\*\* に置き、クライアント側は生成物を npm install。  
   - リリース連携は \*\*GitHub Actions + repository\_dispatch\*\* で “サーバーが main にマージされたらクライアント側レポで API SDK を自動更新 PR” を送ると同期ミスを最小化できる。  

---

## まとめ  

- \*\*型共有と一括変更コスト削減\*\*を最優先するならモノレポが依然有力。  
- \*\*権限・言語・リリースの独立性\*\*を優先するなら分割レポ。  
- 道半ばでのリポジトリ分割は痛みが大きいので、\*\*将来像から逆算\*\*して選ぶのが吉。  

この判断基準をチームで擦り合わせ、まずは \*\*小さく PoC\*\* を走らせて CI 速度・開発体験を計測してみると失敗コストを抑えられます。

---

## 👤 ユーザー
*2025/6/3 16:29:35*

以下について、パッケージ単位のバージョン管理はするときもあるが基本的に社内開発の場合は全部同じバージョンで揃えることが多かったりする気もするが、どうなのだろうか？


パッケージ単位のバージョン管理
	•	changesets + release-it を組み合わせると 個別 SemVer がモノレポ内でも自動化でき、GitHub Releases と CHANGELOG.md を同時生成可。

---

## 🤖 アシスタント
*2025/6/3 16:30:43*

### 「全部同じバージョン」か「パッケージごとにバージョン」か—2 つの流派

| 戦略 | 典型的に選ばれる現場 | 主なメリット | 主なデメリット |
|---|---|---|---|
| **Fixed / Locked-step**<br>（リポジトリ全パッケージが常に同じ `1.4.0` など） | *社内向け SDK 群*・*フルスタック製品を丸ごと deploy* | - 依存解決が単純（`workspace:*` で OK）<br>- 変更範囲が = リポジトリ履歴の 1 コミットなので **追跡が楽**<br>- リリース教育コストが低く「とりあえず `pnpm publish --filter …` で全部出す」 | - 1 ファイル修正でも全パッケージを再発行 ⇒ **ノイズ多め**<br>- 外部 OSS として公開すると「更新してないのに version が跳ねる」不満が出る |
| **Independent / Per-package SemVer** | *OSS ライブラリ*・*他リポから npm install される共有モジュール* | - 触ったパッケージ **だけ** が番号アップ ⇒ 更新ノイズ最小化<br>- 外部利用者に “正しい SemVer シグナル” を出せる | - 依存リンクの追従が面倒（peer/dep の version range 設計必須）<br>- CI で「どのパッケージが変わったか」を判定してテスト／リリースを分岐させる仕組みが要る |

> **現実**: 社内モノレポの場合は ①で始め、OSS 化や他リポ参照が増えた一部パッケージだけ②へ移行する **ハイブリッド** が増えています。Changesets の *fixed/linked packages* や Lerna の *mixed* モードがまさにその用途です。 citeturn0search4turn6search1turn6search0

---

## 典型シナリオで比較

### 1. 完全社内開発 (API + Web + CLI 工具が同リポ)
- **固定版が楽**  
  - 社内開発で *npm link / workspace:* のみ利用 → 依存関係は常に最新 HEAD。  
  - DevOps 側も `nx affected` や `turborepo remote-cache` で **変更がある部分だけ** ビルドさえすれば、全パッケージ同時公開でもビルド時間は肥大しない。  
- **ツール設定**  
  - `changeset config: { fixed: [['*']] }` で一発。  
  - `release-it --plugins.@release-it/workspaces.strategy=all` で root version を1つだけ持たせる方法も。  

### 2. 一部 OSS やモバイルアプリから SDK をインストール
- **個別 SemVer が必要**  
  - 外部利用者が「破壊的変更だけ Major Bump」を期待。  
  - `changesets` デフォルト (independent) or Lerna *independent* モードを使い、`changeset` ファイルでパッケージ単位 bump を宣言。  
  - 依存パッケージの自動追従は `changesets version` が面倒を吸収してくれる citeturn6search3。  

### 3. ハイブリッド (Core は固定、プラグインだけ独立)
```yaml
# .changeset/config.json 抜粋
{
  "fixed": [["packages/core-*"]],      // core-* は1つのバージョングループ
  "linked": [["packages/plugin-*"]],   // plugin-* は緩く同一バージョンを保つ
  "ignore": ["apps/**"]                // 配布しないアプリは無視
}
```
- Core を更新すると **core-** 全部が 2.1.0 → 2.2.0 へ揃う。  
- プラグインは触ったものだけ (例: 1.3.1 → 1.4.0)。  

---

## 社内で「全部同じ」にする際の落とし穴と回避策

| 課題 | 回避策 |
|---|---|
| **npm registry に “更新してない package” が大量に押し上げられ 500 MB 超** | Private registry を使う or `publishConfig.access: "restricted"` で外部漏出を防ぐ |
| **GitHub Releases のリリースノートが冗長** | `changeset —output REPO.md` で monorepo 全体 changelog を 1 ファイルにまとめる (Fixed Group + Single Changelog) citeturn6search0 |
| **「どこが変わった？」が分かりづらい** | Conventional Commits + Changesets の “summary” 行強制 → 1 package 1 見出しを書かせる |

---

## Mansoor さんへの実装ヒント

1. **今の “全部同じ version” を Changesets で再現する**  
   ```bash
   pnpm dlx changeset init              # 初期化
   # config.json
   {
     "fixed": [["*"]],
     "changelog": ["@changesets/changelog-github", { "repo": "your-org/your-repo" }]
   }
   ```
   - これで `changeset version && changeset publish` すると **全パッケージが同じ番号で更新**。  

2. **将来プラグインを切り離したい時は `fixed` を細分化**  
   - `"fixed": [["packages/core-*"]]` へ変更し、プラグインはデフォルト independent に。  

3. **release-it と組み合わせるなら**  
   ```jsonc
   // .release-it.json
   {
     "plugins": {
       "@release-it/workspaces": {
         "npm": {
           "workspaceStrategy": "all"   // root version を一括反映
         }
       }
     }
   }
   ```
   - `changeset tag` で root に Git タグを切り、release-it が CHANGELOG + GitHub Release を生成。  

---

### まとめ

- **社内専用 & 同時デプロイ** → “全部同じバージョン” で十分。  
- **外部公開 or 他リポから依存される** → 個別 SemVer。  
- **両方欲しい** → Changesets/Lerna の *fixed*・*linked* を組み合わせた **ハイブリッド** が今の定番。  

まずは *fixed ＝ \["*"\]* で運用を始め、必要が生じた時だけグループを分割するのが最小コストで移行しやすい道です。

---

## 👤 ユーザー
*2025/6/3 16:33:44*

また、CHANGELOGについて、 GitHub ReleaseではGitHubのgenerate release note ではPRにフィルタリング単位のリリースノートが作成されるが、そのような機能はchangeset にあるか？

---

## 🤖 アシスタント
*2025/6/3 16:34:20*

### 結論だけ先に
- **Changesets には GitHub Release の “Generate release notes” と同じ “ラベルで自動カテゴライズ” 機能は標準では付いていない**。  
- しかし  
  1. `@changesets/changelog-github` が PR 番号・作者・コミットを自動で埋め込み、  
  2. `changelog` オプションに **独自 JS スクリプト** を指定すれば、ラベル別のセクション分けも実装できる。  
- 「PR のラベルをそのままカテゴリ見出しにしたい」場合は  
  - **GitHub Release の自動生成機能 (.github/release.yml) を使う**か、  
  - **release-it ＋ GitHub API を叩くプラグイン**（例: `release-it-github-actions-changelog`）を併用する方が早い。  

---

## 仕組みの違いを整理

| | GitHub Release “Generate release notes” | Changesets |
|---|---|---|
| 変更の情報源 | **タグ間の PR 差分** を GitHub がスキャン | **`*.changeset/*.md` ファイル**（開発者が PR に追加） |
| カテゴリ分け | `.github/release.yml` で **ラベル→見出し** をマッピング可 citeturn2search5 | デフォルトはなし。<br>JS で `changelog` を差し替えて実装 citeturn0search2turn4search7 |
| 自動で埋まるメタ情報 | PR タイトル・番号・作者・リンク | PR/コミット番号・作者（`@changesets/changelog-github` 利用時） |
| 生成場所 | GitHub Release 画面 or `gh release create` | 各パッケージの `CHANGELOG.md`（単一化も可） |
| 必要な設定 | `.github/release.yml` だけ | `changeset init`  + (任意) `config.json` の `changelog` |

---

## Changesets で “ラベル別セクション” を作る方法

1. **GitHub 情報を注入する**  
   ```jsonc
   // .changeset/config.json
   {
     "changelog": ["@changesets/changelog-github", { "repo": "your-org/your-repo" }]
   }
   ```
   これで各行に `(PR #123)` やリンクが付きます。citeturn4search7

2. **ラベルでグループ化したい場合**  
   `changelog` に JS モジュールのパスを渡せば、自由に Markdown を吐けます。
   ```js
   // scripts/categorized-changelog.js
   const { Octokit } = require("@octokit/rest");

   module.exports = async (changeset, versionType, { repo }) => {
     const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
     const pr = await octokit.pulls.get({ ...repo, pull_number: changeset.pull });
     const labels = pr.data.labels.map(l => l.name);

     const title = labels.includes("breaking-change")
       ? "### 💥 Breaking Changes"
       : labels.includes("feature")
       ? "### ✨ Features"
       : "### 🐛 Fixes";

     return `${title}\n- ${changeset.summary} ([#${pr.data.number}](${pr.data.html_url}))`;
   };
   ```
   - `config.json` 側:  
     ```json
     "changelog": ["./scripts/categorized-changelog.js", { "repo": { "owner": "your-org", "repo": "your-repo" } }]
     ```
   - CI で `GITHUB_TOKEN` を渡せば OK。  
   これで **PR ラベル → CHANGELOG セクション** が完成します。

---

## 代替アプローチ

| ツール | 向き・特徴 |
|---|---|
| **release-it** + `@release-it/workspaces` | 生成済み `CHANGELOG.md` を差分抽出して GitHub Release の body に貼り付け。ラベル分類は GitHub 側に委ねても良い。 |
| **release-please** | Conventional Commits 解析で PR ラベル不要。Google 製・自動 PR 作成までフルセット。 |
| **semantic-release** | コミットメッセージ駆動で全自動。PR ベースでなくても OK。 |

---

## どれを採るべきか？

| 目的 | おすすめ |
|---|---|
| **“PR ラベルでカテゴリ分け” をそのまま Release に出したい** | GitHub Release 自動生成を使うのが最短。`changesets` は version/bump だけに専念し、Release 用 markdown は GitHub に任せる。 |
| **社内向け → CHANGELOG.md が第一級** | Changesets 標準 (`@changesets/changelog-github`) で十分。ラベル分類が欲しければカスタム JS を足す。 |
| **OSS で外部利用者が多い** | Conventional Commits 文化があるなら `release-please` or `semantic-release` の方が “読む側が慣れている” ことが多い。 |

---

### まとめ
- **Changesets そのものは「ラベル→カテゴリ」機能を持たない**が、プラグイン or 自作スクリプトで拡張できる。  
- クリックひとつで済む GitHub Release の自動生成に満足しているなら、バージョン管理は Changesets、リリースノートは GitHub 側と **役割分担** するのがシンプル。  
- ラベル分類まで完全自動にしたいなら、上記カスタムスクリプトか、最初から release-please／semantic-release を検討すると手間が減ります。

---
