# ボタン作成アプローチ: モディファイア vs struct

日付: 2023-05-24

---

## 👤 ユーザー
*2023/05/24 19:17:48*

SwiffUIでボタンを作成しようとしています。
ボタンの種類は3パターンです。

モディファイアで修飾するパターンと、structを定義するパターンの両方のアプローチがあるかと思いますが、どちらがいいと思いますか？

---

## 🤖 アシスタント
*2023/05/24 19:18:50*

SwiftUIではボタンの作成に関して、モディファイアを使用する方法と新たにstructを定義する方法の2つが主なアプローチです。どちらが「良い」かは使用するコンテキストと具体的な要件によります。

**1. モディファイアを使用する方法:**

この方法では、基本的なボタンに対してモディファイアを使用して視覚的な変更を加えます。これは比較的簡単で、シンプルなボタンに対する改変に適しています。ただし、複数のビューにわたって同じスタイルのボタンを使いたい場合、モディファイアを何度も書く必要があり、コードが冗長になる可能性があります。

```swift
Button(action: {
    print("Button tapped!")
}) {
    Text("Tap me!")
}
.background(Color.blue)
.foregroundColor(.white)
.cornerRadius(10)
.padding()
```

**2. 新たにstructを定義する方法:**

この方法では、新たにボタン用のstructを定義します。このstruct内部でボタンの視覚的なスタイルと振る舞いを定義します。そして、アプリケーションのどこからでもこのカスタムボタンを使うことができます。複雑なボタンスタイルや複数のビューにわたって同じスタイルのボタンを使う場合に適しています。

```swift
struct CustomButton: View {
    let action: () -> Void
    let label: String

    var body: some View {
        Button(action: action) {
            Text(label)
        }
        .background(Color.blue)
        .foregroundColor(.white)
        .cornerRadius(10)
        .padding()
    }
}
```

これにより、以下のように簡単にカスタムボタンを使用できます。

```swift
CustomButton(action: {
    print("Custom button tapped!")
}, label: "Tap me!")
```

コードの再利用性や維持可能性を考えると、特に複数のビューで同じスタイルのボタンを使用する場合はカスタムボタンを定義する方が良いでしょう。それに対して、一度だけ使う単純なボタンであればモディファイアを使用する方が手っ取り早いです。ただし、これは一般的なガイドラインであり、プロジェクトの具体的な要件によって適切な選択は変わるかもしれません。

---

## 👤 ユーザー
*2023/05/24 19:19:28*

例えば、Viewにexteisonを生やして、以下のコードはまとめることもできると思うけど、それはだめなの？

```swift
.background(Color.blue)
        .foregroundColor(.white)
        .cornerRadius(10)
        .padding()
```

---

## 🤖 アシスタント
*2023/05/24 19:20:06*

SwiftUIのViewに対する拡張(extension)を使用して、特定のスタイルをまとめるという方法は確かに可能です。そのアプローチを採用すると、複数のビューで共有するスタイルを再利用でき、コードの冗長性を減らすことができます。

以下は、ボタンスタイルをまとめるView拡張の例です：

```swift
extension View {
    func blueButtonStyle() -> some View {
        self
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(10)
            .padding()
    }
}
```

これにより、任意のViewに対して`.blueButtonStyle()`を呼び出すことで、上記のスタイルを適用できます：

```swift
Button(action: {
    print("Button tapped!")
}) {
    Text("Tap me!")
}
.blueButtonStyle()
```

ただし、このアプローチはあくまでビュースタイルの再利用を目的としたもので、ボタンの動作やその他の特性は含まれません。このため、動作を含むカスタムボタンを定義する場合には、カスタムView（struct）を作成する方が便利です。また、このアプローチを用いる際は、他のViewに対しても`.blueButtonStyle()`が使用可能となることを理解しておくべきです。これが望ましくない場合には、カスタムボタンのstructを作成する方が適しているかもしれません。

---

## 👤 ユーザー
*2023/05/24 19:20:44*

モディファイアを拡張しても同じようなことはできるよね。それはどういうときに使うのが適しているの？

---

## 🤖 アシスタント
*2023/05/24 19:21:32*

確かに、SwiftUIのモディファイアも拡張(extension)することができます。これは特定のスタイルを一連のモディファイアとしてカプセル化し、再利用するときに便利です。

例えば、次のような拡張を作成できます：

```swift
extension ButtonStyle where Self == MyButtonStyle {
    static var myStyle: MyButtonStyle { MyButtonStyle() }
}

struct MyButtonStyle: ButtonStyle {
    func makeBody(configuration: Self.Configuration) -> some View {
        configuration.label
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(10)
            .padding()
    }
}
```

そして、それを次のように使用できます：

```swift
Button(action: {
    print("Button tapped!")
}) {
    Text("Tap me!")
}
.buttonStyle(.myStyle)
```

このアプローチは、以下のような場合に特に便利です：

1. ある特定のスタイルを持つボタンを複数の場所で再利用したいとき。例えば、全ての画面に同じデザインのボタンを用いるなどです。
2. ボタンだけでなく、他の種類のView（例えばテキストフィールド）でも同じスタイルを適用したいとき。

ただし、この拡張は`ButtonStyle`プロトコルに基づいていますので、これを使用するとボタンに対してのみスタイルを適用できます。この拡張を他のView（例えばText）に適用することはできません。それらのViewにスタイルを適用するためには、別の方法を探す必要があります。

結局のところ、どのアプローチを選択するかはあなたの具体的なニーズによります。どのスタイルをどのViewに適用するのか、そのスタイルをどれだけ再利用するのか、といった事情を考慮して選択してください。

---

## 👤 ユーザー
*2023/05/24 21:38:24*

ViewModifier を継承するパターンでかいてほしかｔｒた

---

## 🤖 アシスタント
*2023/05/24 21:39:12*

`ViewModifier`を使って特定のスタイルをまとめるという方法もあります。これを使用すると、特定のビジュアルスタイルをカプセル化し、様々なViewで繰り返し使用することができます。

以下に`ViewModifier`を使ったスタイルの例を示します：

```swift
struct BlueButtonStyle: ViewModifier {
    func body(content: Content) -> some View {
        content
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(10)
            .padding()
    }
}
```

そして、新たに定義した`BlueButtonStyle`を使って以下のようにボタンにスタイルを適用できます：

```swift
Button(action: {
    print("Button tapped!")
}) {
    Text("Tap me!")
}
.modifier(BlueButtonStyle())
```

また、次のように拡張(extension)を作成して、Viewに対する呼び出しをより直感的にすることも可能です：

```swift
extension View {
    func blueButtonStyle() -> some View {
        self.modifier(BlueButtonStyle())
    }
}
```

これにより、以下のように簡単にスタイルを適用できます：

```swift
Button(action: {
    print("Button tapped!")
}) {
    Text("Tap me!")
}
.blueButtonStyle()
```

この`ViewModifier`アプローチは、一連のスタイルを一つの`ViewModifier`としてまとめるときに特に役立ちます。それにより、そのスタイルをアプリ内の様々な場所で繰り返し使用することが可能になります。また、このアプローチは任意のViewに対して適用可能であるという大きな利点があります。

---

## 👤 ユーザー
*2023/05/24 21:45:36*

以下をViewModifierアプローチで書いて欲しい

(1) enum で以下の4つのボタンタイプを定義してほしい

primary, secondary, tertiary, text

(2) ボーダーについて
secondary は赤色のボーダーあり
primary, tertiary, text はボーダーなし

(3)ボタンの色について
primary は青色塗りつぶしの文字は白色
secondary, tertiary, text は文字は黄色

(4) それぞれ非活性状態 disabled のときには以下の挙動になる
primary は灰色塗りつぶしの文字は白色
secondary, tertiary, text は文字は水色

(5) タップされたりフォーカスされている時は色が薄くなる

---

## 🤖 アシスタント
*2023/05/24 21:46:38*

以下のように`enum`と`ViewModifier`を使用して各ボタンのスタイルを定義することができます。各ボタンのスタイルはボタンタイプに応じて定義されます。

```swift
enum ButtonType {
    case primary, secondary, tertiary, text
}

struct CustomButtonModifier: ViewModifier {
    var type: ButtonType
    @Environment(\.isEnabled) var isEnabled: Bool

    func body(content: Content) -> some View {
        content
            .foregroundColor(foregroundColor)
            .background(backgroundColor)
            .border(borderColor, width: type == .secondary ? 2 : 0)
            .opacity(isEnabled ? 1.0 : 0.5)
    }

    private var foregroundColor: Color {
        if !isEnabled {
            return .cyan
        }
        
        switch type {
        case .primary:
            return .white
        case .secondary, .tertiary, .text:
            return .yellow
        }
    }

    private var backgroundColor: Color {
        if !isEnabled && type == .primary {
            return .gray
        }
        
        switch type {
        case .primary:
            return .blue
        case .secondary, .tertiary, .text:
            return .clear
        }
    }

    private var borderColor: Color {
        switch type {
        case .secondary:
            return .red
        default:
            return .clear
        }
    }
}

extension View {
    func buttonStyle(_ type: ButtonType) -> some View {
        self.modifier(CustomButtonModifier(type: type))
    }
}
```

ここで定義した`buttonStyle`メソッドを使って、以下のようにボタンを作成できます：

```swift
Button(action: {
    print("Button tapped!")
}) {
    Text("Primary Button")
}.buttonStyle(.primary)

Button(action: {
    print("Button tapped!")
}) {
    Text("Secondary Button")
}.buttonStyle(.secondary)

// And so on for tertiary and text...
```

このコードでは、ボタンが押された時に色が薄くなる効果を作るために、`opacity`メソッドを使用しています。また、`.isEnabled` 環境変数を使用して、ボタンの有効/無効状態に応じてスタイルを変更しています。

ボタンのタップ時やフォーカス時の具体的な挙動については、`.onTapGesture`や`.onHover`のようなメソッドを利用してカスタマイズすることが可能です。ただし、これらのメソッドはボタンの基本的な挙動（例えばタップ時のアクション）を上書きする可能性があるため、使用には注意が必要です。

---

## 👤 ユーザー
*2023/05/24 21:47:26*

@Environment(\.isEnabled) var isEnabled: Bool であっているんだっけ？

---

## 🤖 アシスタント
*2023/05/24 21:48:45*

大変申し訳ありませんが、現在の私の知識(2021年までの情報)では、SwiftUIは`isEnabled`をビルトインでサポートしていないようです。それは`Control`プロトコルの一部であり、`Button`などいくつかの具体的な型で利用可能ですが、環境変数としては利用できません。

代わりに、自分自身で`Button`の無効化とその見た目を管理する必要があります。以下に、無効化とボタンのスタイル変更を自分で管理する方法を示します。

```swift
enum ButtonType {
    case primary, secondary, tertiary, text
}

struct CustomButtonModifier: ViewModifier {
    var type: ButtonType
    var isEnabled: Bool

    func body(content: Content) -> some View {
        content
            .foregroundColor(foregroundColor)
            .background(backgroundColor)
            .border(borderColor, width: type == .secondary ? 2 : 0)
            .opacity(isEnabled ? 1.0 : 0.5)
    }

    private var foregroundColor: Color {
        if !isEnabled {
            return .cyan
        }
        
        switch type {
        case .primary:
            return .white
        case .secondary, .tertiary, .text:
            return .yellow
        }
    }

    private var backgroundColor: Color {
        if !isEnabled && type == .primary {
            return .gray
        }
        
        switch type {
        case .primary:
            return .blue
        case .secondary, .tertiary, .text:
            return .clear
        }
    }

    private var borderColor: Color {
        switch type {
        case .secondary:
            return .red
        default:
            return .clear
        }
    }
}

extension View {
    func buttonStyle(_ type: ButtonType, isEnabled: Bool) -> some View {
        self.modifier(CustomButtonModifier(type: type, isEnabled: isEnabled))
    }
}
```

そして以下のように使用できます：

```swift
@State private var isButtonEnabled = true

var body: some View {
    Button(action: {
        print("Button tapped!")
    }) {
        Text("Primary Button")
    }
    .buttonStyle(.primary, isEnabled: isButtonEnabled)
    .disabled(!isButtonEnabled)
}
```

ここでは`@State`プロパティ`isButtonEnabled`を使ってボタンの有効/無効状態を管理しています。そしてそれを`buttonStyle`と`disabled`メソッドの両方に渡しています。`disabled`メソッドはボタンのタップを無効化しますが、見た目には影響を及ぼしません。そのため、見た目の変化も自分で管理する必要があります。

なお、この情報は2021年9月時点のものであり、それ以降のSwiftUIのアップデートにより状況が変わっている可能性もあります。最新の公式ドキュメンテーションをご確認いただくことをお

---

## 👤 ユーザー
*2023/05/24 21:53:38*

SwiftUI って .disabled true にしたら見た目って変わらなかったっけ？

---

## 🤖 アシスタント
*2023/05/24 21:54:19*

はい、ご指摘の通りです。SwiftUIでは`.disabled(_:)`モディファイアを使うと、そのViewが自動的に無効化の見た目になります（デフォルトでは半透明になります）。これは`Button`にも適用され、通常はユーザー入力（タップなど）を無効化するとともに見た目も自動的に更新します。

したがって、ボタンが無効化された場合の特定のスタイルを適用したい場合でも、まずは`.disabled(_:)`を試してみて、それがあなたの要件を満たすかどうかを確認してみてください。

ただし、このモディファイアが適用する見た目の変化はカスタマイズすることができません。`.disabled(_:)`モディファイアが適用するデフォルトの無効化スタイル（半透明化など）が要件を満たさない場合、あるいはボタンが無効化されたときの特定のスタイルを適用したい場合は、自分でスタイルを管理する必要があります。

なお、この情報は2021年9月時点のものであり、それ以降のSwiftUIのアップデートにより状況が変わっている可能性もあります。最新の公式ドキュメンテーションをご確認いただくことをお勧めします。

---

## 👤 ユーザー
*2023/05/24 21:54:40*

自分で disabled 状態のときのボタンの色を決めたい場合はどうすればいいか？

---

## 🤖 アシスタント
*2023/05/24 21:55:50*

SwiftUIでは、`.disabled(_:)`モディファイアを使用すると、そのビューは自動的に無効化され、その見た目も変わります。ただし、このモディファイアが適用する見た目の変化は、一般的にはカスタマイズすることができません。

ですので、無効化した時の特定のスタイルを適用したい場合、自身でステートを管理して、そのステートに応じてビューのスタイルを変更することが必要になります。

以下に、ボタンの有効/無効状態を自身で管理し、その状態に応じてスタイルを変更する例を示します：

```swift
enum ButtonType {
    case primary, secondary, tertiary, text
}

struct CustomButtonStyle: ViewModifier {
    let type: ButtonType
    let isEnabled: Bool

    func body(content: Content) -> some View {
        content
            .foregroundColor(foregroundColor)
            .background(backgroundColor)
            .border(borderColor, width: type == .secondary ? 1 : 0)
            .opacity(isEnabled ? 1.0 : 0.6)
    }

    private var foregroundColor: Color {
        if !isEnabled {
            return .blue
        }

        switch type {
        case .primary:
            return .white
        case .secondary, .tertiary, .text:
            return .yellow
        }
    }

    private var backgroundColor: Color {
        if !isEnabled && type == .primary {
            return .gray
        }

        switch type {
        case .primary:
            return .blue
        case .secondary, .tertiary, .text:
            return .clear
        }
    }

    private var borderColor: Color {
        return type == .secondary ? .red : .clear
    }
}

extension View {
    func buttonStyle(_ type: ButtonType, isEnabled: Bool) -> some View {
        modifier(CustomButtonStyle(type: type, isEnabled: isEnabled))
    }
}
```

そして以下のように使用します：

```swift
@State private var isButtonEnabled = true

var body: some View {
    Button(action: {
        print("Button tapped!")
    }) {
        Text("Primary Button")
    }
    .buttonStyle(.primary, isEnabled: isButtonEnabled)
    .disabled(!isButtonEnabled)
}
```

このようにすると、ボタンの無効化時に特定のスタイルを適用することが可能になります。

---

## 👤 ユーザー
*2023/05/24 21:56:28*

このコード、実は ViewModifier を継承する必要はなかったりする？

---

## 🤖 アシスタント
*2023/05/24 21:57:26*

その通りです。SwiftUIでは、ビューに対する修飾子を作成するために`ViewModifier`プロトコルを継承することは必須ではありません。`extension View`を使用してビューの拡張を行うことも可能です。これは、特定のビューに対してカスタムの修飾子を作成し、それを使い回す場合に便利です。

以下にその例を示します：

```swift
enum ButtonType {
    case primary, secondary, tertiary, text
}

extension View {
    func customButtonStyle(_ type: ButtonType, isEnabled: Bool) -> some View {
        self
            .foregroundColor(foregroundColor(type: type, isEnabled: isEnabled))
            .background(backgroundColor(type: type, isEnabled: isEnabled))
            .border(borderColor(type: type), width: type == .secondary ? 1 : 0)
            .opacity(isEnabled ? 1.0 : 0.6)
    }

    private func foregroundColor(type: ButtonType, isEnabled: Bool) -> Color {
        if !isEnabled {
            return .blue
        }

        switch type {
        case .primary:
            return .white
        case .secondary, .tertiary, .text:
            return .yellow
        }
    }

    private func backgroundColor(type: ButtonType, isEnabled: Bool) -> Color {
        if !isEnabled && type == .primary {
            return .gray
        }

        switch type {
        case .primary:
            return .blue
        case .secondary, .tertiary, .text:
            return .clear
        }
    }

    private func borderColor(type: ButtonType) -> Color {
        return type == .secondary ? .red : .clear
    }
}
```

そして以下のように使用します：

```swift
@State private var isButtonEnabled = true

var body: some View {
    Button(action: {
        print("Button tapped!")
    }) {
        Text("Primary Button")
    }
    .customButtonStyle(.primary, isEnabled: isButtonEnabled)
    .disabled(!isButtonEnabled)
}
```

このようにすることで、`ViewModifier`プロトコルを継承せずにカスタムのビュー修飾子を作成することが可能です。

---

## 👤 ユーザー
*2023/05/24 22:35:42*

ButtonStyleConfiguration を使って書き換えて欲しい

---

## 🤖 アシスタント
*2023/05/24 22:36:35*

SwiftUIでは、`ButtonStyle`プロトコルを利用することで、ボタンのスタイル全体をカスタマイズすることが可能です。これには`ButtonStyleConfiguration`が使用されます。

以下に、`ButtonStyle`を使用して、ボタンのスタイルをカスタマイズする例を示します：

```swift
enum ButtonType {
    case primary, secondary, tertiary, text
}

struct CustomButtonStyle: ButtonStyle {
    var type: ButtonType
    var isEnabled: Bool

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .foregroundColor(foregroundColor)
            .background(backgroundColor)
            .border(borderColor, width: type == .secondary ? 1 : 0)
            .opacity(configuration.isPressed || !isEnabled ? 0.6 : 1.0)
    }

    private var foregroundColor: Color {
        if !isEnabled {
            return .blue
        }

        switch type {
        case .primary:
            return .white
        case .secondary, .tertiary, .text:
            return .yellow
        }
    }

    private var backgroundColor: Color {
        if !isEnabled && type == .primary {
            return .gray
        }

        switch type {
        case .primary:
            return .blue
        case .secondary, .tertiary, .text:
            return .clear
        }
    }

    private var borderColor: Color {
        return type == .secondary ? .red : .clear
    }
}
```

そして以下のように使用します：

```swift
@State private var isButtonEnabled = true

var body: some View {
    Button(action: {
        print("Button tapped!")
    }) {
        Text("Primary Button")
    }
    .buttonStyle(CustomButtonStyle(type: .primary, isEnabled: isButtonEnabled))
    .disabled(!isButtonEnabled)
}
```

この`ButtonStyle`は`isPressed`というプロパティを持つ`configuration`を提供します。これはボタンが現在押下されているかどうかを示します。また、自分で定義したisEnabledプロパティを使って、ボタンが無効化されている場合の見た目を制御します。

---

## 👤 ユーザー
*2023/05/24 23:20:28*

こんな感じで描こうとしていて、extension ButtonType でコンピューテッドプロパティーを生やしたい、全部、switch self {} で return するようにしてほしい。func makeBody(configuration: Configuration) -&gt; some View は private var type のコンピューテットプロパティの変数から値を使って欲しい。ボタンの状態はisEnabled = falseのときとconfiguration.isPressed = true のときとそれ以外に分かれて、優先順位は isEnabled = false のとき、configuration.isPressed = true のとき、それ以外の順序です。

```swift
public enum ButtonType: String, CaseIterable, Identifiable {
    case primary
    case secondary
    case tertiary
    case text
    
    public var id: String {
        rawValue
    }
}


extension ButtonType {
    var isRounded: Bool
    var foregroundColor: Color
    var pressedForegroundColor: Color
    var disabledForegroundColor: Color
    var backgroundColor: Color
    var pressedBackgroundColor: Color
    var disabledBackgroundColor: Color
    var cornerRadius: CGFloat
}

public struct CustomButtonStyle: ButtonStyle {
    // disabled かどうかを情報を取得する
    // Ref: https://stackoverflow.com/questions/59169436/swiftui-buttonstyle-how-to-check-if-button-is-disabled-or-enabled
    @Environment(\.isEnabled) private var isEnabled: Bool
    private var type: ButtonType
    
    init(_ type: ButtonType) {
        self.type = type
    }
    
    public func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(Font.body.weight(.medium))
            .foregroundColor(Color.white)
            .frame(height: 48)
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 30, style: .continuous)
                    .fill(Color.accentColor)
            )
    }
}
```

---

## 🤖 アシスタント
*2023/05/24 23:21:47*

ご要望に合わせて、各`ButtonType`のコンピューテッドプロパティを定義し、それを`CustomButtonStyle`内で利用するようにコードを更新しました：

```swift
public enum ButtonType: String, CaseIterable, Identifiable {
    case primary
    case secondary
    case tertiary
    case text
    
    public var id: String {
        rawValue
    }
}

extension ButtonType {
    var isRounded: Bool {
        switch self {
        case .secondary:
            return true
        default:
            return false
        }
    }
    
    var foregroundColor: Color {
        switch self {
        case .primary:
            return .white
        default:
            return .yellow
        }
    }

    var pressedForegroundColor: Color {
        return .yellow
    }
    
    var disabledForegroundColor: Color {
        return .blue
    }
    
    var backgroundColor: Color {
        switch self {
        case .primary:
            return .blue
        default:
            return .clear
        }
    }
    
    var pressedBackgroundColor: Color {
        return .blue
    }
    
    var disabledBackgroundColor: Color {
        switch self {
        case .primary:
            return .gray
        default:
            return .clear
        }
    }
    
    var cornerRadius: CGFloat {
        return self.isRounded ? 10.0 : 0.0
    }
}

public struct CustomButtonStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled: Bool
    private var type: ButtonType

    init(_ type: ButtonType) {
        self.type = type
    }

    public func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .foregroundColor(
                isEnabled
                    ? (configuration.isPressed ? type.pressedForegroundColor : type.foregroundColor)
                    : type.disabledForegroundColor
            )
            .background(
                isEnabled
                    ? (configuration.isPressed ? type.pressedBackgroundColor : type.backgroundColor)
                    : type.disabledBackgroundColor
            )
            .cornerRadius(type.cornerRadius)
            .opacity(isEnabled ? (configuration.isPressed ? 0.6 : 1.0) : 0.6)
    }
}
```

そして以下のように使用します：

```swift
@State private var isButtonEnabled = true

var body: some View {
    Button(action: {
        print("Button tapped!")
    }) {
        Text("Primary Button")
    }
    .buttonStyle(CustomButtonStyle(.primary))
    .disabled(!isButtonEnabled)
}
```

このコードでは、ボタンが押されたとき、無効化されているとき、およびそれ以外の状況での見た目がそれぞれ変わります。これは、各状態に応じて適切な色やその他のスタイル属性を選択することで実現しています。

---

## 👤 ユーザー
*2023/05/24 23:23:20*

状態が以下の三つなので、それをenumで定義したらいい感じにならないかな？

isDisabled
isPressed
`default`

---

## 🤖 アシスタント
*2023/05/24 23:24:56*

確かに、それぞれの状態をenumで定義することでコードの可読性を上げることができます。それぞれの状態に対して適切なスタイルを返す関数を設定することができます。以下にそのような実装を示します：

```swift
public enum ButtonType: String, CaseIterable, Identifiable {
    case primary
    case secondary
    case tertiary
    case text
    
    public var id: String {
        rawValue
    }
}

enum ButtonState {
    case disabled
    case pressed
    case `default`
}

extension ButtonType {
    var isRounded: Bool {
        switch self {
        case .secondary:
            return true
        default:
            return false
        }
    }
    
    func foregroundColor(for state: ButtonState) -> Color {
        switch state {
        case .disabled:
            return .blue
        case .pressed, .default:
            switch self {
            case .primary:
                return .white
            default:
                return .yellow
            }
        }
    }
    
    func backgroundColor(for state: ButtonState) -> Color {
        switch state {
        case .disabled:
            switch self {
            case .primary:
                return .gray
            default:
                return .clear
            }
        case .pressed, .default:
            switch self {
            case .primary:
                return .blue
            default:
                return .clear
            }
        }
    }
    
    var cornerRadius: CGFloat {
        return self.isRounded ? 10.0 : 0.0
    }
}

public struct CustomButtonStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled: Bool
    private var type: ButtonType

    init(_ type: ButtonType) {
        self.type = type
    }

    public func makeBody(configuration: Configuration) -> some View {
        let state: ButtonState = !isEnabled ? .disabled : (configuration.isPressed ? .pressed : .default)
        
        configuration.label
            .foregroundColor(type.foregroundColor(for: state))
            .background(type.backgroundColor(for: state))
            .cornerRadius(type.cornerRadius)
            .opacity(state == .pressed || state == .disabled ? 0.6 : 1.0)
    }
}
```

そして以下のように使用します：

```swift
@State private var isButtonEnabled = true

var body: some View {
    Button(action: {
        print("Button tapped!")
    }) {
        Text("Primary Button")
    }
    .buttonStyle(CustomButtonStyle(.primary))
    .disabled(!isButtonEnabled)
}
```

このコードでは、`ButtonState`というenumを作成し、ボタンの状態（無効化、押下、デフォルト）に応じて適切なスタイルを選択することができます。

---

## 👤 ユーザー
*2023/05/24 23:25:20*

let state: ButtonState = !isEnabled ? .disabled : (configuration.isPressed ? .pressed : .default) をワンライナーで書くのはやめてほしいな。

---

## 🤖 アシスタント
*2023/05/24 23:26:00*

分かりやすさを重視するために、一連のif文を使用してボタンの状態を判定するコードに書き換えてみます：

```swift
public struct CustomButtonStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled: Bool
    private var type: ButtonType

    init(_ type: ButtonType) {
        self.type = type
    }

    public func makeBody(configuration: Configuration) -> some View {
        let state: ButtonState
        if !isEnabled {
            state = .disabled
        } else if configuration.isPressed {
            state = .pressed
        } else {
            state = .default
        }
        
        configuration.label
            .foregroundColor(type.foregroundColor(for: state))
            .background(type.backgroundColor(for: state))
            .cornerRadius(type.cornerRadius)
            .opacity(state == .pressed || state == .disabled ? 0.6 : 1.0)
    }
}
```

こちらのコードでは、ボタンの状態をif文を使用して確認し、それに応じて`ButtonState`の値を設定しています。それぞれの状態に対する適切なスタイル属性（色など）を選択するロジックは`ButtonType`のextensionで実装しています。

---

## 👤 ユーザー
*2023/05/24 23:27:14*

switch (self, state)  {} でswitch 文を書いた方が読みやすいのかな？

---

## 🤖 アシスタント
*2023/05/24 23:28:37*

組み合わせを考慮に入れる場合、`switch`文を使って`ButtonType`と`ButtonState`の組み合わせを直接判定することで、コードの読みやすさを向上させることができます。以下のように更新してみました：

```swift
public enum ButtonType: String, CaseIterable, Identifiable {
    case primary
    case secondary
    case tertiary
    case text
    
    public var id: String {
        rawValue
    }
}

enum ButtonState {
    case disabled
    case pressed
    case `default`
}

extension ButtonType {
    var isRounded: Bool {
        switch self {
        case .secondary:
            return true
        default:
            return false
        }
    }
    
    func foregroundColor(for state: ButtonState) -> Color {
        switch (self, state) {
        case (.primary, .default), (.primary, .pressed):
            return .white
        case (_, .disabled):
            return .blue
        default:
            return .yellow
        }
    }
    
    func backgroundColor(for state: ButtonState) -> Color {
        switch (self, state) {
        case (.primary, .default):
            return .blue
        case (.primary, .disabled):
            return .gray
        default:
            return .clear
        }
    }
    
    var cornerRadius: CGFloat {
        return self.isRounded ? 10.0 : 0.0
    }
}

public struct CustomButtonStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled: Bool
    private var type: ButtonType

    init(_ type: ButtonType) {
        self.type = type
    }

    public func makeBody(configuration: Configuration) -> some View {
        let state: ButtonState
        if !isEnabled {
            state = .disabled
        } else if configuration.isPressed {
            state = .pressed
        } else {
            state = .default
        }
        
        configuration.label
            .foregroundColor(type.foregroundColor(for: state))
            .background(type.backgroundColor(for: state))
            .cornerRadius(type.cornerRadius)
            .opacity(state == .pressed || state == .disabled ? 0.6 : 1.0)
    }
}
```

このコードでは、`foregroundColor(for:)` および `backgroundColor(for:)` 関数内で、ボタンのタイプと状態の組み合わせを`switch`文で判定し、適切な色を返しています。これにより、各組み合わせの見た目をより明示的に制御できます。

---
