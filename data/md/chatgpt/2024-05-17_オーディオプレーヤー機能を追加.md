# ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼æ©Ÿèƒ½ã‚’è¿½åŠ 

æ—¥ä»˜: 2024-05-17

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/17 18:29:35*

onTapGoBackward ã¨onTapGoForward ã®å‡¦ç†ã‚’æ›¸ã„ã¦æ¬²ã—ã„

//
//  Created by sugurutakahashi on 2024/05/10
//  Copyright Â© 2024 crage Inc. All rights reserved.
//

import AVFoundation
import Combine
import Foundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isSeeking: Bool = false
    @Published var isLoading: Bool = false
    @Published var isPlaying: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
    @Published var shouldDismiss: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    private let fileManageDriver: FileManageDriver = FileManageDriver()

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }

    func onApper() {
        isLoading = true
        defer {
            isLoading = false
        }

        let item = AVPlayerItem(url: audioUrl)
        player = AVPlayer(playerItem: item)

        // 0.1 ç§’ã”ã¨ã«å†ç”Ÿæ™‚åˆ»ã¨ seek bar ã‚’åŒæœŸã•ã›ã‚‹
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest($isPlaying, $isSeeking)
            .filter { _, isPlaying, isSeeking in
                isPlaying && !isSeeking // å†ç”Ÿä¸­ã‹ã¤seekã—ã¦ã„ãªã„ã¨ãã®ã¿æ›´æ–°
            }
            .map { [weak self] _, _, _ in
                self?.player?.currentTime().seconds ?? 0
            }
            .assign(to: &$currentTime)

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else {
                    return
                }
                isPlaying = false
                currentTime = duration
                player?.seek(to: .zero)
            }
            .store(in: &cancellables)

        // å†ç”Ÿæº–å‚™ãŒå®Œäº†ã—ãŸã‚‰å†ç”Ÿæ™‚é–“ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                switch status {
                case .readyToPlay:
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                case .unknown, .failed:
                    break
                @unknown default:
                    break
                }
            }
            .store(in: &cancellables)

        // éŸ³å£°ã‚’å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapPlay() {
        player?.play()
        isPlaying = true
    }

    func onTapPause() {
        player?.pause()
        isPlaying = false
    }
    
    func onTapGoBackward() {
        
    }
    
    func onTapGoForward() {
        
    }
    
    func onTapTrash() {
        appError = .delete
        showAlert = true
    }
    
    func onTapOkDelete() {
        do {
            try fileManageDriver.removeItemIfExists(at: audioUrl)
            shouldDismiss = true
        } catch {
            OSLogger.errorLog("\(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime) { [weak self] completed in
            if completed {
                self?.currentTime = time
                self?.isSeeking = false
            } else {
                OSLogger.errorLog("seek failed")
                self?.appError = .customError("seek failed")
                self?.showAlert = true
            }
        }
    }
}

//
//  Created by sugurutakahashi on 2024/05/10
//  Copyright Â© 2024 crage Inc. All rights reserved.
//

import SwiftUI

// MARK: - View

@MainActor
struct AudioPlayerView: View {
    @Environment(\.presentationMode) var presentationMode
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        List {
            VStack {
                Slider(value: $presenter.currentTime, in: 0...presenter.duration) { editing in
                    if editing {
                        // ã‚ã¾ã‚Š View å´ã§ presenter ã®å€¤ã‚’ Binding ä»¥å¤–ã§æ›´æ–°ã—ãŸãã¯ãªã„ãŒã€seek bar ã®åˆ¶å¾¡ãŒé›£ã—ã„ã®ã§ã‚„ã‚€ã‚’å¾—ãšã“ã†ã—ã¦ã„ã‚‹
                        presenter.isSeeking = true
                    } else {
                        presenter.seek(to: presenter.currentTime)
                    }
                }
                
                HStack {
                    Text(presenter.currentTime.mmss)
                    Spacer()
                    Text(presenter.duration.mmss)
                }
                
                HStack {
                    Button {
                        presenter.onTapGoBackward()
                    } label: {
                        SFSymbols.gobackward15.image
                    }
                    
                    Spacer()
                    
                    if presenter.isPlaying {
                        Button {
                            presenter.onTapPause()
                        } label: {
                            SFSymbols.pauseFill.image
                        }
                    } else {
                        Button {
                            presenter.onTapPlay()
                        } label: {
                            SFSymbols.playFill.image
                        }
                        .disabled(presenter.isLoading)
                    }
                    
                    Spacer()
                    
                    Button {
                        presenter.onTapGoForward()
                    } label: {
                        SFSymbols.goforward15.image
                    }
                }
                .buttonStyle(.borderless)
                .font(.largeTitle)
                .padding()
            }
            .padding()
            
            Section {
                NavigationLink {
                    TranscriptionView(audioUrl: presenter.audioUrl)
                } label: {
                    Label {
                        Text("æ–‡å­—èµ·ã“ã—")
                    } icon: {
                        SFSymbols.rectangleAndPencilAndEllipsis.image
                    }
                }
                
                ShareLink(item: presenter.audioUrl) {
                    Label {
                        Text("URLå…±æœ‰")
                    } icon: {
                        SFSymbols.squareAndArrowUp.image
                    }
                }
                
                ShareLink(item: TransferableAudioFile(audioUrl: presenter.audioUrl), preview: SharePreview(presenter.audioUrl.lastPathComponent)) {
                    Label {
                        Text("Dataå…±æœ‰")
                    } icon: {
                        SFSymbols.squareAndArrowUp.image
                    }
                }
            }
            
            Section {
                Button {
                    presenter.onTapTrash()
                } label: {
                    Label {
                        Text("å‰Šé™¤")
                    } icon: {
                        SFSymbols.trash.image
                    }
                }
                .foregroundStyle(.red)
            }
        }
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError, onOk: { _ in
            presenter.onTapOkDelete()
        })
        .onChange(of: presenter.shouldDismiss) { shouldDismiss in
            if shouldDismiss {
                presentationMode.wrappedValue.dismiss()
            }
        }
        .onAppear {
            presenter.onApper()
        }
    }
}

// MARK: - Entity

public struct TransferableAudioFile: Transferable {
    public let audioUrl: URL

    public init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }

    public static var transferRepresentation: some TransferRepresentation {
        ProxyRepresentation(exporting: \.audioUrl)
    }

// FileRepresentation ã ã¨ .audio ãŒã†ã¾ã AirDrop ãªã©ã§å…±æœ‰ãŒã§ããªã‹ã£ãŸã€‚.mpeg4Audio ã§ã‚‚è©¦ã—ãŸãŒã ã‚ã§ã‚ã£ãŸã€‚ProxyRepresentation ã§ã†ã¾ãã„ã£ãŸã€‚
// Ref: https://developer.apple.com/documentation/coretransferable/filerepresentation
// Ref: ShareLink not reliable, entitlement errors - https://forums.developer.apple.com/forums/thread/739550
//    static var transferRepresentation: some TransferRepresentation {
//        FileRepresentation(contentType: .audio) { audio in
//            SentTransferredFile(audio.audioUrl)
//        } importing: { received in
//            let copy = FileManager.default.temporaryDirectory.appendingPathComponent(received.file.lastPathComponent)
//            try FileManager.default.copyItem(at: received.file, to: copy)
//            return Self.init(audioUrl: copy)
//        }
//    }
}


// MARK: - Preview

#Preview {
    AudioPlayerView(audioUrl: .placeholder)
        .navigationStacked()
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/17 18:30:33*

`onTapGoBackward` ã¨ `onTapGoForward` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¾ã™ã€‚ã“ã®å®Ÿè£…ã§ã¯ã€ãã‚Œãã‚Œ15ç§’é–“ã®ã‚¸ãƒ£ãƒ³ãƒ—ã‚’è¡Œã„ã¾ã™ã€‚

```swift
    func onTapGoBackward() {
        let newTime = max(currentTime - 15, 0)
        seek(to: newTime)
    }
    
    func onTapGoForward() {
        let newTime = min(currentTime + 15, duration)
        seek(to: newTime)
    }
```

å®Œå…¨ãªã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š

```swift
import AVFoundation
import Combine
import Foundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isSeeking: Bool = false
    @Published var isLoading: Bool = false
    @Published var isPlaying: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
    @Published var shouldDismiss: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []
    private let fileManageDriver: FileManageDriver = FileManageDriver()

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }

    func onApper() {
        isLoading = true
        defer {
            isLoading = false
        }

        let item = AVPlayerItem(url: audioUrl)
        player = AVPlayer(playerItem: item)

        // 0.1 ç§’ã”ã¨ã«å†ç”Ÿæ™‚åˆ»ã¨ seek bar ã‚’åŒæœŸã•ã›ã‚‹
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest($isPlaying, $isSeeking)
            .filter { _, isPlaying, isSeeking in
                isPlaying && !isSeeking // å†ç”Ÿä¸­ã‹ã¤seekã—ã¦ã„ãªã„ã¨ãã®ã¿æ›´æ–°
            }
            .map { [weak self] _, _, _ in
                self?.player?.currentTime().seconds ?? 0
            }
            .assign(to: &$currentTime)

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else {
                    return
                }
                isPlaying = false
                currentTime = duration
                player?.seek(to: .zero)
            }
            .store(in: &cancellables)

        // å†ç”Ÿæº–å‚™ãŒå®Œäº†ã—ãŸã‚‰å†ç”Ÿæ™‚é–“ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                switch status {
                case .readyToPlay:
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                case .unknown, .failed:
                    break
                @unknown default:
                    break
                }
            }
            .store(in: &cancellables)

        // éŸ³å£°ã‚’å†ç”Ÿãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapPlay() {
        player?.play()
        isPlaying = true
    }

    func onTapPause() {
        player?.pause()
        isPlaying = false
    }
    
    func onTapGoBackward() {
        let newTime = max(currentTime - 15, 0)
        seek(to: newTime)
    }
    
    func onTapGoForward() {
        let newTime = min(currentTime + 15, duration)
        seek(to: newTime)
    }
    
    func onTapTrash() {
        appError = .delete
        showAlert = true
    }
    
    func onTapOkDelete() {
        do {
            try fileManageDriver.removeItemIfExists(at: audioUrl)
            shouldDismiss = true
        } catch {
            OSLogger.errorLog("\(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime) { [weak self] completed in
            if completed {
                self?.currentTime = time
                self?.isSeeking = false
            } else {
                OSLogger.errorLog("seek failed")
                self?.appError = .customError("seek failed")
                self?.showAlert = true
            }
        }
    }
}

import SwiftUI

// MARK: - View

@MainActor
struct AudioPlayerView: View {
    @Environment(\.presentationMode) var presentationMode
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        List {
            VStack {
                Slider(value: $presenter.currentTime, in: 0...presenter.duration) { editing in
                    if editing {
                        // ã‚ã¾ã‚Š View å´ã§ presenter ã®å€¤ã‚’ Binding ä»¥å¤–ã§æ›´æ–°ã—ãŸãã¯ãªã„ãŒã€seek bar ã®åˆ¶å¾¡ãŒé›£ã—ã„ã®ã§ã‚„ã‚€ã‚’å¾—ãšã“ã†ã—ã¦ã„ã‚‹
                        presenter.isSeeking = true
                    } else {
                        presenter.seek(to: presenter.currentTime)
                    }
                }
                
                HStack {
                    Text(presenter.currentTime.mmss)
                    Spacer()
                    Text(presenter.duration.mmss)
                }
                
                HStack {
                    Button {
                        presenter.onTapGoBackward()
                    } label: {
                        SFSymbols.gobackward15.image
                    }
                    
                    Spacer()
                    
                    if presenter.isPlaying {
                        Button {
                            presenter.onTapPause()
                        } label: {
                            SFSymbols.pauseFill.image
                        }
                    } else {
                        Button {
                            presenter.onTapPlay()
                        } label: {
                            SFSymbols.playFill.image
                        }
                        .disabled(presenter.isLoading)
                    }
                    
                    Spacer()
                    
                    Button {
                        presenter.onTapGoForward()
                    } label: {
                        SFSymbols.goforward15.image
                    }
                }
                .buttonStyle(.borderless)
                .font(.largeTitle)
                .padding()
            }
            .padding()
            
            Section {
                NavigationLink {
                    TranscriptionView(audioUrl: presenter.audioUrl)
                } label: {
                    Label {
                        Text("æ–‡å­—èµ·ã“ã—")
                    } icon: {
                        SFSymbols.rectangleAndPencilAndEllipsis.image
                    }
                }
                
                ShareLink(item: presenter.audioUrl) {
                    Label {
                        Text("URLå…±æœ‰")
                    } icon: {
                        SFSymbols.squareAndArrowUp.image
                    }
                }
                
                ShareLink(item: TransferableAudioFile(audioUrl: presenter.audioUrl), preview: SharePreview(presenter.audioUrl.lastPathComponent)) {
                    Label {
                        Text("Dataå…±æœ‰")
                    } icon: {
                        SFSymbols.squareAndArrowUp.image
                    }
                }
            }
            
            Section {
                Button {
                    presenter.onTapTrash()
                } label: {
                    Label {
                        Text("å‰Šé™¤")
                    } icon: {
                        SFSymbols.trash.image
                    }
                }
                .foregroundStyle(.red)
            }
        }
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError, onOk: { _ in
            presenter.onTapOkDelete()
        })
        .onChange(of: presenter.shouldDismiss) { shouldDismiss in
            if shouldDismiss {
                presentationMode.wrappedValue.dismiss()
            }
        }
        .onAppear {
            presenter.onApper()
        }
    }
}

// MARK: - Entity

public struct TransferableAudioFile: Transferable {
    public let audioUrl: URL

    public init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }

    public static var transferRepresentation: some TransferRepresentation {
        ProxyRepresentation(exporting: \.audioUrl)
    }
}

// MARK: - Preview

#Preview {
    AudioPlayerView(audioUrl: .placeholder)
        .navigationStacked()
}
```

ã“ã‚Œã§ã€å†ç”Ÿä½ç½®ã‚’15ç§’å‰å¾Œã«ç§»å‹•ã™ã‚‹ãŸã‚ã®ãƒœã‚¿ãƒ³ãŒæ©Ÿèƒ½ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---
