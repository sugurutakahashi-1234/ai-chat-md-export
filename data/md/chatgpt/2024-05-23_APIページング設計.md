# APIページング設計

Date: 2024-05-23

---

## 👤 User
*2024-05-23 14:22:37*

API設計をしたい。
一度に全部のデータを取得するとデータ量が多いので複数回に分けて取得したい。
モバイルアプリの下にひっぱたら追加でローディングして追加するイメージである。

---

## 🤖 Assistant
*2024-05-23 14:23:09*

複数回に分けてデータを取得するAPI設計の方法として、ページングを使用することが一般的です。以下に、ページングを使用したAPI設計の例を示します。

### API エンドポイント設計

#### 1. データ取得エンドポイント

```http
GET /api/items?page=1&limit=20
```

- `page`: 現在のページ番号を指定します。デフォルトは1です。
- `limit`: 1ページあたりのアイテム数を指定します。デフォルトは20です。

#### 2. レスポンス形式

```json
{
  "page": 1,
  "limit": 20,
  "totalItems": 100,
  "totalPages": 5,
  "items": [
    {
      "id": 1,
      "name": "Item 1",
      "description": "Description of Item 1"
    },
    {
      "id": 2,
      "name": "Item 2",
      "description": "Description of Item 2"
    }
    // 他のアイテム
  ]
}
```

- `page`: 現在のページ番号
- `limit`: 1ページあたりのアイテム数
- `totalItems`: 全体のアイテム数
- `totalPages`: 全体のページ数
- `items`: アイテムのリスト

### バックエンド実装

#### 1. データベースクエリ

データベースからデータを取得する際に、オフセットとリミットを使用してページングを行います。

```sql
SELECT * FROM items LIMIT 20 OFFSET 0; -- 1ページ目
SELECT * FROM items LIMIT 20 OFFSET 20; -- 2ページ目
```

#### 2. コントローラー

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/api/items', methods=['GET'])
def get_items():
    page = int(request.args.get('page', 1))
    limit = int(request.args.get('limit', 20))
    offset = (page - 1) * limit
    
    # データベースクエリの実行（仮想）
    items = query_database(limit=limit, offset=offset)
    total_items = count_total_items()  # 全体のアイテム数をカウント

    response = {
        "page": page,
        "limit": limit,
        "totalItems": total_items,
        "totalPages": (total_items + limit - 1) // limit,  # 全体のページ数を計算
        "items": items
    }
    
    return jsonify(response)

def query_database(limit, offset):
    # ここでデータベースクエリを実行し、アイテムリストを取得
    return [
        {"id": 1, "name": "Item 1", "description": "Description of Item 1"},
        # 他のアイテム
    ]

def count_total_items():
    # ここで全体のアイテム数をカウント
    return 100

if __name__ == '__main__':
    app.run(debug=True)
```

### クライアント側の実装

クライアント側（モバイルアプリ）では、ユーザーがスクロールしたときに次のページを取得するロジックを追加します。SwiftUIでの簡単な例を示します。

```swift
import SwiftUI

struct ContentView: View {
    @State private var items: [Item] = []
    @State private var currentPage = 1
    @State private var isLoading = false

    var body: some View {
        List {
            ForEach(items) { item in
                Text(item.name)
            }
            if isLoading {
                ProgressView()
                    .onAppear(perform: loadMore)
            }
        }
        .onAppear(perform: loadMore)
    }

    func loadMore() {
        guard !isLoading else { return }
        isLoading = true
        let url = URL(string: "https://example.com/api/items?page=\(currentPage)&limit=20")!
        URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data else { return }
            let response = try! JSONDecoder().decode(APIResponse.self, from: data)
            DispatchQueue.main.async {
                self.items.append(contentsOf: response.items)
                self.currentPage += 1
                self.isLoading = false
            }
        }.resume()
    }
}

struct Item: Identifiable, Decodable {
    let id: Int
    let name: String
    let description: String
}

struct APIResponse: Decodable {
    let page: Int
    let limit: Int
    let totalItems: Int
    let totalPages: Int
    let items: [Item]
}
```

これにより、ユーザーがリストをスクロールするときに追加のデータがロードされ、効率的にデータを取得できます。

---
