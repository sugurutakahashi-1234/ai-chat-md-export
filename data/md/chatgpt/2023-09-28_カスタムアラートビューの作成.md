# カスタムアラートビューの作成

日付: 2023-09-28

---

## 👤 ユーザー
*2023/9/28 17:05:11*

SwiftUIでとある事情によってアラートが表示できないがアラートとほぼ同じようなViewコンポーネントを作成したい。

ボタンはひとつだけで、タイトルと本文がある。

---

## 🤖 アシスタント
*2023/9/28 17:06:26*

SwiftUIでカスタムアラートビューを作成する場合、基本的には新しいViewを作成し、そのViewでアラートのようなデザインを模倣します。以下は、タイトル、本文、一つのボタンを持つ、アラートのようなカスタムViewの例です。

```swift
import SwiftUI

struct CustomAlertView: View {
    @Binding var isPresented: Bool // 表示を制御するためのバインディング変数
    var title: String
    var message: String
    var buttonTitle: String
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            VStack(spacing: 20) {
                Text(title)
                    .font(.headline)
                    .foregroundColor(.black)
                Text(message)
                    .font(.body)
                    .foregroundColor(.gray)
                Button(action: {
                    isPresented = false // ボタンを押すとアラートを非表示にする
                }) {
                    Text(buttonTitle)
                        .padding()
                        .foregroundColor(.white)
                        .background(Color.blue)
                        .cornerRadius(10)
                }
            }
            .padding()
            .background(Color.white)
            .cornerRadius(20)
            .shadow(radius: 20)
        }
    }
}

struct ContentView: View {
    @State private var isAlertPresented = false
    
    var body: some View {
        VStack(spacing: 20) {
            Button("Show Custom Alert") {
                isAlertPresented = true
            }
        }
        .overlay(
            // カスタムアラートビューを表示
            CustomAlertView(isPresented: $isAlertPresented, title: "タイトル", message: "本文", buttonTitle: "閉じる")
                .opacity(isAlertPresented ? 1 : 0)
        )
    }
}

@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

この例では、`CustomAlertView`はアラートが表示されているかどうかを管理する`isPresented`と、アラートのタイトル、メッセージ、ボタンのタイトルを受け取ります。そして、`ContentView`内でこのカスタムアラートビューをオーバーレイとして表示します。ボタンをタップするとアラートが非表示になります。

このコードを適宜変更して、お望みのデザインや機能に合わせてカスタマイズできます。

---

## 👤 ユーザー
*2023/9/28 17:07:34*

タップした時のactionも引数にとるようにしてほしい。

---

## 🤖 アシスタント
*2023/9/28 17:08:48*

もちろんです、ボタンのアクションも引数で受け取れるように`CustomAlertView`を修正できます。以下は、ボタンのアクションを引数で受け取るカスタムアラートビューの修正版です。

```swift
import SwiftUI

struct CustomAlertView: View {
    @Binding var isPresented: Bool // 表示を制御するためのバインディング変数
    var title: String
    var message: String
    var buttonTitle: String
    var buttonAction: () -> Void // ボタンのアクション
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            VStack(spacing: 20) {
                Text(title)
                    .font(.headline)
                    .foregroundColor(.black)
                Text(message)
                    .font(.body)
                    .foregroundColor(.gray)
                Button(action: {
                    isPresented = false // ボタンを押すとアラートを非表示にする
                    buttonAction() // ボタンのアクションを実行する
                }) {
                    Text(buttonTitle)
                        .padding()
                        .foregroundColor(.white)
                        .background(Color.blue)
                        .cornerRadius(10)
                }
            }
            .padding()
            .background(Color.white)
            .cornerRadius(20)
            .shadow(radius: 20)
        }
    }
}

struct ContentView: View {
    @State private var isAlertPresented = false
    
    var body: some View {
        VStack(spacing: 20) {
            Button("Show Custom Alert") {
                isAlertPresented = true
            }
        }
        .overlay(
            // カスタムアラートビューを表示
            CustomAlertView(
                isPresented: $isAlertPresented,
                title: "タイトル",
                message: "本文",
                buttonTitle: "閉じる",
                buttonAction: {
                    // ボタンを押した時のアクション
                    print("Button was tapped")
                }
            )
                .opacity(isAlertPresented ? 1 : 0)
        )
    }
}

@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

このコードでは、`CustomAlertView`の`buttonAction`は、ボタンがタップされたときに実行されるクロージャです。これにより、`CustomAlertView`を使う側で、ボタンタップ時のアクションを自由に定義できます。

---

## 👤 ユーザー
*2023/9/28 17:21:59*

messageとボタンの間に横線があると思う。

---

## 🤖 アシスタント
*2023/9/28 17:23:05*

すみません、その要件を追加しました。以下は、メッセージとボタンの間に横線を追加した`CustomAlertView`です。

```swift
import SwiftUI

struct CustomAlertView: View {
    @Binding var isPresented: Bool
    var title: String
    var message: String
    var buttonTitle: String
    var buttonAction: () -> Void
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 0) {
                Text(title)
                    .font(.headline)
                    .foregroundColor(.black)
                    .padding()
                
                Text(message)
                    .font(.body)
                    .foregroundColor(.gray)
                    .padding([.leading, .trailing, .bottom])
                
                Divider() // メッセージとボタンの間に横線を追加
                
                Button(action: {
                    isPresented = false
                    buttonAction()
                }) {
                    Text(buttonTitle)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .foregroundColor(.blue)
                        .background(Color(UIColor.systemGray6))
                }
            }
            .background(Color.white)
            .cornerRadius(20)
            .shadow(radius: 20)
        }
    }
}

struct ContentView: View {
    @State private var isAlertPresented = false
    
    var body: some View {
        VStack(spacing: 20) {
            Button("Show Custom Alert") {
                isAlertPresented = true
            }
        }
        .overlay(
            CustomAlertView(
                isPresented: $isAlertPresented,
                title: "タイトル",
                message: "本文",
                buttonTitle: "閉じる",
                buttonAction: {
                    print("Button was tapped")
                }
            )
                .opacity(isAlertPresented ? 1 : 0)
        )
    }
}

@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

このコードでは、`Divider()`コンポーネントを使用して、メッセージとボタンの間に横線を描画しています。また、ボタンのテキストの色を青色に、ボタンのバックグラウンドを`systemGray6`に設定しています。

---

## 👤 ユーザー
*2023/9/28 17:31:44*

frameを設定したいのと、テキストを中央に寄せたい

public struct CustomAlertView: View {
    @Binding private var isPresented: Bool
    private let title: String
    private let message: String
    private let buttonText: String
    private let onDismiss: (() -&gt; Void)?

    public init(isPresented: Binding&lt;Bool&gt;, title: String, message: String, buttonText: String, onDismiss: (() -&gt; Void)?) {
        _isPresented = isPresented
        self.title = title
        self.message = message
        self.buttonText = buttonText
        self.onDismiss = onDismiss
    }

    public var body: some View {
        VStack(spacing: 20) {
            Text(title)
                .typographyStyle(.title4)
                .foregroundColor(CoreAssets.Color.Neutral.black.swiftUIColor)
            
            Text(message)
                .typographyStyle(.body2)
                .foregroundColor(CoreAssets.Color.Neutral.black.swiftUIColor)
            
            Divider()
            
            Button {
                onDismiss?()
                isPresented = false
            } label: {
                Text(buttonText)
                    .typographyStyle(.title3)
            }
            
        }
        .padding()
        .background(CoreAssets.Color.Neutral.white.swiftUIColor)
        .cornerRadius(20)
        .shadow(radius: 20)
    }
}

---

## 🤖 アシスタント
*2023/9/28 17:33:00*

`frame`を設定し、テキストを中央に寄せたい場合、以下のようにコードを修正できます。加えて、SwiftUIには直接`.typographyStyle`や`.swiftUIColor`などのメソッドはないため、これらがカスタム拡張であることを前提としています。以下に修正後の`CustomAlertView`を示します。

```swift
public struct CustomAlertView: View {
    @Binding private var isPresented: Bool
    private let title: String
    private let message: String
    private let buttonText: String
    private let onDismiss: (() -> Void)?
    
    public init(isPresented: Binding<Bool>, title: String, message: String, buttonText: String, onDismiss: (() -> Void)?) {
        _isPresented = isPresented
        self.title = title
        self.message = message
        self.buttonText = buttonText
        self.onDismiss = onDismiss
    }
    
    public var body: some View {
        VStack(spacing: 20) {
            Text(title)
                .typographyStyle(.title4) // Assuming this is a custom extension method
                .foregroundColor(CoreAssets.Color.Neutral.black.swiftUIColor) // Assuming this is a custom extension property
                .frame(maxWidth: .infinity, alignment: .center)
            
            Text(message)
                .typographyStyle(.body2) // Assuming this is a custom extension method
                .foregroundColor(CoreAssets.Color.Neutral.black.swiftUIColor) // Assuming this is a custom extension property
                .frame(maxWidth: .infinity, alignment: .center)
            
            Divider()
            
            Button {
                onDismiss?()
                isPresented = false
            } label: {
                Text(buttonText)
                    .typographyStyle(.title3) // Assuming this is a custom extension method
                    .frame(maxWidth: .infinity)
            }
        }
        .frame(width: 300) // Example frame width, adjust as necessary
        .padding()
        .background(CoreAssets.Color.Neutral.white.swiftUIColor) // Assuming this is a custom extension property
        .cornerRadius(20)
        .shadow(radius: 20)
    }
}
```

ここでは、テキストの`frame`に`maxWidth: .infinity`と`alignment: .center`を設定し、テキストを中央に配置しています。また、VStack全体にも`frame`を設定して、アラートの幅を制御しています。この`frame`の`width`値は、アラートがどの程度の幅を必要とするかに応じて調整してください。

---

## 👤 ユーザー
*2023/9/28 17:41:45*

中央揃いにならなかった

---

## 🤖 アシスタント
*2023/9/28 17:43:05*

すみません、`frame`の`alignment`パラメータを利用しても中央揃えにならなかった場合は、`Text`ビューの代わりに`HStack`を利用して、スペーサーを両側に配置することで中央揃えを実現できます。

また、全体の`VStack`に対して`frame`を指定し、中央揃えを行うために`.multilineTextAlignment(.center)`を利用できます。

以下は、中央揃えを行った`CustomAlertView`の例です：

```swift
public struct CustomAlertView: View {
    @Binding private var isPresented: Bool
    private let title: String
    private let message: String
    private let buttonText: String
    private let onDismiss: (() -> Void)?
    
    public init(isPresented: Binding<Bool>, title: String, message: String, buttonText: String, onDismiss: (() -> Void)?) {
        _isPresented = isPresented
        self.title = title
        self.message = message
        self.buttonText = buttonText
        self.onDismiss = onDismiss
    }
    
    public var body: some View {
        VStack(spacing: 20) {
            HStack {
                Spacer()
                Text(title)
                    .typographyStyle(.title4) // Assuming this is a custom extension method
                    .foregroundColor(CoreAssets.Color.Neutral.black.swiftUIColor) // Assuming this is a custom extension property
                Spacer()
            }
            
            HStack {
                Spacer()
                Text(message)
                    .typographyStyle(.body2) // Assuming this is a custom extension method
                    .foregroundColor(CoreAssets.Color.Neutral.black.swiftUIColor) // Assuming this is a custom extension property
                    .multilineTextAlignment(.center) // For aligning multiline text to the center
                Spacer()
            }
            
            Divider()
            
            Button {
                onDismiss?()
                isPresented = false
            } label: {
                Text(buttonText)
                    .typographyStyle(.title3) // Assuming this is a custom extension method
            }
        }
        .frame(width: 300) // Example frame width, adjust as necessary
        .padding()
        .background(CoreAssets.Color.Neutral.white.swiftUIColor) // Assuming this is a custom extension property
        .cornerRadius(20)
        .shadow(radius: 20)
    }
}
```

このコードでは、`title`と`message`の`Text`ビューが`HStack`の中にあり、その`HStack`の両側に`Spacer()`を配置しています。これにより、`Text`ビューは中央に配置されます。そして、`multilineTextAlignment(.center)`によって、複数行のテキストも中央揃えされます。

---

## 👤 ユーザー
*2023/9/29 5:36:47*

CustomAlertViewではなくて、擬似的なという意味の命名をしてほしい

---

## 🤖 アシスタント
*2023/9/29 5:37:47*

擬似的なアラートを意味する名前を付けたい場合、`PseudoAlertView`や`MockAlertView`などが適切かもしれません。以下は、`PseudoAlertView`と命名した場合のコードです。

```swift
public struct PseudoAlertView: View {
    @Binding private var isPresented: Bool
    private let title: String
    private let message: String
    private let buttonText: String
    private let onDismiss: (() -> Void)?
    
    public init(isPresented: Binding<Bool>, title: String, message: String, buttonText: String, onDismiss: (() -> Void)?) {
        _isPresented = isPresented
        self.title = title
        self.message = message
        self.buttonText = buttonText
        self.onDismiss = onDismiss
    }
    
    public var body: some View {
        VStack(spacing: 20) {
            HStack {
                Spacer()
                Text(title)
                    .typographyStyle(.title4) // Assuming this is a custom extension method
                    .foregroundColor(CoreAssets.Color.Neutral.black.swiftUIColor) // Assuming this is a custom extension property
                Spacer()
            }
            
            HStack {
                Spacer()
                Text(message)
                    .typographyStyle(.body2) // Assuming this is a custom extension method
                    .foregroundColor(CoreAssets.Color.Neutral.black.swiftUIColor) // Assuming this is a custom extension property
                    .multilineTextAlignment(.center)
                Spacer()
            }
            
            Divider()
            
            Button {
                onDismiss?()
                isPresented = false
            } label: {
                Text(buttonText)
                    .typographyStyle(.title3) // Assuming this is a custom extension method
            }
        }
        .frame(width: 300) // Example frame width, adjust as necessary
        .padding()
        .background(CoreAssets.Color.Neutral.white.swiftUIColor) // Assuming this is a custom extension property
        .cornerRadius(20)
        .shadow(radius: 20)
    }
}
```

この例では、`CustomAlertView`を`PseudoAlertView`に変更しました。他の部分は変更していません。

---

## 👤 ユーザー
*2023/9/29 5:37:55*

結局これってoverlayして使うことが前提なので、それを使ってモディファイア化できないかな？

---

## 🤖 アシスタント
*2023/9/29 5:39:21*

確かに、このビューを`View`モディファイアとして実装することで、より簡潔に使えるようになります。以下は、`View`拡張として`PseudoAlert`を実装した例です：

```swift
import SwiftUI

public struct PseudoAlert: ViewModifier {
    @Binding var isPresented: Bool
    let title: String
    let message: String
    let buttonText: String
    let onDismiss: (() -> Void)?
    
    public func body(content: Content) -> some View {
        ZStack {
            content
            if isPresented {
                VStack(spacing: 20) {
                    HStack {
                        Spacer()
                        Text(title)
                            .font(.title2) // Updated as an example
                            .foregroundColor(Color.black) // Updated as an example
                        Spacer()
                    }
                    
                    HStack {
                        Spacer()
                        Text(message)
                            .font(.body) // Updated as an example
                            .foregroundColor(Color.black) // Updated as an example
                            .multilineTextAlignment(.center)
                        Spacer()
                    }
                    
                    Divider()
                    
                    Button {
                        isPresented = false
                        onDismiss?()
                    } label: {
                        Text(buttonText)
                            .font(.title3) // Updated as an example
                    }
                }
                .frame(width: 300)
                .padding()
                .background(Color.white) // Updated as an example
                .cornerRadius(20)
                .shadow(radius: 20)
            }
        }
    }
}

extension View {
    public func pseudoAlert(isPresented: Binding<Bool>, title: String, message: String, buttonText: String, onDismiss: (() -> Void)?) -> some View {
        self.modifier(PseudoAlert(isPresented: isPresented, title: title, message: message, buttonText: buttonText, onDismiss: onDismiss))
    }
}

struct ContentView: View {
    @State private var isAlertPresented = false
    
    var body: some View {
        VStack(spacing: 20) {
            Button("Show Pseudo Alert") {
                isAlertPresented = true
            }
        }
        .pseudoAlert(isPresented: $isAlertPresented, title: "タイトル", message: "本文", buttonText: "閉じる", onDismiss: {
            print("Button was tapped")
        })
    }
}
```

このコードでは、新たに`PseudoAlert`という`ViewModifier`を作成し、それを`View`拡張で利用できるようにしました。これで、任意の`View`に対して`.pseudoAlert`モディファイアを使うことで、擬似アラートを表示できます。

また、元のコードにおけるカスタムメソッドやプロパティについては、適当なSwiftUIのデフォルトのメソッドやプロパティに置き換えています。ご使用の際は、適切にカスタマイズしてください。

---

## 👤 ユーザー
*2023/9/29 6:28:42*

ちなみに通常のアラートのようにDividerより下の範囲でタップしたときに押した感じをつけたい

---

## 🤖 アシスタント
*2023/9/29 6:29:38*

通常の`Button`では、ボタン全体がタップ可能になるため、`Divider`以下の部分もボタンとして機能させたい場合は、以下のように`Button`を配置してください：

```swift
public struct PseudoAlert: ViewModifier {
    @Binding var isPresented: Bool
    let title: String
    let message: String
    let buttonText: String
    let onDismiss: (() -> Void)?
    
    public func body(content: Content) -> some View {
        ZStack {
            content
            if isPresented {
                VStack(spacing: 0) { // spacingを0に設定
                    VStack(spacing: 20) {
                        HStack {
                            Spacer()
                            Text(title)
                                .font(.title2)
                                .foregroundColor(Color.black)
                            Spacer()
                        }
                        
                        HStack {
                            Spacer()
                            Text(message)
                                .font(.body)
                                .foregroundColor(Color.black)
                                .multilineTextAlignment(.center)
                            Spacer()
                        }
                    }
                    .padding(.bottom, 20) // ボタン上のスペース
                    
                    Divider()
                    
                    Button {
                        isPresented = false
                        onDismiss?()
                    } label: {
                        VStack { // VStackを利用して、余白を含むボタン全体がタップ可能になるようにする
                            Spacer()
                            Text(buttonText)
                                .font(.title3)
                            Spacer()
                        }
                    }
                }
                .frame(width: 300)
                .padding()
                .background(Color.white)
                .cornerRadius(20)
                .shadow(radius: 20)
            }
        }
    }
}
```

このコードでは、`Divider`以下の`Button`の`label`に新たに`VStack`を配置して、その中に`Text`を配置しています。そして、`VStack`の中に`Spacer`を配置することで、`VStack`全体がタップ可能になり、`Text`は中央に配置されます。

---

## 👤 ユーザー
*2023/9/29 6:32:08*

もっとシンプルにタップ領域を広げられないか？

---

## 🤖 アシスタント
*2023/9/29 6:32:55*

もちろん、シンプルにタップ領域を広げる方法もあります。Buttonのlabelにpaddingを追加するか、またはButtonに直接.frame(modifier:)を追加することで、タップ領域を調整できます。以下は、Buttonにpaddingを追加した例です。

```swift
public struct PseudoAlert: ViewModifier {
    @Binding var isPresented: Bool
    let title: String
    let message: String
    let buttonText: String
    let onDismiss: (() -> Void)?
    
    public func body(content: Content) -> some View {
        ZStack {
            content
            if isPresented {
                VStack(spacing: 20) {
                    VStack(spacing: 20) {
                        HStack {
                            Spacer()
                            Text(title)
                                .font(.title2)
                                .foregroundColor(Color.black)
                            Spacer()
                        }
                        
                        HStack {
                            Spacer()
                            Text(message)
                                .font(.body)
                                .foregroundColor(Color.black)
                                .multilineTextAlignment(.center)
                            Spacer()
                        }
                    }
                    
                    Divider()
                    
                    Button {
                        isPresented = false
                        onDismiss?()
                    } label: {
                        Text(buttonText)
                            .font(.title3)
                            .padding(EdgeInsets(top: 10, leading: 0, bottom: 10, trailing: 0)) // 上下のpaddingを追加
                    }
                }
                .frame(width: 300)
                .padding()
                .background(Color.white)
                .cornerRadius(20)
                .shadow(radius: 20)
            }
        }
    }
}
```

この変更により、`Button`のタップ領域は、テキストの上下に追加のスペースを含むようになります。

---

## 👤 ユーザー
*2023/9/29 6:33:07*

左右も広げて欲しい

---

## 🤖 アシスタント
*2023/9/29 6:33:56*

左右の領域も広げたい場合は、`padding`メソッドに`leading`と`trailing`にも値を設定するか、もしくは`padding`メソッドに値を直接渡して全方向にパディングを追加できます。

以下は全方向にパディングを追加した例です：

```swift
public struct PseudoAlert: ViewModifier {
    @Binding var isPresented: Bool
    let title: String
    let message: String
    let buttonText: String
    let onDismiss: (() -> Void)?
    
    public func body(content: Content) -> some View {
        ZStack {
            content
            if isPresented {
                VStack(spacing: 20) {
                    VStack(spacing: 20) {
                        HStack {
                            Spacer()
                            Text(title)
                                .font(.title2)
                                .foregroundColor(Color.black)
                            Spacer()
                        }
                        
                        HStack {
                            Spacer()
                            Text(message)
                                .font(.body)
                                .foregroundColor(Color.black)
                                .multilineTextAlignment(.center)
                            Spacer()
                        }
                    }
                    
                    Divider()
                    
                    Button {
                        isPresented = false
                        onDismiss?()
                    } label: {
                        Text(buttonText)
                            .font(.title3)
                            .padding(10) // 全方向に10ポイントのパディングを追加
                    }
                }
                .frame(width: 300)
                .padding()
                .background(Color.white)
                .cornerRadius(20)
                .shadow(radius: 20)
            }
        }
    }
}
```

ここでは、`Button`のラベルに`.padding(10)`を追加し、この`Button`のタップ可能領域が上下左右全てに10ポイント広がります。もちろん、値`10`は例ですので、お好みに合わせて調整してください。

---
