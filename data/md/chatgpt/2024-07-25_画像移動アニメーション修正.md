# 画像移動アニメーション修正

日付: 2024-07-25

---

## 👤 ユーザー
*2024/7/25 12:55:02*

拡大したまま画像をドラックして移動させた時に画面内に戻るアニメーションをやっているのだけれども、なにか挙動がおかしい

struct PhotoCropView: View {
    private struct Constants {
        static let frameSize: CGFloat = 300
        
    }
    
    @Binding var image: UIImage?
    
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 0.0
    @State private var offset: CGSize = .zero
    @State private var lastStoredOffset: CGSize = .zero
    @GestureState private var isInteracting: Bool = false

    @Environment(\\.dismiss) private var dismiss

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                if let image = image {
                    Image(uiImage: image)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .overlay {
                            GeometryReader { proxy in
                                let rect = proxy.frame(in: .named("photoCropView"))
                                
                                Color.clear
                                    .onChange(of: isInteracting) { newValue in
                                        withAnimation(.easeInOut(duration: 0.2)) {
                                            if rect.minX &gt; 0 {
                                                offset.width = (offset.width - rect.minX)
                                            }
                                            if rect.minY &gt; 0 {
                                                offset.height = (offset.height - rect.minY)
                                            }
                                            
                                            if rect.maxX &lt; geometry.size.width {
                                                offset.width = (rect.minX - offset.width)
                                            }
                                            
                                            if rect.maxY &lt; geometry.size.height {
                                                offset.height = (rect.minY - offset.height)
                                            }
                                        }
                                        
                                        if !newValue {
                                            lastStoredOffset = offset
                                        }
                                    }
                            }
                        }
                        .frame(width: geometry.size.width, height: geometry.size.height)
                }
            }
        }
        .offset(offset)
        .scaleEffect(scale)
        .coordinateSpace(name: "photoCropView")
        .gesture(
            DragGesture()
                .updating($isInteracting) { \_, state, \_ in
                    state = true
                }
                .onChanged { value in
                    let translation = value.translation
                    offset = CGSize(width: lastStoredOffset.width + translation.width, height: lastStoredOffset.height + translation.height)
                    
                }
        )
        .gesture(
            MagnificationGesture()
                .updating($isInteracting) { \_, state, \_ in
                    state = true
                }
                .onChanged { value in
                    let updatedScale = value + lastScale
                    scale = (updatedScale &lt; 1 ? 1 : updatedScale)
                }
                .onEnded { value in
                    withAnimation(.easeInOut(duration: 0.2)) {
                        if scale &lt; 1 {
                            scale = 1
                            lastScale = 0
                        } else {
                            lastScale = scale - 1
                        }
                    }
                }
        )
        .frame(width: Constants.frameSize, height: Constants.frameSize)
        .clipShape(.rect(cornerRadius: Constants.frameSize / 2))
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            Color.black
                .ignoresSafeArea()
        )
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    // selectedImage = nil
                    dismiss.callAsFunction()
                } label: {
                    Text("キャンセル")
                        .foregroundStyle(.white)
                }
            }
            
            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("適用")
                        .foregroundStyle(.white)
                }
            }
        }
        
    }
}

---

## 🤖 アシスタント
*2024/7/25 12:55:20*

アニメーションがうまく動作しない原因として、座標の計算やアニメーションの適用方法に問題がある可能性があります。以下に、アニメーションと座標の計算を改善する方法を示します。

1. 画像が画面内に戻る際のアニメーションの実行タイミングを調整する。
2. オフセットの計算を正確に行う。

以下に修正したコードを示します。

```swift
struct PhotoCropView: View {
    private struct Constants {
        static let frameSize: CGFloat = 300
    }
    
    @Binding var image: UIImage?
    
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 0.0
    @State private var offset: CGSize = .zero
    @State private var lastStoredOffset: CGSize = .zero
    @GestureState private var isInteracting: Bool = false

    @Environment(\.dismiss) private var dismiss

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                if let image = image {
                    Image(uiImage: image)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: geometry.size.width * scale, height: geometry.size.height * scale)
                        .overlay {
                            GeometryReader { proxy in
                                let rect = proxy.frame(in: .named("photoCropView"))
                                
                                Color.clear
                                    .onChange(of: isInteracting) { newValue in
                                        if !newValue {
                                            withAnimation(.easeInOut(duration: 0.2)) {
                                                if rect.minX > 0 {
                                                    offset.width -= rect.minX
                                                }
                                                if rect.minY > 0 {
                                                    offset.height -= rect.minY
                                                }
                                                
                                                if rect.maxX < geometry.size.width {
                                                    offset.width -= (rect.maxX - geometry.size.width)
                                                }
                                                
                                                if rect.maxY < geometry.size.height {
                                                    offset.height -= (rect.maxY - geometry.size.height)
                                                }
                                            }
                                            lastStoredOffset = offset
                                        }
                                    }
                            }
                        }
                }
            }
        }
        .offset(offset)
        .scaleEffect(scale)
        .coordinateSpace(name: "photoCropView")
        .gesture(
            DragGesture()
                .updating($isInteracting) { _, state, _ in
                    state = true
                }
                .onChanged { value in
                    let translation = value.translation
                    offset = CGSize(width: lastStoredOffset.width + translation.width, height: lastStoredOffset.height + translation.height)
                }
        )
        .gesture(
            MagnificationGesture()
                .updating($isInteracting) { _, state, _ in
                    state = true
                }
                .onChanged { value in
                    let updatedScale = value + lastScale
                    scale = (updatedScale < 1 ? 1 : updatedScale)
                }
                .onEnded { value in
                    withAnimation(.easeInOut(duration: 0.2)) {
                        if scale < 1 {
                            scale = 1
                            lastScale = 0
                        } else {
                            lastScale = scale - 1
                        }
                    }
                }
        )
        .frame(width: Constants.frameSize, height: Constants.frameSize)
        .clipShape(RoundedRectangle(cornerRadius: Constants.frameSize / 2))
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            Color.black
                .ignoresSafeArea()
        )
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("キャンセル")
                        .foregroundStyle(.white)
                }
            }
            
            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("適用")
                        .foregroundStyle(.white)
                }
            }
        }
    }
}
```

変更点：
- `overlay`内での座標計算とアニメーションの適用タイミングを修正しました。
- 拡大縮小の計算をより直感的にしました。

これで、画像が拡大したままドラッグして移動させた場合、正しくアニメーションで画面内に戻るはずです。

---

## 👤 ユーザー
*2024/7/25 12:55:53*

変えた場所を教えてほしい

---

## 🤖 アシスタント
*2024/7/25 12:56:11*

以下に、変更した場所とその内容を説明します。

### 変更点

1. **`frame`の適用箇所を変更**  
   元のコードでは、`Image`のサイズを`geometry.size`に基づいて設定していましたが、変更後は`scale`プロパティに基づいて計算されたサイズに変更しました。

2. **`onChange`のアニメーションタイミングと条件の修正**  
   `isInteracting`が`false`になるタイミングでアニメーションを適用し、画像が画面内に収まるようにオフセットを計算するロジックを修正しました。

### 修正前

```swift
Image(uiImage: image)
    .resizable()
    .aspectRatio(contentMode: .fill)
    .overlay {
        GeometryReader { proxy in
            let rect = proxy.frame(in: .named("photoCropView"))
            Color.clear
                .onChange(of: isInteracting) { newValue in
                    withAnimation(.easeInOut(duration: 0.2)) {
                        if rect.minX > 0 {
                            offset.width = (offset.width - rect.minX)
                        }
                        if rect.minY > 0 {
                            offset.height = (offset.height - rect.minY)
                        }
                        if rect.maxX < geometry.size.width {
                            offset.width = (rect.minX - offset.width)
                        }
                        if rect.maxY < geometry.size.height {
                            offset.height = (rect.minY - offset.height)
                        }
                    }
                    if !newValue {
                        lastStoredOffset = offset
                    }
                }
        }
    }
    .frame(width: geometry.size.width, height: geometry.size.height)
```

### 修正後

```swift
Image(uiImage: image)
    .resizable()
    .aspectRatio(contentMode: .fill)
    .frame(width: geometry.size.width * scale, height: geometry.size.height * scale)
    .overlay {
        GeometryReader { proxy in
            let rect = proxy.frame(in: .named("photoCropView"))
            Color.clear
                .onChange(of: isInteracting) { newValue in
                    if !newValue {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            if rect.minX > 0 {
                                offset.width -= rect.minX
                            }
                            if rect.minY > 0 {
                                offset.height -= rect.minY
                            }
                            if rect.maxX < geometry.size.width {
                                offset.width -= (rect.maxX - geometry.size.width)
                            }
                            if rect.maxY < geometry.size.height {
                                offset.height -= (rect.maxY - geometry.size.height)
                            }
                        }
                        lastStoredOffset = offset
                    }
                }
        }
    }
```

### 主な変更点のポイント

1. `frame(width: geometry.size.width * scale, height: geometry.size.height * scale)`により、拡大縮小時の画像サイズを調整しました。
2. `onChange(of: isInteracting)`内の条件を変更し、アニメーションが`isInteracting`が`false`になるタイミングで実行されるようにしました。これにより、ドラッグやピンチジェスチャーの操作が終了したときにアニメーションが実行されるようになります。

これらの変更により、画像が画面内に戻る際のアニメーションがスムーズに実行されるはずです。

---
