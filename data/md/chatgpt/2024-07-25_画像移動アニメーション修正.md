# ç”»åƒç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¿®æ­£

æ—¥ä»˜: 2024-07-25

---

## ðŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/7/25 12:55:02*

æ‹¡å¤§ã—ãŸã¾ã¾ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚¯ã—ã¦ç§»å‹•ã•ã›ãŸæ™‚ã«ç”»é¢å†…ã«æˆ»ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚„ã£ã¦ã„ã‚‹ã®ã ã‘ã‚Œã©ã‚‚ã€ãªã«ã‹æŒ™å‹•ãŒãŠã‹ã—ã„

struct PhotoCropView: View {
    private struct Constants {
        static let frameSize: CGFloat = 300
        
    }
    
    @Binding var image: UIImage?
    
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 0.0
    @State private var offset: CGSize = .zero
    @State private var lastStoredOffset: CGSize = .zero
    @GestureState private var isInteracting: Bool = false

    @Environment(\\.dismiss) private var dismiss

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                if let image = image {
                    Image(uiImage: image)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .overlay {
                            GeometryReader { proxy in
                                let rect = proxy.frame(in: .named("photoCropView"))
                                
                                Color.clear
                                    .onChange(of: isInteracting) { newValue in
                                        withAnimation(.easeInOut(duration: 0.2)) {
                                            if rect.minX &gt; 0 {
                                                offset.width = (offset.width - rect.minX)
                                            }
                                            if rect.minY &gt; 0 {
                                                offset.height = (offset.height - rect.minY)
                                            }
                                            
                                            if rect.maxX &lt; geometry.size.width {
                                                offset.width = (rect.minX - offset.width)
                                            }
                                            
                                            if rect.maxY &lt; geometry.size.height {
                                                offset.height = (rect.minY - offset.height)
                                            }
                                        }
                                        
                                        if !newValue {
                                            lastStoredOffset = offset
                                        }
                                    }
                            }
                        }
                        .frame(width: geometry.size.width, height: geometry.size.height)
                }
            }
        }
        .offset(offset)
        .scaleEffect(scale)
        .coordinateSpace(name: "photoCropView")
        .gesture(
            DragGesture()
                .updating($isInteracting) { \_, state, \_ in
                    state = true
                }
                .onChanged { value in
                    let translation = value.translation
                    offset = CGSize(width: lastStoredOffset.width + translation.width, height: lastStoredOffset.height + translation.height)
                    
                }
        )
        .gesture(
            MagnificationGesture()
                .updating($isInteracting) { \_, state, \_ in
                    state = true
                }
                .onChanged { value in
                    let updatedScale = value + lastScale
                    scale = (updatedScale &lt; 1 ? 1 : updatedScale)
                }
                .onEnded { value in
                    withAnimation(.easeInOut(duration: 0.2)) {
                        if scale &lt; 1 {
                            scale = 1
                            lastScale = 0
                        } else {
                            lastScale = scale - 1
                        }
                    }
                }
        )
        .frame(width: Constants.frameSize, height: Constants.frameSize)
        .clipShape(.rect(cornerRadius: Constants.frameSize / 2))
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            Color.black
                .ignoresSafeArea()
        )
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    // selectedImage = nil
                    dismiss.callAsFunction()
                } label: {
                    Text("ã‚­ãƒ£ãƒ³ã‚»ãƒ«")
                        .foregroundStyle(.white)
                }
            }
            
            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("é©ç”¨")
                        .foregroundStyle(.white)
                }
            }
        }
        
    }
}

---

## ðŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/7/25 12:55:20*

ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã†ã¾ãå‹•ä½œã—ãªã„åŽŸå› ã¨ã—ã¦ã€åº§æ¨™ã®è¨ˆç®—ã‚„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é©ç”¨æ–¹æ³•ã«å•é¡ŒãŒã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã«ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨åº§æ¨™ã®è¨ˆç®—ã‚’æ”¹å–„ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

1. ç”»åƒãŒç”»é¢å†…ã«æˆ»ã‚‹éš›ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’èª¿æ•´ã™ã‚‹ã€‚
2. ã‚ªãƒ•ã‚»ãƒƒãƒˆã®è¨ˆç®—ã‚’æ­£ç¢ºã«è¡Œã†ã€‚

ä»¥ä¸‹ã«ä¿®æ­£ã—ãŸã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
struct PhotoCropView: View {
    private struct Constants {
        static let frameSize: CGFloat = 300
    }
    
    @Binding var image: UIImage?
    
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 0.0
    @State private var offset: CGSize = .zero
    @State private var lastStoredOffset: CGSize = .zero
    @GestureState private var isInteracting: Bool = false

    @Environment(\.dismiss) private var dismiss

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                if let image = image {
                    Image(uiImage: image)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: geometry.size.width * scale, height: geometry.size.height * scale)
                        .overlay {
                            GeometryReader { proxy in
                                let rect = proxy.frame(in: .named("photoCropView"))
                                
                                Color.clear
                                    .onChange(of: isInteracting) { newValue in
                                        if !newValue {
                                            withAnimation(.easeInOut(duration: 0.2)) {
                                                if rect.minX > 0 {
                                                    offset.width -= rect.minX
                                                }
                                                if rect.minY > 0 {
                                                    offset.height -= rect.minY
                                                }
                                                
                                                if rect.maxX < geometry.size.width {
                                                    offset.width -= (rect.maxX - geometry.size.width)
                                                }
                                                
                                                if rect.maxY < geometry.size.height {
                                                    offset.height -= (rect.maxY - geometry.size.height)
                                                }
                                            }
                                            lastStoredOffset = offset
                                        }
                                    }
                            }
                        }
                }
            }
        }
        .offset(offset)
        .scaleEffect(scale)
        .coordinateSpace(name: "photoCropView")
        .gesture(
            DragGesture()
                .updating($isInteracting) { _, state, _ in
                    state = true
                }
                .onChanged { value in
                    let translation = value.translation
                    offset = CGSize(width: lastStoredOffset.width + translation.width, height: lastStoredOffset.height + translation.height)
                }
        )
        .gesture(
            MagnificationGesture()
                .updating($isInteracting) { _, state, _ in
                    state = true
                }
                .onChanged { value in
                    let updatedScale = value + lastScale
                    scale = (updatedScale < 1 ? 1 : updatedScale)
                }
                .onEnded { value in
                    withAnimation(.easeInOut(duration: 0.2)) {
                        if scale < 1 {
                            scale = 1
                            lastScale = 0
                        } else {
                            lastScale = scale - 1
                        }
                    }
                }
        )
        .frame(width: Constants.frameSize, height: Constants.frameSize)
        .clipShape(RoundedRectangle(cornerRadius: Constants.frameSize / 2))
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            Color.black
                .ignoresSafeArea()
        )
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("ã‚­ãƒ£ãƒ³ã‚»ãƒ«")
                        .foregroundStyle(.white)
                }
            }
            
            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("é©ç”¨")
                        .foregroundStyle(.white)
                }
            }
        }
    }
}
```

å¤‰æ›´ç‚¹ï¼š
- `overlay`å†…ã§ã®åº§æ¨™è¨ˆç®—ã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é©ç”¨ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ä¿®æ­£ã—ã¾ã—ãŸã€‚
- æ‹¡å¤§ç¸®å°ã®è¨ˆç®—ã‚’ã‚ˆã‚Šç›´æ„Ÿçš„ã«ã—ã¾ã—ãŸã€‚

ã“ã‚Œã§ã€ç”»åƒãŒæ‹¡å¤§ã—ãŸã¾ã¾ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç§»å‹•ã•ã›ãŸå ´åˆã€æ­£ã—ãã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ç”»é¢å†…ã«æˆ»ã‚‹ã¯ãšã§ã™ã€‚

---

## ðŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/7/25 12:55:53*

å¤‰ãˆãŸå ´æ‰€ã‚’æ•™ãˆã¦ã»ã—ã„

---

## ðŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/7/25 12:56:11*

ä»¥ä¸‹ã«ã€å¤‰æ›´ã—ãŸå ´æ‰€ã¨ãã®å†…å®¹ã‚’èª¬æ˜Žã—ã¾ã™ã€‚

### å¤‰æ›´ç‚¹

1. **`frame`ã®é©ç”¨ç®‡æ‰€ã‚’å¤‰æ›´**  
   å…ƒã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`Image`ã®ã‚µã‚¤ã‚ºã‚’`geometry.size`ã«åŸºã¥ã„ã¦è¨­å®šã—ã¦ã„ã¾ã—ãŸãŒã€å¤‰æ›´å¾Œã¯`scale`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«åŸºã¥ã„ã¦è¨ˆç®—ã•ã‚ŒãŸã‚µã‚¤ã‚ºã«å¤‰æ›´ã—ã¾ã—ãŸã€‚

2. **`onChange`ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¨æ¡ä»¶ã®ä¿®æ­£**  
   `isInteracting`ãŒ`false`ã«ãªã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨ã—ã€ç”»åƒãŒç”»é¢å†…ã«åŽã¾ã‚‹ã‚ˆã†ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä¿®æ­£ã—ã¾ã—ãŸã€‚

### ä¿®æ­£å‰

```swift
Image(uiImage: image)
    .resizable()
    .aspectRatio(contentMode: .fill)
    .overlay {
        GeometryReader { proxy in
            let rect = proxy.frame(in: .named("photoCropView"))
            Color.clear
                .onChange(of: isInteracting) { newValue in
                    withAnimation(.easeInOut(duration: 0.2)) {
                        if rect.minX > 0 {
                            offset.width = (offset.width - rect.minX)
                        }
                        if rect.minY > 0 {
                            offset.height = (offset.height - rect.minY)
                        }
                        if rect.maxX < geometry.size.width {
                            offset.width = (rect.minX - offset.width)
                        }
                        if rect.maxY < geometry.size.height {
                            offset.height = (rect.minY - offset.height)
                        }
                    }
                    if !newValue {
                        lastStoredOffset = offset
                    }
                }
        }
    }
    .frame(width: geometry.size.width, height: geometry.size.height)
```

### ä¿®æ­£å¾Œ

```swift
Image(uiImage: image)
    .resizable()
    .aspectRatio(contentMode: .fill)
    .frame(width: geometry.size.width * scale, height: geometry.size.height * scale)
    .overlay {
        GeometryReader { proxy in
            let rect = proxy.frame(in: .named("photoCropView"))
            Color.clear
                .onChange(of: isInteracting) { newValue in
                    if !newValue {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            if rect.minX > 0 {
                                offset.width -= rect.minX
                            }
                            if rect.minY > 0 {
                                offset.height -= rect.minY
                            }
                            if rect.maxX < geometry.size.width {
                                offset.width -= (rect.maxX - geometry.size.width)
                            }
                            if rect.maxY < geometry.size.height {
                                offset.height -= (rect.maxY - geometry.size.height)
                            }
                        }
                        lastStoredOffset = offset
                    }
                }
        }
    }
```

### ä¸»ãªå¤‰æ›´ç‚¹ã®ãƒã‚¤ãƒ³ãƒˆ

1. `frame(width: geometry.size.width * scale, height: geometry.size.height * scale)`ã«ã‚ˆã‚Šã€æ‹¡å¤§ç¸®å°æ™‚ã®ç”»åƒã‚µã‚¤ã‚ºã‚’èª¿æ•´ã—ã¾ã—ãŸã€‚
2. `onChange(of: isInteracting)`å†…ã®æ¡ä»¶ã‚’å¤‰æ›´ã—ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒ`isInteracting`ãŒ`false`ã«ãªã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ‰ãƒ©ãƒƒã‚°ã‚„ãƒ”ãƒ³ãƒã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã®æ“ä½œãŒçµ‚äº†ã—ãŸã¨ãã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

ã“ã‚Œã‚‰ã®å¤‰æ›´ã«ã‚ˆã‚Šã€ç”»åƒãŒç”»é¢å†…ã«æˆ»ã‚‹éš›ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¹ãƒ ãƒ¼ã‚ºã«å®Ÿè¡Œã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚

---
