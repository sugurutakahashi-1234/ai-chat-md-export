# éŸ³å£°å…¥åŠ›è¨­å®šæŒ‡å—

æ—¥ä»˜: 2024-05-07

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 9:54:58*

iOSã‚¢ãƒ—ãƒªã§ãƒã‚¤ã‚¯ã‹ã‚‰ã®éŸ³å£°å…¥åŠ›ã‚’ã•ã›ãŸã„ã€‚
ã‚„ã‚‰ãªã‘ã‚Œã°ãªã‚‰ãªã„è¨­å®šã‚’æ•™ãˆã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 9:55:42*

iOSã‚¢ãƒ—ãƒªã§ãƒã‚¤ã‚¯ã‹ã‚‰ã®éŸ³å£°å…¥åŠ›ã‚’åˆ©ç”¨ã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®æ‰‹é †ã«å¾“ã£ã¦è¨­å®šã‚’è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

1. **ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼è¨­å®šã®è¿½åŠ **:
   iOSã¯ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã‚’é‡è¦–ã—ã¦ã„ã‚‹ãŸã‚ã€ã‚¢ãƒ—ãƒªãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒã‚¤ã‚¯ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€äº‹å‰ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¨±å¯ã‚’å¾—ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚`Info.plist`ãƒ•ã‚¡ã‚¤ãƒ«ã«`NSMicrophoneUsageDescription`ã‚­ãƒ¼ã‚’è¿½åŠ ã—ã€ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã®ç›®çš„ã‚’èª¬æ˜ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¨­å®šã—ã¾ã™ã€‚

   ```xml
   <key>NSMicrophoneUsageDescription</key>
   <string>ã“ã®ã‚¢ãƒ—ãƒªã¯ã€éŸ³å£°èªè­˜ã®ãŸã‚ã«ãƒã‚¤ã‚¯ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒå¿…è¦ã§ã™ã€‚</string>
   ```

2. **ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã®è¨±å¯ã‚’æ±‚ã‚ã‚‹**:
   ã‚¢ãƒ—ãƒªå†…ã§`AVFoundation`ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã—ã¦ã€ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã®è¨±å¯ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æ±‚ã‚ã¾ã™ã€‚ä¾‹ãˆã°ã€`AVAudioSession`ã‚’ä½¿ã£ã¦ã€ãƒã‚¤ã‚¯ã®ä½¿ç”¨è¨±å¯ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ çš„ã«è¦æ±‚ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

   ```swift
   import AVFoundation

   func requestMicrophoneAccess() {
       switch AVAudioSession.sharedInstance().recordPermission {
       case .granted:
           // è¨±å¯æ¸ˆã¿ã®å ´åˆ
           break
       case .denied:
           // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æ‹’å¦ã•ã‚ŒãŸå ´åˆ
           break
       case .undetermined:
           // ã¾ã ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å°‹ã­ã¦ã„ãªã„å ´åˆ
           AVAudioSession.sharedInstance().requestRecordPermission { granted in
               if granted {
                   // è¨±å¯ã•ã‚ŒãŸå ´åˆ
               } else {
                   // è¨±å¯ã•ã‚Œãªã‹ã£ãŸå ´åˆ
               }
           }
       default:
           break
       }
   }
   ```

3. **ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®è¨­å®š**:
   ãƒã‚¤ã‚¯ã‹ã‚‰ã®å…¥åŠ›ã‚’å—ã‘å–ã‚‹ãŸã‚ã«ã¯ã€é©åˆ‡ãªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚«ãƒ†ã‚´ãƒªã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚é€šå¸¸ã€`playAndRecord`ã‚«ãƒ†ã‚´ãƒªãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

   ```swift
   func setupAudioSession() {
       do {
           try AVAudioSession.sharedInstance().setCategory(.playAndRecord, mode: .default)
           try AVAudioSession.sharedInstance().setActive(true)
       } catch {
           print("Failed to set audio session category. \(error)")
       }
   }
   ```

ã“ã‚Œã‚‰ã®è¨­å®šã‚’è¡Œã£ãŸå¾Œã€ãƒã‚¤ã‚¯ã‹ã‚‰ã®éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã«ã¯ã€`AVAudioRecorder`ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§éŸ³å£°ã‚’å‡¦ç†ã™ã‚‹å ´åˆã¯`AVAudioEngine`ã‚’ä½¿ç”¨ã™ã‚‹ãªã©ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œãã‚Œã®ã‚±ãƒ¼ã‚¹ã«åˆã‚ã›ã¦å®Ÿè£…ã‚’é€²ã‚ã¦ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 10:51:21*

éŒ²éŸ³ã—ã‚ˆã†ã¨ã—ãŸã‚‰ã€AddInstanceForFactory: No factory registered for id &lt;CFUUID 0x6000002ceea0&gt; F8BB1C28-BAE8-11D6-9C31-00039315CD46ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã«ãªã£ãŸ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 10:52:23*

ã“ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ `AddInstanceForFactory: No factory registered for id <CFUUID 0x6000002ceea0> F8BB1C28-BAE8-11D6-9C31-00039315CD46` ã¯ã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®è¨­å®šãŒé©åˆ‡ã«è¡Œã‚ã‚Œã¦ã„ãªã„ã‹ã€ä½•ã‹ãŒæ­£ã—ãåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã«ç™ºç”Ÿã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—ã§å•é¡Œã‚’è§£æ±ºã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

1. **ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®è¨­å®šç¢ºèª**:
   - ã‚¢ãƒ—ãƒªãŒã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é©åˆ‡ã«è¨­å®šã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚ç‰¹ã«ã€`setCategory` ã¨ `setActive` ã®å‘¼ã³å‡ºã—ãŒæ­£ã—ã„ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚

2. **ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã¯ãªãå®Ÿæ©Ÿã§ãƒ†ã‚¹ãƒˆ**:
   - iOSã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–¢é€£ã®æ©Ÿèƒ½ã¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã¯é™å®šçš„ã§ã™ã€‚å®Ÿæ©Ÿã§ã®ãƒ†ã‚¹ãƒˆã‚’è¡Œã†ã“ã¨ã§ã€å•é¡ŒãŒè§£æ±ºã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

3. **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã¨ãƒ“ãƒ«ãƒ‰**:
   - Xcodeã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªãƒ¼ãƒ³ã—ã¦ã‹ã‚‰å†ãƒ“ãƒ«ãƒ‰ã‚’è©¦ã¿ã¦ãã ã•ã„ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒåŸå› ã§èµ·ãã‚‹å•é¡Œã‚’è§£æ¶ˆã§ãã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

4. **ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®ç¢ºèª**:
   - ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ‡ãƒã‚¤ã‚¹ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå…¥åŠ›ãŒæ­£å¸¸ã«æ©Ÿèƒ½ã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚

5. **æœ€å°é™ã®ã‚³ãƒ¼ãƒ‰ã§ã®ãƒ†ã‚¹ãƒˆ**:
   - æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¦ã€æœ€å°é™ã®ã‚³ãƒ¼ãƒ‰ã§ãƒã‚¤ã‚¯å…¥åŠ›ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã“ã¨ã§ã€å•é¡ŒãŒã‚³ãƒ¼ãƒ‰ã«ç”±æ¥ã™ã‚‹ã®ã‹ã€ç’°å¢ƒã«å•é¡ŒãŒã‚ã‚‹ã®ã‹ã‚’åˆ¤æ–­ã§ãã¾ã™ã€‚

ã“ã“ã«ç°¡å˜ãªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

```swift
import AVFoundation

class AudioRecorder {

    var audioRecorder: AVAudioRecorder?

    func setupAudioSession() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playAndRecord, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            startRecording()
        } catch {
            print("Failed to set audio session category. \(error)")
        }
    }

    func startRecording() {
        let audioFilename = getDocumentsDirectory().appendingPathComponent("recording.m4a")

        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.record()
        } catch {
            print("Could not start recording: \(error)")
        }
    }

    func getDocumentsDirectory() -> URL {
        let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
        return paths[0]
    }
}
```

ã“ã®ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’è¨­å®šã—ã€ç°¡å˜ãªãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’é–‹å§‹ã§ãã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å ´åˆã¯ã€æä¾›ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’åŸºã«ã•ã‚‰ã«ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 10:55:06*

stop ãƒ¬ã‚³ãƒ¼ãƒ‰å‡¦ç†ã‚’æ›¸ã„ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 10:55:46*

ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’åœæ­¢ã™ã‚‹ãŸã‚ã®å‡¦ç†ã‚’è¿½åŠ ã™ã‚‹ã«ã¯ã€`AVAudioRecorder` ã® `stop` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã«ã€å…ˆã»ã©ã®ã‚¯ãƒ©ã‚¹ã«ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’åœæ­¢ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ãŸä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
import AVFoundation

class AudioRecorder {

    var audioRecorder: AVAudioRecorder?

    func setupAudioSession() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playAndRecord, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            startRecording()
        } catch {
            print("Failed to set audio session category. \(error)")
        }
    }

    func startRecording() {
        let audioFilename = getDocumentsDirectory().appendingPathComponent("recording.m4a")

        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.record()
        } catch {
            print("Could not start recording: \(error)")
        }
    }

    func stopRecording() {
        audioRecorder?.stop()
        try? AVAudioSession.sharedInstance().setActive(false)
        print("Recording stopped.")
    }

    func getDocumentsDirectory() -> URL {
        let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
        return paths[0]
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ä»¥ä¸‹ã®å¤‰æ›´ã‚’åŠ ãˆã¦ã„ã¾ã™ï¼š

- `stopRecording()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€`audioRecorder` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® `stop` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’åœæ­¢ã—ã¾ã™ã€‚ãã®å¾Œã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«è¨­å®šã—ã¦ã€ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾ã—ã¾ã™ã€‚

- `print("Recording stopped.")` ã‚’è¿½åŠ ã—ã¦ã€ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒåœæ­¢ã—ãŸã“ã¨ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤ºã—ã¾ã™ã€‚

ã“ã®ã‚¯ãƒ©ã‚¹ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€iOSãƒ‡ãƒã‚¤ã‚¹ä¸Šã§ç°¡å˜ã«éŸ³å£°ã®éŒ²éŸ³ã¨åœæ­¢ãŒè¡Œãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ä½¿ç”¨ã™ã‚‹éš›ã¯ã€é©åˆ‡ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ `startRecording()` ã¨ `stopRecording()` ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 10:56:45*

ãƒ¬ã‚³ãƒ¼ãƒ‰ã—ãŸéŸ³æºã‚’ä¸€è¦§è¡¨ç¤ºã™ã‚‹SwiftUIã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 10:57:33*

éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€è¦§ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®SwiftUIãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã€ãƒªã‚¹ãƒˆã§è¡¨ç¤ºã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒªã‚¹ãƒˆã®é …ç›®ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ã€ãã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†ç”Ÿã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãªæ©Ÿèƒ½ã‚‚å«ã‚ã¦ã„ã¾ã™ã€‚

ã¾ãšã¯ã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®å†ç”Ÿã‚’æ‹…å½“ã™ã‚‹å˜ç´”ãªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚

```swift
import SwiftUI
import AVFoundation

class AudioPlayer: ObservableObject {
    var player: AVAudioPlayer?

    func playAudio(from url: URL) {
        do {
            player = try AVAudioPlayer(contentsOf: url)
            player?.play()
        } catch {
            print("Audio playback failed: \(error)")
        }
    }
}
```

æ¬¡ã«ã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€è¦§ã‚’å–å¾—ã—è¡¨ç¤ºã™ã‚‹SwiftUIãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚

```swift
struct AudioListView: View {
    @State private var audioFiles: [URL] = []
    @ObservedObject var audioPlayer = AudioPlayer()

    var body: some View {
        NavigationView {
            List(audioFiles, id: \.self) { fileUrl in
                Button(action: {
                    self.audioPlayer.playAudio(from: fileUrl)
                }) {
                    Text(fileUrl.lastPathComponent)
                        .padding()
                }
            }
            .navigationBarTitle("Recordings")
            .onAppear {
                loadAudioFiles()
            }
        }
    }

    func loadAudioFiles() {
        let fileManager = FileManager.default
        let documentsPath = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!
        do {
            let audioFilePaths = try fileManager.contentsOfDirectory(at: documentsPath, includingPropertiesForKeys: nil)
            audioFiles = audioFilePaths.filter { $0.pathExtension == "m4a" }
        } catch {
            print("Failed to read audio files: \(error)")
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ä»¥ä¸‹ã®æ©Ÿèƒ½ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ï¼š

- `AudioListView` ã¯éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€è¦§è¡¨ç¤ºã™ã‚‹ãƒ“ãƒ¥ãƒ¼ã§ã™ã€‚ãƒªã‚¹ãƒˆå†…ã®å„é …ç›®ã¯ãƒœã‚¿ãƒ³ã¨ã—ã¦è¡¨ç¤ºã•ã‚Œã€ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨å¯¾å¿œã™ã‚‹éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒå†ç”Ÿã•ã‚Œã¾ã™ã€‚
- `loadAudioFiles` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ `.m4a` æ‹¡å¼µå­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã¦ãƒªã‚¹ãƒˆã«ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚
- `AudioPlayer` ã‚¯ãƒ©ã‚¹ã¯ã€æŒ‡å®šã•ã‚ŒãŸURLã‹ã‚‰éŸ³å£°ã‚’å†ç”Ÿã—ã¾ã™ã€‚

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®é©åˆ‡ãªå ´æ‰€ã«ãƒ“ãƒ¥ãƒ¼ã‚’é…ç½®ã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ­ãƒ¼ã«çµ„ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 11:40:41*

iOSæ¨™æº–ã®ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¢ãƒ—ãƒªã®ã‚ˆã†ãªç”»é¢ã‚’å®Ÿè£…ã—ã¦ã»ã—ã„ã€‚

SwiftUI ã§ãªã‚‹ã¹ããƒ¢ãƒ€ãƒ³ãªå®Ÿè£…ã‚’ã—ã¦ã»ã—ã„ã€‚

æ©Ÿèƒ½ã¨ã—ã¦ã¯ä»¥ä¸‹ã§ã‚ã‚‹


- ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®é–‹å§‹
- ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®åœæ­¢
- ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æƒ…å ±ã®ä¸€è¦§ã®è¡¨ç¤º
- ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ãŸãƒ‡ãƒ¼ã‚¿ã®å†ç”Ÿã®é–‹å§‹
- ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ãŸãƒ‡ãƒ¼ã‚¿ã®å†ç”Ÿã®åœæ­¢
- ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æƒ…å ±ã®å‰Šé™¤

ãŸã ã—ã€ä¸Š2ã¤ã¨ä¸‹4ã¤ã¯ç”»é¢ã‚’åˆ†ã‘ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 11:41:41*

iOSæ¨™æº–ã®ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¢ãƒ—ãƒªã®ã‚ˆã†ãªæ©Ÿèƒ½ã‚’æŒã¤ã‚¢ãƒ—ãƒªã‚’SwiftUIã§å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®2ã¤ã®ä¸»è¦ãªãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¾ã™ï¼š

1. **ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ“ãƒ¥ãƒ¼**ï¼šãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®é–‹å§‹ã¨åœæ­¢ã‚’è¡Œã„ã¾ã™ã€‚
2. **ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒªã‚¹ãƒˆãƒ“ãƒ¥ãƒ¼**ï¼šãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ãŸãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§è¡¨ç¤ºã€å†ç”Ÿã€å‰Šé™¤ã‚’è¡Œã„ã¾ã™ã€‚

ã¾ãšã€å…±é€šã§ä½¿ç”¨ã™ã‚‹`AudioRecorder`ã‚¯ãƒ©ã‚¹ã¨`AudioPlayer`ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¾ã™ã€‚

### AudioRecorder.swift
```swift
import Foundation
import AVFoundation

class AudioRecorder: ObservableObject {
    var audioRecorder: AVAudioRecorder?
    @Published var recordings = [Recording]()

    func startRecording() {
        let audioFilename = getDocumentsDirectory().appendingPathComponent("\(Date().toString(dateFormat: "dd-MM-YY_'at'_HH:mm:ss")).m4a")

        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.record()
        } catch {
            print("Could not start recording: \(error)")
        }
    }

    func stopRecording() {
        audioRecorder?.stop()
        loadRecordings()
    }

    func loadRecordings() {
        recordings = FileManager.default.fetchRecordings()
    }

    private func getDocumentsDirectory() -> URL {
        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    }
}
```

### AudioPlayer.swift
```swift
import Foundation
import AVFoundation

class AudioPlayer: ObservableObject {
    var player: AVAudioPlayer?

    func playAudio(_ recording: Recording) {
        do {
            player = try AVAudioPlayer(contentsOf: recording.fileURL)
            player?.play()
        } catch {
            print("Playback failed: \(error)")
        }
    }

    func stopAudio() {
        player?.stop()
    }
}
```

### Recording.swift
```swift
import Foundation

struct Recording {
    let fileURL: URL
    let createdAt: Date

    var fileName: String {
        fileURL.lastPathComponent
    }
}
```

### RecorderView.swift
```swift
import SwiftUI

struct RecorderView: View {
    @ObservedObject var audioRecorder: AudioRecorder

    var body: some View {
        VStack {
            Button(action: {
                if audioRecorder.audioRecorder == nil {
                    audioRecorder.startRecording()
                } else {
                    audioRecorder.stopRecording()
                }
            }) {
                Image(systemName: audioRecorder.audioRecorder == nil ? "record.circle" : "stop.circle")
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(width: 70, height: 70)
                    .clipped()
                    .foregroundColor(.red)
            }
            .padding()
        }
        .navigationBarTitle("Recorder")
    }
}
```

### AudioListView.swift
```swift
import SwiftUI

struct AudioListView: View {
    @ObservedObject var audioRecorder: AudioRecorder
    @ObservedObject var audioPlayer: AudioPlayer

    var body: some View {
        List {
            ForEach(audioRecorder.recordings, id: \.fileName) { recording in
                HStack {
                    Text(recording.fileName)
                    Spacer()
                    Button(action: {
                        audioPlayer.playAudio(recording)
                    }) {
                        Image(systemName: "play.circle")
                    }
                    Button(action: {
                        audioRecorder.deleteRecording(recording)
                    }) {
                        Image(systemName: "trash")
                    }
                }
            }
        }
        .onAppear(perform: audioRecorder.loadRecordings)
        .navigationBarTitle("Recordings")
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã«ã¯ã€SwiftUIãƒ“ãƒ¥ãƒ¼ã§ã®ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ“ä½œã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å†ç”Ÿã€ãŠã‚ˆã³å‰Šé™¤æ©Ÿèƒ½ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚FileManageræ‹¡å¼µã§ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚’è£œåŠ©ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã€é©åˆ‡ã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã§å‡¦ç†ã—ã¦ãã ã•ã„ã€‚å„ãƒ“ãƒ¥ãƒ¼ã¯ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒªãƒ³ã‚¯ã¾ãŸã¯ã‚¿ãƒ–ã§åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 11:51:59*

ä»¥ä¸‹ã®å‡¦ç†ã£ã¦ã„ã‚‰ãªã„ã®ï¼Ÿ

try AVAudioSession.sharedInstance().setCategory(.playAndRecord, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 11:52:47*

ã¯ã„ã€ãã®é€šã‚Šã§ã™ã€‚iOSã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªéŒ²éŸ³ã‚„å†ç”Ÿã‚’è¡Œã†å ´åˆã€`AVAudioSession` ã®è¨­å®šã¯éå¸¸ã«é‡è¦ã§ã™ã€‚ç‰¹ã«ã€ãƒã‚¤ã‚¯ã‹ã‚‰ã®éŒ²éŸ³ã‚’è¡Œã†å ´åˆã«ã¯ `AVAudioSession` ã‚’é©åˆ‡ã«è¨­å®šã—ã¦ã€ã‚¢ãƒ—ãƒªãŒã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’ã‚·ã‚¹ãƒ†ãƒ ã«ä¼ãˆã€ä»–ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã¨ã®å„ªå…ˆé †ä½ã‚’ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

`AudioRecorder`ã‚¯ãƒ©ã‚¹ã®ä¸­ã«`AVAudioSession`ã®è¨­å®šã‚’çµ„ã¿è¾¼ã‚€ä¾‹ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚éŒ²éŸ³é–‹å§‹å‰ã«ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚«ãƒ†ã‚´ãƒªã‚’è¨­å®šã—ã€éŒ²éŸ³ãŒçµ‚äº†ã—ãŸå¾Œã«ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹å‡¦ç†ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚

### AudioRecorder.swiftï¼ˆæ›´æ–°ç‰ˆï¼‰
```swift
import Foundation
import AVFoundation

class AudioRecorder: ObservableObject {
    var audioRecorder: AVAudioRecorder?
    @Published var recordings = [Recording]()

    func startRecording() {
        let audioFilename = getDocumentsDirectory().appendingPathComponent("\(Date().toString(dateFormat: "dd-MM-YY_'at'_HH:mm:ss")).m4a")
        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            try AVAudioSession.sharedInstance().setCategory(.playAndRecord, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.record()
        } catch {
            print("Failed to start recording: \(error)")
        }
    }

    func stopRecording() {
        audioRecorder?.stop()
        try? AVAudioSession.sharedInstance().setActive(false)
        loadRecordings()
    }

    func loadRecordings() {
        recordings = FileManager.default.fetchRecordings()
    }

    private func getDocumentsDirectory() -> URL {
        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€éŒ²éŸ³ã‚’é–‹å§‹ã™ã‚‹å‰ã«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚«ãƒ†ã‚´ãƒªã‚’ `playAndRecord` ã«è¨­å®šã—ã¦ã€ã‚¢ãƒ—ãƒªãŒå†ç”Ÿã¨éŒ²éŸ³ã®ä¸¡æ–¹ã‚’è¡Œã†ã“ã¨ã‚’ã‚·ã‚¹ãƒ†ãƒ ã«ä¼ãˆã¦ã„ã¾ã™ã€‚ã¾ãŸã€éŒ²éŸ³ãŒçµ‚äº†ã—ãŸå¾Œã«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹ã“ã¨ã§ã€ä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’ä½¿ç”¨ã™ã‚‹éš›ã®ç«¶åˆã‚’é˜²ãã¾ã™ã€‚

ã“ã®ã‚ˆã†ã«è¨­å®šã™ã‚‹ã“ã¨ã§ã€ã‚¢ãƒ—ãƒªã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªæ©Ÿèƒ½ãŒã‚ˆã‚Šå®‰å®šã—ã€ä»–ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚½ãƒ¼ã‚¹ã¨ã®å¹²æ¸‰ã‚’é¿ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 15:27:18*

fetchRecordings ã£ã¦ãªã«ï¼Ÿã‚ã¨ã€m4a ã ã‘ã§ã¯ãªãä»¥ä¸‹ã®ã‚ˆã†ãªenumã§å®šç¾©ã—ãŸæ‹¡å¼µå­ã«å¯¾å¿œã—ãŸã„ã€‚

public enum AudioFileExtension: String {
    case m4a
    case mp3
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 15:28:23*

`fetchRecordings` ã¯ã€ã“ã“ã§ã¯ä»®ã«å®šç¾©ã—ãŸé–¢æ•°ã§ã€ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹ç›®çš„ã§ä½¿ã‚ã‚Œã¾ã™ã€‚å®Ÿéš›ã«ã¯ã€ã“ã®é–¢æ•°ã®å®Ÿè£…ãŒå¿…è¦ã§ã™ã€‚

ã¾ãŸã€æŒ‡å®šã•ã‚ŒãŸ `AudioFileExtension` enumã‚’ä½¿ã£ã¦ã€ç•°ãªã‚‹ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ï¼ˆ`.m4a` ã¨ `.mp3`ï¼‰ã®éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†ã“ã¨ã‚‚è€ƒæ…®ã—ã¾ã™ã€‚ä»¥ä¸‹ã«ã€FileManagerã‚’æ‹¡å¼µã—ã¦éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ•ã‚§ãƒƒãƒã™ã‚‹æ–¹æ³•ã¨ã€`AudioRecorder` ã‚¯ãƒ©ã‚¹ã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’ç¤ºã—ã¾ã™ã€‚

### FileManagerã®æ‹¡å¼µ
```swift
import Foundation

extension FileManager {
    func fetchRecordings() -> [Recording] {
        let documentsPath = urls(for: .documentDirectory, in: .userDomainMask).first!
        do {
            let audioFiles = try contentsOfDirectory(at: documentsPath, includingPropertiesForKeys: nil)
            return audioFiles.filter { $0.pathExtension == AudioFileExtension.m4a.rawValue || $0.pathExtension == AudioFileExtension.mp3.rawValue }
                           .map { Recording(fileURL: $0, createdAt: getFileCreationDate(url: $0) ?? Date()) }
        } catch {
            print("Failed to read audio files: \(error)")
            return []
        }
    }

    private func getFileCreationDate(url: URL) -> Date? {
        try? url.resourceValues(forKeys: [.creationDateKey]).creationDate
    }
}
```

### AudioRecorder.swiftï¼ˆæ›´æ–°ç‰ˆï¼‰
```swift
import Foundation
import AVFoundation

class AudioRecorder: ObservableObject {
    var audioRecorder: AVAudioRecorder?
    @Published var recordings = [Recording]()

    func startRecording(fileExtension: AudioFileExtension = .m4a) {
        let audioFilename = getDocumentsDirectory().appendingPathComponent("\(Date().toString(dateFormat: "dd-MM-YY_'at'_HH:mm:ss")).\(fileExtension.rawValue)")
        let settings = [
            AVFormatIDKey: fileExtension == .m4a ? Int(kAudioFormatMPEG4AAC) : Int(kAudioFormatMPEGLayer3),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            try AVAudioSession.sharedInstance().setCategory(.playAndRecord, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.record()
        } catch {
            print("Failed to start recording: \(error)")
        }
    }

    func stopRecording() {
        audioRecorder?.stop()
        try? AVAudioSession.sharedInstance().setActive(false)
        loadRecordings()
    }

    func loadRecordings() {
        recordings = FileManager.default.fetchRecordings()
    }

    private func getDocumentsDirectory() -> URL {
        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ä»¥ä¸‹ã®æ©Ÿèƒ½ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ï¼š
- `fetchRecordings` é–¢æ•°ã¯ `FileManager` ã®æ‹¡å¼µã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ãŠã‚Šã€æŒ‡å®šã•ã‚ŒãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã®éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã¾ã™ã€‚
- `AudioRecorder` ã«ã¯ã€éŒ²éŸ³ã‚’é–‹å§‹ã™ã‚‹éš›ã«ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã® `fileExtension` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚ã¾ãŸã€é©åˆ‡ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆIDã‚’è¨­å®šã™ã‚‹ãŸã‚ã®æ¡ä»¶åˆ†å²ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ `.m4a` ã¨ `.mp3` å½¢å¼ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’éŒ²éŸ³ã—ã€ç®¡ç†ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 15:28:53*

getFileCreationDate ã¯ãªã‚“ã®ãŸã‚ã«è¡Œã‚ã‚Œã¦ã„ã‚‹ã®ï¼Ÿ

ã‚ã¨ã§ãã‚‹ã ã‘å¤šãã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚‚ç”»é¢ã«è¡¨ç¤ºã—ãŸã„ã¨æ€ã†

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 15:29:58*

`getFileCreationDate`é–¢æ•°ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒä½œæˆã•ã‚ŒãŸæ—¥ä»˜ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã«ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆæ—¥ã‚’è¡¨ç¤ºã—ãŸã„å ´åˆã«å½¹ç«‹ã¡ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€è¦§è¡¨ç¤ºæ™‚ã«ä½œæˆæ—¥ã ã‘ã§ãªãã€ä»–ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚‚è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒå¤šãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§æ±‚ã‚ã‚‰ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®é•·ã•ï¼ˆå†ç”Ÿæ™‚é–“ï¼‰ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã€ãƒ“ãƒƒãƒˆãƒ¬ãƒ¼ãƒˆãªã©ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚

### ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹æ–¹æ³•
ä»¥ä¸‹ã¯ã€éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚ˆã‚Šè©³ç´°ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã€ãã‚Œã‚‰ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®UIã«è¡¨ç¤ºã™ã‚‹æ–¹æ³•ã‚’ç¤ºã™ã‚³ãƒ¼ãƒ‰ä¾‹ã§ã™ã€‚

1. **ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã‚’æ‹…ã†é–¢æ•°ã®å®šç¾©**
    - ä½œæˆæ—¥æ™‚ã ã‘ã§ãªãã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚„å†ç”Ÿæ™‚é–“ã‚‚å–å¾—ã—ã¾ã™ã€‚

2. **`Recording`æ§‹é€ ä½“ã‚’æ›´æ–°ã—ã¦ã€æ–°ãŸã«å–å¾—ã™ã‚‹ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚**

### FileManagerã®æ‹¡å¼µï¼ˆæ›´æ–°ç‰ˆï¼‰
```swift
import AVFoundation

extension FileManager {
    func fetchRecordings() -> [Recording] {
        let documentsPath = urls(for: .documentDirectory, in: .userDomainMask).first!
        do {
            let audioFiles = try contentsOfDirectory(at: documentsPath, includingPropertiesForKeys: nil)
            return audioFiles.map { fileURL -> Recording? in
                let attributes = try? attributesOfItem(atPath: fileURL.path)
                let fileSize = attributes?[.size] as? Int64
                let creationDate = attributes?[.creationDate] as? Date
                let duration = getAudioDuration(fileURL: fileURL)
                return Recording(fileURL: fileURL, createdAt: creationDate ?? Date(), fileSize: fileSize, duration: duration)
            }
            .compactMap { $0 }
        } catch {
            print("Failed to read audio files: \(error)")
            return []
        }
    }

    private func getAudioDuration(fileURL: URL) -> TimeInterval {
        let asset = AVURLAsset(url: fileURL)
        return CMTimeGetSeconds(asset.duration)
    }
}
```

### Recording.swiftï¼ˆæ›´æ–°ç‰ˆï¼‰
```swift
import Foundation

struct Recording {
    let fileURL: URL
    let createdAt: Date
    let fileSize: Int64?
    let duration: TimeInterval

    var fileName: String {
        fileURL.lastPathComponent
    }

    var formattedSize: String {
        guard let fileSize = fileSize else { return "Unknown size" }
        if fileSize < 1024 {
            return "\(fileSize) bytes"
        } else if fileSize < 1024 * 1024 {
            return "\(fileSize / 1024) KB"
        } else {
            return "\(fileSize / (1024 * 1024)) MB"
        }
    }

    var formattedDuration: String {
        let hours = Int(duration / 3600)
        let minutes = Int((duration / 60).truncatingRemainder(dividingBy: 60))
        let seconds = Int(duration.truncatingRemainder(dividingBy: 60))
        if hours > 0 {
            return String(format: "%02i:%02i:%02i", hours, minutes, seconds)
        } else {
            return String(format: "%02i:%02i", minutes, seconds)
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã«ã‚ˆã‚Šã€å„éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆæ—¥ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã€å†ç”Ÿæ™‚é–“ã‚’å–å¾—ã—ã€ã“ã‚Œã‚‰ã®æƒ…å ±ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚FileManagerã®æ‹¡å¼µã‚’é€šã˜ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã«é–¢ã™ã‚‹è©³ç´°æƒ…å ±ã‚’ä¸€è¦§ã§è¦‹ã‚„ã™ãè¡¨ç¤ºã™ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 15:38:12*

Recording ã‚’ AudioMetadata ã«ã—ã¦ã»ã—ã„ã€‚ç‰¹å®šã®ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ç‰¹å®šã®æ‹¡å¼µå­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡ºã™ã‚‹ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã¯ãªã„ã®ã‹ï¼Ÿ
fileSize: Int64? ã‚’ Int ã«ã—ã¦ã»ã—ã„ã€‚ä¸æ˜ãªå ´åˆã¯ 0 ç§’ã§ã‚ˆã„ã€‚formattedSize ã‚„  formattedDuration ã¯å…¬å¼ã®é–¢æ•°ãªã©ã§æä¾›ã•ã‚Œã¦ã„ãªã„ã®ã‹ï¼Ÿ

å‰²ã‚Šç®—ã¯quotientAndRemainderã‚’ä½¿ã£ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 15:39:14*

æ§‹é€ ä½“åã‚’`Recording`ã‹ã‚‰`AudioMetadata`ã«å¤‰æ›´ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’`Int64?`ã‹ã‚‰`Int`ã«å¤‰æ›´ã—ã€`FileManager`ã®æ‹¡å¼µã§ç‰¹å®šã®ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ç‰¹å®šã®æ‹¡å¼µå­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡ºã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚ã¾ãŸã€`formattedSize`ã¨`formattedDuration`ã‚’ã‚ˆã‚Šæ­£ç¢ºã«è¨ˆç®—ã™ã‚‹ãŸã‚ã«`quotientAndRemainder`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

### FileManagerã®æ‹¡å¼µï¼ˆæ›´æ–°ç‰ˆï¼‰

```swift
import AVFoundation

extension FileManager {
    func fetchAudioMetadata(folder: URL, extensions: [AudioFileExtension]) -> [AudioMetadata] {
        do {
            let audioFiles = try contentsOfDirectory(at: folder, includingPropertiesForKeys: nil)
            return audioFiles.filter { fileURL in
                extensions.contains { $0.rawValue == fileURL.pathExtension }
            }
            .compactMap { fileURL -> AudioMetadata? in
                let attributes = try? attributesOfItem(atPath: fileURL.path)
                let fileSize = (attributes?[.size] as? Int) ?? 0
                let creationDate = attributes?[.creationDate] as? Date ?? Date()
                let duration = getAudioDuration(fileURL: fileURL)
                return AudioMetadata(fileURL: fileURL, createdAt: creationDate, fileSize: fileSize, duration: duration)
            }
        } catch {
            print("Failed to read audio files: \(error)")
            return []
        }
    }

    private func getAudioDuration(fileURL: URL) -> TimeInterval {
        let asset = AVURLAsset(url: fileURL)
        return CMTimeGetSeconds(asset.duration)
    }
}
```

### AudioMetadata.swiftï¼ˆæ›´æ–°ç‰ˆï¼‰

```swift
import Foundation

struct AudioMetadata {
    let fileURL: URL
    let createdAt: Date
    let fileSize: Int
    let duration: TimeInterval

    var fileName: String {
        fileURL.lastPathComponent
    }

    var formattedSize: String {
        if fileSize < 1024 {
            return "\(fileSize) bytes"
        } else {
            let (kb, _) = fileSize.quotientAndRemainder(dividingBy: 1024)
            if kb < 1024 {
                return "\(kb) KB"
            } else {
                let (mb, _) = kb.quotientAndRemainder(dividingBy: 1024)
                return "\(mb) MB"
            }
        }
    }

    var formattedDuration: String {
        let (minutes, secondsRemainder) = Int(duration).quotientAndRemainder(dividingBy: 60)
        let (hours, minutesRemainder) = minutes.quotientAndRemainder(dividingBy: 60)
        let seconds = secondsRemainder
        if hours > 0 {
            return String(format: "%02i:%02i:%02i", hours, minutesRemainder, seconds)
        } else {
            return String(format: "%02i:%02i", minutesRemainder, seconds)
        }
    }
}
```

ã“ã®æ›´æ–°ã§ã¯ã€æ¬¡ã®å¤‰æ›´ã‚’åŠ ãˆã¾ã—ãŸï¼š

- `Recording`ã‚’`AudioMetadata`ã«åå‰å¤‰æ›´ã—ã¾ã—ãŸã€‚
- `FileManager`ã®æ‹¡å¼µãƒ¡ã‚½ãƒƒãƒ‰`fetchAudioMetadata`ã‚’è¿½åŠ ã—ã€æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚©ãƒ«ãƒ€å†…ã®ç‰¹å®šã®æ‹¡å¼µå­ã‚’æŒã¤ãƒ•ã‚¡ã‚¤ãƒ«ã ã‘ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã¦å–å¾—ã—ã¾ã™ã€‚
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’0ã«è¨­å®šã—ã¾ã—ãŸã€‚
- `formattedSize`ã¨`formattedDuration`ã®è¨ˆç®—ã«`quotientAndRemainder`ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚

ã“ã‚Œã§ã€ç‰¹å®šã®ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ç‰¹å®šã®ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’æŒã¤ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã€ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã«é–¢ã™ã‚‹è©³ç´°ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 15:44:01*

var formattedSize: String {
        if fileSize &lt; 1024 {
            return "\(fileSize) bytes"
        } else {
            let (kb, _) = fileSize.quotientAndRemainder(dividingBy: 1024)
            if kb &lt; 1024 {
                return "\(kb) KB"
            } else {
                let (mb, _) = kb.quotientAndRemainder(dividingBy: 1024)
                return "\(mb) MB"
            }
        }
    } ã¯quotientAndRemainderã‚’ä½¿ã‚ãªãã¦ã„ã„ã€‚ã¾ãŸã€Intã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ãƒƒãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼ã¨ã—ã¦ä¸€èˆ¬çš„ã«æ‹¡å¼µã—ã¦ã€ã»ã—ã„ã€‚

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 15:44:52*

ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã®è¡¨ç¤ºã‚’ã‚ˆã‚Šä¸€èˆ¬çš„ã«ä½¿ãˆã‚‹ã‚ˆã†ã«`Int`å‹ã®æ‹¡å¼µã¨ã—ã¦`formattedSize`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å®šç¾©ã—ã¾ã™ã€‚ã“ã“ã§ã€`quotientAndRemainder`ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ã¯ãªã„ãŸã‚ã€ã‚ˆã‚Šå˜ç´”ãªæ–¹æ³•ã§å®Ÿè£…ã—ã¾ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯`Int`å‹ã«å¯¾ã™ã‚‹æ‹¡å¼µã¨ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå¤‰æ›ã‚’æä¾›ã—ã¾ã™ã€‚

### Int Extension for Formatted File Size

```swift
extension Int {
    var formattedSize: String {
        if self < 1024 {
            return "\(self) bytes"
        } else if self < 1_048_576 { // 1024 * 1024
            return "\((self / 1024)) KB"
        } else if self < 1_073_741_824 { // 1024 * 1024 * 1024
            return "\((self / 1_048_576)) MB"
        } else {
            return "\((self / 1_073_741_824)) GB"
        }
    }
}
```

ã“ã®æ‹¡å¼µã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€`Int`å‹ã®ä»»æ„ã®æ•´æ•°ã«å¯¾ã—ã¦`.formattedSize`ã‚’å‘¼ã³å‡ºã—ã¦ã€èª­ã¿ã‚„ã™ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå½¢å¼ã‚’å–å¾—ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€`fileSize.formattedSize`ã®ã‚ˆã†ã«ä½¿ç”¨ã§ãã€è‡ªå‹•çš„ã«é©åˆ‡ãªå˜ä½ï¼ˆãƒã‚¤ãƒˆã€ã‚­ãƒ­ãƒã‚¤ãƒˆã€ãƒ¡ã‚¬ãƒã‚¤ãƒˆã€ã‚®ã‚¬ãƒã‚¤ãƒˆï¼‰ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚

### AudioMetadata.swiftã®æ›´æ–°

`AudioMetadata`æ§‹é€ ä½“ã§ã¯ã€`fileSize`ã®å‹ã‚’`Int`ã¨ã—ã¦å®šç¾©ã—ã€`formattedSize`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ã†å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’è¡¨ç¤ºã™ã‚‹éš›ã«ã€ã“ã®æ‹¡å¼µã‚’ç›´æ¥ä½¿ç”¨ã—ã¾ã™ã€‚

```swift
struct AudioMetadata {
    let fileURL: URL
    let createdAt: Date
    let fileSize: Int
    let duration: TimeInterval

    var fileName: String {
        fileURL.lastPathComponent
    }

    var formattedDuration: String {
        let (minutes, secondsRemainder) = Int(duration).quotientAndRemainder(dividingBy: 60)
        let (hours, minutesRemainder) = minutes.quotientAndRemainder(dividingBy: 60)
        let seconds = secondsRemainder
        if hours > 0 {
            return String(format: "%02i:%02i:%02i", hours, minutesRemainder, seconds)
        } else {
            return String(format: "%02i:%02i", minutesRemainder, seconds)
        }
    }
}
```

ã“ã®å¤‰æ›´ã«ã‚ˆã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ãŒç°¡ç´ åŒ–ã•ã‚Œã€ä»–ã®æ•´æ•°å€¤ã«ã‚‚åŒæ§˜ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 15:46:56*

format: "%02i:%02i:%02i" ã‚„ format: "%02i:%02i" ã¯ãªã‚“ã§ã™ã‹ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 15:47:36*

`format: "%02i:%02i:%02i"` ã¨ `format: "%02i:%02i"` ã¯ã€Swift ã§ã®æ–‡å­—åˆ—ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®šã§ã™ã€‚ã“ã‚Œã‚‰ã®æ›¸å¼æŒ‡å®šå­ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€æ•°å€¤ã‚’ç‰¹å®šã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§æ–‡å­—åˆ—ã«å¤‰æ›ã§ãã¾ã™ã€‚ã“ã®å½¢å¼ã¯ã€ç‰¹ã«æ™‚é–“ã‚„æ•°å€¤ã‚’è¦–è¦šçš„ã«æ•´ç†ã—ã¦è¡¨ç¤ºã™ã‚‹å ´é¢ã§æœ‰ç”¨ã§ã™ã€‚

### æ›¸å¼æŒ‡å®šã®è©³ç´°:

1. **`%02i`**:
   - `%i` ã¯æ•´æ•°ã‚’æ„å‘³ã—ã¾ã™ã€‚
   - `02` ã¯å°‘ãªãã¨ã‚‚2æ¡ã®æ•°ã‚’è¡¨ç¤ºã—ã€ä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã¯ã‚¼ãƒ­ã§åŸ‹ã‚ã‚‹ã“ã¨ã‚’æŒ‡ç¤ºã—ã¾ã™ã€‚ä¾‹ãˆã°ã€`1` ã¯ `01` ã¨ã—ã¦è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ç‰¹ã«æ™‚åˆ»è¡¨ç¤ºã«ãŠã„ã¦ä¸€èˆ¬çš„ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã™ã€‚

2. **ã‚³ãƒ­ãƒ³(`:`)**:
   - æ™‚é–“ã®éƒ¨åˆ†ï¼ˆæ™‚ã€åˆ†ã€ç§’ï¼‰ã‚’åŒºåˆ‡ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

### ä½¿ç”¨ä¾‹:

- **`"%02i:%02i:%02i"`**:
  - 3ã¤ã®æ•´æ•°å€¤ï¼ˆä¾‹ãˆã°æ™‚ã€åˆ†ã€ç§’ï¼‰ã‚’å–ã‚Šã€ãã‚Œãã‚Œ2æ¡ã§è¡¨ç¤ºã—ã¾ã™ã€‚æ™‚é–“ãŒ `9` æ™‚ `2` åˆ† `5` ç§’ã®å ´åˆã€`"09:02:05"` ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

- **`"%02i:%02i"`**:
  - 2ã¤ã®æ•´æ•°å€¤ï¼ˆä¾‹ãˆã°åˆ†ã¨ç§’ï¼‰ã‚’å–ã‚Šã€åŒæ§˜ã«ãã‚Œãã‚Œ2æ¡ã§è¡¨ç¤ºã—ã¾ã™ã€‚åˆ†ãŒ `2` ã§ç§’ãŒ `9` ã®å ´åˆã€`"02:09"` ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

ã“ã®ã‚ˆã†ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã€æ™‚åˆ»ã‚„ã‚¿ã‚¤ãƒãƒ¼ã€ã‚¹ãƒãƒ¼ãƒ„ã®ã‚¿ã‚¤ãƒ ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ãªã©ã€æ™‚é–“ã‚’æ‰±ã†å¤šãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ã‚ã‚Œã¾ã™ã€‚æ•´æ•°ã®è¡¨ç¤ºã‚’ä¸€è²«æ€§ãŒã‚ã‚Šã€èª­ã¿ã‚„ã™ãã™ã‚‹ãŸã‚ã«é‡è¦ãªãƒ„ãƒ¼ãƒ«ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 15:47:47*

ã“ã‚Œã£ã¦Swiftã®æ¨™æº–æ©Ÿèƒ½ã§æ­è¼‰ã•ã‚Œã¦ã„ãªã„ã®ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 15:48:42*

Swift ã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ã€ç‰¹å®šã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§æ™‚é–“ã‚’æ•´å½¢ã—ã¦è¡¨ç¤ºã™ã‚‹ç›´æ¥çš„ãªæ©Ÿèƒ½ã¯æä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã—ã‹ã—ã€Swift ã¨ iOS SDK ã«ã¯ `DateFormatter` ã‚„ `DateComponentsFormatter` ãªã©ã®ã‚¯ãƒ©ã‚¹ãŒå«ã¾ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã‚’ä½¿ç”¨ã—ã¦æ™‚é–“ã‚„æ—¥ä»˜ã‚’ä»»æ„ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ç‰¹ã«æ™‚é–“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«é–¢ã—ã¦ã¯ `DateComponentsFormatter` ãŒé©ã—ã¦ã„ã¾ã™ã€‚

### DateComponentsFormatter ã®ä½¿ç”¨ä¾‹

æ™‚é–“ã®é•·ã•ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ãŸã‚ã« `DateComponentsFormatter` ã‚’ä½¿ã†ä¾‹ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã‚’ä½¿ãˆã°ã€æ™‚é–“ã€åˆ†ã€ç§’ã‚’å«ã‚€æœŸé–“ã‚’é©åˆ‡ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```swift
import Foundation

func formattedDuration(from totalSeconds: TimeInterval) -> String {
    let formatter = DateComponentsFormatter()
    formatter.allowedUnits = [.hour, .minute, .second]
    formatter.unitsStyle = .positional
    formatter.zeroFormattingBehavior = .pad

    return formatter.string(from: totalSeconds) ?? "00:00"
}
```

ã“ã®é–¢æ•°ã¯ `TimeInterval` ï¼ˆç§’å˜ä½ã®æ™‚é–“ï¼‰ã‚’å—ã‘å–ã‚Šã€`DateComponentsFormatter` ã‚’ä½¿ç”¨ã—ã¦ã€ä¾‹ãˆã° `3661` ç§’ï¼ˆ1æ™‚é–“1åˆ†1ç§’ï¼‰ã‚’ `"01:01:01"` ã®ã‚ˆã†ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã—ã¾ã™ã€‚è¨­å®šã«ã‚ˆã‚Šã€æ™‚é–“ãŒå­˜åœ¨ã—ãªã„å ´åˆã§ã‚‚ `00` ã§ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚

### DateFormatter ã®ä½¿ç”¨ä¾‹

æ—¥ä»˜ã‚„æ™‚é–“ã‚’ç‰¹å®šã®ã‚¹ã‚¿ã‚¤ãƒ«ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã—ãŸã„å ´åˆã«ã¯ `DateFormatter` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€ç‰¹å®šã®æ—¥ä»˜ã‚’ã€Œå¹´æœˆæ—¥ã€å½¢å¼ã§è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```swift
import Foundation

func formattedDate(from date: Date) -> String {
    let formatter = DateFormatter()
    formatter.dateStyle = .long
    formatter.timeStyle = .none
    return formatter.string(from: date)
}
```

ã“ã®é–¢æ•°ã¯ `Date` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã€ãã‚Œã‚’é•·ã„ã‚¹ã‚¿ã‚¤ãƒ«ã®æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆä¾‹: "June 27, 2024"ï¼‰ã§æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚

### ã¾ã¨ã‚
Swift ã«ã¯ã€æ–‡å­—åˆ—ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ©Ÿèƒ½ã¨ã—ã¦ `%02i` ã®ã‚ˆã†ãªCè¨€èªã‚¹ã‚¿ã‚¤ãƒ«ã®æ›¸å¼æŒ‡å®šãŒåˆ©ç”¨å¯èƒ½ã§ã™ãŒã€ã‚ˆã‚Šé«˜åº¦ã§ç›´æ„Ÿçš„ãªæ—¥ä»˜ã‚„æ™‚é–“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã¯ `DateComponentsFormatter` ã‚„ `DateFormatter` ã®ã‚ˆã†ãªå°‚ç”¨ã®ã‚¯ãƒ©ã‚¹ã‚’åˆ©ç”¨ã™ã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å¤šãã®ãƒ­ã‚±ãƒ¼ãƒ«ã‚„ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ä¾å­˜ã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒ‹ãƒ¼ã‚ºã«æŸ”è»Ÿã«å¯¾å¿œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 15:51:28*

DateComponentsFormatterã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ä½¿ã£ã¦ã€Int -&gt; String ã®å¤‰æ›ã‚’ä¸€è¦§åŒ–ã—ãŸã„ã€‚

private extension DateFormatter {
    /// String-&gt;Dateã¨Date-&gt;Stringå¤‰æ›ã®ãŸã‚ã®DateFormatter
    ///
    /// DateFormatterã®ç”ŸæˆãŒé…ã„ãŸã‚ã€1ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ã„å›ã™
    static let shared: DateFormatter = {
        let formatter = DateFormatter()
        formatter.calendar = Calendar(identifier: .gregorian)
        formatter.locale = .current
        return formatter
    }()
}

public extension String {
    /// String -&gt; Date å¤‰æ›
    func toDate(format: StringToDateFormat) -&gt; Date {
        DateFormatter.shared.dateFormat = format.rawValue
        guard let date = DateFormatter.shared.date(from: self) else {
            assertionFailure("unexpected")
            return Date()
        }
        return date
    }
}

public extension Date {
    /// Date -&gt; String å¤‰æ›
    func toString(format: DateToStringFormat) -&gt; String {
        DateFormatter.shared.dateFormat = format.rawValue
        return DateFormatter.shared.string(from: self)
    }
}

/// String -&gt; Date å¤‰æ›ç”¨ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
public enum StringToDateFormat: String {
    case dateFormat = "yyyy-MM-dd"
    case dateTimeNoFractionFormat = "yyyy-MM-dd'T'HH:mm:ss"
    case dateTimeFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"
}

/// Date -&gt; String å¤‰æ›ç”¨ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
public enum DateToStringFormat: String {
    case display = "yyyy/MM.dd(EEE)"
    case dateTimeWithWeekDay = "yyyy/MM/dd(EEEEE) HH:mm"
    case dateTimeWithWeekDayNoZero = "yyyy/M/d(EEEEE) H:mm"
    case dateWithWeekDayNoZero = "yyyy/M/d(EEEEE)"
    case dateWithWeekDay = "yyyy/MM/dd(EEEEE)"
    case time = "HH:mm"
    case timeHourNoZero = "H:mm"
    case day = "d"
    case weekDay = "eee"
    case monthDay = "MM/dd"
    case dateWithTime = "yyyy/MM/dd HH:mm"
    case dateWithTimeNoZero = "yyyy/M/d H:mm"
    case monthDayWithTime = "M/d HH:mm"
    case yearNoZeroMonthDay = "yyyy/M/d"
    case yearMonth = "yyyy/MM"
    case yearMonthDay = "yyyy/MM/dd"
    case dateTimeFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"
    case dateFormat = "yyyy-MM-dd"
    case defaultPictureName = "MMæœˆ-dd-yyyy-HH:mm:ss-'JST'-+0900"
    case dateWithTimeInJa = "yyyyå¹´MMæœˆddæ—¥ H:mm"
    case dateTimeFormatForPath = "yyyy-MM-dd_HH-mm-ss-SSS"
    case allIntFormat = "yyyyMMddHHmmss"
    case allIntMsFormat = "yyyyMMddHHmmsss"
    case hhmmsssss = "HH:mm:ss.SSS"
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 15:52:21*

ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€æ—¥ä»˜ã¨æ–‡å­—åˆ—ã®å¤‰æ›ã‚’åŠ¹ç‡ã‚ˆãè¡Œã†ãŸã‚ã«`DateFormatter`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…±æœ‰ã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å¤šæ•°ã®æ—¥ä»˜å¤‰æ›å‡¦ç†ã‚’è¡Œã†å ´åˆã§ã‚‚ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå‘ä¸Šã—ã¾ã™ã€‚åŒæ§˜ã«ã€`DateComponentsFormatter` ã‚’ä½¿ç”¨ã—ã¦æ™‚é–“ã®æ•´å½¢ã‚’è¡Œã†ãŸã‚ã®æ‹¡å¼µã‚‚å¯èƒ½ã§ã™ã€‚

ä»¥ä¸‹ã«`Int`ã‹ã‚‰æ™‚é–“è¡¨ç¾ã®æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ãŸã‚ã®æ‹¡å¼µã‚’ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã‚’ä½¿ã£ã¦ã€ä¾‹ãˆã°ç§’å˜ä½ã®æ•´æ•°å€¤ã‹ã‚‰èª­ã¿ã‚„ã™ã„æ™‚é–“è¡¨ç¾ã¸ã¨å¤‰æ›ã§ãã¾ã™ã€‚

### DateComponentsFormatterã®æ‹¡å¼µ
`DateComponentsFormatter` ã‚’ç”¨ã„ãŸ `Int` å‹ã®æ‹¡å¼µã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€æ•´æ•°å‹ã®æ™‚é–“ï¼ˆç§’æ•°ï¼‰ã‚’ã€ŒHH:mm:ssã€ã‚„ã€Œmm:ssã€ãªã©ã®å½¢å¼ã§è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```swift
import Foundation

extension Int {
    /// Converts an integer value (seconds) to a formatted string representing time duration.
    var formattedTime: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .positional
        formatter.zeroFormattingBehavior = .pad

        // æ™‚é–“ãŒ1æ™‚é–“æœªæº€ã®å ´åˆã€"00:"ã‚’çœç•¥ã™ã‚‹
        if self < 3600 {
            formatter.allowedUnits = [.minute, .second]
        }

        return formatter.string(from: TimeInterval(self)) ?? "00:00"
    }
}
```

ã“ã®æ‹¡å¼µã¯ã€ç§’æ•°ã‚’å–å¾—ã—ã¦ `DateComponentsFormatter` ã«ã‚ˆã‚Šæ•´å½¢ã•ã‚ŒãŸæ™‚é–“è¡¨ç¾ã®æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚æ™‚é–“ãŒ1æ™‚é–“æœªæº€ã®å ´åˆã«ã¯ã€æ™‚é–“éƒ¨åˆ†ã‚’è¡¨ç¤ºã—ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

### ä½¿ç”¨ä¾‹
ã“ã®æ‹¡å¼µã‚’ä½¿ã†ã“ã¨ã§ã€ä¾‹ãˆã°ã‚¢ãƒ—ãƒªå†…ã§ã‚¿ã‚¤ãƒãƒ¼æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹éš›ã‚„ã€ã‚ã‚‹æœŸé–“ã®ç§’æ•°ã‚’èª­ã¿ã‚„ã™ã„å½¢ã§è¡¨ç¤ºã™ã‚‹éš›ã«å½¹ç«‹ã¡ã¾ã™ã€‚

```swift
let durationInSeconds = 3661  // 1æ™‚é–“1åˆ†1ç§’
print(durationInSeconds.formattedTime)  // "01:01:01"

let shortDurationInSeconds = 61  // 1åˆ†1ç§’
print(shortDurationInSeconds.formattedTime)  // "01:01"
```

ã“ã®æ‹¡å¼µã‚’ä½¿ã†ã“ã¨ã§ã€æ•´æ•°å€¤ã®ç§’æ•°ã‚’ç›´æ„Ÿçš„ã«ç†è§£ã—ã‚„ã™ã„å½¢ã§è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã€ã‚¢ãƒ—ãƒªã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚ã¾ãŸã€æ‹¡å¼µã®ä¸­ã§`DateComponentsFormatter`ã®è¨­å®šã‚’èª¿æ•´ã™ã‚‹ã“ã¨ã§ã€ã•ã¾ã–ã¾ãªè¡¨ç¤ºè¦ä»¶ã«æŸ”è»Ÿã«å¯¾å¿œã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 15:53:35*

DateComponentsFormatter ã¨ DateFormatter ã®é•ã„ã‚’æ•™ãˆã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 15:54:40*

`DateComponentsFormatter` ã¨ `DateFormatter` ã¯ã©ã¡ã‚‰ã‚‚ Swift ãŠã‚ˆã³ Objective-C ã®ä¸€éƒ¨ã¨ã—ã¦ Apple ã® Foundation ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«å«ã¾ã‚Œã¦ã„ã¾ã™ãŒã€ãã‚Œãã‚Œç•°ãªã‚‹ç›®çš„ã¨ä½¿ç”¨ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚

### DateFormatter
`DateFormatter` ã¯æ—¥ä»˜ã¨æ–‡å­—åˆ—ã®é–“ã§å¤‰æ›ã‚’è¡Œã†ã‚¯ãƒ©ã‚¹ã§ã™ã€‚å…·ä½“çš„ã«ã¯ã€æ—¥ä»˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (`Date`) ã‚’äººé–“ãŒèª­ã‚ã‚‹æ–‡å­—åˆ—å½¢å¼ã«å¤‰æ›ã—ãŸã‚Šã€é€†ã«æ–‡å­—åˆ—ã‹ã‚‰æ—¥ä»˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ãŸã‚Šã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ãƒ­ã‚±ãƒ¼ãƒ«ã€ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã€ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«ã«åŸºã¥ã„ãŸãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãŠã‚Šã€æ—¥ä»˜ã¨æ™‚åˆ»ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®å¤šæ§˜ãªã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå¯èƒ½ã§ã™ã€‚

- **ä¾‹**: "2024-01-01" ã‹ã‚‰ `Date` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã€ã¾ãŸã¯ `Date` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ "January 1, 2024" ã®ã‚ˆã†ãªå½¢å¼ã§è¡¨ç¤ºã™ã‚‹ã€‚

```swift
let formatter = DateFormatter()
formatter.dateFormat = "yyyy-MM-dd"
let date = formatter.date(from: "2024-01-01")  // String to Date
formatter.dateStyle = .long
let dateString = formatter.string(from: date!)  // Date to String, outputs "January 1, 2024"
```

### DateComponentsFormatter
`DateComponentsFormatter` ã¯æ™‚é–“ã®é–“éš”ã‚’è¡¨ã™ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯ç‰¹å®šã®æ™‚é–“ï¼ˆä¾‹ãˆã°ç§’æ•°ï¼‰ã‚’ã€Œ2 hours, 10 minutesã€ã‚„ã€Œ2æ™‚é–“10åˆ†ã€ã¨ã„ã£ãŸå½¢å¼ã®æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚`DateComponentsFormatter` ã¯æ™‚é–“é–“éš”ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«æœ€é©åŒ–ã•ã‚Œã¦ãŠã‚Šã€ç‰¹ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¨ã£ã¦èª­ã¿ã‚„ã™ã„å½¢å¼ã§æ™‚é–“ã‚’è¡¨ç¤ºã™ã‚‹å ´åˆã«ä¾¿åˆ©ã§ã™ã€‚

- **ä¾‹**: 3910ç§’ã‚’ "1 hour, 5 minutes, 10 seconds" ã¨ã„ã†å½¢å¼ã§è¡¨ç¤ºã™ã‚‹ã€‚

```swift
let formatter = DateComponentsFormatter()
formatter.unitsStyle = .full
formatter.allowedUnits = [.hour, .minute, .second]
let timeString = formatter.string(from: 3910)  // outputs "1 hour, 5 minutes, 10 seconds"
```

### ä¸»ãªé•ã„
- **ç”¨é€”**:
  - `DateFormatter`: æ—¥ä»˜ã¨æ™‚åˆ»ã‚’äººé–“ãŒèª­ã‚ã‚‹å½¢ã§è¡¨ç¤ºã—ãŸã‚Šã€æ—¥ä»˜ã®æ–‡å­—åˆ—ã‚’è§£æã—ãŸã‚Šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚
  - `DateComponentsFormatter`: æ™‚é–“é–“éš”ï¼ˆæŒç¶šæœŸé–“ï¼‰ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã€ä¾‹ãˆã°ã‚¹ãƒãƒ¼ãƒ„ã‚¢ãƒ—ãƒªã§ã®ãƒ©ãƒƒãƒ—ã‚¿ã‚¤ãƒ ã‚„ã‚¯ãƒƒã‚­ãƒ³ã‚°ã‚¿ã‚¤ãƒãƒ¼ãªã©ã«é©ã—ã¦ã„ã¾ã™ã€‚

- **æ©Ÿèƒ½**:
  - `DateFormatter`: ãƒ­ã‚±ãƒ¼ãƒ«ã‚„ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã«ä¾å­˜ã™ã‚‹æ—¥ä»˜ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
  - `DateComponentsFormatter`: æ™‚é–“é–“éš”ã®å˜ä½ï¼ˆç§’ã€åˆ†ã€æ™‚é–“ï¼‰ã‚’é¸æŠã—ã€ãã‚Œã‚‰ã‚’çµ„ã¿åˆã‚ã›ã¦è¡¨ç¤ºã™ã‚‹æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚

ä¸¡è€…ã¯ç›®çš„ãŒç•°ãªã‚Šã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ç‰¹å®šã®ãƒ‹ãƒ¼ã‚ºã«å¿œã˜ã¦é¸æŠã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚æ—¥ä»˜ã‚„æ™‚åˆ»ã‚’æ‰±ã†éš›ã«ã¯ `DateFormatter` ã‚’ã€æ™‚é–“é–“éš”ã‚„æŒç¶šæœŸé–“ã‚’æ‰±ã†éš›ã«ã¯ `DateComponentsFormatter` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 17:32:45*

DateComponentsFormatter ã¯ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ã«ã¤ã‹ã£ãŸã»ã†ãŒã„ã„ã®ã‹ãªï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 17:34:01*

`DateComponentsFormatter` ã‚„ `DateFormatter` ã®ã‚ˆã†ãªæ—¥ä»˜é–¢é€£ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ç”ŸæˆãŒæ¯”è¼ƒçš„ã‚³ã‚¹ãƒˆãŒã‹ã‹ã‚‹æ“ä½œã§ã™ã€‚ã“ã‚Œã¯ã€ã“ã‚Œã‚‰ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ãŒå†…éƒ¨çš„ã«å¤šãã®è¨­å®šã‚’ç®¡ç†ã—ã¦ãŠã‚Šã€ãƒ­ã‚±ãƒ¼ãƒ«ã‚„ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ãªã©ã®ç’°å¢ƒè¨­å®šã«åŸºã¥ã„ã¦é©åˆ‡ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚

ãã®ãŸã‚ã€ã“ã‚Œã‚‰ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ã‚’é »ç¹ã«ä½œæˆã—ã€çŸ­æœŸé–“ã§ç ´æ£„ã™ã‚‹ã‚ˆã†ãªä½¿ã„æ–¹ã¯åŠ¹ç‡ãŒè‰¯ãã‚ã‚Šã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚·ãƒŠãƒªã‚ªã§ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚„é¡ä¼¼ã®æ‰‹æ³•ã‚’æ¡ç”¨ã™ã‚‹ã“ã¨ãŒä¸€èˆ¬çš„ã«æ¨å¥¨ã•ã‚Œã¾ã™ï¼š

### ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ä½¿ç”¨ã®ãƒ¡ãƒªãƒƒãƒˆ
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–**: ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§å†åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆã®ã‚³ã‚¹ãƒˆã‚’å‰Šæ¸›ã—ã€å…¨ä½“çš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å‘ä¸Šã•ã›ã¾ã™ã€‚
- **ãƒ¡ãƒ¢ãƒªä½¿ç”¨ã®å‰Šæ¸›**: åŒã˜ç¨®é¡ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ã‚’è¤‡æ•°ç”Ÿæˆã™ã‚‹ä»£ã‚ã‚Šã«ã€å˜ä¸€ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã§ãƒ¡ãƒ¢ãƒªæ¶ˆè²»ã‚’æŠ‘ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### å®Ÿè£…ä¾‹
ä»¥ä¸‹ã¯ `DateComponentsFormatter` ã‚’ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ã«åˆ©ç”¨ã™ã‚‹ä¾‹ã§ã™ã€‚ã“ã®æ–¹æ³•ã¯ã€ç‰¹ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ãŒã‚¢ãƒ—ãƒªå…¨ä½“ã§ä¸€è²«ã—ãŸè¨­å®šã§ä½¿ç”¨ã•ã‚Œã‚‹å ´åˆã«é©ã—ã¦ã„ã¾ã™ã€‚

```swift
import Foundation

class FormatterProvider {
    static let shared = FormatterProvider()

    let durationFormatter: DateComponentsFormatter

    private init() {
        durationFormatter = DateComponentsFormatter()
        durationFormatter.unitsStyle = .abbreviated
        durationFormatter.allowedUnits = [.hour, .minute, .second]
        durationFormatter.zeroFormattingBehavior = .pad
    }
}

// ä½¿ç”¨ä¾‹
let formattedDuration = FormatterProvider.shared.durationFormatter.string(from: TimeInterval(3661)) ?? "00:00"
```

### ä½¿ç”¨æ™‚ã®æ³¨æ„ç‚¹
ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’å–ã‚‹éš›ã«ã¯ã€ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼š

- **ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•**: ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ç’°å¢ƒã§ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚`DateComponentsFormatter` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã¯ç‰¹ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã‚ã‚‹ã¨ã®è¨˜è¿°ãŒãªã„ãŸã‚ã€åŒæ™‚ã«è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹å ´åˆã¯ãƒ­ãƒƒã‚¯ãªã©ã®åŒæœŸå‡¦ç†ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
- **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã®æŸ”è»Ÿæ€§**: ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ãã®è¨­å®šå¤‰æ›´ãŒã‚¢ãƒ—ãƒªå…¨ä½“ã«å½±éŸ¿ã‚’åŠã¼ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ä½¿ç”¨ã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ã‚ˆã£ã¦ç•°ãªã‚‹è¨­å®šãŒå¿…è¦ãªå ´åˆã¯ã€ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã§ã¯ãªãã€å¿…è¦ã«å¿œã˜ã¦å€‹åˆ¥ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹æ–¹ãŒé©åˆ‡ãªå ´åˆãŒã‚ã‚Šã¾ã™ã€‚

ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ãªä½¿ç”¨ãŒé©åˆ‡ã‹ã©ã†ã‹ã¯ã€ãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å…·ä½“çš„ãªè¦ä»¶ã¨ä½¿ç”¨ã‚·ãƒŠãƒªã‚ªã«ä¾å­˜ã—ã¾ã™ã€‚å¤šãã®å ´åˆã€ã“ã‚Œã‚‰ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ã‚’é »ç¹ã«ä½¿ç”¨ã™ã‚‹å ´åˆã«ã¯ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ãƒ¡ãƒ¢ãƒªä½¿ç”¨ã®ãƒãƒ©ãƒ³ã‚¹ã‚’è€ƒæ…®ã—ã¦ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒæœ‰åŠ¹ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 17:43:56*

ã“ã†ã„ã†ã‚¤ãƒ¡ãƒ¼ã‚¸ã ã£ãŸ

public extension ISO8601DateFormatter {
    static let sharedWithFractionalSeconds: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        formatter.timeZone = TimeZone.current
        return formatter
    }()
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 17:44:46*

ç†è§£ã—ã¾ã—ãŸã€‚ã”æç¤ºã„ãŸã ã„ãŸã‚³ãƒ¼ãƒ‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¸è¥²ã—ã¦ã€`DateComponentsFormatter` ã‚’ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ã«ä½¿ç”¨ã™ã‚‹ãŸã‚ã® Swift æ‹¡å¼µã‚’æ›¸ãã“ã¨ã¯ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®è¦³ç‚¹ã‹ã‚‰ã‚‚è‰¯ã„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã™ã€‚`ISO8601DateFormatter` ã®ä¾‹ã¨åŒæ§˜ã«ã€`DateComponentsFormatter` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…±æœ‰ã—ã¦å†åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆã®ã‚³ã‚¹ãƒˆã‚’å‰Šæ¸›ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åŠ¹ç‡ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸‹ã« `DateComponentsFormatter` ç”¨ã®ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ãªæ‹¡å¼µã‚’ç¤ºã—ã¾ã™ï¼š

```swift
import Foundation

public extension DateComponentsFormatter {
    static let shared: DateComponentsFormatter = {
        let formatter = DateComponentsFormatter()
        formatter.unitsStyle = .full
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.zeroFormattingBehavior = .pad
        return formatter
    }()
}
```

ã“ã®æ‹¡å¼µã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€`DateComponentsFormatter` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§ä½¿ã„å›ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ç¹°ã‚Šè¿”ã—åŒã˜ç¨®é¡ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹éš›ã®åŠ¹ç‡ãŒå‘ä¸Šã—ã¾ã™ã€‚

### ä½¿ç”¨ä¾‹
ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ãª`DateComponentsFormatter`ã‚’ä½¿ã£ã¦ã€ç§’æ•°ã‚’äººé–“ãŒèª­ã‚ã‚‹å½¢å¼ã«å¤‰æ›ã—ã¾ã™ã€‚

```swift
let durationInSeconds = 3661  // 1æ™‚é–“1åˆ†1ç§’
if let formattedString = DateComponentsFormatter.shared.string(from: TimeInterval(durationInSeconds)) {
    print(formattedString)  // "1 hour, 1 minute, 1 second"ï¼ˆãƒ­ã‚±ãƒ¼ãƒ«ã«ã‚ˆã‚Šç•°ãªã‚‹ï¼‰
}
```

ã“ã®æ–¹æ³•ã§ã¯ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ã®è¨­å®šã‚’ä¸€ç®‡æ‰€ã§ç®¡ç†ã§ãã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®ã©ã“ã‹ã‚‰ã§ã‚‚åŒã˜è¨­å®šã§æ™‚é–“ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ãã‚‹ãŸã‚ã€ä¸€è²«æ€§ãŒä¿ãŸã‚Œã¾ã™ã€‚ãŸã ã—ã€ç•°ãªã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè¨­å®šã‚’é »ç¹ã«åˆ‡ã‚Šæ›¿ãˆã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€ãã‚Œãã‚Œã®è¨­å®šã«åˆã‚ã›ã¦åˆ¥ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”¨æ„ã™ã‚‹ã‹ã€è¨­å®šã‚’å‹•çš„ã«å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/7 18:19:32*

AudioFileUrl ã‹ã‚‰ AudioMetadata ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã‚’ä½œã£ã¦ã‚ã’ãŸæ–¹ãŒã‚¹ãƒãƒ¼ãƒˆãªæ°—ãŒã—ã¦ããŸã€‚ã¾ãŸã€æ‹¡å¼µå­ã§æŠ½å‡ºã™ã‚‹å‡¦ç†ã‚‚åˆ¥é–¢æ•°ã§å®šç¾©ã—ã¦ã‚ã’ãŸã»ã†ãŒã‚¹ãƒãƒ¼ãƒˆãªæ°—ãŒã—ã¦ããŸã€‚

extension FileManager {
    func fetchRecordings(folder: URL, extensions: [FileExtension]) throws -&gt; [AudioMetadata] {
        do {
            return try contentsOfDirectory(at: folder, includingPropertiesForKeys: nil).filter { fileUrl in
                extensions.contains { $0.pathExtension == fileUrl.pathExtension }
            }
            .map { fileUrl -&gt; AudioMetadata in
                let attributes = try attributesOfItem(atPath: fileUrl.path)
                let fileSize: Int = (attributes[.size] as? Int) ?? 0
                let creationDate: Date = attributes[.creationDate] as? Date ?? Date()
                let duration: TimeInterval = CMTimeGetSeconds(AVURLAsset(url: fileUrl).duration)
                return AudioMetadata(
                    fileUrl: fileUrl,
                    createdAt: creationDate,
                    fileSize: fileSize,
                    duration: duration
                )
            }
        } catch {
            print("Failed to read audio files: \(error)")
            throw error
        }
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/7 18:20:40*

æŒ‡æ‘˜ã®é€šã‚Šã€`FileManager` ã®æ‹¡å¼µã‚’ä½¿ã£ã¦ç‰¹å®šã®ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ç‰¹å®šã®æ‹¡å¼µå­ã‚’æŒã¤ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã‚’æ•´ç†ã—ã€ãã‚Œã‚’`AudioMetadata`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯éå¸¸ã«åˆç†çš„ã§ã™ã€‚ã¾ãŸã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‹¡å¼µå­ã«åŸºã¥ã„ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’åˆ¥ã®é–¢æ•°ã«åˆ†å‰²ã™ã‚‹ã“ã¨ã‚‚ã‚³ãƒ¼ãƒ‰ã®å†åˆ©ç”¨æ€§ã¨æ˜ç­ã•ã‚’é«˜ã‚ã‚‹ãŸã‚ã«å½¹ç«‹ã¡ã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€æä¾›ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦ã€ã„ãã¤ã‹ã®æ”¹å–„ã‚’æ–½ã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚ã“ã‚Œã«ã¯ã€ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’æ”¹å–„ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’åˆ¥ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§è¡Œã†ã‚ˆã†ã«åˆ†å‰²ã—ã¾ã—ãŸã€‚

### FileExtension Enum
ã¾ãšã€ä½¿ç”¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã® `enum` ã‚’ä½œæˆã—ã¾ã™ã€‚

```swift
public enum FileExtension: String {
    case m4a
    case mp3
}
```

### FileManager Extension
æ¬¡ã«ã€`FileManager` ã®æ‹¡å¼µã‚’è¡Œã„ã€æ‹¡å¼µå­ã«åŸºã¥ããƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®æŠ½å‡ºã‚’è¡Œã„ã¾ã™ã€‚

```swift
import Foundation
import AVFoundation

extension FileManager {
    func fetchRecordings(folder: URL, extensions: [FileExtension]) throws -> [AudioMetadata] {
        let audioFiles = try fetchFiles(at: folder, extensions: extensions)
        return try audioFiles.map(metadataFromAudioFile)
    }
    
    private func fetchFiles(at folder: URL, extensions: [FileExtension]) throws -> [URL] {
        return try contentsOfDirectory(at: folder, includingPropertiesForKeys: nil).filter { fileUrl in
            extensions.contains { $0.rawValue == fileUrl.pathExtension }
        }
    }
    
    private func metadataFromAudioFile(fileUrl: URL) throws -> AudioMetadata {
        let attributes = try attributesOfItem(atPath: fileUrl.path)
        let fileSize = (attributes[.size] as? Int) ?? 0
        let creationDate = attributes[.creationDate] as? Date ?? Date()
        let duration = CMTimeGetSeconds(AVURLAsset(url: fileUrl).duration)
        
        return AudioMetadata(
            fileUrl: fileUrl,
            createdAt: creationDate,
            fileSize: fileSize,
            duration: duration
        )
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€æ¬¡ã®ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™ï¼š

1. **fetchFiles**: ç‰¹å®šã®ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸæ‹¡å¼µå­ã‚’æŒã¤ãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‚’æŠ½å‡ºã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€æŒ‡å®šã•ã‚ŒãŸæ‹¡å¼µå­ã®ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã ã‘ã‚’è¿”ã—ã¾ã™ã€‚
2. **metadataFromAudioFile**: å„ãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‹ã‚‰ `AudioMetadata` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®å±æ€§ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã€ä½œæˆæ—¥ã€å†ç”Ÿæ™‚é–“ã‚’æŠ½å‡ºã—ã¾ã™ã€‚

ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€é–¢æ•°ã®è²¬å‹™ã‚’åˆ†é›¢ã—ã€å†åˆ©ç”¨å¯èƒ½ãªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ã¨ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§ã‚’å‘ä¸Šã•ã›ã¾ã™ã€‚ã¾ãŸã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«ã¯ã€ãã‚Œã‚’å‘¼ã³å‡ºã—å…ƒã«ä¼æ’­ã•ã›ã€é©åˆ‡ã«å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---
