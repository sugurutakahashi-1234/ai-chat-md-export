# Flutter アプリバージョン取得

日付: 2025-01-29

---

## 👤 ユーザー
*2025/01/29 14:27:29*

Flutterでアプリバージョンを取得する

---

## 🔧 ツール
*2025/01/29 14:28:01*

**Setting up the environment**

Looks like the next step involves adding the `package_info_plus` dependency to `pubspec.yaml` and importing it from 'package:package_info_plus/package_info_plus.dart'. This sets the stage for integrating the library.

**Fetching version info**

I’m piecing together how to use `package_info_plus` in Flutter. In the `initState` method, it grabs the app version and build number from the platform to `setState`.

---

## 🤖 アシスタント
*2025/01/29 14:28:01*

Flutter でアプリバージョンやビルド番号を取得するには、**package_info_plus** というパッケージを使う方法が一般的です。以下の手順で実装できます。

---

## 1. pubspec.yaml に依存関係を追加

```yaml
dependencies:
  flutter:
    sdk: flutter

  # 追加
  package_info_plus: ^X.Y.Z
```

&gt; **メモ**: 2023 年ごろから公式の `package_info` はメンテナンスされていません。代わりに `package_info_plus` を利用します。

---

## 2. パッケージをインポート

```dart
import 'package:package_info_plus/package_info_plus.dart';
```

---

## 3. バージョン・ビルド番号を取得

以下のようにアプリ起動時や画面生成時 (StatefulWidget の `initState` など) で非同期的に取得できます。

```dart
import 'package:flutter/material.dart';
import 'package:package_info_plus/package_info_plus.dart';

class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key}) : super(key: key);

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  String _appVersion = '';
  String _buildNumber = '';

  @override
  void initState() {
    super.initState();
    _fetchAppInfo();
  }

  Future<void> _fetchAppInfo() async {
    final info = await PackageInfo.fromPlatform();
    setState(() {
      _appVersion = info.version;       // pubspec.yamlの version: 1.0.0 の部分に相当
      _buildNumber = info.buildNumber;  // pubspec.yamlの +1 の部分に相当
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('アプリバージョン確認'),
      ),
      body: Center(
        child: Text('バージョン: $_appVersion\nビルド番号: $_buildNumber'),
      ),
    );
  }
}
```

これで、`_appVersion` にバージョン (例: `1.0.0`)、`_buildNumber` にビルド番号 (例: `1`) が格納され、UI 上で表示できます。

---

## 4. pubspec.yaml のバージョン設定

Flutter のバージョンは一般的に `pubspec.yaml` の冒頭付近に書かれています。たとえば:

```yaml
name: your_app
description: A new Flutter project.

# version: <versionCode>+<buildNumber>
version: 1.2.3+4
```

- `version: 1.2.3` → アプリバージョン
- `+4` → ビルド番号

この設定がそのまま `info.version` と `info.buildNumber` に反映されます。

---

## 5. Tips
- **iOS / Android / Web** のいずれでも同じコードで取得可能です。  
- 実機やエミュレータ・シミュレータでビルドすると自動的に指定したバージョンが反映されます。  
- ビルド番号はリリース時に更新を忘れないように管理する必要があります。リリースのたびにバージョン・ビルド番号を increment (加算) するのが一般的です。

---

これで Flutter アプリ内でバージョンやビルド番号を取得・表示できるようになります。ぜひお試しください。

---

## 👤 ユーザー
*2025/01/29 14:28:58*

デフォルトでapp_version というヘッダーでpubspec.yamlの version: 1.0.0 の部分に相当する文字列を埋めたい

import 'package:dio/dio.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:snpit_guild_app/presentation/providers/access_token.dart';

part 'dio_provider.g.dart';

@Riverpod(keepAlive: true)
Dio dio(Ref ref) {
  final dio = Dio(
    BaseOptions(
      headers: {
        'Content-Type': 'application/json',
      },
    ),
  );

  dio.interceptors.add(
    InterceptorsWrapper(
      onRequest: (options, handler) async {
        final accessToken = await ref.read(accessTokenNotifierProvider.future);

        if (accessToken != null) {
          options.headers['access_token'] = accessToken;
        }

        return handler.next(options);
      },
      onError: (e, handler) {
        return handler.next(e);
      },
      onResponse: (response, handler) {
        return handler.next(response);
      },
    ),
  );

  dio.interceptors.add(
    LogInterceptor(
      requestBody: true,
      responseBody: true,
    ),
  );

  return dio;
}

---

## 🔧 ツール
*2025/01/29 14:29:33*

**Piecing together options**

The user is exploring how to integrate the `app_version` header from `pubspec.yaml` into a Dio HTTP request. Runtime extraction with `package_info_plus` or compile-time using `flutter_dotenv` are the main options considered.

**Implementing runtime retrieval**

Using `PackageInfo.fromPlatform()` at runtime, the app version is asynchronously fetched and integrated into the Dio request headers, leveraging Riverpod for provider management.

**Integrating app version**

I’m setting up a provider to fetch the app version from `package_info_plus` and adding it to Dio request headers using an interceptor, ensuring a seamless integration process.

**Showcasing the solution**

I'm planning to provide a code snippet that uses `package_info_plus` to read the app version at runtime and integrate it into Dio request headers, focusing on a dynamic, real-time approach.

**Integrating version management**

I'm considering adding `appVersionProvider` to async interceptors in the Dio provider, ensuring headers dynamically reflect the current app version. This approach helps streamline the process effectively.

---

## 🤖 アシスタント
*2025/01/29 14:29:33*

Flutter アプリ内で `pubspec.yaml` に定義した `version: 1.0.0` を HTTP ヘッダー（例: `app_version`）に自動的に付与したい場合、以下のように **package_info_plus** を用いてバージョン情報を取得し、それを Dio の Interceptor でヘッダーにセットする方法がよく使われます。

---

## 手順概要

1. **package_info_plus** を導入する  
2. アプリのバージョンを取得するための **FutureProvider**（または他の Riverpod Provider）を用意  
3. `dio` Provider の Interceptor で、バージョンをヘッダーにセット  

---

## 1. package_info_plus の導入

`pubspec.yaml` に以下を追加し、`flutter pub get` を実行します。

```yaml
dependencies:
  package_info_plus: ^X.Y.Z
```

---

## 2. アプリバージョンを取得する Provider を作成

`package_info_plus` の `PackageInfo.fromPlatform()` を呼び出し、`pubspec.yaml` の `version: x.y.z` を取得します。Riverpod であれば、例として以下のような **FutureProvider** を作成できます。

```dart
import 'package:package_info_plus/package_info_plus.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'app_version_provider.g.dart';

@riverpod
Future<String> appVersion(AppVersionRef ref) async {
  final info = await PackageInfo.fromPlatform();
  return info.version; // pubspec.yaml の version: x.y.z に相当
}
```

上記を `app_version_provider.dart` など適当なファイル名で作成してください。  
(`@riverpod` アノテーションを使うためには `riverpod_annotation` や `build_runner` 設定が必要ですが、そこは既に整備済みと仮定します)

---

## 3. Dio の Provider でヘッダーに埋め込む

先ほどの `appVersion` プロバイダを使ってバージョンを取得し、Interceptor の `onRequest` で設定します。以下は質問文で提示されていた `dio_provider.dart` の例です。

```dart
import 'package:dio/dio.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
// バージョン取得用のProviderをインポート
import 'package:snpit_guild_app/presentation/providers/app_version_provider.dart';
import 'package:snpit_guild_app/presentation/providers/access_token.dart';

part 'dio_provider.g.dart';

@Riverpod(keepAlive: true)
Dio dio(Ref ref) {
  final dio = Dio(
    BaseOptions(
      headers: {
        'Content-Type': 'application/json',
      },
    ),
  );

  dio.interceptors.add(
    InterceptorsWrapper(
      onRequest: (options, handler) async {
        // ---- ここでバージョンを取得してヘッダーに設定 ----
        final version = await ref.read(appVersionProvider.future);
        options.headers['app_version'] = version;

        // アクセストークンがあれば追加
        final accessToken = await ref.read(accessTokenNotifierProvider.future);
        if (accessToken != null) {
          options.headers['access_token'] = accessToken;
        }

        return handler.next(options);
      },
      onError: (e, handler) {
        return handler.next(e);
      },
      onResponse: (response, handler) {
        return handler.next(response);
      },
    ),
  );

  dio.interceptors.add(
    LogInterceptor(
      requestBody: true,
      responseBody: true,
    ),
  );

  return dio;
}
```

上記のように書くと、リクエスト前にアプリバージョンを取得し、 `app_version` ヘッダーとして自動的に付与されるようになります。  
これで、サーバー側で `app_version` ヘッダーを見れば、Flutter の `pubspec.yaml` に設定したバージョン文字列（例 `1.0.0`）を確認できるようになります。

---

## 補足: pubspec.yaml のバージョン設定

`pubspec.yaml` では以下のようにバージョンとビルド番号を指定します。

```yaml
name: my_flutter_app
description: A new Flutter project.

version: 1.0.0+1
```

- `1.0.0` → **アプリバージョン**  
- `+1` → **ビルド番号** (`PackageInfo.fromPlatform()` で取得した際 `info.buildNumber` に相当)

この `1.0.0` 部分が、上記のコードで `app_version` ヘッダーに設定される文字列です。

---

## まとめ

1. `package_info_plus` でバージョン取得  
2. Riverpod の FutureProvider などでラップ  
3. Dio の Interceptor でヘッダーにセット  

これだけで、アプリからの全リクエストに `app_version` ヘッダーが付与されます。ぜひお試しください。

---

## 👤 ユーザー
*2025/01/29 14:30:01*

interceptors で植える必要はあるのか？以下ではダメなのか？

BaseOptions(
      headers: {
        'Content-Type': 'application/json',
      },
    ),

---

## 🔧 ツール
*2025/01/29 14:30:17*

**Navigating asynchronous configurations**

I’m tackling the asynchronous challenge of setting headers in Dio by retrieving the app version from pubspec.yaml using package_info_plus. Awaiting a sync initialization is off-limits, suggesting an async initialization or conditional assignment.

**Evaluating caching and interceptors**

Considering caching the version for ease or handling it asynchronously through interceptors to ensure up-to-date headers in Dio, though this approach might introduce occasional 'unknown' headers.

**Ensuring dynamic headers**

I’m leaning towards using interceptors for dynamic headers like the app version or accessToken, ensuring each request gets updated details. This method fits well with the need for consistent updates.

---

## 🤖 アシスタント
*2025/01/29 14:30:17*

結論から言うと、**「バージョンなど常に固定の値であり、同期的に用意できるなら `BaseOptions` に直接書いても構わない」** ですが、ほとんどの場合、`package_info_plus` などで取得するバージョンは **非同期処理** になるため、**Interceptor で設定する方が簡単かつ確実** というのが一般的なやり方です。

---

## なぜ Interceptor で設定するのか？

1. **非同期でバージョンを取得する**  
   `package_info_plus` の `PackageInfo.fromPlatform()` は `Future` を返す非同期処理です。Dio の `BaseOptions` は **基本的には同期的に生成** されるものなので、非同期で取得した値をそのまま `BaseOptions` に入れにくい場合があります。

2. **リクエストごとに値を変えたい (トークンなど)**  
   アクセストークンなど、リクエストごとに変わる可能性のある値がある場合、Interceptor の `onRequest` で都度設定する方が管理がしやすいです。  
   - 例）トークンが期限切れで更新された場合など。  
   - ただしアプリのバージョンは変わりにくいですが、それでも仕組みを統一しておくと楽なことがあります。

3. **アプリ起動時にバージョンを先読みして保持しておけば可能では？**  
   アプリ起動直後に `PackageInfo.fromPlatform()` を読んで、Riverpod などで保持しておけば同期的に取り出すかのように使うことはできます。しかしその場合も、  
   - 「まだバージョン読み込みが終わっていない」タイミングでDioを生成する可能性  
   - 値を引き回す実装の手間  
   などを考えると、最終的に「Interceptor で都度（あるいは初回だけ）読み込む」実装に落ち着くことが多いです。

---

## 直接 BaseOptions で設定するケース

もし「バージョンが常に固定文字列でも問題ない」「非同期を使わない」などの要件なら、次のように書くことは技術的には可能です。

```dart
final dio = Dio(
  BaseOptions(
    headers: {
      'Content-Type': 'application/json',
      'app_version': '1.0.0', // ここを固定値とする
    },
  ),
);
```

- このようにすると常に `'app_version': '1.0.0'` がヘッダーに入ります。  
- ただし実際には、ビルドしたときに `pubspec.yaml` のバージョンを毎回手で書き換えるか、あるいはビルドスクリプト等で自動的に書き換える仕組みが必要になるかもしれません。  
- また、バージョン更新時には都度ソースコードを修正・ビルドし直しになります。

---

## まとめ

- **非同期の値（`package_info_plus` で取得するバージョン）を使いたい場合は、Interceptor で設定するのが一般的。**  
- **もしバージョンを「固定文字列」として書き込んでも良いなら、`BaseOptions.headers` に直接追加しても構わない。**  

実運用では、アプリバージョンだけでなくアクセストークンのように動的に変わる可能性があるものをまとめて管理することが多いため、Interceptor でまとめて入れるパターンが主流となっています。

---
