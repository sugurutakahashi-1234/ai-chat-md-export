# レイアウト崩れ修正

日付: 2025-02-01

---

## 👤 ユーザー
*2025/02/02 01:18:23*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-5etCUqhz1jDsCxKb2Fwzft",
  "size_bytes": 466550,
  "width": 791,
  "height": 1595,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
このようにレイアウトが崩れてしまっている

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/presentation/providers/access_token.dart';

import 'package:snpit_guild_app/presentation/providers/api_client/auth/request_code.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/flavor_provider.dart';
import 'package:snpit_guild_app/presentation/providers/show_force_update.dart';
import 'package:snpit_guild_app/presentation/providers/show_maintenance.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/terms_of_service_dialog.dart';
import 'package:snpit_guild_app/utils/show_dialog_utils.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';

class LoginPage extends HookConsumerWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final flavor = ref.watch(flavorProvider);
    final textEditingController = useTextEditingController();
    final isLoadingState = useState(false);

    ref
      ..listen&lt;int&gt;(showMaintenanceNotifierProvider, (previous, next) async {
        showMaintenanceDialog(context);
      })
      ..listen&lt;int&gt;(showForceUpdateNotifierProvider, (previous, next) async {
        showForceUpdateDialog(context);
      });

    useEffect(
      () {
        Future.microtask(() async {
          try {
            isLoadingState.value = true;

            final currentAccessToken =
                await ref.read(accessTokenNotifierProvider.future);

            if (currentAccessToken == null) {
              debugPrint('No access token found.');
              return;
            }

            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

            if (context.mounted) {
              context.go(Screen.map.path);
            }
          } on Exception catch (error) {
            // アクセストークン切れの時もあるのでスナックバーは出さない
            debugPrint('Error: $error');
          } finally {
            if (context.mounted) {
              isLoadingState.value = false;
            }
          }
        });
        return null;
      },
      [],
    );

    Future&lt;void&gt; onLongPressLogo() async {
      if (flavor.isDebugMode) {
        await context.push(Screen.debugMenu.path);
      }
    }

    Future&lt;void&gt; onTapLogin() async {
      final email = textEditingController.text.trim();
      if (email.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please enter a valid email.'),
          ),
        );
        return;
      }

      try {
        isLoadingState.value = true;

        if (context.mounted) {
          final confirm = await showDialog&lt;bool&gt;(
            context: context,
            barrierDismissible: false,
            builder: (BuildContext context) {
              return const TermsOfServiceDialog();
            },
          );

          if (confirm != true) {
            return;
          }
        }

        await ref.read(requestCodeNotifierProvider.notifier).requestCode(email);

        if (context.mounted) {
          await context.push(Screen.verificationCode.path, extra: email);
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        if (context.mounted) {
          isLoadingState.value = false;
        }
      }
    }

    return Scaffold(
      body: GestureDetector(
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: Stack(
          children: [
            Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    GestureDetector(
                      onLongPress: () async {
                        await onLongPressLogo();
                      },
                      child: SvgPicture.asset(
                        Assets.images.logoLogin.path,
                      ),
                    ),
                    const SizedBox(height: 38),
                    Image.asset(
                      Assets.images.loginFig.path,
                    ),
                    const SizedBox(height: 54),
                    TextField(
                      controller: textEditingController,
                      decoration: const InputDecoration(
                        prefixIcon: Padding(
                          padding: EdgeInsets.all(12),
                          child: Icon(
                            Icons.email_outlined,
                            color: ColorToken.text,
                            size: 24,
                          ),
                        ),
                        hintText: 'Enter your email',
                      ),
                    ),
                    const SizedBox(height: 24),
                    ElevatedButton(
                      onPressed: isLoadingState.value
                          ? null
                          : () async {
                              await onTapLogin();
                            },
                      child: const Text('Login'),
                    ),
                  ],
                ),
              ),
            ),
            if (isLoadingState.value)
              const Center(
                child: CircularProgressIndicator(),
              ),
          ],
        ),
      ),
    );
  }
}

---

## 🤖 アシスタント
*2025/02/02 01:18:40*

キーボードが出ることで下方向にはみ出してしまう典型的なパターンなので、以下のように「スクロール可能な親ウィジェットを用意し、キーボード表示時に画面が縮むようにする」実装にするのが一般的です。  
具体的には、`Scaffold` に `resizeToAvoidBottomInset: true` を設定したり、`body` を `SingleChildScrollView` や `ListView` で包んであげると、キーボードが出てもレイアウトが崩れにくくなります。

たとえば下記のように書き換えてみてください（要点は `SingleChildScrollView` と `SafeArea` の利用です）。

```dart
return Scaffold(
  resizeToAvoidBottomInset: true, // キーボード分だけスクリーンを縮める
  body: GestureDetector(
    onTap: () {
      FocusScope.of(context).unfocus();
    },
    child: SafeArea(
      child: SingleChildScrollView(
        padding: const EdgeInsets.symmetric(horizontal: 24),
        child: Container(
          // MediaQueryで全体の高さを取得しておくと、
          // スクロールで無駄な空きが出ないように調整しやすい
          constraints: BoxConstraints(
            minHeight: MediaQuery.of(context).size.height 
                      - MediaQuery.of(context).padding.top
                      - MediaQuery.of(context).padding.bottom,
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              GestureDetector(
                onLongPress: onLongPressLogo,
                child: SvgPicture.asset(
                  Assets.images.logoLogin.path,
                ),
              ),
              const SizedBox(height: 38),
              Image.asset(
                Assets.images.loginFig.path,
              ),
              const SizedBox(height: 54),
              TextField(
                controller: textEditingController,
                decoration: const InputDecoration(
                  prefixIcon: Padding(
                    padding: EdgeInsets.all(12),
                    child: Icon(
                      Icons.email_outlined,
                      color: ColorToken.text,
                      size: 24,
                    ),
                  ),
                  hintText: 'Enter your email',
                ),
              ),
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: isLoadingState.value ? null : onTapLogin,
                child: const Text('Login'),
              ),
              // ここに余白を入れておくとキーボードがかぶりにくくなる
              const SizedBox(height: 40),
            ],
          ),
        ),
      ),
    ),
  ),
);
```

- `SingleChildScrollView` でラップすることで、キーボードが出ても全体をスクロールできるようになります。  
- `resizeToAvoidBottomInset` を `true` にしておくと、キーボードの高さ分だけスクリーンを縮めてくれます。  
- `SafeArea` を使うと、ノッチやステータスバーにコンテンツがかぶらないように調整できます。  
- 画面の高さより大きい要素がある場合は `SingleChildScrollView` や `ListView` を使ってスクロールさせるとレイアウト崩れを防げます。  

このように書き換えれば、「BOTTOM OVERFLOWED BY xx PIXELS」が解消され、キーボード表示時にも崩れずに表示できるようになるはずです。

---

## 👤 ユーザー
*2025/02/02 01:22:12*

ロゴをセンターに置いておきたいんだ

---

## 🤖 アシスタント
*2025/02/02 01:22:38*

キーボードが出てきても縦方向にスクロールできるようにしつつ、「画面が大きい場合はロゴを縦中央に配置しておきたい」という場合は、以下のように `SingleChildScrollView` と `ConstrainedBox` を組み合わせて書くと実現しやすいです。

ポイントは、**最小高さ(`minHeight`)を画面高(`MediaQuery.of(context).size.height`)にして**おき、`Column` の `mainAxisAlignment` を `center` にすることです。これで

- **画面サイズより小さい内容**ならロゴなどが画面中央に来る  
- **画面サイズより大きい内容**になる (キーボードが表示されるなど) とスクロールできる  

ようになります。

```dart
return Scaffold(
  resizeToAvoidBottomInset: true, // キーボードで画面が小さくなるのを許可
  body: GestureDetector(
    onTap: () => FocusScope.of(context).unfocus(),
    child: SafeArea(
      child: SingleChildScrollView(
        child: ConstrainedBox(
          // 中身の最小の高さを「画面一杯」にする
          constraints: BoxConstraints(
            minHeight: MediaQuery.of(context).size.height,
          ),
          // ↑これにより、画面が広いときはちょうど1画面にフィットし、
          // コンテンツが画面より大きいときはスクロールできる
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center, // 縦中央揃え
              children: [
                // --- ロゴ ---
                GestureDetector(
                  onLongPress: onLongPressLogo,
                  child: SvgPicture.asset(
                    Assets.images.logoLogin.path,
                  ),
                ),
                const SizedBox(height: 38),
                Image.asset(
                  Assets.images.loginFig.path,
                ),
                const SizedBox(height: 54),

                // --- メールアドレス入力 ---
                TextField(
                  controller: textEditingController,
                  decoration: const InputDecoration(
                    prefixIcon: Padding(
                      padding: EdgeInsets.all(12),
                      child: Icon(
                        Icons.email_outlined,
                        color: ColorToken.text,
                        size: 24,
                      ),
                    ),
                    hintText: 'Enter your email',
                  ),
                ),
                const SizedBox(height: 24),

                // --- ログインボタン ---
                ElevatedButton(
                  onPressed: isLoadingState.value ? null : onTapLogin,
                  child: const Text('Login'),
                ),

                // キーボードに隠れにくくするための余白
                const SizedBox(height: 40),
              ],
            ),
          ),
        ),
      ),
    ),
  ),
);
```

このように実装すると、画面が余っているときはロゴを含むすべてのウィジェットが真ん中に配置され、キーボードが出てコンテンツが画面以上に大きくなってもスクロールが有効になるので、下端が切れずにレイアウト崩れを防ぐことができます。

---
