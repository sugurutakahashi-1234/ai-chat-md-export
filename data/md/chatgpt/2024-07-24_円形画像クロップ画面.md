# 円形画像クロップ画面

日付: 2024-07-24

---

## 👤 ユーザー
*2024/07/24 18:34:34*

SwiftUIで画像を円形にクロップする画面を作りたい

- 背景は黒
- セーフエリアは無視
- キャンセルとDoneボタンを用意する
- 画像の拡大と縮小は可能。移動もう可能である
- 実際は正方形にくり抜く
- 画面は縦画面のみに対応するが、画像は横長でも縦長でも両方対応できるようにする
- 円は画面中央に大きく配置する。円の中はクリアになっていて外側は半透明になっている
- 正方形のガイドがなくていい
- 画像の移動は正方形をはみ出ないようにしたい

---

## 🤖 アシスタント
*2024/07/24 18:35:16*

SwiftUIで画像を円形にクロップする画面を作成するには、以下のようにコードを組むことができます。ここでは、黒い背景、キャンセルとDoneボタン、画像の拡大・縮小・移動、円形のクリア部分、そして画像の移動制限などを実装しています。

```swift
import SwiftUI

struct ImageCropView: View {
    @State private var image: UIImage?
    @State private var scale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        ZStack {
            Color.black
                .edgesIgnoringSafeArea(.all)

            if let image = image {
                GeometryReader { geometry in
                    let circleDiameter = min(geometry.size.width, geometry.size.height) * 0.8
                    let circleRadius = circleDiameter / 2

                    ZStack {
                        Image(uiImage: image)
                            .resizable()
                            .scaledToFit()
                            .scaleEffect(scale)
                            .offset(offset)
                            .frame(width: geometry.size.width, height: geometry.size.height)
                            .clipShape(Rectangle())

                        Circle()
                            .strokeBorder(Color.black.opacity(0.5), lineWidth: 5)
                            .frame(width: circleDiameter, height: circleDiameter)
                            .background(Circle().foregroundColor(Color.black.opacity(0.5)))

                        Circle()
                            .stroke(Color.white, lineWidth: 2)
                            .frame(width: circleDiameter, height: circleDiameter)
                    }
                    .mask(Circle().frame(width: circleDiameter, height: circleDiameter))
                    .gesture(
                        MagnificationGesture()
                            .onChanged { value in
                                scale = value.magnitude
                            }
                            .simultaneously(with: DragGesture()
                                .onChanged { value in
                                    let newOffset = CGSize(
                                        width: offset.width + value.translation.width,
                                        height: offset.height + value.translation.height
                                    )
                                    let imageBounds = CGRect(
                                        x: -circleRadius * scale,
                                        y: -circleRadius * scale,
                                        width: geometry.size.width * scale,
                                        height: geometry.size.height * scale
                                    )
                                    let circleBounds = CGRect(
                                        x: (geometry.size.width - circleDiameter) / 2,
                                        y: (geometry.size.height - circleDiameter) / 2,
                                        width: circleDiameter,
                                        height: circleDiameter
                                    )
                                    if circleBounds.contains(imageBounds.offsetBy(dx: newOffset.width, dy: newOffset.height)) {
                                        offset = newOffset
                                    }
                                }
                            )
                    )
                }
            }

            VStack {
                HStack {
                    Button(action: {
                        presentationMode.wrappedValue.dismiss()
                    }) {
                        Text("キャンセル")
                            .foregroundColor(.white)
                    }
                    Spacer()
                    Button(action: {
                        // Done action, implement cropping and saving the image
                    }) {
                        Text("Done")
                            .foregroundColor(.white)
                    }
                }
                .padding()
                Spacer()
            }
        }
        .onAppear {
            // Load your image here
            // image = UIImage(named: "your_image")
        }
    }
}

struct ImageCropView_Previews: PreviewProvider {
    static var previews: some View {
        ImageCropView()
    }
}
```

このコードでは、以下のポイントを実現しています：

1. **背景を黒に設定**：`Color.black.edgesIgnoringSafeArea(.all)` で全画面を黒にしています。
2. **キャンセルとDoneボタンの追加**：上部にボタンを配置しました。
3. **画像の拡大・縮小と移動**：`MagnificationGesture` と `DragGesture` を使用して画像の拡大・縮小および移動を可能にしています。
4. **円形のクリア部分と外側の半透明部分**：円形のクリア部分を表示し、外側を半透明にしています。
5. **画像の移動制限**：画像の移動が円の範囲内に収まるように制限しています。

実際に正方形にくり抜く処理は、`Done`ボタンのアクション内で実装してください。これにより、ユーザーが指定した部分を正方形で切り取り、必要な処理を行うことができます。

---

## 👤 ユーザー
*2024/07/24 18:35:24*

ボタンはナビゲーションに配置してほしい

---

## 🤖 アシスタント
*2024/07/24 18:35:54*

ナビゲーションバーにキャンセルとDoneボタンを配置するには、`NavigationView`を使用し、ナビゲーションバーアイテムとしてボタンを設定する必要があります。以下のように修正します。

```swift
import SwiftUI

struct ImageCropView: View {
    @State private var image: UIImage?
    @State private var scale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        NavigationView {
            ZStack {
                Color.black
                    .edgesIgnoringSafeArea(.all)

                if let image = image {
                    GeometryReader { geometry in
                        let circleDiameter = min(geometry.size.width, geometry.size.height) * 0.8
                        let circleRadius = circleDiameter / 2

                        ZStack {
                            Image(uiImage: image)
                                .resizable()
                                .scaledToFit()
                                .scaleEffect(scale)
                                .offset(offset)
                                .frame(width: geometry.size.width, height: geometry.size.height)
                                .clipShape(Rectangle())

                            Circle()
                                .strokeBorder(Color.black.opacity(0.5), lineWidth: 5)
                                .frame(width: circleDiameter, height: circleDiameter)
                                .background(Circle().foregroundColor(Color.black.opacity(0.5)))

                            Circle()
                                .stroke(Color.white, lineWidth: 2)
                                .frame(width: circleDiameter, height: circleDiameter)
                        }
                        .mask(Circle().frame(width: circleDiameter, height: circleDiameter))
                        .gesture(
                            MagnificationGesture()
                                .onChanged { value in
                                    scale = value.magnitude
                                }
                                .simultaneously(with: DragGesture()
                                    .onChanged { value in
                                        let newOffset = CGSize(
                                            width: offset.width + value.translation.width,
                                            height: offset.height + value.translation.height
                                        )
                                        let imageBounds = CGRect(
                                            x: -circleRadius * scale,
                                            y: -circleRadius * scale,
                                            width: geometry.size.width * scale,
                                            height: geometry.size.height * scale
                                        )
                                        let circleBounds = CGRect(
                                            x: (geometry.size.width - circleDiameter) / 2,
                                            y: (geometry.size.height - circleDiameter) / 2,
                                            width: circleDiameter,
                                            height: circleDiameter
                                        )
                                        if circleBounds.contains(imageBounds.offsetBy(dx: newOffset.width, dy: newOffset.height)) {
                                            offset = newOffset
                                        }
                                    }
                                )
                        )
                    }
                }
            }
            .navigationBarTitle("画像をクロップ", displayMode: .inline)
            .navigationBarItems(
                leading: Button("キャンセル") {
                    presentationMode.wrappedValue.dismiss()
                },
                trailing: Button("Done") {
                    // Done action, implement cropping and saving the image
                }
            )
            .onAppear {
                // Load your image here
                // image = UIImage(named: "your_image")
            }
        }
    }
}

struct ImageCropView_Previews: PreviewProvider {
    static var previews: some View {
        ImageCropView()
    }
}
```

このコードでは、`NavigationView`を使用し、ナビゲーションバーに「キャンセル」と「Done」のボタンを配置しています。ナビゲーションバーのタイトルを「画像をクロップ」とし、中央に配置される円の中に画像を表示して拡大・縮小・移動ができるようにしています。

---

## 👤 ユーザー
*2024/07/25 11:17:46*

PhotoCropViewにしてほしいのとツールバーは以下の実装にしてほしい

.toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    selectedImage = nil
                    dismiss.callAsFunction()
                } label: {
                    Text("キャンセル")
                        .foregroundStyle(.white)
                }
            }

            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("適用")
                        .foregroundStyle(.white)
                }
            }
        }

---

## 🤖 アシスタント
*2024/07/25 11:18:08*

`PhotoCropView`として、指定されたツールバーアイテムを使用したコードは以下の通りです。

```swift
import SwiftUI

struct PhotoCropView: View {
    @State private var image: UIImage?
    @State private var scale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        NavigationView {
            ZStack {
                Color.black
                    .edgesIgnoringSafeArea(.all)

                if let image = image {
                    GeometryReader { geometry in
                        let circleDiameter = min(geometry.size.width, geometry.size.height) * 0.8
                        let circleRadius = circleDiameter / 2

                        ZStack {
                            Image(uiImage: image)
                                .resizable()
                                .scaledToFit()
                                .scaleEffect(scale)
                                .offset(offset)
                                .frame(width: geometry.size.width, height: geometry.size.height)
                                .clipShape(Rectangle())

                            Circle()
                                .strokeBorder(Color.black.opacity(0.5), lineWidth: 5)
                                .frame(width: circleDiameter, height: circleDiameter)
                                .background(Circle().foregroundColor(Color.black.opacity(0.5)))

                            Circle()
                                .stroke(Color.white, lineWidth: 2)
                                .frame(width: circleDiameter, height: circleDiameter)
                        }
                        .mask(Circle().frame(width: circleDiameter, height: circleDiameter))
                        .gesture(
                            MagnificationGesture()
                                .onChanged { value in
                                    scale = value.magnitude
                                }
                                .simultaneously(with: DragGesture()
                                    .onChanged { value in
                                        let newOffset = CGSize(
                                            width: offset.width + value.translation.width,
                                            height: offset.height + value.translation.height
                                        )
                                        let imageBounds = CGRect(
                                            x: -circleRadius * scale,
                                            y: -circleRadius * scale,
                                            width: geometry.size.width * scale,
                                            height: geometry.size.height * scale
                                        )
                                        let circleBounds = CGRect(
                                            x: (geometry.size.width - circleDiameter) / 2,
                                            y: (geometry.size.height - circleDiameter) / 2,
                                            width: circleDiameter,
                                            height: circleDiameter
                                        )
                                        if circleBounds.contains(imageBounds.offsetBy(dx: newOffset.width, dy: newOffset.height)) {
                                            offset = newOffset
                                        }
                                    }
                                )
                        )
                    }
                }
            }
            .navigationBarTitle("画像をクロップ", displayMode: .inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button {
                        image = nil
                        presentationMode.wrappedValue.dismiss()
                    } label: {
                        Text("キャンセル")
                            .foregroundStyle(.white)
                    }
                }

                ToolbarItem(placement: .topBarTrailing) {
                    Button {
                        // Apply the cropping action
                        presentationMode.wrappedValue.dismiss()
                    } label: {
                        Text("適用")
                            .foregroundStyle(.white)
                    }
                }
            }
            .onAppear {
                // Load your image here
                // image = UIImage(named: "your_image")
            }
        }
    }
}

struct PhotoCropView_Previews: PreviewProvider {
    static var previews: some View {
        PhotoCropView()
    }
}
```

このコードでは、`PhotoCropView`に名前を変更し、ツールバーに「キャンセル」と「適用」のボタンを配置しています。`@Environment(\.presentationMode)` を使用してビューを閉じるための`dismiss`操作も追加しています。

---

## 👤 ユーザー
*2024/07/25 11:20:07*

@Binding var selectedImage: UIImage? としてほしい。iOS18以降の#Preview でじっそうしてほしい。

---

## 🤖 アシスタント
*2024/07/25 11:20:16*

`@Binding var selectedImage: UIImage?`を使用し、iOS18以降の`#Preview`を実装した`PhotoCropView`のコードは以下の通りです。

```swift
import SwiftUI

struct PhotoCropView: View {
    @Binding var selectedImage: UIImage?
    @State private var scale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        NavigationView {
            ZStack {
                Color.black
                    .edgesIgnoringSafeArea(.all)

                if let image = selectedImage {
                    GeometryReader { geometry in
                        let circleDiameter = min(geometry.size.width, geometry.size.height) * 0.8
                        let circleRadius = circleDiameter / 2

                        ZStack {
                            Image(uiImage: image)
                                .resizable()
                                .scaledToFit()
                                .scaleEffect(scale)
                                .offset(offset)
                                .frame(width: geometry.size.width, height: geometry.size.height)
                                .clipShape(Rectangle())

                            Circle()
                                .strokeBorder(Color.black.opacity(0.5), lineWidth: 5)
                                .frame(width: circleDiameter, height: circleDiameter)
                                .background(Circle().foregroundColor(Color.black.opacity(0.5)))

                            Circle()
                                .stroke(Color.white, lineWidth: 2)
                                .frame(width: circleDiameter, height: circleDiameter)
                        }
                        .mask(Circle().frame(width: circleDiameter, height: circleDiameter))
                        .gesture(
                            MagnificationGesture()
                                .onChanged { value in
                                    scale = value.magnitude
                                }
                                .sim

---
