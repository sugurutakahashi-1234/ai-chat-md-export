# å††å½¢ç”»åƒã‚¯ãƒ­ãƒƒãƒ—ç”»é¢

æ—¥ä»˜: 2024-07-24

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/07/24 18:34:34*

SwiftUIã§ç”»åƒã‚’å††å½¢ã«ã‚¯ãƒ­ãƒƒãƒ—ã™ã‚‹ç”»é¢ã‚’ä½œã‚ŠãŸã„

- èƒŒæ™¯ã¯é»’
- ã‚»ãƒ¼ãƒ•ã‚¨ãƒªã‚¢ã¯ç„¡è¦–
- ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¨Doneãƒœã‚¿ãƒ³ã‚’ç”¨æ„ã™ã‚‹
- ç”»åƒã®æ‹¡å¤§ã¨ç¸®å°ã¯å¯èƒ½ã€‚ç§»å‹•ã‚‚ã†å¯èƒ½ã§ã‚ã‚‹
- å®Ÿéš›ã¯æ­£æ–¹å½¢ã«ãã‚ŠæŠœã
- ç”»é¢ã¯ç¸¦ç”»é¢ã®ã¿ã«å¯¾å¿œã™ã‚‹ãŒã€ç”»åƒã¯æ¨ªé•·ã§ã‚‚ç¸¦é•·ã§ã‚‚ä¸¡æ–¹å¯¾å¿œã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
- å††ã¯ç”»é¢ä¸­å¤®ã«å¤§ããé…ç½®ã™ã‚‹ã€‚å††ã®ä¸­ã¯ã‚¯ãƒªã‚¢ã«ãªã£ã¦ã„ã¦å¤–å´ã¯åŠé€æ˜ã«ãªã£ã¦ã„ã‚‹
- æ­£æ–¹å½¢ã®ã‚¬ã‚¤ãƒ‰ãŒãªãã¦ã„ã„
- ç”»åƒã®ç§»å‹•ã¯æ­£æ–¹å½¢ã‚’ã¯ã¿å‡ºãªã„ã‚ˆã†ã«ã—ãŸã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/07/24 18:35:16*

SwiftUIã§ç”»åƒã‚’å††å½¢ã«ã‚¯ãƒ­ãƒƒãƒ—ã™ã‚‹ç”»é¢ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã‚’çµ„ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã“ã§ã¯ã€é»’ã„èƒŒæ™¯ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¨Doneãƒœã‚¿ãƒ³ã€ç”»åƒã®æ‹¡å¤§ãƒ»ç¸®å°ãƒ»ç§»å‹•ã€å††å½¢ã®ã‚¯ãƒªã‚¢éƒ¨åˆ†ã€ãã—ã¦ç”»åƒã®ç§»å‹•åˆ¶é™ãªã©ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚

```swift
import SwiftUI

struct ImageCropView: View {
    @State private var image: UIImage?
    @State private var scale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        ZStack {
            Color.black
                .edgesIgnoringSafeArea(.all)

            if let image = image {
                GeometryReader { geometry in
                    let circleDiameter = min(geometry.size.width, geometry.size.height) * 0.8
                    let circleRadius = circleDiameter / 2

                    ZStack {
                        Image(uiImage: image)
                            .resizable()
                            .scaledToFit()
                            .scaleEffect(scale)
                            .offset(offset)
                            .frame(width: geometry.size.width, height: geometry.size.height)
                            .clipShape(Rectangle())

                        Circle()
                            .strokeBorder(Color.black.opacity(0.5), lineWidth: 5)
                            .frame(width: circleDiameter, height: circleDiameter)
                            .background(Circle().foregroundColor(Color.black.opacity(0.5)))

                        Circle()
                            .stroke(Color.white, lineWidth: 2)
                            .frame(width: circleDiameter, height: circleDiameter)
                    }
                    .mask(Circle().frame(width: circleDiameter, height: circleDiameter))
                    .gesture(
                        MagnificationGesture()
                            .onChanged { value in
                                scale = value.magnitude
                            }
                            .simultaneously(with: DragGesture()
                                .onChanged { value in
                                    let newOffset = CGSize(
                                        width: offset.width + value.translation.width,
                                        height: offset.height + value.translation.height
                                    )
                                    let imageBounds = CGRect(
                                        x: -circleRadius * scale,
                                        y: -circleRadius * scale,
                                        width: geometry.size.width * scale,
                                        height: geometry.size.height * scale
                                    )
                                    let circleBounds = CGRect(
                                        x: (geometry.size.width - circleDiameter) / 2,
                                        y: (geometry.size.height - circleDiameter) / 2,
                                        width: circleDiameter,
                                        height: circleDiameter
                                    )
                                    if circleBounds.contains(imageBounds.offsetBy(dx: newOffset.width, dy: newOffset.height)) {
                                        offset = newOffset
                                    }
                                }
                            )
                    )
                }
            }

            VStack {
                HStack {
                    Button(action: {
                        presentationMode.wrappedValue.dismiss()
                    }) {
                        Text("ã‚­ãƒ£ãƒ³ã‚»ãƒ«")
                            .foregroundColor(.white)
                    }
                    Spacer()
                    Button(action: {
                        // Done action, implement cropping and saving the image
                    }) {
                        Text("Done")
                            .foregroundColor(.white)
                    }
                }
                .padding()
                Spacer()
            }
        }
        .onAppear {
            // Load your image here
            // image = UIImage(named: "your_image")
        }
    }
}

struct ImageCropView_Previews: PreviewProvider {
    static var previews: some View {
        ImageCropView()
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€ä»¥ä¸‹ã®ãƒã‚¤ãƒ³ãƒˆã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ï¼š

1. **èƒŒæ™¯ã‚’é»’ã«è¨­å®š**ï¼š`Color.black.edgesIgnoringSafeArea(.all)` ã§å…¨ç”»é¢ã‚’é»’ã«ã—ã¦ã„ã¾ã™ã€‚
2. **ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¨Doneãƒœã‚¿ãƒ³ã®è¿½åŠ **ï¼šä¸Šéƒ¨ã«ãƒœã‚¿ãƒ³ã‚’é…ç½®ã—ã¾ã—ãŸã€‚
3. **ç”»åƒã®æ‹¡å¤§ãƒ»ç¸®å°ã¨ç§»å‹•**ï¼š`MagnificationGesture` ã¨ `DragGesture` ã‚’ä½¿ç”¨ã—ã¦ç”»åƒã®æ‹¡å¤§ãƒ»ç¸®å°ãŠã‚ˆã³ç§»å‹•ã‚’å¯èƒ½ã«ã—ã¦ã„ã¾ã™ã€‚
4. **å††å½¢ã®ã‚¯ãƒªã‚¢éƒ¨åˆ†ã¨å¤–å´ã®åŠé€æ˜éƒ¨åˆ†**ï¼šå††å½¢ã®ã‚¯ãƒªã‚¢éƒ¨åˆ†ã‚’è¡¨ç¤ºã—ã€å¤–å´ã‚’åŠé€æ˜ã«ã—ã¦ã„ã¾ã™ã€‚
5. **ç”»åƒã®ç§»å‹•åˆ¶é™**ï¼šç”»åƒã®ç§»å‹•ãŒå††ã®ç¯„å›²å†…ã«åã¾ã‚‹ã‚ˆã†ã«åˆ¶é™ã—ã¦ã„ã¾ã™ã€‚

å®Ÿéš›ã«æ­£æ–¹å½¢ã«ãã‚ŠæŠœãå‡¦ç†ã¯ã€`Done`ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å†…ã§å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸéƒ¨åˆ†ã‚’æ­£æ–¹å½¢ã§åˆ‡ã‚Šå–ã‚Šã€å¿…è¦ãªå‡¦ç†ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/07/24 18:35:24*

ãƒœã‚¿ãƒ³ã¯ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã«é…ç½®ã—ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/07/24 18:35:54*

ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¨Doneãƒœã‚¿ãƒ³ã‚’é…ç½®ã™ã‚‹ã«ã¯ã€`NavigationView`ã‚’ä½¿ç”¨ã—ã€ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦ãƒœã‚¿ãƒ³ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ã‚ˆã†ã«ä¿®æ­£ã—ã¾ã™ã€‚

```swift
import SwiftUI

struct ImageCropView: View {
    @State private var image: UIImage?
    @State private var scale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        NavigationView {
            ZStack {
                Color.black
                    .edgesIgnoringSafeArea(.all)

                if let image = image {
                    GeometryReader { geometry in
                        let circleDiameter = min(geometry.size.width, geometry.size.height) * 0.8
                        let circleRadius = circleDiameter / 2

                        ZStack {
                            Image(uiImage: image)
                                .resizable()
                                .scaledToFit()
                                .scaleEffect(scale)
                                .offset(offset)
                                .frame(width: geometry.size.width, height: geometry.size.height)
                                .clipShape(Rectangle())

                            Circle()
                                .strokeBorder(Color.black.opacity(0.5), lineWidth: 5)
                                .frame(width: circleDiameter, height: circleDiameter)
                                .background(Circle().foregroundColor(Color.black.opacity(0.5)))

                            Circle()
                                .stroke(Color.white, lineWidth: 2)
                                .frame(width: circleDiameter, height: circleDiameter)
                        }
                        .mask(Circle().frame(width: circleDiameter, height: circleDiameter))
                        .gesture(
                            MagnificationGesture()
                                .onChanged { value in
                                    scale = value.magnitude
                                }
                                .simultaneously(with: DragGesture()
                                    .onChanged { value in
                                        let newOffset = CGSize(
                                            width: offset.width + value.translation.width,
                                            height: offset.height + value.translation.height
                                        )
                                        let imageBounds = CGRect(
                                            x: -circleRadius * scale,
                                            y: -circleRadius * scale,
                                            width: geometry.size.width * scale,
                                            height: geometry.size.height * scale
                                        )
                                        let circleBounds = CGRect(
                                            x: (geometry.size.width - circleDiameter) / 2,
                                            y: (geometry.size.height - circleDiameter) / 2,
                                            width: circleDiameter,
                                            height: circleDiameter
                                        )
                                        if circleBounds.contains(imageBounds.offsetBy(dx: newOffset.width, dy: newOffset.height)) {
                                            offset = newOffset
                                        }
                                    }
                                )
                        )
                    }
                }
            }
            .navigationBarTitle("ç”»åƒã‚’ã‚¯ãƒ­ãƒƒãƒ—", displayMode: .inline)
            .navigationBarItems(
                leading: Button("ã‚­ãƒ£ãƒ³ã‚»ãƒ«") {
                    presentationMode.wrappedValue.dismiss()
                },
                trailing: Button("Done") {
                    // Done action, implement cropping and saving the image
                }
            )
            .onAppear {
                // Load your image here
                // image = UIImage(named: "your_image")
            }
        }
    }
}

struct ImageCropView_Previews: PreviewProvider {
    static var previews: some View {
        ImageCropView()
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`NavigationView`ã‚’ä½¿ç”¨ã—ã€ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã«ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ã¨ã€ŒDoneã€ã®ãƒœã‚¿ãƒ³ã‚’é…ç½®ã—ã¦ã„ã¾ã™ã€‚ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’ã€Œç”»åƒã‚’ã‚¯ãƒ­ãƒƒãƒ—ã€ã¨ã—ã€ä¸­å¤®ã«é…ç½®ã•ã‚Œã‚‹å††ã®ä¸­ã«ç”»åƒã‚’è¡¨ç¤ºã—ã¦æ‹¡å¤§ãƒ»ç¸®å°ãƒ»ç§»å‹•ãŒã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/07/25 11:17:46*

PhotoCropViewã«ã—ã¦ã»ã—ã„ã®ã¨ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã¯ä»¥ä¸‹ã®å®Ÿè£…ã«ã—ã¦ã»ã—ã„

.toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    selectedImage = nil
                    dismiss.callAsFunction()
                } label: {
                    Text("ã‚­ãƒ£ãƒ³ã‚»ãƒ«")
                        .foregroundStyle(.white)
                }
            }

            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    dismiss.callAsFunction()
                } label: {
                    Text("é©ç”¨")
                        .foregroundStyle(.white)
                }
            }
        }

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/07/25 11:18:08*

`PhotoCropView`ã¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½¿ç”¨ã—ãŸã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```swift
import SwiftUI

struct PhotoCropView: View {
    @State private var image: UIImage?
    @State private var scale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        NavigationView {
            ZStack {
                Color.black
                    .edgesIgnoringSafeArea(.all)

                if let image = image {
                    GeometryReader { geometry in
                        let circleDiameter = min(geometry.size.width, geometry.size.height) * 0.8
                        let circleRadius = circleDiameter / 2

                        ZStack {
                            Image(uiImage: image)
                                .resizable()
                                .scaledToFit()
                                .scaleEffect(scale)
                                .offset(offset)
                                .frame(width: geometry.size.width, height: geometry.size.height)
                                .clipShape(Rectangle())

                            Circle()
                                .strokeBorder(Color.black.opacity(0.5), lineWidth: 5)
                                .frame(width: circleDiameter, height: circleDiameter)
                                .background(Circle().foregroundColor(Color.black.opacity(0.5)))

                            Circle()
                                .stroke(Color.white, lineWidth: 2)
                                .frame(width: circleDiameter, height: circleDiameter)
                        }
                        .mask(Circle().frame(width: circleDiameter, height: circleDiameter))
                        .gesture(
                            MagnificationGesture()
                                .onChanged { value in
                                    scale = value.magnitude
                                }
                                .simultaneously(with: DragGesture()
                                    .onChanged { value in
                                        let newOffset = CGSize(
                                            width: offset.width + value.translation.width,
                                            height: offset.height + value.translation.height
                                        )
                                        let imageBounds = CGRect(
                                            x: -circleRadius * scale,
                                            y: -circleRadius * scale,
                                            width: geometry.size.width * scale,
                                            height: geometry.size.height * scale
                                        )
                                        let circleBounds = CGRect(
                                            x: (geometry.size.width - circleDiameter) / 2,
                                            y: (geometry.size.height - circleDiameter) / 2,
                                            width: circleDiameter,
                                            height: circleDiameter
                                        )
                                        if circleBounds.contains(imageBounds.offsetBy(dx: newOffset.width, dy: newOffset.height)) {
                                            offset = newOffset
                                        }
                                    }
                                )
                        )
                    }
                }
            }
            .navigationBarTitle("ç”»åƒã‚’ã‚¯ãƒ­ãƒƒãƒ—", displayMode: .inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button {
                        image = nil
                        presentationMode.wrappedValue.dismiss()
                    } label: {
                        Text("ã‚­ãƒ£ãƒ³ã‚»ãƒ«")
                            .foregroundStyle(.white)
                    }
                }

                ToolbarItem(placement: .topBarTrailing) {
                    Button {
                        // Apply the cropping action
                        presentationMode.wrappedValue.dismiss()
                    } label: {
                        Text("é©ç”¨")
                            .foregroundStyle(.white)
                    }
                }
            }
            .onAppear {
                // Load your image here
                // image = UIImage(named: "your_image")
            }
        }
    }
}

struct PhotoCropView_Previews: PreviewProvider {
    static var previews: some View {
        PhotoCropView()
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`PhotoCropView`ã«åå‰ã‚’å¤‰æ›´ã—ã€ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã«ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ã¨ã€Œé©ç”¨ã€ã®ãƒœã‚¿ãƒ³ã‚’é…ç½®ã—ã¦ã„ã¾ã™ã€‚`@Environment(\.presentationMode)` ã‚’ä½¿ç”¨ã—ã¦ãƒ“ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹ãŸã‚ã®`dismiss`æ“ä½œã‚‚è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/07/25 11:20:07*

@Binding var selectedImage: UIImage? ã¨ã—ã¦ã»ã—ã„ã€‚iOS18ä»¥é™ã®#Preview ã§ã˜ã£ãã†ã—ã¦ã»ã—ã„ã€‚

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/07/25 11:20:16*

`@Binding var selectedImage: UIImage?`ã‚’ä½¿ç”¨ã—ã€iOS18ä»¥é™ã®`#Preview`ã‚’å®Ÿè£…ã—ãŸ`PhotoCropView`ã®ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```swift
import SwiftUI

struct PhotoCropView: View {
    @Binding var selectedImage: UIImage?
    @State private var scale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        NavigationView {
            ZStack {
                Color.black
                    .edgesIgnoringSafeArea(.all)

                if let image = selectedImage {
                    GeometryReader { geometry in
                        let circleDiameter = min(geometry.size.width, geometry.size.height) * 0.8
                        let circleRadius = circleDiameter / 2

                        ZStack {
                            Image(uiImage: image)
                                .resizable()
                                .scaledToFit()
                                .scaleEffect(scale)
                                .offset(offset)
                                .frame(width: geometry.size.width, height: geometry.size.height)
                                .clipShape(Rectangle())

                            Circle()
                                .strokeBorder(Color.black.opacity(0.5), lineWidth: 5)
                                .frame(width: circleDiameter, height: circleDiameter)
                                .background(Circle().foregroundColor(Color.black.opacity(0.5)))

                            Circle()
                                .stroke(Color.white, lineWidth: 2)
                                .frame(width: circleDiameter, height: circleDiameter)
                        }
                        .mask(Circle().frame(width: circleDiameter, height: circleDiameter))
                        .gesture(
                            MagnificationGesture()
                                .onChanged { value in
                                    scale = value.magnitude
                                }
                                .sim

---
