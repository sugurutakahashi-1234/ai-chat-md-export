# APIキーセキュリティ対策

日付: 2025-05-28

---

## 👤 ユーザー
*2025/5/28 10:51:28*

Swiftで、apiKeyなどはほとんどハードコードしていたが、セキュリティー的にGitHubのアクセスを制限している場合問題ないのか？

これをwebアプリ開発だとapiKeyの実装を気をつけないといけないことはあるのか？

---

## 🤖 アシスタント
*2025/5/28 10:51:29*

### 1️⃣ Swift（ネイティブアプリ）で API キーをハードコードするときの落とし穴
| よくある誤解 | 実際に起きるリスク | 対策の方向性 |
| --- | --- | --- |
| **「GitHub を private にしているから安全」** | ▸ レビュー依頼・招待で第三者が閲覧可能になる<br>▸ GitHub API や GitHub Apps から漏れる<br>▸ 将来リポジトリを公開／フォークすると流出 | リモートに置かない（GitHub Secrets や環境変数で注入） |
| **「バイナリに埋め込んで署名すれば抜けない」** | ▸ .ipa を展開すれば文字列検索で発見可能<br>▸ Jailbreak・Frida で動的解析される<br>▸ HTTPS でも MITM＋SSL-Pinning 回避で傍受可 | - 機密度が高いキーは**端末に配布しない**<br>- どうしても必要なときは<br> ◦ Keychain + Secure Enclave に保管<br> ◦ Runtime でサーバーから短寿命トークンを取得 |

> ✅ **結論**  
> GitHub のアクセス制限だけでは不十分。  
> **① “コードベースには機密キーを残さない”** **② “アプリに渡すキーを最小化する”** の二段構えが基本です。

---

### 2️⃣ iOS ネイティブで実際によく使う 3 つの方法

| 方法 | 使い所 | 概略手順 |
| --- | --- | --- |
| **ビルド時注入 (.xcconfig / Swift Package Plugin)** | 公開しても問題ない「公開キー」やベース URL など | 1. `Config.xcconfig` に `API_BASE_URL=$(API_BASE_URL)`<br>2. Xcode では `$(inherited)` で参照<br>3. CI で `xcodebuild` に `API_BASE_URL=https://example.com` を渡す |
| **Keychain + Remote Token** | Stripe 秘密キーなど本当に守るべき情報 | 1. アプリ初回起動時に認証<br>2. サーバーから **短寿命** の署名付きトークンを取得<br>3. Keychain に保存、失効したら再取得 |
| **App Attestation / DeviceCheck 経由サーバー署名** | 不正改変・Bot 対策が必要なケース | 1. クライアントは公開情報だけ持つ<br>2. 決済や高権限 API はサーバーで実行<br>3. App Attest で署名したリクエストだけ通す |

---

### 3️⃣ Web アプリ（SPA / PWA）で気を付けるポイント

1. **ブラウザへ配布した時点で“すべて公開情報”**  
   - JavaScript バンドルは `curl` で誰でも取得可能。  
   - “環境変数に入れたから大丈夫” → ビルド後は生 JS に展開される。

2. **機密キーは必ずバックエンド・プロキシに隠蔽**  
   - フロントエンドは **公開キー** や **匿名アクセス用トークン** だけを使う。  
   - 例：Firebase は `apiKey` が公開前提、権限制御はルールで行う。

3. **CORS＋ドメイン制限は鍵の代わりにならない**  
   - Origin 偽装用の中継サーバーは容易に立てられる。  
   - 認証／認可は JWT・OAuth や署名で行う。

> 📝 **実装の鉄則（Web）**  
> - 「秘密の値をブラウザへ渡さない」  
> - 「フロント → 自前 API → 外部サービス**という 2 段階**で呼ぶ」  
> - Netlify Functions / Cloudflare Workers など **軽量サーバーレス層**が便利。

---

### 4️⃣ GitHub／CI/CD での安全なシークレット管理フロー例

```
name: iOS Release
on: push:
  tags: ["v*"]
jobs:
  build:
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4
      - name: Set up secrets
        run: |
          echo "API_BASE_URL=$API_BASE_URL" >> Config.xcconfig
      - name: Build & Notarize
        run: xcodebuild -scheme MyApp ...
    env:
      # GitHub Secrets にだけ置く
      API_BASE_URL: ${{ secrets.API_BASE_URL }}
      STRIPE_SECRET: ${{ secrets.STRIPE_SECRET }}  # ← サーバー側でのみ使用
```

- **コードベースには置かない** → `.gitignore` で `*.xcconfig` を除外。  
- **GitHub Secrets** → UI または `gh secret set` コマンドで登録。  
- **PR で外部コントリビューターが見られない** ように `secrets: inherit` を避ける。

---

### 5️⃣ まとめ

| アプリ種別 | “クライアントへ埋め込んでもよい情報” | 守るべき実装パターン |
| --- | --- | --- |
| **iOS/Android** | 公開キー・ベース URL・アナリティクス ID など | Keychain、短寿命トークン、Secure Enclave、App Attest |
| **Web (SPA/PWA)** | 公開キーのみ（Firebase apiKey 等） | すべてバックエンド経由／サーバーレスプロキシ |
| **バックエンド** | すべての機密情報 | 環境変数（.env）、Secret Manager、KMS、Vault |

> 🔐 **鍵は基本「サーバー側でのみ保持し、クライアントは最小権限のトークンで動く」**。  
> GitHub を閉じてもバイナリやブラウザコードは公開される――ここを出発点に設計すると安全性と運用の手間のバランスがとれます。

---

## 👤 ユーザー
*2025/5/28 10:54:16*

たとえば、openapiのapikeyなどha

---
