# 特定enumのエラーハンドリング

日付: 2023-06-25

---

## 👤 ユーザー
*2023/6/25 15:35:35*

Swift で do {} catch で特定のenumのエラーのみ特別なエラーハンドリングがしたい。

---

## 🤖 アシスタント
*2023/6/25 15:36:02*

Swiftのエラーハンドリングでは、特定のenumのエラーだけを特別にハンドリングするために、`do-catch` ブロック内でそのエラー型を特定できます。以下はその例です：

まず、ある特定のエラーを定義しましょう。

```swift
enum MyError: Error {
    case errorType1
    case errorType2
    case errorType3
}
```

それから、これらのエラーをスローするかもしれない関数を作成します。

```swift
func doSomething() throws {
    // Some code
    // If something goes wrong, throw an error
    throw MyError.errorType1
}
```

最後に、do-catch ブロックで特定のエラータイプをハンドルします。

```swift
do {
    try doSomething()
} catch MyError.errorType1 {
    // Handle errorType1
    print("Error Type 1 Occurred")
} catch MyError.errorType2 {
    // Handle errorType2
    print("Error Type 2 Occurred")
} catch {
    // Handle all other errors
    print("An Unknown Error Occurred")
}
```

これにより、`errorType1` と `errorType2` のエラーはそれぞれの `catch` ブロックで処理され、それ以外のエラーは最後の `catch` ブロックで処理されます。エラーの順序は重要で、最初に一致したエラーがハンドルされ、その後のエラーは無視されます。したがって、最も具体的なエラータイプを最初に捕捉し、最も一般的なエラータイプを最後に捕捉することが重要です。

---

## 👤 ユーザー
*2023/6/25 15:41:44*

let っていらないんだっけ？

---

## 🤖 アシスタント
*2023/6/25 15:42:03*

すみません、あなたのご指摘は正しいです。それぞれのエラーケースに対して変数を定義し、エラーの詳細にアクセスする場合、`let` を使用する必要があります。以下に修正したコードを示します：

```swift
do {
    try doSomething()
} catch MyError.errorType1 {
    // Handle errorType1
    print("Error Type 1 Occurred")
} catch MyError.errorType2(let details) {
    // Handle errorType2
    print("Error Type 2 Occurred, Details: \(details)")
} catch {
    // Handle all other errors
    print("An Unknown Error Occurred")
}
```

上記の例では、`MyError.errorType2` の場合に `let details` を使用してエラーの詳細にアクセスしています。ただし、`MyError` enumが具体的なエラー情報を保持していない場合、つまりエラーが単なる識別子のみで詳細を持っていない場合（上記の例のように）、`let`を使用する必要はありません。

---

## 👤 ユーザー
*2023/6/25 15:44:57*

2つのenum が合った場合のハンドリングも教えて欲しい



public enum HogeError: Error {
    case hogehoge
    case hogehogehoge
}

public enum MogeError: Error {
    case mogemoge
    case mogemogemoge
}

---

## 🤖 アシスタント
*2023/6/25 15:45:27*

複数の `enum` を含むエラーをハンドリングする場合でも、Swiftの `do-catch` 構文を使用します。それぞれの `enum` の異なるエラーを別々の `catch` ブロックでハンドルできます。具体的には、以下のように行います：

```swift
do {
    try doSomething()
} catch HogeError.hogehoge {
    // Handle hogehoge error
    print("Hoge Error: hogehoge Occurred")
} catch HogeError.hogehogehoge {
    // Handle hogehogehoge error
    print("Hoge Error: hogehogehoge Occurred")
} catch MogeError.mogemoge {
    // Handle mogemoge error
    print("Moge Error: mogemoge Occurred")
} catch MogeError.mogemogemoge {
    // Handle mogemogemoge error
    print("Moge Error: mogemogemoge Occurred")
} catch {
    // Handle all other errors
    print("An Unknown Error Occurred")
}
```

ここでは、`doSomething`関数が `HogeError` または `MogeError` のインスタンスをスローする可能性があると想定しています。それぞれの `catch` ブロックは特定のエラーケースを処理し、最後の `catch` ブロックはこれらのエラーケース以外のすべてのエラーを処理します。

また、各エラーケースが詳細な情報を含んでいる場合、`catch` ブロックの定義で `let` キーワードを使用してそれにアクセスできます。例えば：

```swift
do {
    try doSomething()
} catch HogeError.hogehoge(let details) {
    // Handle hogehoge error and access details
    print("Hoge Error: hogehoge Occurred, Details: \(details)")
} // ...
```

ただし、ここでも注意が必要で、エラーの詳細情報はエラー定義の一部として存在する場合のみアクセスできます。

---

## 👤 ユーザー
*2023/6/25 15:45:52*

HogeError と MogeError とそれ以外の3つの catch ブロックにはできないの？

---

## 🤖 アシスタント
*2023/6/25 15:46:14*

もちろん可能です。Swiftのエラーハンドリングは非常に柔軟で、あなたが述べたようなユースケースでも対応できます。以下に示すように、`HogeError`と`MogeError`を別々のcatchブロックで捕捉し、それ以外のすべてのエラーを一つのcatchブロックで捕捉することができます：

```swift
do {
    try doSomething()
} catch let error as HogeError {
    switch error {
    case .hogehoge:
        print("Hoge Error: hogehoge Occurred")
    case .hogehogehoge:
        print("Hoge Error: hogehogehoge Occurred")
    }
} catch let error as MogeError {
    switch error {
    case .mogemoge:
        print("Moge Error: mogemoge Occurred")
    case .mogemogemoge:
        print("Moge Error: mogemogemoge Occurred")
    }
} catch {
    // Handle all other errors
    print("An Unknown Error Occurred")
}
```

ここでは、`as`キーワードを使用してエラーを特定のエラータイプにダウンキャストし、それから`switch`ステートメントを使用してそのエラータイプの特定のエラーケースを処理しています。最後の`catch`ブロックは、`HogeError`と`MogeError`以外のすべてのエラーを処理します。

---
