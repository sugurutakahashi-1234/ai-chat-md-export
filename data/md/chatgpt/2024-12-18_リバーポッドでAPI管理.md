# リバーポッドでAPI管理

Date: 2024-12-18

---

## 👤 User
*2024-12-18 15:32:48*

以下のような api をリバーポッドアノテーションを使って便利に使いたい。
どうすればいいか？ 
class GuildApi {
  GuildApi(
    this.dio,
    this.baseUri,
  );

  final Dio dio;

  final Uri baseUri;

  /// Get guild information of requested user[GLD0101]
  /// get: /v1/guilds
  ///
  Future&lt;Response&lt;GuildInfoResponseDto&gt;&gt; guildControllerGetGuildInfo() async {
    final queryParams = &lt;String, dynamic&gt;{};
    final uri = baseUri.replace(
        queryParameters: queryParams, path: baseUri.path + '/v1/guilds');
    final response = await dio.getUri&lt;Map&lt;String, dynamic&gt;&gt;(uri);
    final parsed = GuildInfoResponseDto.fromJson(response.data!);
    return Response&lt;GuildInfoResponseDto&gt;(
      data: parsed,
      headers: response.headers,
      requestOptions: response.requestOptions,
      isRedirect: response.isRedirect,
      statusCode: response.statusCode,
      redirects: response.redirects,
      extra: response.extra,
    );
  }

  /// Create a new guild [GLD0103]
  /// post: /v1/guilds
  ///
  Future&lt;Response&lt;EmptyResponseSchema&gt;&gt; guildControllerCreateGuild(
      CreateGuildRequestDto body) async {
    final queryParams = &lt;String, dynamic&gt;{};
    final uri = baseUri.replace(
        queryParameters: queryParams, path: baseUri.path + '/v1/guilds');
    final response = await dio.postUri&lt;Map&lt;String, dynamic&gt;&gt;(uri, data: body);
    final parsed = EmptyResponseSchema.fromJson(response.data!);
    return Response&lt;EmptyResponseSchema&gt;(
      data: parsed,
      headers: response.headers,
      requestOptions: response.requestOptions,
      isRedirect: response.isRedirect,
      statusCode: response.statusCode,
      redirects: response.redirects,
      extra: response.extra,
    );
  }
}

@freezed
class EmptyResponseSchema with _$EmptyResponseSchema {
  factory EmptyResponseSchema({
    @JsonKey(name: 'code') required num? code,
    @JsonKey(name: 'data') required String? data,
    @JsonKey(name: 'errorMessage') required String? errorMessage,
  }) = _EmptyResponseSchema;

  factory EmptyResponseSchema.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$EmptyResponseSchemaFromJson(jsonMap);
}



@freezed
class GuildInfoResponseDto with _$GuildInfoResponseDto {
  factory GuildInfoResponseDto({
    @JsonKey(name: 'code') required num? code,
    @JsonKey(name: 'errorMessage') required String? errorMessage,
    @JsonKey(name: 'data') required GuildInfoResponseDtoData? data,
  }) = _GuildInfoResponseDto;

  factory GuildInfoResponseDto.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$GuildInfoResponseDtoFromJson(jsonMap);
}


{
    "code": 0,
    "data": {
        "guild_id": "4571566835",
        "guild_name": "222222",
        "guild_description": "test",
        "guild_owner": "123e4567-e89b-12d3-a456-426614174000",
        "guild_avatar": null,
        "guild_banner": null,
        "guild_members": [
            {
                "user_id": "123e4567-e89b-12d3-a456-426614174000",
                "role": "OWNER",
                "member_status": "JOINED"
            }
        ]
    }
}

---

## 🤖 Assistant
*2024-12-18 15:33:11*

リバーポッド（Riverpod）のアノテーションを使用して `GuildApi` を便利に利用するには、以下のような手順を踏むと良いです。

---

### 1. **`GuildApi` のプロバイダを作成する**
まず、`GuildApi` をプロバイダとして管理します。リバーポッドではアノテーションを使用してプロバイダを簡略化できます。

#### 例:

```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';

part 'guild_api_provider.g.dart'; // 自動生成されたコードの出力先

@riverpod
GuildApi guildApi(GuildApiRef ref) {
  final dio = Dio(); // 必要に応じて Dio をカスタマイズ
  final baseUri = Uri.parse('https://api.example.com'); // API のベース URI
  return GuildApi(dio, baseUri);
}
```

---

### 2. **`GuildApi` のメソッドをリバーポッドで非同期プロバイダとしてラップする**
Riverpod アノテーションの `@riverpod` を使い、API メソッドを非同期プロバイダとしてラップします。これにより、非同期の状態管理が自動化されます。

#### 例:

```dart
@riverpod
Future<GuildInfoResponseDto> guildInfo(GuildInfoRef ref) async {
  final api = ref.watch(guildApiProvider); // GuildApi のインスタンスを取得
  final response = await api.guildControllerGetGuildInfo();
  return response.data!;
}
```

---

### 3. **データ取得の状態を UI で監視**
プロバイダで管理されたデータを UI に簡単にバインドできます。

#### 例:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class GuildInfoScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final guildInfoAsyncValue = ref.watch(guildInfoProvider);

    return Scaffold(
      appBar: AppBar(title: Text('Guild Info')),
      body: guildInfoAsyncValue.when(
        data: (guildInfo) => ListView(
          children: [
            Text('Guild Name: ${guildInfo.data?.guildName}'),
            Text('Description: ${guildInfo.data?.guildDescription}'),
            // 他のギルド情報を表示
          ],
        ),
        loading: () => Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(child: Text('Error: $error')),
      ),
    );
  }
}
```

---

### 4. **API パラメータが必要なケースの対応**
例えば、`guildControllerCreateGuild` メソッドを呼び出す場合、リクエストボディを受け取るように非同期プロバイダを作成します。

#### 例:

```dart
@riverpod
Future<EmptyResponseSchema> createGuild(
  CreateGuildRef ref, {
  required CreateGuildRequestDto body,
}) async {
  final api = ref.watch(guildApiProvider);
  final response = await api.guildControllerCreateGuild(body);
  return response.data!;
}
```

使用例:

```dart
final response = await ref.read(createGuildProvider(body: CreateGuildRequestDto(
  guildName: 'New Guild',
  description: 'Guild Description',
)));
```

---

### 5. **自動生成コードの実行**
`guild_api_provider.dart` の自動生成コードを生成するには、以下を実行してください。

```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

---

### 完成後のメリット
- **状態管理の簡略化:** `FutureProvider` を活用することで API 呼び出しの状態（ロード中、成功、失敗）を簡単に管理できます。
- **再利用性:** `GuildApi` を他のプロバイダやビューで簡単に再利用可能。
- **コードの可読性向上:** アノテーションを活用することで手動でのプロバイダ設定が不要。

これで、`GuildApi` を Riverpod と組み合わせて効率よく管理できるようになります！

---
