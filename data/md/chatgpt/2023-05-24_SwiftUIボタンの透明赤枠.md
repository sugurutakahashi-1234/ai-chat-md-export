# SwiftUIボタンの透明赤枠

日付: 2023-05-24

---

## 👤 ユーザー
*2023/05/24 23:54:05*

SwiftUIで透明背景のボーダー赤色のボタンを実装して欲しい

---

## 🤖 アシスタント
*2023/05/24 23:54:32*

SwiftUIを使って透明背景に赤色のボーダーを持つボタンを実装するには、以下のようにコードを書くことができます。

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        Button(action: {
            print("Button tapped")
        }) {
            Text("Button")
                .padding()
                .foregroundColor(.black)
        }
        .background(Color.clear)
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(Color.red, lineWidth: 2)
        )
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードでは、ボタンは透明な背景を持ち、その周りには赤色のボーダーがあります。ボーダーの形状は四角形で、角は少し丸みを持っています。ボタンがタップされた時には "Button tapped" というメッセージがコンソールに表示されます。

---

## 👤 ユーザー
*2023/05/24 23:56:16*

Text("Button") の .foregroundColor(.black) を入れたくない

---

## 🤖 アシスタント
*2023/05/24 23:56:36*

`foregroundColor(.black)`を使わない場合、Textの色はデフォルトの色（通常は黒）になります。そのため、以下のようにコードを変更することができます：

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        Button(action: {
            print("Button tapped")
        }) {
            Text("Button")
                .padding()
        }
        .background(Color.clear)
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(Color.red, lineWidth: 2)
        )
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードでは、ボタンのテキストの色はデフォルトの色（通常は黒）になります。

---

## 👤 ユーザー
*2023/05/24 23:57:12*

そういう意味ではなくて、ラベルの色をButtonのメソッドチェーンで変更したいんだ

---

## 🤖 アシスタント
*2023/05/24 23:57:48*

あ、なるほど理解しました。SwiftUIのButtonでは、`buttonStyle`や`foregroundColor`メソッドを使ってボタン全体の色を変更することができます。ですが、これらのメソッドはボタン全体の色を変更するため、透明背景に赤色のボーダーを持つボタンを作成する際には使うことができません。

代わりに、`Button`のラベルをカスタマイズして、ラベルの色を変更することができます。以下にその例を示します。

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        Button(action: {
            print("Button tapped")
        }) {
            Text("Button")
                .foregroundColor(.black) // ラベルの色を変更
                .padding()
        }
        .background(Color.clear)
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(Color.red, lineWidth: 2)
        )
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードでは、`Text`の`foregroundColor`メソッドを使って、ボタンのラベルの色を変更しています。

---

## 👤 ユーザー
*2023/05/24 23:58:24*

もし透明ではなくて白色背景のボーダーありだったらどんな実装になるの？

---

## 🤖 アシスタント
*2023/05/24 23:58:53*

白色の背景を持つボーダー付きのボタンを実装する場合、以下のようにコードを変更することができます：

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        Button(action: {
            print("Button tapped")
        }) {
            Text("Button")
                .padding()
                .background(Color.white)
                .cornerRadius(10)
        }
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(Color.red, lineWidth: 2)
        )
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

ここでは、`Text`に`.background(Color.white)`を追加し、`.cornerRadius(10)`で角を丸めています。この方法でボタン自体の背景色を白色に設定できます。そして、その上に`.overlay`で赤色のボーダーを付けています。

---

## 👤 ユーザー
*2023/05/24 23:59:03*

Text("Button") 側は編集したくないんだ

---

## 🤖 アシスタント
*2023/05/24 23:59:32*

理解しました。その場合、ボタン自体の背景色とボーダーを設定するために、`Button`のメソッドチェーンを編集することができます。以下のコードが参考になるかと思います：

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        Button(action: {
            print("Button tapped")
        }) {
            Text("Button")
                .padding()
        }
        .background(Color.white)
        .cornerRadius(10)
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(Color.red, lineWidth: 2)
        )
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードでは、`Button`メソッドチェーンに`.background(Color.white)`と`.cornerRadius(10)`を追加して、ボタン自体の背景色を白に設定し、角を丸くしています。その上に赤色のボーダーを付けています。

---

## 👤 ユーザー
*2023/05/25 00:10:05*

以下を全部検証するSwiftUIのコードを書いて欲しい
List で ButtonType ごとの Section をつくってほしい。ボタンの位置は中央揃いだと嬉しい

public enum ButtonState: String, CaseIterable, Identifiable {
    case `default`
    case pressed
    case disabled
    
    public var id: String {
        rawValue
    }
}

public enum ButtonType: String, CaseIterable, Identifiable {
    case primary
    case secondary
    case tertiary
    case text
    
    public var id: String {
        rawValue
    }
}

---

## 🤖 アシスタント
*2023/05/25 00:11:11*

指定された条件に基づいて、以下のようにSwiftUIのコードを作成します：

```swift
import SwiftUI

public enum ButtonState: String, CaseIterable, Identifiable {
    case `default`
    case pressed
    case disabled

    public var id: String {
        rawValue
    }
}

public enum ButtonType: String, CaseIterable, Identifiable {
    case primary
    case secondary
    case tertiary
    case text

    public var id: String {
        rawValue
    }
}

struct ContentView: View {
    var body: some View {
        List {
            ForEach(ButtonType.allCases) { buttonType in
                Section(header: Text(buttonType.rawValue.capitalized)) {
                    ForEach(ButtonState.allCases) { buttonState in
                        ButtonView(type: buttonType, state: buttonState)
                    }
                }
            }
        }
    }
}

struct ButtonView: View {
    let type: ButtonType
    let state: ButtonState
    
    var body: some View {
        switch state {
        case .default:
            Text("\(type.rawValue.capitalized) \(state.rawValue.capitalized)")
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color.white)
                .cornerRadius(10)
                .overlay(
                    RoundedRectangle(cornerRadius: 10)
                        .stroke(Color.red, lineWidth: 2)
                )
        case .pressed:
            Text("\(type.rawValue.capitalized) \(state.rawValue.capitalized)")
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color.gray)
                .cornerRadius(10)
        case .disabled:
            Text("\(type.rawValue.capitalized) \(state.rawValue.capitalized)")
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color.gray)
                .cornerRadius(10)
                .disabled(true)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードでは、`List`と`Section`を使用して、各`ButtonType`ごとにセクションを作成します。各セクションでは、全ての`ButtonState`に対してボタンを作成します。

`ButtonView`では、ボタンの見た目を`state`に基づいて変更します。`.default`の状態では白色の背景と赤色のボーダーがあり、`.pressed`と`.disabled`の状態では灰色の背景があります。また、`.disabled`の状態ではボタンが無効化されています。

各ボタンは中央揃えに設定されています（`.frame(maxWidth: .infinity)`を使用）。

---

## 👤 ユーザー
*2023/05/25 00:12:37*

伝え方が悪かった。全量は以下でコードで、
Button(}.buttonStyle(CustomButtonStyle(ButtonType))をすべてけんしょうしてほしいんだ

```swift
public enum ButtonState: String, CaseIterable, Identifiable {
    case `default`
    case pressed
    case disabled
    
    public var id: String {
        rawValue
    }
}

public enum ButtonType: String, CaseIterable, Identifiable {
    case primary
    case secondary
    case tertiary
    case text
    
    public var id: String {
        rawValue
    }

    var isRounded: Bool {
        switch self {
        case .primary, .secondary:
            return true
        case .tertiary, .text:
            return false
        }
    }
    
    func foregroundColor(for state: ButtonState) -> Color {
        switch (self, state) {
        case (.primary, _):
            return .white
        case (_, .default):
            return .red
        case (_, .pressed):
            return .orange
        case (_, .disabled):
            return .gray
        }
    }
    
    func backgroundColor(for state: ButtonState) -> Color {
        switch (self, state) {
        case (.primary, .default):
            return .red
        case (.primary, .pressed):
            return .orange
        case (.primary, .disabled):
            return .gray
        default:
            return .clear
        }
    }
    
    func boarderColor(for state: ButtonState) -> Color {
        switch (self, state) {
        case (.secondary, .default):
            return .red
        case (.secondary, .pressed):
            return .orange
        case (.secondary, .disabled):
            return .gray
        default:
            return .clear
        }
    }
}

public struct CustomButtonStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled: Bool
    private var buttonType: ButtonType
    private static let boarder: CGFloat = 2
    private static let cornerRadius: CGFloat = 30
    private static let roundButtonHeight: CGFloat = 48

    init(_ type: ButtonType) {
        self.buttonType = type
    }

    public func makeBody(configuration: Configuration) -> some View {
        let state: ButtonState = !isEnabled ? .disabled : (configuration.isPressed ? .pressed : .default)
        
        if buttonType.isRounded {
            configuration.label
                .font(.headline)
                .foregroundColor(buttonType.foregroundColor(for: state))
                .frame(height: Self.roundButtonHeight)
                .frame(maxWidth: .infinity)
                .cornerRadius(Self.cornerRadius)
                .overlay(
                    RoundedRectangle(cornerRadius: Self.cornerRadius)
                        .stroke(buttonType.boarderColor(for: state), lineWidth: Self.boarder)
                )
                .background(
                    RoundedRectangle(cornerRadius: Self.cornerRadius)
                        .fill(buttonType.backgroundColor(for: state))
                )
        } else {
            configuration.label
                .foregroundColor(buttonType.foregroundColor(for: state))
                .background(buttonType.backgroundColor(for: state))
        }
    }
}


```

---

## 🤖 アシスタント
*2023/05/25 00:13:30*

以下のコードは、提供された`ButtonType`と`ButtonState`の組み合わせ全てを表示し、各ボタンの見た目と動作を検証します。それぞれの`ButtonType`に対して、`ButtonState`の全ての状態が独自のセクションで表示されます。

```swift
import SwiftUI

struct ContentView: View {
    @State private var isEnabled = true
    
    var body: some View {
        VStack {
            Toggle("Enabled", isOn: $isEnabled)
                .padding()
            
            List {
                ForEach(ButtonType.allCases) { buttonType in
                    Section(header: Text(buttonType.rawValue.capitalized)) {
                        ForEach(ButtonState.allCases) { buttonState in
                            Button(action: {}) {
                                Text("\(buttonType.rawValue.capitalized) \(buttonState.rawValue.capitalized)")
                            }
                            .buttonStyle(CustomButtonStyle(buttonType))
                            .disabled(buttonState == .disabled || !isEnabled)
                            .padding(.vertical)
                        }
                    }
                }
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードは`ButtonState`が`.disabled`の場合、または`isEnabled`が`false`の場合にボタンを無効化します。そのため、ボタンが無効化されるべき時に正しく無効化されることを確認できます。

また、各ボタンはそれぞれの`ButtonType`と`ButtonState`を表示するため、どのボタンがどの組み合わせを表しているのか分かりやすくなっています。

このコードの上部にはボタンの有効/無効を切り替えるトグルがあります。これにより全てのボタンが一度に有効化/無効化されるため、ボタンの動作を一度に確認できます。

---

## 👤 ユーザー
*2023/05/25 00:16:16*

外から isPressed 状態にする方法はないの？

---

## 🤖 アシスタント
*2023/05/25 00:17:15*

SwiftUIの`Button`はユーザーインタラクションによって自動的に`isPressed`状態が管理されます。そのため、現在（2021年時点）ではコードから直接`isPressed`状態を制御する方法は提供されていません。

ただし、異なる視覚的なスタイルを模倣するためにビューを作成し、それを`isPressed`状態であると見なすことは可能です。これはボタンが`isPressed`状態であるかどうかをプログラム的に決定するための近似的な解決策で、ボタンが本当に押されたかどうかとは一致しない場合があります。

---

## 👤 ユーザー
*2023/05/25 00:21:45*

ボタンをList のちゅうおうにはいちしてほしい

---

## 🤖 アシスタント
*2023/05/25 00:22:21*

SwiftUIでは、リスト内のボタンを中央に配置するために、HStackとSpacerを使用することができます。Spacerは、親ビューに対して可能な限りのスペースを占めるため、それを利用してボタンを中央に配置します。以下のコードが参考になるかと思います：

```swift
import SwiftUI

struct ContentView: View {
    @State private var isEnabled = true
    
    var body: some View {
        VStack {
            Toggle("Enabled", isOn: $isEnabled)
                .padding()
            
            List {
                ForEach(ButtonType.allCases) { buttonType in
                    Section(header: Text(buttonType.rawValue.capitalized)) {
                        ForEach(ButtonState.allCases) { buttonState in
                            HStack {
                                Spacer()
                                Button(action: {}) {
                                    Text("\(buttonType.rawValue.capitalized) \(buttonState.rawValue.capitalized)")
                                }
                                .buttonStyle(CustomButtonStyle(buttonType))
                                .disabled(buttonState == .disabled || !isEnabled)
                                Spacer()
                            }
                            .padding(.vertical)
                        }
                    }
                }
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードでは、各ボタンがHStackの中央に配置されます。HStackの両側にはSpacerがあるため、ボタンが中央に配置されます。

---

## 👤 ユーザー
*2023/05/25 01:36:55*

primary のボタンについてshadowを適応させたいのだけれどもどうすればいい？

---

## 🤖 アシスタント
*2023/05/25 01:37:57*

Shadow（影）を適用するには、`.shadow`修飾子を使用します。この修飾子はビューに影を追加し、色、半径（ぼかし）、およびオフセットを指定することができます。

`CustomButtonStyle`内の`makeBody`メソッドで`primary`ボタンタイプに`.shadow`修飾子を追加することができます。

以下に修正を加えたコードを示します。ここでは、primaryのボタンに対して影（shadow）を適用しています：

```swift
public struct CustomButtonStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled: Bool
    private var buttonType: ButtonType
    private static let boarder: CGFloat = 2
    private static let cornerRadius: CGFloat = 30
    private static let roundButtonHeight: CGFloat = 48

    init(_ type: ButtonType) {
        self.buttonType = type
    }

    public func makeBody(configuration: Configuration) -> some View {
        let state: ButtonState = !isEnabled ? .disabled : (configuration.isPressed ? .pressed : .default)
        
        if buttonType.isRounded {
            configuration.label
                .font(.headline)
                .foregroundColor(buttonType.foregroundColor(for: state))
                .frame(height: Self.roundButtonHeight)
                .frame(maxWidth: .infinity)
                .cornerRadius(Self.cornerRadius)
                .overlay(
                    RoundedRectangle(cornerRadius: Self.cornerRadius)
                        .stroke(buttonType.boarderColor(for: state), lineWidth: Self.boarder)
                )
                .background(
                    RoundedRectangle(cornerRadius: Self.cornerRadius)
                        .fill(buttonType.backgroundColor(for: state))
                )
                .if(buttonType == .primary) { view in
                    view.shadow(color: .gray, radius: 5, x: 0, y: 2)
                }
        } else {
            configuration.label
                .foregroundColor(buttonType.foregroundColor(for: state))
                .background(buttonType.backgroundColor(for: state))
        }
    }
}

extension View {
    @ViewBuilder
    func `if`<Content: View>(_ conditional: Bool, transform: (Self) -> Content) -> some View {
        if conditional {
            transform(self)
        } else {
            self
        }
    }
}
```

`.if`メソッドは`View`プロトコルの拡張として定義しています。このメソッドを使用すると、特定の条件が満たされた場合にのみビューに修飾子を適用できます。上記のコードでは、`buttonType`が`primary`の場合にのみ影（shadow）を適用しています。

影（shadow）のパラメーター（色、半径、オフセット）はお好みに合わせて調整できます。

---

## 👤 ユーザー
*2023/05/25 01:39:56*

if buttonType.isRounded であれば一律でshadowをつけてほしいんだ

---

## 🤖 アシスタント
*2023/05/25 01:40:41*

それならば、次のように`CustomButtonStyle`を変更することができます：

```swift
public struct CustomButtonStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled: Bool
    private var buttonType: ButtonType
    private static let boarder: CGFloat = 2
    private static let cornerRadius: CGFloat = 30
    private static let roundButtonHeight: CGFloat = 48

    init(_ type: ButtonType) {
        self.buttonType = type
    }

    public func makeBody(configuration: Configuration) -> some View {
        let state: ButtonState = !isEnabled ? .disabled : (configuration.isPressed ? .pressed : .default)
        
        if buttonType.isRounded {
            configuration.label
                .font(.headline)
                .foregroundColor(buttonType.foregroundColor(for: state))
                .frame(height: Self.roundButtonHeight)
                .frame(maxWidth: .infinity)
                .cornerRadius(Self.cornerRadius)
                .overlay(
                    RoundedRectangle(cornerRadius: Self.cornerRadius)
                        .stroke(buttonType.boarderColor(for: state), lineWidth: Self.boarder)
                )
                .background(
                    RoundedRectangle(cornerRadius: Self.cornerRadius)
                        .fill(buttonType.backgroundColor(for: state))
                )
                .shadow(color: .gray, radius: 5, x: 0, y: 2) // Apply shadow here
        } else {
            configuration.label
                .foregroundColor(buttonType.foregroundColor(for: state))
                .background(buttonType.backgroundColor(for: state))
        }
    }
}
```

このように修正すると、ボタンの`isRounded`プロパティが`true`の場合（つまり、ボタンタイプが`primary`または`secondary`の場合）に影が適用されます。影のパラメータ（色、半径、オフセット）は好みに応じて調整することができます。

---
