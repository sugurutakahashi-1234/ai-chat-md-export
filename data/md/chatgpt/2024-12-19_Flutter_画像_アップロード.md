# Flutter 画像 アップロード

日付: 2024-12-19

---

## 👤 ユーザー
*2024/12/19 10:08:57*

flutterで画像をサーバーにリクエストしたい
なるべくRest APiのリクエストでやりたい

---

## 🤖 アシスタント
*2024/12/19 10:09:20*

Flutterで画像をサーバーにリクエストとして送信するには、`http`パッケージを使用してREST APIリクエストを作成できます。以下は、その手順を説明します。

---

### 手順

1. **パッケージのインストール**
   Flutterプロジェクトの`pubspec.yaml`ファイルに`http`パッケージを追加します。

   ```yaml
   dependencies:
     http: ^1.0.0
   ```

   その後、以下を実行して依存関係を取得します。

   ```bash
   flutter pub get
   ```

2. **画像ファイルの選択**
   `image_picker`を使用して、画像を選択します。

   ```yaml
   dependencies:
     image_picker: ^1.0.0
   ```

   依存関係を取得します。

   ```bash
   flutter pub get
   ```

3. **画像をサーバーに送信するコード**
   以下のコードは、選択した画像をPOSTリクエストとしてサーバーに送信する例です。

---

### コード例

```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:http/http.dart' as http;

class ImageUploadPage extends StatefulWidget {
  @override
  _ImageUploadPageState createState() => _ImageUploadPageState();
}

class _ImageUploadPageState extends State<ImageUploadPage> {
  File? _image;

  // 画像を選択する
  Future<void> _pickImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: ImageSource.gallery);

    if (pickedFile != null) {
      setState(() {
        _image = File(pickedFile.path);
      });
    }
  }

  // 画像をサーバーにアップロードする
  Future<void> _uploadImage() async {
    if (_image == null) return;

    final uri = Uri.parse('https://example.com/upload'); // サーバーのURLを設定
    final request = http.MultipartRequest('POST', uri);

    // 画像ファイルを追加
    request.files.add(
      await http.MultipartFile.fromPath(
        'file', // サーバー側で期待されるキー名
        _image!.path,
      ),
    );

    // 必要に応じてヘッダーやその他のパラメータを追加
    request.headers.addAll({
      'Authorization': 'Bearer YOUR_ACCESS_TOKEN',
      'Content-Type': 'multipart/form-data',
    });

    // リクエストを送信
    final response = await request.send();

    // レスポンスを処理
    if (response.statusCode == 200) {
      print('Image uploaded successfully');
    } else {
      print('Image upload failed: ${response.statusCode}');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Image Upload')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            _image == null
                ? Text('No image selected.')
                : Image.file(_image!, height: 200),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: _pickImage,
              child: Text('Pick Image'),
            ),
            ElevatedButton(
              onPressed: _uploadImage,
              child: Text('Upload Image'),
            ),
          ],
        ),
      ),
    );
  }
}
```

---

### 実装のポイント

1. **REST APIのURL**
   サーバーのエンドポイントURLを適切に設定してください（例: `https://example.com/upload`）。

2. **ヘッダーと認証**
   サーバーで必要なヘッダー（例: 認証トークン）がある場合は、`request.headers.addAll`で設定します。

3. **画像のバリデーション**
   ファイルサイズやフォーマットを事前にチェックすることで、無効なリクエストを防げます。

---

### サーバー側の処理
サーバー側で`file`キーを受け取れるように設定してください。例:

- **Node.js (Express)**:
  ```javascript
  const multer = require('multer');
  const upload = multer({ dest: 'uploads/' });

  app.post('/upload', upload.single('file'), (req, res) => {
    console.log(req.file); // アップロードされたファイル情報
    res.send('File uploaded successfully');
  });
  ```

- **Python (Flask)**:
  ```python
  from flask import Flask, request

  app = Flask(__name__)

  @app.route('/upload', methods=['POST'])
  def upload_file():
      file = request.files['file']
      file.save(f"./uploads/{file.filename}")
      return "File uploaded successfully"
  ```

これでFlutterアプリから画像をREST API経由でサーバーに送信できます。

---

## 👤 ユーザー
*2024/12/19 10:10:03*

いわゆる画像データってどうすれば送れるの？
色々情報(撮影した緯度経度など)を保持したまま送りたい

---

## 🤖 アシスタント
*2024/12/19 10:10:34*

撮影した画像データを送る際に、画像そのもの（バイナリデータ）だけでなく、画像に付随するメタデータ（撮影日時や緯度経度など）も含めて送信する場合、以下の方法があります。

---

### 方法
1. **EXIFデータを含めた画像送信**
   画像ファイルそのものを送信する場合、多くの場合はEXIFデータ（撮影日時や緯度経度など）が保持されています。この場合、画像ファイルをそのまま送信すればメタデータも含まれます。

2. **メタデータをJSON形式で別送する**
   EXIFデータの代わりに、画像のメタデータをJSONとして抽出し、サーバー側に別途送信する方法もあります。

3. **画像とメタデータをマルチパートリクエストで一緒に送る**
   画像とメタデータを同時に送信するには、`multipart/form-data`形式を使用します。

---

### コード例: 画像とメタデータを一緒に送信

```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:http/http.dart' as http;
import 'package:image/image.dart' as img; // EXIFデータを抽出するライブラリ

class ImageMetadataUploadPage extends StatefulWidget {
  @override
  _ImageMetadataUploadPageState createState() =>
      _ImageMetadataUploadPageState();
}

class _ImageMetadataUploadPageState extends State<ImageMetadataUploadPage> {
  File? _image;
  Map<String, dynamic>? _metadata;

  // 画像を選択してEXIFデータを抽出
  Future<void> _pickImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: ImageSource.camera);

    if (pickedFile != null) {
      final file = File(pickedFile.path);

      // EXIFデータの抽出
      final bytes = file.readAsBytesSync();
      final decodedImage = img.decodeImage(bytes);
      final exif = decodedImage?.exif;

      if (exif != null) {
        final latitude = exif['GPS Latitude'];
        final longitude = exif['GPS Longitude'];
        final datetime = exif['DateTime'];

        setState(() {
          _image = file;
          _metadata = {
            'latitude': latitude,
            'longitude': longitude,
            'datetime': datetime,
          };
        });
      }
    }
  }

  // サーバーに画像とメタデータを送信
  Future<void> _uploadImageWithMetadata() async {
    if (_image == null || _metadata == null) return;

    final uri = Uri.parse('https://example.com/upload');
    final request = http.MultipartRequest('POST', uri);

    // 画像ファイルを追加
    request.files.add(
      await http.MultipartFile.fromPath(
        'file',
        _image!.path,
      ),
    );

    // メタデータを追加
    request.fields['metadata'] = _metadata.toString(); // JSON文字列に変換

    // 必要なヘッダーを追加
    request.headers.addAll({
      'Authorization': 'Bearer YOUR_ACCESS_TOKEN',
      'Content-Type': 'multipart/form-data',
    });

    final response = await request.send();

    if (response.statusCode == 200) {
      print('Image and metadata uploaded successfully');
    } else {
      print('Upload failed: ${response.statusCode}');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Upload Image with Metadata')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            _image == null
                ? Text('No image selected.')
                : Image.file(_image!, height: 200),
            SizedBox(height: 20),
            _metadata != null
                ? Text('Metadata: ${_metadata.toString()}')
                : SizedBox.shrink(),
            ElevatedButton(
              onPressed: _pickImage,
              child: Text('Pick Image'),
            ),
            ElevatedButton(
              onPressed: _uploadImageWithMetadata,
              child: Text('Upload Image'),
            ),
          ],
        ),
      ),
    );
  }
}
```

---

### 解説

1. **EXIFデータの抽出**
   - `package:image`を使って、画像のバイナリデータからEXIF情報を取得します。
   - EXIF情報にはGPSデータ（緯度経度）や撮影日時が含まれます。

2. **マルチパートリクエスト**
   - 画像は`MultipartFile`として追加。
   - メタデータ（JSON形式）は`fields`に文字列として追加。

3. **サーバー側の処理**
   サーバーで画像とメタデータを同時に受け取る必要があります。
   - Python（Flask）例:
     ```python
     from flask import Flask, request
     import json

     app = Flask(__name__)

     @app.route('/upload', methods=['POST'])
     def upload():
         file = request.files['file']
         metadata = json.loads(request.form['metadata'])  # メタデータをパース
         print(f"Received file: {file.filename}")
         print(f"Metadata: {metadata}")
         return "File and metadata uploaded successfully"
     ```

---

### 注意点

- **画像形式**:
  一部の画像形式ではEXIFデータが含まれていない場合があります（例: PNG）。

- **サーバー側のデータ受け取り方法**:
  REST APIでマルチパート形式を受け取れるようにサーバーを設計してください。

- **セキュリティ**:
  画像やメタデータの内容を検証する処理をサーバー側で必ず実装してください。

---

この方法を使うことで、撮影した画像の情報をそのままサーバーに送信することができます！

---

## 👤 ユーザー
*2024/12/19 10:11:22*

ちなみにこのApiをopenapi.yamlで定義するとどうなるの？

---

## 🤖 アシスタント
*2024/12/19 10:11:47*

以下は、画像とメタデータを送信するAPIを `openapi.yaml` で定義する例です。このAPIは、`multipart/form-data` を使用して画像とメタデータを送信する形式に対応しています。

---

### `openapi.yaml` の例

```yaml
openapi: 3.1.0
info:
  title: Image Upload API
  version: 1.0.0
  description: API to upload images with metadata
paths:
  /upload:
    post:
      summary: Upload an image with metadata
      operationId: uploadImage
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  type: string
                  format: binary
                  description: The image file to upload
                metadata:
                  type: string
                  description: >
                    Metadata for the image in JSON format, including information like latitude, longitude, and timestamp.
                  example: '{"latitude": "35.6895", "longitude": "139.6917", "datetime": "2024-12-19T12:34:56"}'
              required:
                - file
                - metadata
      responses:
        '200':
          description: Successful upload
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: Image and metadata uploaded successfully
        '400':
          description: Bad request
          content:
            application/json:
              schema:
                type: object
                properties:
                  error:
                    type: string
                    example: Invalid metadata format
```

---

### 説明

1. **`paths`**
   - `/upload`: 画像アップロードのエンドポイントを定義しています。
   - `post`: HTTP POSTリクエストで画像とメタデータを送信します。

2. **`requestBody`**
   - `multipart/form-data` を使用して画像ファイル (`file`) とメタデータ (`metadata`) を送信します。
   - `file`: バイナリ形式の画像ファイル。
   - `metadata`: JSON形式の文字列としてメタデータを送信します。

3. **`responses`**
   - `200`: アップロードが成功した場合のレスポンス。
   - `400`: 無効なリクエストやメタデータのフォーマットエラーが発生した場合。

4. **例 (`example`)**
   メタデータの例として、緯度、経度、撮影日時を含んだJSON形式を示しています。

---

### サーバーサイドの処理例 (Flask)

このOpenAPI定義に対応するサーバーの処理例を以下に示します。

```python
from flask import Flask, request, jsonify
import json

app = Flask(__name__)

@app.route('/upload', methods=['POST'])
def upload_image():
    try:
        # 画像ファイルを取得
        file = request.files['file']
        # メタデータを取得してJSONにパース
        metadata = json.loads(request.form['metadata'])
        
        # メタデータの内容を確認
        latitude = metadata.get('latitude')
        longitude = metadata.get('longitude')
        datetime = metadata.get('datetime')
        
        # ファイル保存例 (必要なら保存処理を実装)
        file.save(f"./uploads/{file.filename}")
        
        return jsonify({
            "message": "Image and metadata uploaded successfully",
            "fileName": file.filename,
            "metadata": metadata
        }), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 400
```

---

### OpenAPIの用途

1. **APIドキュメント**
   - OpenAPI仕様を使うことで、Swagger UIなどで自動生成されたAPIドキュメントを提供できます。

2. **コード生成**
   - クライアントやサーバーのコードを生成するツール（例: `openapi-generator`）を利用できます。

3. **バリデーション**
   - API仕様に基づいたリクエスト/レスポンスのバリデーションを自動化できます。

---

この`openapi.yaml`を使えば、APIドキュメントとして共有するだけでなく、実装やテストにも活用できます。必要に応じてさらに細かい仕様（例えば、ファイルサイズや形式の制限）を追加することも可能です。

---

## 👤 ユーザー
*2024/12/19 10:12:30*

openapi-ジェネレーターを使ってDartに変換してリクエストしてみてhlしい

---

## 🤖 アシスタント
*2024/12/19 10:12:48*

It seems that the `openapi-generator-cli` tool is not installed in this environment, or the command is not recognized. To proceed, you can follow these steps locally:

### 1. **Install OpenAPI Generator CLI**
Ensure you have `openapi-generator-cli` installed. You can do this using npm:

```bash
npm install @openapitools/openapi-generator-cli -g
```

### 2. **Save the OpenAPI Specification**
Save the provided OpenAPI YAML definition to a file, e.g., `openapi.yaml`.

### 3. **Generate the Dart Client**
Run the following command to generate the Dart client:

```bash
openapi-generator-cli generate -i openapi.yaml -g dart -o ./dart-client
```

- `-i`: Path to the OpenAPI YAML file.
- `-g`: Specifies the generator type (`dart` for Dart client).
- `-o`: Output directory for the generated code.

### 4. **Integrate the Generated Client**
After generation, include the Dart client in your Flutter project by copying the generated files to your project or using it as a separate package.

If you'd like, I can guide you through setting up the request code in Flutter once you have the generated client. Let me know!

---

## 👤 ユーザー
*2024/12/19 10:13:01*

flutterのコードも書いて欲しい

---

## 🤖 アシスタント
*2024/12/19 10:13:25*

以下に、生成されたDartクライアントを使用して画像をサーバーに送信するFlutterコード例を示します。`openapi-generator` で生成されたクライアントを利用することを前提としています。

---

### クライアント設定
生成されたクライアントは、例えば `lib/api_client.dart` に存在するとします。

---

### Flutterコード例

```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:openapi/openapi.dart'; // 生成されたクライアントパッケージをインポート

class ImageUploadPage extends StatefulWidget {
  @override
  _ImageUploadPageState createState() => _ImageUploadPageState();
}

class _ImageUploadPageState extends State<ImageUploadPage> {
  File? _image;
  final ImagePicker _picker = ImagePicker();
  late Openapi openApiClient;

  @override
  void initState() {
    super.initState();
    // APIクライアントの初期化
    openApiClient = Openapi(
      basePathOverride: 'https://example.com', // サーバーのURLを設定
    );
  }

  // 画像を選択
  Future<void> _pickImage() async {
    final pickedFile = await _picker.pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      setState(() {
        _image = File(pickedFile.path);
      });
    }
  }

  // 画像とメタデータをアップロード
  Future<void> _uploadImage() async {
    if (_image == null) return;

    try {
      // メタデータ
      final metadata = {
        "latitude": "35.6895",
        "longitude": "139.6917",
        "datetime": "2024-12-19T12:34:56"
      };

      // ファイルをMultipartFileに変換
      final multipartFile = MultipartFile.fromBytes(
        'file', // サーバー側のフィールド名
        await _image!.readAsBytes(),
        filename: _image!.path.split('/').last,
      );

      // API呼び出し
      final apiInstance = openApiClient.getDefaultApi();
      final response = await apiInstance.uploadImage(
        multipartFile: multipartFile,
        metadata: metadata.toString(),
      );

      // アップロード結果を表示
      if (response != null) {
        print("Upload successful: ${response.message}");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Upload successful')),
        );
      }
    } catch (e) {
      print("Upload failed: $e");
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Upload failed')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Upload Image')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            _image == null
                ? Text('No image selected.')
                : Image.file(_image!, height: 200),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: _pickImage,
              child: Text('Pick Image'),
            ),
            ElevatedButton(
              onPressed: _uploadImage,
              child: Text('Upload Image'),
            ),
          ],
        ),
      ),
    );
  }
}
```

---

### 重要ポイント

1. **OpenAPIクライアントの使用**
   - `openapi` は生成されたDartクライアントパッケージを指します。
   - `Openapi` クラスを使い、ベースURLやエンドポイントを設定します。

2. **`MultipartFile`の作成**
   - Flutterでファイルを読み込み、`MultipartFile`形式に変換します。

3. **メタデータの送信**
   - メタデータはJSON文字列として送信します。サーバー側で適切にパースされるように設計してください。

4. **エラーハンドリング**
   - API呼び出し時のエラーは例外でキャッチされるので、`try-catch`ブロックを使用します。

---

### 必要な生成物

このコードを動作させるには、以下が必要です：
- OpenAPI Generatorで生成されたクライアントコード（Dart）。
- クライアントパッケージの`pubspec.yaml`への追加。
- サーバー側でのエンドポイントの実装。

---

このコードをベースに、必要に応じてUIやエラーメッセージをカスタマイズしてください！

---
