# スマートなSwiftコード

日付: 2024-06-04

---

## 👤 ユーザー
*2024/6/4 12:49:26*

もっとスマートに直せないか？


// MARK: - View

struct PropertyView&lt;T: Encodable&gt;: View {
    @Binding var showToast: Bool
    let objects: [T]
    let onTapElement: (Any) -&gt; Void

    public var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                propertyView(object: object)
            } header: {
                HStack {
                    Text("\(type(of: object))[\(index)]")

                    Spacer()

                    Button {
                        onTapElement(object)
                    } label: {
                        SFSymbols.docOnDoc.image
                    }
                    .buttonStyle(.borderless)
                }
            }
            .textCase(.none)
        }
    }

    func propertyView(object: any Encodable) -&gt; some View {
        AnyView(ForEach(Array(Mirror(reflecting: object).children.enumerated()), id: \.offset) { index, child in
            if let label = child.label {
                let childMirror = Mirror(reflecting: child.value)
                if childMirror.displayStyle == .struct || childMirror.displayStyle == .class, let childValue = child.value as? any Encodable {
                    DisclosureGroup {
                        propertyView(object: childValue)
                    } label: {
                        Text(label)
                    }
                } else if let subObjects = child.value as? [any Encodable] {
                    DisclosureGroup {
                        ForEach(Array(subObjects.enumerated()), id: \.offset) { subIndex, subObject in
                            let subObjectMirror = Mirror(reflecting: subObject)
                            if subObjectMirror.displayStyle == .struct || subObjectMirror.displayStyle == .class {
                                DisclosureGroup {
                                    propertyView(object: subObject)
                                } label: {
                                    PropertyRowView(title: "\(type(of: subObject))", detail: "\(type(of: subObject))[\(subIndex)]")
                                }
                            } else {
                                Button {
                                    onTapElement(subObject)
                                } label: {
                                    PropertyRowView(title: "[\(subIndex)]", detail: "\(subObject)")
                                }
                            }
                        }
                    } label: {
                        PropertyRowView(title: label, detail: "\(Mirror(reflecting: child.value).subjectType)")
                    }
                } else {
                    Button {
                        onTapElement(child.value)
                    } label: {
                        PropertyRowView(title: label, detail: "\(child.value)")
                    }
                }
            } else {
                Button {
                    onTapElement(child.value)
                } label: {
                    PropertyRowView(title: "[\(index)]", detail: "\(child.value)")
                }
            }
        })
    }

    struct PropertyRowView: View {
        let title: String
        let detail: String

        var body: some View {
            HStack(alignment: .top) {
                Text(title)
                    .foregroundStyle(.black)
                Spacer()
                Text(detail)
            }
        }
    }
}

---

## 🤖 アシスタント
*2024/6/4 12:49:55*

こちらのコードをリファクタリングして、よりスマートにしてみます。主な改善点は、コードの再利用性を高め、ネストを減らし、コードを簡潔にすることです。

```swift
// MARK: - View

struct PropertyView<T: Encodable>: View {
    @Binding var showToast: Bool
    let objects: [T]
    let onTapElement: (Any) -> Void

    var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                PropertyViewBody(object: object, onTapElement: onTapElement)
            } header: {
                HeaderView(index: index, object: object, onTapElement: onTapElement)
            }
            .textCase(.none)
        }
    }
}

struct PropertyViewBody: View {
    let object: any Encodable
    let onTapElement: (Any) -> Void

    var body: some View {
        AnyView(
            ForEach(Array(Mirror(reflecting: object).children.enumerated()), id: \.offset) { index, child in
                if let label = child.label {
                    PropertyChildView(label: label, child: child.value, onTapElement: onTapElement)
                } else {
                    Button {
                        onTapElement(child.value)
                    } label: {
                        PropertyRowView(title: "[\(index)]", detail: "\(child.value)")
                    }
                }
            }
        )
    }
}

struct PropertyChildView: View {
    let label: String
    let child: Any
    let onTapElement: (Any) -> Void

    var body: some View {
        let childMirror = Mirror(reflecting: child)

        if let childValue = child as? any Encodable {
            if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                DisclosureGroup {
                    PropertyViewBody(object: childValue, onTapElement: onTapElement)
                } label: {
                    Text(label)
                }
            } else if let subObjects = child as? [any Encodable] {
                DisclosureGroup {
                    ForEach(Array(subObjects.enumerated()), id: \.offset) { subIndex, subObject in
                        let subObjectMirror = Mirror(reflecting: subObject)
                        if subObjectMirror.displayStyle == .struct || subObjectMirror.displayStyle == .class {
                            DisclosureGroup {
                                PropertyViewBody(object: subObject, onTapElement: onTapElement)
                            } label: {
                                PropertyRowView(title: "\(type(of: subObject))", detail: "\(type(of: subObject))[\(subIndex)]")
                            }
                        } else {
                            Button {
                                onTapElement(subObject)
                            } label: {
                                PropertyRowView(title: "[\(subIndex)]", detail: "\(subObject)")
                            }
                        }
                    }
                } label: {
                    PropertyRowView(title: label, detail: "\(Mirror(reflecting: child).subjectType)")
                }
            } else {
                Button {
                    onTapElement(child)
                } label: {
                    PropertyRowView(title: label, detail: "\(child)")
                }
            }
        } else {
            Button {
                onTapElement(child)
            } label: {
                PropertyRowView(title: label, detail: "\(child)")
            }
        }
    }
}

struct HeaderView<T: Encodable>: View {
    let index: Int
    let object: T
    let onTapElement: (Any) -> Void

    var body: some View {
        HStack {
            Text("\(type(of: object))[\(index)]")
            Spacer()
            Button {
                onTapElement(object)
            } label: {
                SFSymbols.docOnDoc.image
            }
            .buttonStyle(.borderless)
        }
    }
}

struct PropertyRowView: View {
    let title: String
    let detail: String

    var body: some View {
        HStack(alignment: .top) {
            Text(title)
                .foregroundStyle(.black)
            Spacer()
            Text(detail)
        }
    }
}
```

このリファクタリングでは、以下の点を改善しました：
1. 各コンポーネントを独立したビューとして分離し、再利用性を高めました。
2. コードのネストを減らし、見通しを良くしました。
3. 重複するコードを簡素化しました。

これにより、全体の構造が明確になり、保守性が向上します。

---

## 👤 ユーザー
*2024/6/4 12:55:16*

let onTapElement: (any Encodable) -&gt; Void としたい

struct PropertyView&lt;T: Encodable&gt;: View {
    @Binding var showToast: Bool
    let objects: [T]
    let onTapElement: (Any) -&gt; Void

    var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                PropertyViewBody(object: object, onTapElement: onTapElement)
            } header: {
                HeaderView(index: index, object: object, onTapElement: onTapElement)
            }
            .textCase(.none)
        }
    }
}

struct PropertyViewBody: View {
    let object: any Encodable
    let onTapElement: (Any) -&gt; Void

    var body: some View {
        AnyView(
            ForEach(Array(Mirror(reflecting: object).children.enumerated()), id: \.offset) { index, child in
                if let label = child.label {
                    PropertyChildView(label: label, child: child.value, onTapElement: onTapElement)
                } else {
                    Button {
                        onTapElement(child.value)
                    } label: {
                        PropertyRowView(title: "[\(index)]", detail: "\(child.value)")
                    }
                }
            }
        )
    }
}

struct PropertyChildView: View {
    let label: String
    let child: Any
    let onTapElement: (Any) -&gt; Void

    var body: some View {
        let childMirror = Mirror(reflecting: child)

        if let childValue = child as? any Encodable {
            if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                DisclosureGroup {
                    PropertyViewBody(object: childValue, onTapElement: onTapElement)
                } label: {
                    Text(label)
                }
            } else if let subObjects = child as? [any Encodable] {
                DisclosureGroup {
                    ForEach(Array(subObjects.enumerated()), id: \.offset) { subIndex, subObject in
                        let subObjectMirror = Mirror(reflecting: subObject)
                        if subObjectMirror.displayStyle == .struct || subObjectMirror.displayStyle == .class {
                            DisclosureGroup {
                                PropertyViewBody(object: subObject, onTapElement: onTapElement)
                            } label: {
                                PropertyRowView(title: "\(type(of: subObject))", detail: "\(type(of: subObject))[\(subIndex)]")
                            }
                        } else {
                            Button {
                                onTapElement(subObject)
                            } label: {
                                PropertyRowView(title: "[\(subIndex)]", detail: "\(subObject)")
                            }
                        }
                    }
                } label: {
                    PropertyRowView(title: label, detail: "\(Mirror(reflecting: child).subjectType)")
                }
            } else {
                Button {
                    onTapElement(child)
                } label: {
                    PropertyRowView(title: label, detail: "\(child)")
                }
            }
        } else {
            Button {
                onTapElement(child)
            } label: {
                PropertyRowView(title: label, detail: "\(child)")
            }
        }
    }
}

struct HeaderView&lt;T: Encodable&gt;: View {
    let index: Int
    let object: T
    let onTapElement: (Any) -&gt; Void

    var body: some View {
        HStack {
            Text("\(type(of: object))[\(index)]")
            Spacer()
            Button {
                onTapElement(object)
            } label: {
                SFSymbols.docOnDoc.image
            }
            .buttonStyle(.borderless)
        }
    }
}

struct PropertyRowView: View {
    let title: String
    let detail: String

    var body: some View {
        HStack(alignment: .top) {
            Text(title)
                .foregroundStyle(.black)
            Spacer()
            Text(detail)
        }
    }
}

---

## 🤖 アシスタント
*2024/6/4 12:55:40*

User prefers to use the function type signature `let onTapElement: (any Encodable) -&gt; Void`.

---

## 🔧 ツール
*2024/6/4 12:55:40*

Model set context updated.

---

## 🤖 アシスタント
*2024/6/4 12:55:40*

`onTapElement`の型を`(any Encodable) -> Void`に変更し、それに応じてコードをリファクタリングします。

```swift
// MARK: - View

struct PropertyView<T: Encodable>: View {
    @Binding var showToast: Bool
    let objects: [T]
    let onTapElement: (any Encodable) -> Void

    var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                PropertyViewBody(object: object, onTapElement: onTapElement)
            } header: {
                HeaderView(index: index, object: object, onTapElement: onTapElement)
            }
            .textCase(.none)
        }
    }
}

struct PropertyViewBody: View {
    let object: any Encodable
    let onTapElement: (any Encodable) -> Void

    var body: some View {
        AnyView(
            ForEach(Array(Mirror(reflecting: object).children.enumerated()), id: \.offset) { index, child in
                if let label = child.label {
                    PropertyChildView(label: label, child: child.value, onTapElement: onTapElement)
                } else {
                    Button {
                        onTapElement(child.value as! Encodable)
                    } label: {
                        PropertyRowView(title: "[\(index)]", detail: "\(child.value)")
                    }
                }
            }
        )
    }
}

struct PropertyChildView: View {
    let label: String
    let child: Any
    let onTapElement: (any Encodable) -> Void

    var body: some View {
        let childMirror = Mirror(reflecting: child)

        if let childValue = child as? any Encodable {
            if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                DisclosureGroup {
                    PropertyViewBody(object: childValue, onTapElement: onTapElement)
                } label: {
                    Text(label)
                }
            } else if let subObjects = child as? [any Encodable] {
                DisclosureGroup {
                    ForEach(Array(subObjects.enumerated()), id: \.offset) { subIndex, subObject in
                        let subObjectMirror = Mirror(reflecting: subObject)
                        if subObjectMirror.displayStyle == .struct || subObjectMirror.displayStyle == .class {
                            DisclosureGroup {
                                PropertyViewBody(object: subObject, onTapElement: onTapElement)
                            } label: {
                                PropertyRowView(title: "\(type(of: subObject))", detail: "\(type(of: subObject))[\(subIndex)]")
                            }
                        } else {
                            Button {
                                onTapElement(subObject)
                            } label: {
                                PropertyRowView(title: "[\(subIndex)]", detail: "\(subObject)")
                            }
                        }
                    }
                } label: {
                    PropertyRowView(title: label, detail: "\(Mirror(reflecting: child).subjectType)")
                }
            } else {
                Button {
                    onTapElement(childValue)
                } label: {
                    PropertyRowView(title: label, detail: "\(childValue)")
                }
            }
        } else {
            Button {
                onTapElement(child as! Encodable)
            } label: {
                PropertyRowView(title: label, detail: "\(child)")
            }
        }
    }
}

struct HeaderView<T: Encodable>: View {
    let index: Int
    let object: T
    let onTapElement: (any Encodable) -> Void

    var body: some View {
        HStack {
            Text("\(type(of: object))[\(index)]")
            Spacer()
            Button {
                onTapElement(object)
            } label: {
                SFSymbols.docOnDoc.image
            }
            .buttonStyle(.borderless)
        }
    }
}

struct PropertyRowView: View {
    let title: String
    let detail: String

    var body: some View {
        HStack(alignment: .top) {
            Text(title)
                .foregroundStyle(.black)
            Spacer()
            Text(detail)
        }
    }
}
```

この変更により、`onTapElement`の型が`(any Encodable) -> Void`に対応しました。その他のコードも型安全にするために調整されています。

---

## 👤 ユーザー
*2024/6/4 13:01:31*

PropertyViewBody や PropertyChildView の init で Mirror の処理を行なって、保持する変数を減らして欲しい

---

## 🤖 アシスタント
*2024/6/4 13:01:37*

`PropertyViewBody`や`PropertyChildView`の初期化時に`Mirror`の処理を行い、保持する変数を減らすようにリファクタリングします。

```swift
// MARK: - View

struct PropertyView<T: Encodable>: View {
    @Binding var showToast: Bool
    let objects: [T]
    let onTapElement: (any Encodable) -> Void

    var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                PropertyViewBody(object: object, onTapElement: onTapElement)
            } header: {
                HeaderView(index: index, object: object, onTap

---
