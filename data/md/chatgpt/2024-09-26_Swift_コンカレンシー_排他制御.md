# Swift コンカレンシー 排他制御

日付: 2024-09-26

---

## 👤 ユーザー
*2024/9/26 15:39:37*

Swift コンカレンシーで異なる箇所から呼ばれる関数を同期的に順番に処理させたい。具体的にはこのloadMoreExecuteは連続で呼ばれた際にcursorが正しく制御されるようにしたい。複数の箇所から呼ばれて、cursorの更新が競合してしまうのを避けたいんだ。


class GetMessageThreadsUseCaseImpl: GetMessageThreadsUseCase {

    private let repository: MessageThreadRepository
    private let size: Int = 2
    private var cursor: String?

    init(repository: MessageThreadRepository = MessageThreadRepositoryImpl()) {
        self.repository = repository
    }

    func initialExecute() async throws -&gt; \[MessageThread\] {
        let (messageThreads, paginationMetadata) = try await repository.getMessageThreads(cursor: nil, size: size)
        cursor = paginationMetadata.nextPage
        return messageThreads.filter { $0.finishedAt != nil }.sorted { $0.finishedAt ?? Date() &gt; $1.finishedAt ?? Date() }
    }

    func loadMoreExecute() async throws -&gt; \[MessageThread\] {
        let (messageThreads, paginationMetadata) = try await repository.getMessageThreads(cursor: cursor, size: size)
        cursor = paginationMetadata.nextPage
        return messageThreads.filter { $0.finishedAt != nil }.sorted { $0.finishedAt ?? Date() &gt; $1.finishedAt ?? Date() }
    }
}

---

## 🤖 アシスタント
*2024/9/26 15:39:50*

`loadMoreExecute` が複数の箇所から同時に呼ばれると、`cursor` の更新が競合してしまう可能性があります。そのため、この関数を同期的に順番に処理させたい場合には、`@Synchronized` のような Swift の排他制御を活用するか、非同期のタスクを順番に処理する方法を導入することが有効です。

具体的には、`actor` を使用して排他制御を実装する方法があります。`actor` は内部状態の保護やスレッドセーフな実装を簡単に行うための Swift の機能です。

以下に `loadMoreExecute` を順番に処理するための `actor` を利用した解決策を示します。

```swift
actor GetMessageThreadsUseCaseImpl: GetMessageThreadsUseCase {

    private let repository: MessageThreadRepository
    private let size: Int = 2
    private var cursor: String?

    init(repository: MessageThreadRepository = MessageThreadRepositoryImpl()) {
        self.repository = repository
    }

    // 初期のロード処理
    func initialExecute() async throws -> [MessageThread] {
        let (messageThreads, paginationMetadata) = try await repository.getMessageThreads(cursor: nil, size: size)
        cursor = paginationMetadata.nextPage
        return messageThreads.filter { $0.finishedAt != nil }.sorted { $0.finishedAt ?? Date() > $1.finishedAt ?? Date() }
    }

    // ロード処理 (競合を防ぐために順番に処理)
    func loadMoreExecute() async throws -> [MessageThread] {
        let (messageThreads, paginationMetadata) = try await repository.getMessageThreads(cursor: cursor, size: size)
        cursor = paginationMetadata.nextPage
        return messageThreads.filter { $0.finishedAt != nil }.sorted { $0.finishedAt ?? Date() > $1.finishedAt ?? Date() }
    }
}
```

### 解説
- `actor` を使うことで、`cursor` の操作がスレッドセーフに行われます。
- `actor` 内での関数は一度に一つしか実行されないため、`loadMoreExecute` が複数の箇所から呼ばれても順番に処理され、`cursor` が正しく更新されることが保証されます。

これにより、`cursor` の競合を防ぎつつ、非同期処理の順序制御も行えるようになります。

---
