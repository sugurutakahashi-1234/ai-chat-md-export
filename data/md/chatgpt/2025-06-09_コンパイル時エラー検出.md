# コンパイル時エラー検出

日付: 2025-06-09

---

## 👤 ユーザー
*2025/6/9 17:19:54*

今のままを大きく変えずにzodとnative enumを最大限利用して、
export function getErrorMessage(
  apiErrorType: ApiErrorType,
  messageParams?: Partial&lt;Record&lt;ErrorParamKey, string&gt;&gt;,
)
の呼び出しの段階で、ApiErrorTypeに対応したmessageParamsが来ているかどうか、コンパイル時に判定できるようにしたい。

型名は消してもいいが、少なくとも引数の数や型で判定はしたい。

import { z } from "zod";
import { ErrorParamKey } from "../../../errors/api-error.js";

/**
 * APIエラータイプのenum
 *
 * 新しいエラータイプを追加する際の注意:
 * 1. このenumに新しい値を追加する
 * 2. 下記のgetStatusCode関数とgetErrorMessage関数に対応するcaseを追加する
 *    （追加しないとTypeScriptのコンパイルエラーになります）
 */
export enum ApiErrorType {
  Unknown = "Unknown",
  ValidationError = "ValidationError",
  NotFound = "NotFound",
  Conflict = "Conflict",
  Unauthorized = "Unauthorized",
  Forbidden = "Forbidden",
  InternalServerError = "InternalServerError",
  BadRequest = "BadRequest",

  // 具体的なビジネスエラー
  UserNotFound = "UserNotFound",
  EmailAlreadyExists = "EmailAlreadyExists",
}

/**
 * APIエラータイプのDTO
 */
export const ApiErrorTypeDto: z.ZodNativeEnum&lt;typeof ApiErrorType&gt; = z
  .nativeEnum(ApiErrorType)
  .openapi("ApiErrorTypeDto", {
    description: "APIエラーの種類",
    example: ApiErrorType.ValidationError,
  });

/**
 * ApiErrorTypeからHTTPステータスコードを取得
 * exhaustiveスイッチパターンにより、新しいApiErrorTypeを追加した際に
 * ステータスコードの追加を忘れるとコンパイルエラーになる
 */
export function getStatusCode(apiErrorType: ApiErrorType): number {
  switch (apiErrorType) {
    case ApiErrorType.Unknown:
      return 500;
    case ApiErrorType.ValidationError:
      return 400;
    case ApiErrorType.NotFound:
      return 404;
    case ApiErrorType.Conflict:
      return 409;
    case ApiErrorType.Unauthorized:
      return 401;
    case ApiErrorType.Forbidden:
      return 403;
    case ApiErrorType.InternalServerError:
      return 500;
    case ApiErrorType.BadRequest:
      return 400;
    case ApiErrorType.UserNotFound:
      return 404;
    case ApiErrorType.EmailAlreadyExists:
      return 409;
    default: {
      // exhaustiveness check: すべてのケースが網羅されていることを保証
      const _exhaustiveCheck: never = apiErrorType;
      void _exhaustiveCheck; // 未使用変数の警告を抑制
      return 500;
    }
  }
}

/**
 * ApiErrorTypeからエラーメッセージを取得
 * exhaustiveスイッチパターンにより、新しいApiErrorTypeを追加した際に
 * メッセージの追加を忘れるとコンパイルエラーになる
 */
export function getErrorMessage(
  apiErrorType: ApiErrorType,
  messageParams?: Partial&lt;Record&lt;ErrorParamKey, string&gt;&gt;,
): string {
  switch (apiErrorType) {
    case ApiErrorType.Unknown:
      return "予期しないエラーが発生しました。";
    case ApiErrorType.ValidationError:
      return "入力値の検証エラーが発生しました。";
    case ApiErrorType.NotFound:
      return "データが見つかりません。";
    case ApiErrorType.Conflict:
      return "既に存在するデータです。";
    case ApiErrorType.Unauthorized:
      return "認証が必要です。";
    case ApiErrorType.Forbidden:
      return "アクセス権限がありません。";
    case ApiErrorType.InternalServerError:
      return "サーバー内部エラーが発生しました。";
    case ApiErrorType.BadRequest:
      return "データの形式が正しくありません。";
    case ApiErrorType.UserNotFound:
      return "ユーザーが見つかりません。";
    case ApiErrorType.EmailAlreadyExists:
      return messageParams?.[ErrorParamKey.Email]
        ? `${messageParams[ErrorParamKey.Email]} は既に使用されています。`
        : "このメールアドレスは既に使用されています。";
    default: {
      // exhaustiveness check: すべてのケースが網羅されていることを保証
      const _exhaustiveCheck: never = apiErrorType;
      void _exhaustiveCheck;
      return "予期しないエラーが発生しました。";
    }
  }
}

---

## 🤖 アシスタント
*2025/6/9 17:19:57*

以下の手順だけで **実装ロジックを一切変えず**、  
呼び出し側で *ApiErrorType に合った引数* が渡っているかを **コンパイル時** に保証できます。  

---

## 1. “エラータイプ ↔ パラメータ” を 1 か所に集約する

```ts
// error-param-schema.ts
import { z } from "zod";
import { ApiErrorType } from "./api-error-type";
import { ErrorParamKey } from "../../../errors/api-error";

/**
 * 「このエラーのときはどんな messageParams が必要か」を Zod で表現
 * - パラメータが不要 → z.never()
 * - 任意            → z.object({}).partial() など
 */
export const errorParamSchema = {
  // --- パラメータ不要 ----------------------------
  [ApiErrorType.Unknown]            : z.never(),
  [ApiErrorType.ValidationError]    : z.never(),
  [ApiErrorType.NotFound]           : z.never(),
  [ApiErrorType.Conflict]           : z.never(),
  [ApiErrorType.Unauthorized]       : z.never(),
  [ApiErrorType.Forbidden]          : z.never(),
  [ApiErrorType.InternalServerError]: z.never(),
  [ApiErrorType.BadRequest]         : z.never(),
  [ApiErrorType.UserNotFound]       : z.never(),

  // --- 必須パラメータあり ------------------------
  [ApiErrorType.EmailAlreadyExists]: z.object({
    [ErrorParamKey.Email]: z.string(),
  }),
} as const;

/** 各エラータイプに対する TypeScript 上の型 */
export type ErrorParamMap = {
  [K in keyof typeof errorParamSchema]: z.infer<(typeof errorParamSchema)[K]>;
};
```

*ポイント*  

* **Zod** を使うことで *ランタイム検証* も同時に確保  
* `z.never()` を使って「このエラーは param 不要」と明示 → 後述の型計算に利用  
* 新しい `ApiErrorType` を追加したらここに必ず書くので、漏れればコンパイルエラー

---

## 2. `getErrorMessage` の型だけを “賢く” する

```ts
// api-error-message.ts
import { ApiErrorType } from "./api-error-type";
import { ErrorParamKey } from "../../../errors/api-error";
import { ErrorParamMap } from "./error-param-schema";

/** 2 番目の引数を「必要な場合だけ必須」にするタプル型 */
type MessageParamArg<T extends ApiErrorType> =
  // param 型が never → 省略可
  [ErrorParamMap[T]] extends [never]
    ? [messageParams?: undefined]
    : [messageParams: ErrorParamMap[T]];

/**
 * オーバーロード不要・実装は 1 つだけ
 */
export function getErrorMessage<T extends ApiErrorType>(
  ...[apiErrorType, messageParams]: [apiErrorType: T, ...MessageParamArg<T>]
): string {
  // ---- ここから下は既存実装をそのまま貼り付けで OK ----
  switch (apiErrorType) {
    case ApiErrorType.Unknown:
      return "予期しないエラーが発生しました。";
    /* ... 省略 ... */
    case ApiErrorType.EmailAlreadyExists:
      return messageParams?.[ErrorParamKey.Email]
        ? `${messageParams[ErrorParamKey.Email]} は既に使用されています。`
        : "このメールアドレスは既に使用されています。";
    default: {
      const _exhaustiveCheck: never = apiErrorType;
      void _exhaustiveCheck;
      return "予期しないエラーが発生しました。";
    }
  }
}
```

### 型チェックがどう変わるか

```ts
// ✅ OK（必須パラメータあり）
getErrorMessage(ApiErrorType.EmailAlreadyExists, {
  [ErrorParamKey.Email]: "foo@example.com",
});

// ❌ コンパイルエラー: Email が必須
getErrorMessage(ApiErrorType.EmailAlreadyExists);

// ✅ OK（param 不要）
getErrorMessage(ApiErrorType.NotFound);

// ❌ コンパイルエラー: 不要なのに渡している
getErrorMessage(ApiErrorType.NotFound, {
  [ErrorParamKey.Email]: "foo@example.com",
});
```

---

## 3. 追加するときに発生する“守り”のコンパイルエラー

1. **新しい `ApiErrorType` を enum に追加**  
2. それを **`errorParamSchema` に書き忘れる**  
3. → `ErrorParamMap` が欠落し、`getErrorMessage` の `switch` でも `_exhaustiveCheck` が発火  
   → **ビルドが通らない**ので “追加したけど各所が未対応” を確実に検出できます。

---

### まとめ — 変更点は型宣言のみ

* **実装ロジック／呼び出し方は現状維持**  
* Zod + native enum だけで  
  * 必要／不要／必須キーの判定を **静的型** で保証  
  * さらに **ランタイム検証** も同時に確保  
* 追加漏れはすべて **コンパイルエラー** で検知  

これで「呼び出し段階での安全性」を最大化できます。

---

## 👤 ユーザー
*2025/6/9 17:26:12*

xport const errorParamSchema = {
  // --- パラメータ不要 ----------------------------
  [ApiErrorType.Unknown]: z.never(),
  [ApiErrorType.ValidationError]: z.never(),
  [ApiErrorType.NotFound]: z.never(),
  [ApiErrorType.Conflict]: z.never(),
  [ApiErrorType.Unauthorized]: z.never(),
  [ApiErrorType.Forbidden]: z.never(),
  [ApiErrorType.InternalServerError]: z.never(),
  [ApiErrorType.BadRequest]: z.never(),
  [ApiErrorType.UserNotFound]: z.never(),

  // --- 必須パラメータあり ------------------------
  [ApiErrorType.EmailAlreadyExists]: z.object({
    [ErrorParamKey.Email]: z.string(),
  }),
} as const;

について、

クラスまたはオブジェクト リテラル上の計算されたプロパティ名を --isolatedDeclarations と共に推論することはできません。ts(9038)
api-error-type.ts(114, 14): 変数 errorParamSchema に型注釈を追加してください。

というエラーになってしまった。
as const という、この手のmap処理は良くないかもしれない。
ちゃんとswitch-caseみたいな制御だったり、enum出ないとダメかも

---

## 🤖 アシスタント
*2025/6/9 17:26:13*

`--isolatedDeclarations` を有効にすると

```
const obj = { [SOME_ENUM_KEY]: 1 }  // ← 計算済みプロパティ
```

のような **計算済みプロパティ名** を含むオブジェクト・リテラルは  
トップレベル変数として宣言するときに必ず **明示的な型注釈** が要ります。  
（d.ts 生成時にキー型を推論できないため -– というのが ts 9038 の趣旨です）

### 速攻で直すなら（型注釈を付けるだけ）

```ts
export const errorParamSchema: Record<ApiErrorType, z.ZodTypeAny> = {
  [ApiErrorType.Unknown]            : z.never(),
  [ApiErrorType.ValidationError]    : z.never(),
  /* ……以下略…… */
  [ApiErrorType.EmailAlreadyExists] : z.object({
    [ErrorParamKey.Email]: z.string(),
  }),
} as const;
```

* **利点** 既存コードを一文字も削らずエラーが消える  
* **欠点** プロパティごとの型が `ZodTypeAny` に潰れてしまう  
  * ＝ 前回提案した *「パラメータ必須／不要」* の静的判定が効かなくなる

---

## 推奨パターン – `as const satisfies` で両立させる

TypeScript 5.2+ なら次の書き方で

* **isolatedDeclarations を満たす**  
* **キー網羅性を静的チェック**  
* **値型情報（`z.never()` か `z.object(...)` か）を保持**

が同時にできます。

```ts
import { z, type ZodTypeAny } from "zod";
import { ApiErrorType } from "./api-error-type";
import { ErrorParamKey } from "../../../errors/api-error";

export const errorParamSchema = {
  // --- パラメータ不要 ----------------------------
  Unknown            : z.never(),
  ValidationError    : z.never(),
  NotFound           : z.never(),
  Conflict           : z.never(),
  Unauthorized       : z.never(),
  Forbidden          : z.never(),
  InternalServerError: z.never(),
  BadRequest         : z.never(),
  UserNotFound       : z.never(),

  // --- 必須パラメータあり ------------------------
  EmailAlreadyExists : z.object({
    [ErrorParamKey.Email]: z.string(),
  }),
} as const satisfies Record<ApiErrorType, ZodTypeAny>;
```

### ここがポイント

1. **計算済みプロパティをやめて**  
   `Unknown`, `ValidationError` … と “そのまま文字列” で書く  
   *Enum の値そのものがキー* なので型チェックは問題なく通ります。
2. `satisfies Record<ApiErrorType, ZodTypeAny>`  
   * *網羅性*: すべての `ApiErrorType` がキーに無いと即コンパイルエラー  
   * *値型保持*: `as const` と組み合わせても **各プロパティの具体型** を維持
3. `ZodTypeAny` には `never` も `ZodObject` も代入可 → 値の型が自由

> **Q. computed property を残したまま `satisfies` だけで直らない？**  
> A. 残念ながら `--isolatedDeclarations` では依然エラーになります。  
>      トップレベルの *計算済みキー* は d.ts 出力時に表現できないためです。

---

### これでも “必須／不要” 判定は維持される？

はい。前回示した型

```ts
type ErrorParamMap = {
  [K in keyof typeof errorParamSchema]: z.infer<(typeof errorParamSchema)[K]>;
};
```

はそのまま機能し、`getErrorMessage` の

```ts
type MessageParamArg<T extends ApiErrorType> = ...
```

も問題なく動きます。  
つまり **ランタイム用のマップ** と **静的型安全** を両立しつつ  
`--isolatedDeclarations` もクリアできる、というわけです。

---

## 👤 ユーザー
*2025/6/9 17:27:52*

こうなった

変数には、--isolatedDeclarations を含む明示的な型注釈が必要です。ts(9010)
api-error-type.ts(114, 14): 変数 errorParamSchema に型注釈を追加してください。
const errorParamSchema: {
    readonly Unknown: z.ZodNever;
    readonly ValidationError: z.ZodNever;
    readonly NotFound: z.ZodNever;
    readonly Conflict: z.ZodNever;
    readonly Unauthorized: z.ZodNever;
    ... 4 more ...;
    readonly EmailAlreadyExists: z.ZodObject&lt;...&gt;;
}

---

## 🤖 アシスタント
*2025/6/9 17:27:53*

`--isolatedDeclarations` は  

> **「ファイル単位で `.d.ts` が生成できるように、  
>  *export される変数* には必ず “書ける” 型注釈を付けてね」**

という制約です。  
`as const satisfies …` で型は推論できていますが、**“明示的な” 型注釈** が無いので ts 9010 が出ています。

---

## ✅ 失わない型で注釈を付ける 2 つのやり方

### ❶ “内部用 → 外部公開” の二段構えにする（推奨）

```ts
import { z } from "zod";
import { ApiErrorType } from "./api-error-type";
import { ErrorParamKey } from "../../../errors/api-error";
import type { ZodTypeAny } from "zod";

/* --- プライベート: 型推論させたい --- */
const _errorParamSchema = {
  Unknown            : z.never(),
  ValidationError    : z.never(),
  NotFound           : z.never(),
  Conflict           : z.never(),
  Unauthorized       : z.never(),
  Forbidden          : z.never(),
  InternalServerError: z.never(),
  BadRequest         : z.never(),
  UserNotFound       : z.never(),

  EmailAlreadyExists : z.object({
    [ErrorParamKey.Email]: z.string(),
  }),
} as const satisfies Record<ApiErrorType, ZodTypeAny>;

/* --- 公開用: isolatedDeclarations を満たす “明示型” --- */
export const errorParamSchema: Readonly<typeof _errorParamSchema> =
  _errorParamSchema;
```

* `_errorParamSchema` は **各キーごとの具体型** を保持  
* `errorParamSchema` は **明示的な型注釈** 付きなので ts 9010 を回避  
* `ErrorParamMap` などは `typeof _errorParamSchema` を使えば  
  **従来どおり “必須/不要” 判定が静的に効く** まま

---

### ❷ 1 行で済ませたいなら “ザックリ” 注釈

```ts
export const errorParamSchema: Record<ApiErrorType, z.ZodTypeAny> = {
  /* …同じ中身… */
} as const;
```

* **一瞬でエラーは消える**  
* ただしプロパティ型がすべて `ZodTypeAny` になるため  
  `getErrorMessage` 側での *必須パラメータ判定* が効かなくなる  
  （静的安全性を犠牲にした妥協案）

---

## どちらを選ぶ？

| 方法 | 静的安全性 | 追記量 | わかりやすさ |
|------|------------|--------|--------------|
| **❶ 二段構え** | ◎ 保持 | △ 3 行増える | ○ 型が読める |
| ❷ ザックリ注釈 | △ 失われる | ◎ 1 行 | ◎ シンプル |

> **型安全を維持したい** → **❶** を採用  
> 型はそこまで気にしない／とりあえずビルドを通したい → **❷**

---

### その後のコードは変更不要

`ErrorParamMap` や `getErrorMessage` で参照しているのは  
`typeof errorParamSchema` もしくは `_errorParamSchema` なので、  
上記どちらのパターンでも **実装はそのまま動きます**。

---

## 👤 ユーザー
*2025/6/9 17:30:33*

まだ、同じエラーが発生しているのだけれども。

変数には、--isolatedDeclarations を含む明示的な型注釈が必要です。ts(9010)
api-error-type.ts(115, 7): 変数 _errorParamSchema に型注釈を追加してください。

---

## 🤖 アシスタント
*2025/6/9 17:30:33*

### `--isolatedDeclarations` が求めているのは **「トップレベルの変数に“書ける”型注釈を付けろ」** という一点だけです。  
`as const` + `satisfies` で型推論させるだけでは **“注釈”** が無いとみなされるため、依然 TS9010 が出続けます。  
そこで **「注釈を付けても具体型は失わない」** 形に書き換えます。  

---

## 1 手で保守できる注釈つきマップ

```ts
import { z } from "zod";
import { ApiErrorType } from "./api-error-type";
import { ErrorParamKey } from "../../../errors/api-error";

/* ---------- ①: マップ全体の“型”を宣言 ---------- */
type ErrorParamSchema = {
  /** パラメータ不要 → z.ZodNever */
  [K in | ApiErrorType.Unknown
        | ApiErrorType.ValidationError
        | ApiErrorType.NotFound
        | ApiErrorType.Conflict
        | ApiErrorType.Unauthorized
        | ApiErrorType.Forbidden
        | ApiErrorType.InternalServerError
        | ApiErrorType.BadRequest
        | ApiErrorType.UserNotFound]: z.ZodNever;

} & {
  /** 必須パラメータあり */
  [ApiErrorType.EmailAlreadyExists]: z.ZodObject<{
    [ErrorParamKey.Email]: z.ZodString;
  }>;
};

/* ---------- ②: “明示的な型注釈” 付きで定義 ---------- */
export const errorParamSchema: ErrorParamSchema = {
  // --- パラメータ不要 ----------------------------
  Unknown            : z.never(),
  ValidationError    : z.never(),
  NotFound           : z.never(),
  Conflict           : z.never(),
  Unauthorized       : z.never(),
  Forbidden          : z.never(),
  InternalServerError: z.never(),
  BadRequest         : z.never(),
  UserNotFound       : z.never(),

  // --- 必須パラメータあり ------------------------
  EmailAlreadyExists : z.object({
    [ErrorParamKey.Email]: z.string(),
  }),
} as const;
```

### なぜこれで通る？

* **型注釈**（`: ErrorParamSchema`）を付けたので `isolatedDeclarations` が満足
* 初期化子に `as const` を付けているので  
  *各キー固有* の `z.ZodNever` / `z.ZodObject<…>` がそのまま保持
* `ErrorParamSchema` は **1 か所** だけ書けば OK  
  新しい `ApiErrorType` を追加したときは  
  * 型別名にキーを追加  
  * オブジェクトにもプロパティを追加  
  しないと **即コンパイルエラー** になる ―― “漏れ防止” は従来どおり

---

## 2 行だけで済ませたい “最小パターン” (型安全度は下がる)

```ts
import { z } from "zod";
import { ApiErrorType } from "./api-error-type";
import { ErrorParamKey } from "../../../errors/api-error";

export const errorParamSchema: Record<ApiErrorType, z.ZodTypeAny> = {
  /* …同じ中身… */
} as const;
```

* エラーは消えるが **各プロパティの具体型が `ZodTypeAny` に潰れる**  
* `getErrorMessage` での “必須／不要” 判定が静的に効かなくなる

---

## 既存コードへの影響

* `type ErrorParamMap = { [K in keyof typeof errorParamSchema]: … }`  
  → **そのまま動く**（①案なら具体型も保持）
* `getErrorMessage<T extends ApiErrorType>(…`  
  → **必須パラメータ判定が継続**（①案）

---

### まとめ

| 書き方 | 型安全 | 記述量 | isolatedDeclarations |
|--------|--------|--------|----------------------|
| **① 具体型付き注釈** (上記 `ErrorParamSchema` 案) | **◎** | △ (キー列挙が必要) | **◎ クリア** |
| ② Record\<ApiErrorType, any\> 注釈 | △ | ◎ | ◎ |

「**型安全を保ちつつ `--isolatedDeclarations` も通す**」場合は **①** を採用してください。

---

## 👤 ユーザー
*2025/6/9 17:33:02*

型安全を保ちながらこのキー列挙が必要なのを簡略化したくて、このときに constは相性が悪いのではないかとずっと思っている。なので、native enumとかで制御したりできないかな？

---

## 🤖 アシスタント
*2025/6/9 17:33:04*

### “キーの二重列挙” をほぼゼロにする完全版

> ✅ **型安全**  
> ✅ **`--isolatedDeclarations` を満たす**  
> ✅ **列挙が必要なのは「パラメータ必須のエラー」だけ**  

---

## 1. ヘルパーを 1 度だけ定義

```ts
// helpers/define-error-param-schema.ts
import { z, type ZodTypeAny } from "zod";
import { ApiErrorType } from "../api-error-type";

/**
 * 必須パラメータを列挙したオブジェクトだけ渡せば
 * - 他のエラー → z.never()
 * を自動で埋めてくれる。  
 *
 * 返り値の型は **全 ApiErrorType をキーに持ちつつ**
 * パラメータ有無を静的に保持する。
 */
export function defineErrorParamSchema<
  T extends Partial<Record<ApiErrorType, ZodTypeAny>>,
>(paramRequired: T) {
  // --- ランタイムで「z.never() テーブル」を作成 -------------
  const base = Object.fromEntries(
    Object.values(ApiErrorType).map((k) => [k, z.never()]),
  ) as Record<ApiErrorType, ZodTypeAny>;

  // --- “必須パラメータあり” 部分で上書き ----------------------
  const merged = { ...base, ...paramRequired };

  /* ----------------------------------------------------------
   * ここが型のキモ:
   *   - 返り値は “全キー” を持つ Record
   *   - paramRequired に書いたキーだけ具体型に置換
   * -------------------------------------------------------- */
  return merged as {
    [K in ApiErrorType]: K extends keyof T ? T[K] : typeof z.never;
  };
}
```

*トップレベル変数も計算済みプロパティも無いので* **`ts(9010)` は出ません**。  
`.d.ts` 生成時も返り値型が完全に書けるため問題なし。

---

## 2. 呼び出し側は「必須パラメータ」のみ列挙

```ts
// api-error-type.ts（※一部抜粋）
import { z } from "zod";
import { ErrorParamKey } from "../../../errors/api-error";
import { defineErrorParamSchema } from "./helpers/define-error-param-schema";

/** ここで *必須パラメータがある* エラーだけ書けば OK */
export const errorParamSchema = defineErrorParamSchema({
  [ApiErrorType.EmailAlreadyExists]: z.object({
    [ErrorParamKey.Email]: z.string(),
  }),
  // 必要なら ↓ のように他を追加していくだけ
  // [ApiErrorType.SomethingWrong]: z.object({...}),
});
```

### ✔ コンパイル時チェック例

```ts
// OK: 必須パラメータ付き
getErrorMessage(ApiErrorType.EmailAlreadyExists, {
  [ErrorParamKey.Email]: "foo@example.com",
});

// コンパイルエラー: Email が必須
getErrorMessage(ApiErrorType.EmailAlreadyExists);

// OK: param 不要
getErrorMessage(ApiErrorType.NotFound);

// コンパイルエラー: 不要なのに渡している
getErrorMessage(ApiErrorType.NotFound, {
  [ErrorParamKey.Email]: "foo@example.com",
});
```

---

## 3. 仕組みのポイント

| 目的 | どう達成しているか |
|-----|-------------------|
| **列挙を減らす** | `defineErrorParamSchema` で *未指定キー → 自動で `z.never()`* |
| **型安全** | 返り値型で「指定キーは具体型」「それ以外は `never`」を保持 |
| **`--isolatedDeclarations` 合格** | 変数に計算済みキー無し & 関数返り値の **明示型** がある |
| **追加漏れ検知** | 必須パラメータが無いエラーを `paramRequired` に “うっかり書いた／書かなかった” 際に型が合わずビルド失敗 |

---

### まとめ

* **列挙の二重管理** は “0 or 1 回” だけ  
  *デフォルトは全部 `z.never()`* だから、  
  **パラメータが要るエラーを足すたびに 1 行追加するだけ**  
* `getErrorMessage` の呼び出し側では **静的に必須/不要が判定** される  
* `--isolatedDeclarations` も **エラーなしで完全クリア**

これで *enum 追加漏れの検出* と *呼び出し時の型安全* を両立しつつ、  
メンテ工数を最小限にできます。

---
