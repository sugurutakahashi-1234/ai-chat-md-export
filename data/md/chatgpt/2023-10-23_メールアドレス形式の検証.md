# メールアドレス形式の検証

日付: 2023-10-23

---

## 👤 ユーザー
*2023/10/23 16:48:01*

SwiftUI で 入力された文字列がメールアドレス形式であることの判定

---

## 🤖 アシスタント
*2023/10/23 16:48:43*

SwiftUIと組み合わせて、入力された文字列がメールアドレスの形式に従っているかどうかを確認する方法の一つは、`TextField`の入力を監視して、正規表現または`NSDataDetector`を使用してその形式を検証することです。

以下は、SwiftUIでこのタスクを実行するための簡単な例です：

```swift
import SwiftUI

struct ContentView: View {
    // 入力されたテキストを格納する変数
    @State private var emailAddress = ""

    var body: some View {
        VStack {
            // ユーザーがメールアドレスを入力できるテキストフィールド
            TextField("メールアドレスを入力してください", text: $emailAddress)
                .padding()
                .border(isValidEmail(emailAddress) ? Color.green : Color.red, width: /*...*/)
                .autocapitalization(.none)
                .keyboardType(.emailAddress)

            // 入力が有効なメールアドレスかどうかを表示するテキスト
            Text(isValidEmail(emailAddress) ? "有効なメールアドレスです" : "無効なメールアドレスです")
                .foregroundColor(isValidEmail(emailAddress) ? .green : .red)
                .padding()
        }
        .padding()
    }

    // メールアドレスが有効かどうかをチェックする関数
    func isValidEmail(_ email: String) -> Bool {
        // 正規表現パターンを使用してメールアドレスの形式を定義
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: email)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードは、`TextField`を使用してユーザーの入力を受け取り、その入力がメールアドレスの形式に適合しているかどうかをリアルタイムで検証します。検証には正規表現が使用され、入力がメールアドレスの形式に適合しているかに応じて、メッセージの色が変わります。

この正規表現は基本的なメール形式にマッチしますが、実際のシナリオではさらに複雑な検証が必要になる場合があります。また、アプリケーションのバックエンドで追加の検証を行うことも、一般的なベストプラクティスです。

---

## 👤 ユーザー
*2023/10/23 17:39:19*

isValidEmail は Stringのextensionにしたい。

---

## 🤖 アシスタント
*2023/10/23 17:39:57*

`isValidEmail`を`String`の拡張として実装することは、コードの再利用性と可読性を向上させる素晴らしいアイデアです。以下のコードでは、`isValidEmail`を`String`拡張として定義し、それを`ContentView`内で使用しています。

まず、`String`の拡張を作成します:

```swift
import Foundation

extension String {
    // このStringが有効なメールアドレスかどうかをチェックするプロパティ
    var isValidEmail: Bool {
        // 正規表現パターンを使用してメールアドレスの形式を定義
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: self)
    }
}
```

次に、`ContentView`を更新して、この新しい`String`拡張機能を使用します:

```swift
import SwiftUI

struct ContentView: View {
    // 入力されたテキストを格納する変数
    @State private var emailAddress = ""

    var body: some View {
        VStack {
            // ユーザーがメールアドレスを入力できるテキストフィールド
            TextField("メールアドレスを入力してください", text: $emailAddress)
                .padding()
                .border(emailAddress.isValidEmail ? Color.green : Color.red, width: /*...*/)
                .autocapitalization(.none)
                .keyboardType(.emailAddress)

            // 入力が有効なメールアドレスかどうかを表示するテキスト
            Text(emailAddress.isValidEmail ? "有効なメールアドレスです" : "無効なメールアドレスです")
                .foregroundColor(emailAddress.isValidEmail ? .green : .red)
                .padding()
        }
        .padding()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

この方法で、どんな`String`インスタンスでも、`.isValidEmail`プロパティを使用して簡単にメールの形式を検証できます。これはSwiftの拡張機能の力を示す良い例であり、コードをよりクリーンに保ち、再利用性を向上させる方法です。

---

## 👤 ユーザー
*2023/10/23 17:40:05*

isValidEmail を複数のパターンでテストするプレイグラウンドを記述してほしい。

---

## 🤖 アシスタント
*2023/10/23 17:40:45*

SwiftのPlaygroundを使用して、`isValidEmail`拡張機能を様々なメールアドレスのパターンでテストすることは、その機能を確認するのに非常に役立ちます。以下にそのための基本的なコードを示します。

まず、新しいSwift Playgroundを開始し、以下のコードをコピーして貼り付けます:

```swift
import Foundation

// Stringの拡張としてisValidEmailプロパティを定義
extension String {
    var isValidEmail: Bool {
        // 正規表現パターンを使用してメールアドレスの形式を定義
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: self)
    }
}

// テストするメールアドレスのサンプル
let emails = [
    "email@example.com",
    "firstname.lastname@example.co.jp",
    "email@123.123.123.123",
    "email@[123.123.123.123]",
    "plainaddress", // 無効なアドレス
    "@missingusername.com", // 無効なアドレス
    "username@.com.", // 無効なアドレス
    "username@.com" // 無効なアドレス
]

// 各メールアドレスをチェックし、その結果を印刷
for email in emails {
    print("\(email) is valid: \(email.isValidEmail)")
}
```

このコードは、各メールアドレスの文字列に対して`isValidEmail`を呼び出し、その有効性をコンソールに出力します。メールアドレスのサンプルリスト`emails`には、有効と期待されるアドレスと無効と期待されるアドレスの両方が含まれています。

Playgroundはコードをリアルタイムで実行し、即座にフィードバックを提供するため、この環境でのテストは、新しいメソッドや拡張機能の動作を迅速に理解するのに理想的です。必要に応じて、さまざまなメール形式を`emails`配列に追加して、`isValidEmail`関数の堅牢性をさらにテストすることができます。

---

## 👤 ユーザー
*2023/10/23 17:42:01*

もう少しテストケース増やして欲しい

---

## 🤖 アシスタント
*2023/10/23 17:42:53*

もちろん、`isValidEmail`メソッドのテストの正確性と完全性を高めるために、さらに多くのテストケースを追加することが重要です。メールアドレスの構造は非常に多様であり、多くの異なる形式が存在するため、さまざまなシナリオをカバーすることが重要です。

以下は、様々な形式のメールアドレスで`isValidEmail`メソッドをテストするための拡張されたテストセットです。

```swift
import Foundation

// Stringの拡張としてisValidEmailプロパティを定義
extension String {
    var isValidEmail: Bool {
        // 正規表現パターンを使用してメールアドレスの形式を定義
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: self)
    }
}

// テストするメールアドレスのサンプル
let emails = [
    "email@example.com",
    "firstname.lastname@example.co.jp",
    "email@123.123.123.123",
    "email@[123.123.123.123]",
    "_email@example.com",
    "email@example.co.jp",
    "firstname+lastname@example.com",
    "email@localhost", // 特定の場合には有効ですが、一般的な場合には無効とみなされるかもしれません。
    "email@s.s", // 無効なアドレス
    "plainaddress", // 無効なアドレス
    "@missingusername.com", // 無効なアドレス
    "username@.com.", // 無効なアドレス
    "username@.com", // 無効なアドレス
    "username@example..com", // 無効なアドレス (連続したドット)
    ".username@example.com", // 無効なアドレス (先頭にドット)
    "username@example.com.", // 無効なアドレス (最後にドット)
    "username@-example.com", // 無効なアドレス (ドメインがハイフンで始まる)
    "username@exam_ple.com", // 無効なアドレス (ドメイン名にアンダースコアが含まれている)
    "example@invalid_domain.com" // 無効なアドレス (ドメイン名に無効な文字が含まれている)
]

// 各メールアドレスをチェックし、その結果を印刷
for email in emails {
    print("\(email) is valid: \(email.isValidEmail)")
}
```

ここにリストされているメールアドレスは、有効とされるものから、一般的なエラー（先頭または末尾の文字、禁止されている特殊文字、構造上の問題など）を含む無効なものまで、さまざまです。これらのテストケースは`isValidEmail`関数が予想される動作をするかどうかをチェックしますが、メールアドレスの検証は複雑なため、可能な限り多くの実際のシナリオでテストすることが重要です。また、いくつかのエッジケース（例：`email@localhost`）では、有効性がコンテキストに依存することに注意してください。

---

## 👤 ユーザー
*2023/10/23 17:52:54*

予測値も書いて欲しい。また、一回見直して欲しいのと、正規表現を正しく理解して、必要なテストに絞って欲しい。

---

## 🤖 アシスタント
*2023/10/23 17:53:56*

承知しました。まず、使用されている正規表現を解析し、それから適切なテストケースをリストアップしましょう。

正規表現: `"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"`

この正規表現は、一般的なメールアドレスのパターンを捉えるために設計されています:
1. 1つ以上の英大文字、小文字、数字、または`._%+-`の文字（これがメールアドレスのローカル部分です）。
2. `@`記号。
3. 1つ以上の英大文字、小文字、数字、または`.`の文字（これがドメインです）。
4. `.`記号。
5. 2から64文字の英大文字または小文字（これがトップレベルドメインです）。

これを踏まえて、テストケースを見直し、予測される結果とともに提供しましょう。

```swift
let emailTests = [
    ("email@example.com", true),
    ("firstname.lastname@example.co.jp", true),
    ("email@123.123.123.123", true),
    ("_email@example.com", true),
    ("email@example.co.jp", true),
    ("firstname+lastname@example.com", true),
    ("email@localhost", true), // 一般的な場合には無効ですが、ローカルドメインは許容される場合がある
    ("email@s.s", true), // 短いTLDは実際に存在する
    ("plainaddress", false), // @記号が欠けています
    ("@missingusername.com", false), // ユーザー名が欠けています
    ("username@.com.", false), // ドメインが無効です
    ("username@.com", false), // ドメインが無効です
    ("username@example..com", false), // 連続するドットは許容されません
    (".username@example.com", true), // ユーザー名がドットで始まることは許容されます
    ("username@example.com.", false), // メールアドレスがドットで終わることは許容されません
    ("username@-example.com", false), // ドメインがハイフンで始まることは許容されません
    ("username@exam_ple.com", false), // ドメイン名にアンダースコアは通常許容されません
    ("example@invalid_domain.com", false) // ドメイン名にアンダースコアは許容されません
]

for (email, expectedResult) in emailTests {
    let result = email.isValidEmail
    assert(result == expectedResult, "Test failed for \(email): expected \(expectedResult), got \(result)")
    print("Test passed for \(email)")
}
```

注意: `email@localhost`や`email@s.s`のようないくつかのケースは、特定のコンテキストでは有効であると見なされるかもしれません。しかし、一般的な状況やパブリックドメインのメールアドレスとしては、これらは無効と見なされることが多いです。

このテストスイートは、正規表現が期待通りに機能するかどうかを確認するための基本となりますが、実際のシナリオでは、より多くのエッジケースや異なるメールアドレス形式をテストすることが重要です。また、メールアドレスの検証には多くの複雑さがあり、完璧な正規表現パターンは実際には存在しないため、実際のアプリケーションでは、メールアドレスの実際の受信可能性を確認するために、確認メールを送信するなどの追加手段を講じることが一般的です。

---

## 👤 ユーザー
*2023/10/23 17:54:29*

こうなった、

Test passed for email@example.com
Test passed for firstname.lastname@example.co.jp
__lldb_expr_11/#900_isValidEmail.playground:36: Assertion failed: Test failed for email@123.123.123.123: expected true, got false

---

## 🤖 アシスタント
*2023/10/23 17:55:07*

`email@123.123.123.123`が失敗するのは、使用されている正規表現がIPアドレスのドメインを許容しないためです。現在の正規表現では、ドメイン名が英字と`.`、`-`で構成されていることを期待していますが、数字やドットだけのドメイン（この場合はIPv4アドレス）はマッチしません。

IPアドレスをドメインとして許容するには、正規表現を更新する必要があります。ただし、これは非常に複雑になる可能性があります。IPv4アドレスの正確な正規表現は非常に複雑であり、IPv6を含めるとさらに複雑になります。それでも、シンプルなケースでのIPv4アドレスを許容する基本的な例を以下に示します：

```swift
let emailRegex = "(?:[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64})|(?:[A-Z0-9a-z._%+-]+@[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)"
```

これにより、`user@example.com`や`user@111.222.333.444`のようなアドレスが許容されますが、`user@2001:0db8:85a3:0000:0000:8a2e:0370:7334`（IPv6）のようなアドレスや、サブドメインを含むものは許容されません。

全ての可能なメールアドレス形式を正確に検証する正規表現を作成することは、実際には非常に困難であり、おそらく不可能です。実際のアプリケーションでは、正規表現による検証の後に実際のメールサーバーに対して確認メールを送信するなど、追加の検証ステップを実行することが一般的です。

---

## 👤 ユーザー
*2023/10/23 17:57:37*

もっと正規表現を緩くしていいかも。


// Stringの拡張としてisValidEmailプロパティを定義
extension String {
    var isValidEmail: Bool {
        // 正規表現パターンを使用してメールアドレスの形式を定義
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: self)
    }
}

let emailTests = [
    ("email@example.com", true),
    ("firstname.lastname@example.co.jp", true),
    ("email@123.123.123.123", true),
    ("_email@example.com", true),
    ("email@example.co.jp", true),
    ("firstname+lastname@example.com", true),
    ("email@localhost", true), // 一般的な場合には無効ですが、ローカルドメインは許容される場合がある
    ("email@s.s", true), // 短いTLDは実際に存在する
    ("plainaddress", false), // @記号が欠けています
    ("@missingusername.com", false), // ユーザー名が欠けています
    ("username@.com.", false), // ドメインが無効です
    ("username@.com", false), // ドメインが無効です
    ("username@example..com", false), // 連続するドットは許容されません
    (".username@example.com", true), // ユーザー名がドットで始まることは許容されます
    ("username@example.com.", false), // メールアドレスがドットで終わることは許容されません
    ("username@-example.com", false), // ドメインがハイフンで始まることは許容されません
    ("username@exam_ple.com", false), // ドメイン名にアンダースコアは通常許容されません
    ("example@invalid_domain.com", false) // ドメイン名にアンダースコアは許容されません
]

for (email, expectedResult) in emailTests {
    let result = email.isValidEmail
    assert(result == expectedResult, "Test failed for \(email): expected \(expectedResult), got \(result)")
    print("Test passed for \(email)")
}

---

## 🤖 アシスタント
*2023/10/23 17:58:33*

正規表現を緩くすることで、より多くのメールアドレスの形式を許容できますが、無効なアドレスも通過する可能性があります。以下は、ドメイン部分における検証を緩和した正規表現です：

```swift
extension String {
    var isValidEmail: Bool {
        // 正規表現パターンを緩和し、一般的なメールアドレス形式をより広く受け入れる
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]+"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: self)
    }
}

let emailTests = [
    ("email@example.com", true),
    ("firstname.lastname@example.co.jp", true),
    ("email@123.123.123.123", true), // IPアドレスのドメインも許容する
    ("_email@example.com", true),
    ("email@example.co.jp", true),
    ("firstname+lastname@example.com", true),
    ("email@localhost", true), // ローカルドメインも許容する
    ("email@s.s", true), // 短いTLDも許容する
    ("plainaddress", false), // @記号が欠けている
    ("@missingusername.com", false), // ユーザー名が欠けている
    ("username@.com.", false), // ドメインが無効
    ("username@.com", false), // ドメインが無効
    ("username@example..com", false), // 連続するドットは許容されない
    (".username@example.com", true), // ユーザー名がドットで始まることを許容
    ("username@example.com.", false), // メールアドレスがドットで終わることは許容されない
    ("username@-example.com", false), // ドメインがハイフンで始まることは許容されない
    ("username@exam_ple.com", true), // ドメイン名にアンダースコアを許容（ただし一般的には許容されない）
    ("example@invalid_domain.com", true) // ドメイン名にアンダースコアを許容（ただし一般的には許容されない）
]

for (email, expectedResult) in emailTests {
    let result = email.isValidEmail
    assert(result == expectedResult, "Test failed for \(email): expected \(expectedResult), got \(result)")
    print("Test passed for \(email)")
}
```

このスクリプトでは、ドメイン名にアンダースコアが含まれている場合や、ドメインがIPアドレスの形式である場合に、メールアドレスを有効と見なします。しかし、これは標準的なメールアドレスの形式とは異なるため、これらのケースが実際のシナリオで許容されるかどうかは、使用するメールサーバーやアプリケーションに依存します。

正規表現を緩和することで柔軟性は高まりますが、一方で無効なフォーマットも許容してしまうリスクが伴います。そのため、実際のアプリケーションでは、サーバーサイドでの追加的なメールアドレスの検証や、確認メールの送信など、クライアントサイドの検証と組み合わせて使用することが重要です。

---

## 👤 ユーザー
*2023/10/23 17:58:49*

以下でエラーになったなんで？

Test passed for email@example.com
Test passed for firstname.lastname@example.co.jp
__lldb_expr_19/#900_isValidEmail.playground:35: Assertion failed: Test failed for email@123.123.123.123: expected true, got false

---

## 🤖 アシスタント
*2023/10/23 17:59:16*

現在の正規表現`"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]+"`では、ドメイン部分（@の後ろ）が英数字、ドット、ハイフンのみで構成され、最後がアルファベットのみのTLD（トップレベルドメイン）で終わる必要があります。この正規表現では、IPアドレスのような数値のみのドメインは許容されません。

"email@123.123.123.123"のようなメールアドレスは、ドメイン部分が数値のIPアドレスであるため、この正規表現にはマッチしません。このメールアドレス形式を許容するには、正規表現を以下のように調整する必要があります：

```swift
"[A-Z0-9a-z._%+-]+@([A-Za-z0-9.-]+|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})"
```

この変更で、ドメインが通常のドメイン名（英数字、ドット、ハイフンが含まれる）またはIPv4アドレス（数値とドット）のどちらかである場合にマッチします。

新しい正規表現を使って`isValidEmail`を更新し、テストを再度実行してください。これで"email@123.123.123.123"のテストがパスするはずです。

---

## 👤 ユーザー
*2023/10/23 17:59:59*

email@localhost が失敗したなぜ？

---

## 🤖 アシスタント
*2023/10/23 18:00:25*

`email@localhost`が失敗する理由は、現在の正規表現がトップレベルドメイン(TLD)に一致する部分を要求しているためです。具体的には、`\\.[A-Za-z]+`の部分がTLDであり、これは少なくとも1つの`.`に続いてアルファベットが1文字以上必要であることを意味します。`localhost`はTLDを含まないため、この正規表現とは一致しません。

ローカル開発や特定の環境でのテスト目的で`localhost`のようなTLDを含まないドメインを許可する必要がある場合、正規表現を修正してTLD部分をオプショナル（あってもなくても良い）にする必要があります。

以下の正規表現では、TLDがないドメインも許容します：

```swift
"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+(\\.[A-Za-z]+)?"
```

この正規表現では、`\\.[A-Za-z]+`の周りにある`()?`が、TLD部分があってもなくてもマッチすることを意味します。これにより、`email@localhost`も有効なメールアドレスとして認識されるようになります。

ただし、TLDがないメールアドレスはインターネット上で通常有効ではないため（ローカル環境では機能する可能性がありますが）、この変更を本番環境のアプリケーションに適用する場合は慎重に行う必要があります。

---

## 👤 ユーザー
*2023/10/23 18:06:22*

__lldb_expr_43/#900_isValidEmail.playground:35: Assertion failed: Test failed for username@exam_ple.com: expected true, got false となった。

---

## 🤖 アシスタント
*2023/10/23 18:06:53*

現在使用している正規表現`"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]+"`では、メールアドレスのドメイン名部分（@の後ろ）にアンダースコア（_）が含まれることは許されていません。この正規表現では、ドメイン名はアルファベット、数字、ドット（.）、ハイフン（-）のみで構成される必要があります。

`username@exam_ple.com`のようなメールアドレスは、ドメイン名にアンダースコアが含まれているため、この正規表現とは一致しません。

ドメイン名にアンダースコアを許容する場合は、正規表現を以下のように変更する必要があります：

```swift
"[A-Z0-9a-z._%+-]+@[A-Za-z0-9._-]+\\.[A-Za-z]+"
```

この変更により、ドメイン名にアンダースコアが使用されても、メールアドレスが有効と見なされるようになります。

ただし、一般的には、ドメイン名にアンダースコアが含まれることは推奨されておらず、標準的なメールアドレスの形式では許容されていません。そのため、この変更を適用する場合は、実際の利用シーンで問題がないかどうかを確認する必要があります。

---

## 👤 ユーザー
*2023/10/23 20:13:43*

もっとざっくりでいい。
文字列が@で挟まれていれば十分

extension String {
    var isValidEmail: Bool {
        // 正規表現パターンを緩和し、一般的なメールアドレス形式をより広く受け入れる
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9._-]+\\.[A-Za-z]+"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: self)
    }
}

let emailTests = [
    ("email@example.com", true),
    ("firstname.lastname@example.co.jp", true),
    ("email@123.123.123.123", false), // 最後が数字はNG
    ("_email@example.com", true),
    ("email@example.co.jp", true),
    ("firstname+lastname@example.com", true),
    ("email@localhost", false), // TLDが不足している
    ("email@s.s", true), // 短いTLDも許容する
    ("plainaddress", false), // @記号が欠けている
    ("@missingusername.com", false), // ユーザー名が欠けている
    ("username@.com.", false), // ドメインが無効
    ("username@.com", false), // ドメインが無効
    ("username@example.com.", false), // メールアドレスがドットで終わることは許容されない
    ("username@example..com", true), // 連続するドットを許容（ただし一般的には許容されない）
    (".username@example.com", true), // ユーザー名がドットで始まることを許容
    ("username@-example.com", true), // ドメインがハイフンで始まることを許容（ただし一般的には許容されない）
    ("username@exam_ple.com", true), // ドメイン名にアンダースコアを許容（ただし一般的には許容されない）
    ("example@invalid_domain.com", true), // ドメイン名にアンダースコアを許容（ただし一般的には許容されない）
]

for (email, expectedResult) in emailTests {
    let result = email.isValidEmail
    assert(result == expectedResult, "Test failed for \(email): expected \(expectedResult), got \(result)")
    print("Test passed for \(email)")
}

---

## 🤖 アシスタント
*2023/10/23 20:14:13*

あなたが提案した正規表現は、いくつかの通常は無効とされるパターンを許容するようになっていますが、それでもまだ特定の形式を要求しています。たとえば、TLD（トップレベルドメイン）が必要であるなどです。

ただし、ご要望に応じて、単に"@"で区切られた文字列をチェックするだけの非常に基本的な検証を行いたいということであれば、正規表現をさらに緩和することができます。以下にそのような実装を示します。

```swift
extension String {
    var isValidEmail: Bool {
        // "@"が含まれているかどうかだけをチェックする非常に基本的な正規表現
        let emailRegex = ".+@.+"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        return emailPredicate.evaluate(with: self)
    }
}

let emailTests = [
    ("email@example.com", true),
    ("firstname.lastname@example.co.jp", true),
    ("email@123.123.123.123", true), // IPアドレスはこの正規表現では許容されます
    ("_email@example.com", true),
    ("email@example.co.jp", true),
    ("firstname+lastname@example.com", true),
    ("email@localhost", true), // TLDがなくても、この正規表現では許容されます
    ("email@s.s", true), 
    ("plainaddress", false), // @記号が欠けています
    ("@missingusername.com", true), // ユーザー名が欠けていますが、この正規表現では許容されます
    ("username@.com.", true), // ドメインが一般的には無効ですが、この正規表現では許容されます
    ("username@.com", true), 
    ("username@example.com.", true), 
    ("username@example

---
