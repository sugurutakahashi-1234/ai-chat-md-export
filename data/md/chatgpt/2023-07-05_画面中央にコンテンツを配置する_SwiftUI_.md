# 画面中央にコンテンツを配置する(SwiftUI)

日付: 2023-07-05

---

## 👤 ユーザー
*2023/7/5 22:16:52*

SwiftUI で画面の中央をbottomにコンテンツを表示したいのと、同じように画面の中央をtopにしてコンテンツを表示したい。できれば同じVStackの中に定義したい。

---

## 🤖 アシスタント
*2023/7/5 22:17:53*

SwiftUIでは、フレキシブルにレイアウトを制御することが可能です。VStack内でSpacerを使用することで、コンテンツを画面の特定の位置に配置することが可能です。

画面の中央をbottomとしてコンテンツを配置する場合、Spacerを上部に配置することでコンテンツを下へ移動させることができます。同様に、画面の中央をtopとしてコンテンツを配置する場合、Spacerを下部に配置することでコンテンツを上に移動させることができます。

以下にその例を示します。

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            // 画面の中央をbottomとしてコンテンツを表示
            Spacer()
            Text("Bottom Content")
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.red)

            // 画面の中央をtopとしてコンテンツを表示
            Text("Top Content")
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.blue)
            Spacer()
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

上記のコードでは、"Bottom Content"というテキストが画面の中央より下部に配置され、"Top Content"というテキストが画面の中央より上部に配置されます。これはVStack内でのSpacerの位置によるものです。

SpacerはVStack内で利用可能な残りの空間をすべて占有します。最初のSpacerがVStackの最初に配置されているため、VStack内の残りの空間を占有し、"Bottom Content"テキストを下に押し出します。2つ目のSpacerが"Top Content"テキストの後に配置されているため、"Top Content"テキストを上に押し上げます。

ただし、上記のコードでは両方のテキストが均等にスペースを占有します。もし、特定のテキストがより多くのスペースを占有することを望むなら、`.frame(maxWidth: .infinity, maxHeight: .infinity)`を適切に調整することで実現できます。

---

## 👤 ユーザー
*2023/7/5 22:18:35*

Text("Bottom Content") が中央のセンターラインより、パディングを16pt、Text("Top Content")を中央のセンターラインよりパディングを16pt設定したい

---

## 🤖 アシスタント
*2023/7/5 22:19:17*

SwiftUIのPaddingを使用して、特定のViewにパディングを適用することができます。ただし、直接の方法でセンターラインからのパディングを設定することは難しいです。そこで、SpacerとGeometryReaderを併用して、Viewを所望の位置に配置することが可能です。

以下にその例を示します。

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        GeometryReader { geometry in
            VStack {
                Spacer()
                    .frame(height: geometry.size.height / 2 - 16) // 中央より少し上に配置
                Text("Top Content")
                    .background(Color.blue)

                Spacer()
                    .frame(height: 32) // 上下のテキスト間に32ptのスペースを確保

                Text("Bottom Content")
                    .background(Color.red)
                Spacer()
                    .frame(height: geometry.size.height / 2 - 16) // 中央より少し下に配置
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

上記のコードでは、GeometryReaderを使用して、画面のサイズを取得し、その情報を使用してSpacerの高さを動的に設定しています。これにより、"Bottom Content"テキストと"Top Content"テキストがそれぞれ画面の中央から16pt上下に配置されます。

なお、この例では2つのテキストの間に32ptのスペースが確保されていますが、これは2つのパディング（16pt + 16pt）を合計したものです。この値は、必要に応じて適宜調整することができます。

---

## 👤 ユーザー
*2023/7/5 22:19:28*

.frame(height: geometry.size.height / 2 - 16) // 中央より少し下に配置 はどう言う意味？

---

## 🤖 アシスタント
*2023/7/5 22:20:29*

SwiftUIのGeometryReaderは、親ビューのサイズと座標空間を提供します。これにより、子ビューのレイアウトを動的に調整することが可能になります。GeometryReader内部で利用可能なプロパティは次のとおりです：

- size: 親ビューのサイズを提供します。
- safeAreaInsets: 親ビューの安全エリアインセットを提供します。
- frame(in:): 指定した座標空間に対する親ビューのフレームを提供します。

コード中の `geometry.size.height / 2 - 16` は、GeometryReaderを利用して親ビューの高さの半分から16ポイントを引いた値を示しています。

具体的には：

- `geometry.size.height` は親ビューの高さを取得しています。
- その高さを2で割ることで中央の位置を取得しています（`geometry.size.height / 2`）。
- そして、その中央の位置からさらに16ポイント引くことで、中央より少し上（または下）の位置を取得しています（`geometry.size.height / 2 - 16`）。

この値をSpacerのフレームの高さとして設定することで、"Top Content"と"Bottom Content"がそれぞれ画面の中央から16pt上下に配置されることを意図しています。

ただし、Spacerは利用可能な全てのスペースを占有するため、単に `Spacer().frame(height: geometry.size.height / 2 - 16)` とするだけでは期待した結果にはなりません。上記の解説はコードの意図を理解するためのもので、実際にはこのアプローチを使って期待したレイアウトを得ることは難しいです。

あなたが望むレイアウトを得るためには、各テキストコンテンツを個別のVStackでラップし、それぞれのVStackにGeometryReaderを使用して動的なパディングを適用する方法があります。この方法を用いると、それぞれのテキストが画面の中央から16pt上下に配置されます。

---

## 👤 ユーザー
*2023/7/5 22:26:51*

参考にして以下のコードを書いたのだけれどもうまくいかなかった

GeometryReader { geometry in
                    VStack {
                        Spacer()
                            .frame(height: geometry.size.height / 2 - 32)
                        
                        HStack {
                            CoreAssets.Image.GazeTrackCalibration.portraitDevice.swiftUIImage
                                .resizable()
                                .scaledToFit()
                                .frame(width: 140, height: 135)
                                .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                                .isHidden(presenter.orientation != .portrait, remove: true)
                            
                            CoreAssets.Image.GazeTrackCalibration.landscapeDevice.swiftUIImage
                                .resizable()
                                .scaledToFit()
                                .frame(width: 140, height: 135)
                                .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                                .isHidden(presenter.orientation != .landscapeRight, remove: true)
                            
                            CoreAssets.Image.GazeTrackCalibration.posture.swiftUIImage
                                .resizable()
                                .scaledToFit()
                                .frame(width: 140, height: 135)
                                .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                        }
                        
                        Spacer()
                            .frame(height: 64) // 上下のテキスト間に32pt x 2 のスペースを確保
                        
                        Text("スマートフォンを顔から30cmほどはなして、\\n画面上の赤い丸を見続けてください")
                            .typographyStyle(.body2)
                            .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                            .multilineTextAlignment(.center)
                        
                        Spacer()
                            .frame(height: geometry.size.height / 2 - 32)
                    }
                }

---

## 🤖 アシスタント
*2023/7/5 22:28:05*

ご提供いただいたコードは全体的に正しいと思われますが、具体的に何が期待通りでないのか明確でないため、一般的なアドバイスをいくつか提供いたします。

1. まず、GeometryReaderが提供する親ビューの高さが予想と異なる場合があります。これは、GeometryReaderが配置される場所によって、親ビューとして扱うビューが異なるためです。そのため、親ビューのサイズが予想より大きい場合、GeometryReaderが全体の親ビューのサイズを取得している可能性があります。

2. Spacerの動作は、そのコンテクストによります。VStack内の他のビューのサイズや配置によっては、期待通りのスペーシングが得られない場合があります。特に.frame(height: ...)で高さを指定した場合、その高さは必ずしも保証されるわけではありません。

3. SwiftUIにおけるビューのレイアウトはしばしば試行錯誤が必要で、微調整が必要な場合があります。そのため、32ポイントのパディングがうまく動作しない場合は、値を少し調整してみると良いかもしれません。

上記を踏まえて、以下のようにコードを修正してみてください：

```swift
GeometryReader { geometry in
    VStack {
        Spacer()
            .frame(height: geometry.size.height / 2 - 16)
        
        HStack {
            // HStack内の要素
        }
        
        Spacer()
            .frame(height: 32) // 上下のテキスト間に32pt x 2 のスペースを確保
        
        Text("スマートフォンを顔から30cmほどはなして、\n画面上の赤い丸を見続けてください")
            .typographyStyle(.body2)
            .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
            .multilineTextAlignment(.center)
        
        Spacer()
            .frame(height: geometry.size.height / 2 - 16)
    }
}
```

これにより、テキストとHStackがそれぞれ中央から16ptずつ離れた位置に配置されるはずです。ただし、実際の結果は使用されるデバイスや親ビューのサイズ、その他の要素のレイアウトにより異なる可能性があるため、必要に応じて値を調整してみてください。

---

## 👤 ユーザー
*2023/7/5 22:28:38*

HStack やTextが想定よりもだいぶ左下にいるように見えるんだ

---

## 🤖 アシスタント
*2023/7/5 22:29:52*

ご提供いただいたコードを見ると、VStackは自動的にビューの高さを調整し、コンテンツを上下に均等に配置しようとしているようです。このため、コンテンツが中央よりも下に見える可能性があります。

これを解決するためには、まずVStack内部の要素の高さを確認し、それに基づいてSpacerの高さを調整する必要があります。具体的には、HStackとTextの高さの合計を計算し、それを元にしてSpacerの高さを調整します。

そのためには、まずHStackとTextの高さを取得する必要があります。これを行う一つの方法は、それぞれのビューに.frame(height: ...)を適用して高さを固定することです。たとえば、以下のようにすることができます：

```swift
GeometryReader { geometry in
    VStack {
        Spacer()
            .frame(height: (geometry.size.height - (hStackHeight + textHeight + spaceHeight)) / 2)
        
        HStack {
            // HStack内の要素
        }
        .frame(height: hStackHeight) // HStackの高さを固定
        
        Spacer()
            .frame(height: spaceHeight) // 上下のテキスト間にスペースを確保
        
        Text("スマートフォンを顔から30cmほどはなして、\n画面上の赤い丸を見続けてください")
            .typographyStyle(.body2)
            .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
            .multilineTextAlignment(.center)
            .frame(height: textHeight) // Textの高さを固定
        
        Spacer()
            .frame(height: (geometry.size.height - (hStackHeight + textHeight + spaceHeight)) / 2)
    }
}
```

ただし、このコードではhStackHeight, textHeight, spaceHeightはそれぞれのビューの高さを表す値であり、事前に計算または固定された値である必要があります。

なお、このアプローチは完全な解決策ではないかもしれません。SwiftUIのレイアウトシステムは高度に動的であり、特定のコンポーネントの高さを正確に計算することは難しい場合があります。したがって、この解決策は試行錯誤が必要であり、完全な解決策ではないかもしれません。

理想的な解決策を見つけるためには、アプリケーションの具体的なレイアウト要件と、利用可能なデバイスの特性を詳細に理解することが必要です。この情報に基づいて、適切なレイアウト戦略を選

---

## 👤 ユーザー
*2023/7/5 22:29:57*

public struct GazeTrackCalibrationView: View {
    @StateObject private var presenter: GazeTrackCalibrationPresenter

    public init(
        orientation: AppUIInterfaceOrientation,
        shouldShowCalibrationView: Binding&lt;Bool&gt;,
        gazeCalibrationFinishedStatus: Binding&lt;GazeCalibrationFinishedStatus?&gt;
    ) {
        \_presenter = StateObject(wrappedValue: GazeTrackCalibrationPresenter(
            orientation: orientation,
            shouldShowCalibrationView: shouldShowCalibrationView,
            gazeCalibrationFinishedStatus: gazeCalibrationFinishedStatus
        ))
    }

    public var body: some View {
        ZStack {
            CoreAssets.Color.Neutral.black.swiftUIColor
                .frame(maxWidth: .infinity, maxHeight: .infinity)

            switch presenter.calibrationStatus {
            case .notStarted:
                // Figmaにはないが実装必要そうなので実装した
                closeButton

                GeometryReader { geometry in
                    VStack {
                        Spacer()
                            .frame(height: geometry.size.height / 2 - 32)
                        
                        HStack {
                            CoreAssets.Image.GazeTrackCalibration.portraitDevice.swiftUIImage
                                .resizable()
                                .scaledToFit()
                                .frame(width: 140, height: 135)
                                .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                                .isHidden(presenter.orientation != .portrait, remove: true)
                            
                            CoreAssets.Image.GazeTrackCalibration.landscapeDevice.swiftUIImage
                                .resizable()
                                .scaledToFit()
                                .frame(width: 140, height: 135)
                                .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                                .isHidden(presenter.orientation != .landscapeRight, remove: true)
                            
                            CoreAssets.Image.GazeTrackCalibration.posture.swiftUIImage
                                .resizable()
                                .scaledToFit()
                                .frame(width: 140, height: 135)
                                .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                        }
                        
                        Spacer()
                            .frame(height: 64) // 上下のテキスト間に32pt x 2 のスペースを確保
                        
                        Text("スマートフォンを顔から30cmほどはなして、\\n画面上の赤い丸を見続けてください")
                            .typographyStyle(.body2)
                            .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                            .multilineTextAlignment(.center)
                        
                        Spacer()
                            .frame(height: geometry.size.height / 2 - 32)
                    }
                }
                
                // Figmaにはないが実装必要そうなので実装した
                VStack {
                    Spacer()
                    Button {
                        presenter.calibrationStartButtonTapped()
                    } label: {
                        Text("\\(presenter.isLoading ? "キャリブレーション準備中..." : "キャリブレーションを開始する")")
                    }
                    .buttonStyle(CustomButtonStyle(.primary))
                    .disabled(presenter.isLoading)
                    .padding(.horizontal, 24)
                    .padding(.bottom, 42)
                }

                // キャリブレーション開始前の中央表示用の赤丸
                ProgressCircle()
                    .isHidden(presenter.isLoading)

            case .started:
                ProgressCircle(progressPercentage: presenter.progressPercentage, position: presenter.calibrationPoint)

            case .finished:
                EmptyView()
            case .error:
                // Figmaにはないが実装必要そうなので実装した
                closeButton

                VStack {
                    Text("キャリブレーションエラー")
                        .typographyStyle(.body1)
                        .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
                    Button {
                        presenter.retryButtonTapped()
                    } label: {
                        Text("リトライする")
                    }
                    .buttonStyle(CustomButtonStyle(.tertiary))
                }
            }
        }
        .ignoresSafeArea()
        .navigationBarHidden(true)
        .overlayLoading(isPresented: $presenter.isLoading, allowsGesture: true) // 左上の中断を可能にさせるため
        .appErrorAlert(isPresented: $presenter.shouldShowAlert, appError: presenter.appError)
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}

---

## 🤖 アシスタント
*2023/7/5 22:31:17*

ご提供いただいたコードを見ると、以下のいくつかの要素が中央に配置されているように見えます：

1. プレゼンターのカリブレーションステータスに基づいて表示されるさまざまなビュー。
2. GeometryReaderを使用して、VStack内の要素（画像とテキスト）を動的に配置しています。

ただし、このコードにはさらなる要素が含まれているようで、それがVStack内のレイアウトに影響を与えている可能性があります。具体的には、"キャリブレーションを開始する"ボタンや、キャリブレーション開始前の中央表示用の赤丸、そしてさまざまなカリブレーションステータスに基づいて表示されるビューなどがあります。

これらの要素は、それぞれが親ビュー（この場合はZStack）の高さを使用して位置を決定しています。その結果、VStack内の要素が親ビューの中央に表示されない可能性があります。

この問題を解決するための一つのアプローチは、VStack内の要素と、それ以外の要素との間に明確な区別を設けることです。これは、VStack内の要素を別のビューにラップし、そのビューにGeometryReaderを適用することで達成できます。これにより、VStack内の要素はそのビューの高さを使用して中央に配置され、それ以外の要素は親ビュー（ZStack）の高さを使用して配置されます。

以下に、これを適用した一部のコードを示します：

```swift
GeometryReader { geometry in
    VStack {
        Spacer()
            .frame(height: geometry.size.height / 2 - 32)
        
        HStack {
            // HStack内の要素
        }
        
        Spacer()
            .frame(height: 64) // 上下のテキスト間に32pt x 2 のスペースを確保
        
        Text("スマートフォンを顔から30cmほどはなして、\n画面上の赤い丸を見続けてください")
            .typographyStyle(.body2)
            .foregroundColor(CoreAssets.Color.Neutral.white.swiftUIColor)
            .multilineTextAlignment(.center)
        
        Spacer()
            .frame(height: geometry.size.height / 2 - 32)
    }
}
.frame(maxHeight: .infinity)
.zIndex(1)
```

上記のコードでは、VStackは新たなビューにラップされ、そのビューは.maxHeight(.infinity)を使用して親ビュー（ZStack）の全高を占めるように設定されています。また、.zIndex(1)が適用されているため、V

---
