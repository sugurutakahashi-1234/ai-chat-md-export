# NSError初期化の問題解決。

日付: 2023-08-05

---

## 👤 ユーザー
*2023/8/5 21:32:29*

というエラーが起こった。

public enum AppError: LocalizedError {}

extension AppError: Identifiable {
    public var id: String {
        String(describing: self)
    }
}

[NSError init] called; this results in an invalid NSError instance. It will raise an exception in a future release. Please call errorWithDomain:code:userInfo: or initWithDomain:code:userInfo:. This message shown only once.

---

## 🤖 アシスタント
*2023/8/5 21:32:44*

エラーメッセージから、`NSError` の初期化方法に問題があるようです。

Objective-Cの`NSError`は、Swiftから利用する際に特定の方法で初期化する必要があります。提示されたエラーメッセージに従って、`NSError`を直接初期化するのではなく、`errorWithDomain:code:userInfo:`または`initWithDomain:code:userInfo:`を使って初期化してみてください。

`AppError`として定義されたenumを使用してNSErrorを作成する場合、以下のように書くことができます。

```swift
extension AppError {
    func toNSError() -> NSError {
        return NSError(domain: "com.example.app", code: 0, userInfo: [NSLocalizedDescriptionKey: String(describing: self)])
    }
}
```

このコードは、エラーのドメイン、コード、そしてエラーの説明を`NSError`オブジェクトに変換します。ドメインとコードはエラーを識別するために使用され、適切な値に設定することが必要です。

---

## 👤 ユーザー
*2023/8/5 21:33:06*

String(describing: self) でそのエラーが発生したんだ。

---

## 🤖 アシスタント
*2023/8/5 21:33:28*

ああ、理解しました。Swiftのエラーの`String(describing:)`を使用して`NSError`の`userInfo`ディクショナリに値を渡そうとしているのが問題のようですね。

`NSError`の初期化時に必要な情報は、通常、エラーの説明、失敗した理由、回復の提案などが含まれます。この情報は通常、文字列として`userInfo`ディクショナリに追加されます。しかし、`String(describing: self)`は`self`の全てのプロパティを文字列として返すため、適切な形式でない場合があるのかもしれません。

解決策の一つとして、`AppError` enumに具体的なエラーメッセージを提供するプロパティを追加するとよいでしょう。例:

```swift
public enum AppError: LocalizedError {
    case someError

    var localizedDescription: String {
        switch self {
        case .someError:
            return "ここに具体的なエラーメッセージを書く"
        }
    }
}

extension AppError {
    func toNSError() -> NSError {
        return NSError(domain: "com.example.app", code: 0, userInfo: [NSLocalizedDescriptionKey: localizedDescription])
    }
}
```

これにより、各エラーに対して具体的なエラーメッセージを提供できます。`localizedDescription`の部分はエラーに応じた適切なメッセージを返すようにカスタマイズできます。

---
