# 画像選択UI修正

Date: 2025-01-16

---

## 👤 User
*2025-01-16 18:08:00*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-F9tQnvqVjQnY7qDfwQekTQ",
  "size_bytes": 310843,
  "width": 402,
  "height": 824,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
Scaffold の body を添付した画像のように修正してほしい
weaveTargetSpot.photoUrl は インターネットのhttps でアップロードされている写真で、shotPhoto.path は端末で撮った写真である。
タップされている方を選択されている画像として、画面の上部に大きく配置してほしい。
weaveTargetSpot.photoUrlの画像とshotPhoto.path はその下に配置して、選択されている画像はそれがわかるようにボーダーをつけてほしい
管理が難しかったら、weaveTargetSpot.photoUrl と shotPhoto.path を抽象化するような class などを定義してもいい。不要だったら定義しなくてもいい。


import 'dart:io';
import 'package:dio/dio.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:http_parser/http_parser.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/photos/upload_photo.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/weave_spot.dart';
import 'package:snpit_guild_app/presentation/providers/on_pop_snap_confirm.dart';
import 'package:snpit_guild_app/presentation/providers/shot_photo.dart';
import 'package:snpit_guild_app/presentation/providers/weave_target_spot.dart';

class SnapConfirmPage extends HookConsumerWidget {
  const SnapConfirmPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final shotPhoto = ref.watch(shotPhotoNotifierProvider);
    final weaveTargetSpot = ref.watch(weaveTargetSpotNotifierProvider);

    Future&lt;void&gt; onTapCancel() async {
      ref.read(shotPhotoNotifierProvider.notifier).clear();
      ref.read(onPopSnapConfirmNotifierProvider.notifier).trigger();
      context.pop();
    }

    Future&lt;void&gt; onTapGotIt() async {
      final weaveTargetSpot = ref.read(weaveTargetSpotNotifierProvider);
      final shotPhoto = ref.read(shotPhotoNotifierProvider);

      if (weaveTargetSpot == null) {
        debugPrint('Weave target spot ID is null');
        return;
      }

      if (shotPhoto == null) {
        debugPrint('No photo');
        return;
      }
      final file = File(shotPhoto.path);
      if (!file.existsSync()) {
        debugPrint('File does not exist');
        return;
      }

      final fileBytes = await file.readAsBytes();

      final multipartFile = MultipartFile.fromBytes(
        fileBytes,
        filename: 'image.jpeg',
        contentType: MediaType.parse('image/jpeg'),
      );

      final uploadPhotoNotifier =
          ref.read(uploadPhotoNotifierProvider.notifier);
      final weaveSpotNotifier = ref.read(weaveSpotNotifierProvider.notifier);
      try {
        final uploadedPhoto = await uploadPhotoNotifier.uploadPhoto(
          multipartFile,
          shotPhoto.location,
        );

        await weaveSpotNotifier.weaveSpot(
          weaveTargetSpot.spotId,
          shotPhoto.location,
          uploadedPhoto.url,
        );
        debugPrint('Weave Spot completed successfully');
        if (context.mounted) {
          // MapPage まで戻る
          Navigator.of(context).popUntil((route) =&gt; route.isFirst);
        }
      } on Exception catch (e, stackTrace) {
        debugPrint('Error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Snap'),
        automaticallyImplyLeading: false,
      ),
      body: Column(
        children: [
          weaveTargetSpot != null
              ? Image.network(
                  weaveTargetSpot.photoUrl,
                  width: 64,
                  height: 64,
                  fit: BoxFit.cover,
                  errorBuilder: (context, error, stackTrace) {
                    return const Text('No spot photo');
                  },
                )
              : const Text('No spot photo'),
          shotPhoto != null
              ? Image.file(
                  File(shotPhoto.path),
                  width: 64,
                  height: 64,
                  fit: BoxFit.cover,
                )
              : const Text('No shot photo'),
        ],
      ),
      bottomNavigationBar: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: onTapCancel,
                  child: const Text('Cancel'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton(
                  onPressed: () async {
                    await onTapGotIt();
                  },
                  child: const Text('Got it'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

---

## 🤖 Assistant
*2025-01-16 18:09:34*

下記のように実装例を修正すると、**上部に選択中の画像を大きく表示**し、下部に2つのサムネイルを並べて、**選択されている画像にはボーダー(枠線)**がつくようにできます。サンプルとして `selectedIndex` を State で持ち、どちらの画像が選択されているかを管理しています。`weaveTargetSpot.photoUrl` と `shotPhoto.path` をラップするクラスを作ってもいいですが、シンプルさのためにここでは直接扱っています。

```dart
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:http_parser/http_parser.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/photos/upload_photo.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/weave_spot.dart';
import 'package:snpit_guild_app/presentation/providers/on_pop_snap_confirm.dart';
import 'package:snpit_guild_app/presentation/providers/shot_photo.dart';
import 'package:snpit_guild_app/presentation/providers/weave_target_spot.dart';

class SnapConfirmPage extends HookConsumerWidget {
  const SnapConfirmPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final shotPhoto = ref.watch(shotPhotoNotifierProvider);
    final weaveTargetSpot = ref.watch(weaveTargetSpotNotifierProvider);

    // 0: weaveTargetSpot.photoUrl, 1: shotPhoto.path という想定で管理する
    final selectedIndex = useState(0);

    Future<void> onTapCancel() async {
      ref.read(shotPhotoNotifierProvider.notifier).clear();
      ref.read(onPopSnapConfirmNotifierProvider.notifier).trigger();
      context.pop();
    }

    Future<void> onTapGotIt() async {
      final weaveTargetSpot = ref.read(weaveTargetSpotNotifierProvider);
      final shotPhoto = ref.read(shotPhotoNotifierProvider);

      if (weaveTargetSpot == null) {
        debugPrint('Weave target spot ID is null');
        return;
      }

      if (shotPhoto == null) {
        debugPrint('No photo');
        return;
      }
      final file = File(shotPhoto.path);
      if (!file.existsSync()) {
        debugPrint('File does not exist');
        return;
      }

      final fileBytes = await file.readAsBytes();

      final multipartFile = MultipartFile.fromBytes(
        fileBytes,
        filename: 'image.jpeg',
        contentType: MediaType.parse('image/jpeg'),
      );

      final uploadPhotoNotifier =
          ref.read(uploadPhotoNotifierProvider.notifier);
      final weaveSpotNotifier = ref.read(weaveSpotNotifierProvider.notifier);
      try {
        final uploadedPhoto = await uploadPhotoNotifier.uploadPhoto(
          multipartFile,
          shotPhoto.location,
        );

        await weaveSpotNotifier.weaveSpot(
          weaveTargetSpot.spotId,
          shotPhoto.location,
          uploadedPhoto.url,
        );
        debugPrint('Weave Spot completed successfully');
        if (context.mounted) {
          // MapPage まで戻る
          Navigator.of(context).popUntil((route) => route.isFirst);
        }
      } on Exception catch (e, stackTrace) {
        debugPrint('Error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }

    // 選択中の画像ウィジェット
    Widget buildSelectedImage() {
      // selectedIndex が 0 → weaveTargetSpot.photoUrl
      //                1 → shotPhoto.path
      if (selectedIndex.value == 0) {
        // weaveTargetSpot が null、あるいは photoUrl が無かった場合のハンドリング
        if (weaveTargetSpot == null || weaveTargetSpot.photoUrl.isEmpty) {
          return const Center(child: Text('No spot photo'));
        }
        return Image.network(
          weaveTargetSpot.photoUrl,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            return const Center(child: Text('No spot photo'));
          },
        );
      } else {
        // shotPhoto が null の場合のハンドリング
        if (shotPhoto == null) {
          return const Center(child: Text('No shot photo'));
        }
        return Image.file(
          File(shotPhoto.path),
          fit: BoxFit.cover,
        );
      }
    }

    // サムネイル用のウィジェット生成
    Widget buildThumbnail({
      required Widget child,
      required bool isSelected,
      required VoidCallback onTap,
    }) {
      return InkWell(
        onTap: onTap,
        child: Container(
          width: 80,
          height: 80,
          margin: const EdgeInsets.symmetric(horizontal: 8),
          decoration: BoxDecoration(
            border: Border.all(
              color: isSelected ? Colors.blue : Colors.transparent,
              width: 3,
            ),
          ),
          child: child,
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Snap'),
        automaticallyImplyLeading: false,
      ),
      body: Column(
        children: [
          // 選択されている画像を大きく表示
          Expanded(
            child: SizedBox(
              width: double.infinity,
              child: buildSelectedImage(),
            ),
          ),
          const SizedBox(height: 16),
          // 下にサムネイルを2つ並べる
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // weaveTargetSpot.photoUrl
              buildThumbnail(
                child: weaveTargetSpot != null && weaveTargetSpot.photoUrl.isNotEmpty
                    ? Image.network(
                        weaveTargetSpot.photoUrl,
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) {
                          return const Center(child: Text('No spot photo'));
                        },
                      )
                    : const Center(child: Text('No spot photo')),
                isSelected: selectedIndex.value == 0,
                onTap: () => selectedIndex.value = 0,
              ),

              // shotPhoto.path
              buildThumbnail(
                child: shotPhoto != null
                    ? Image.file(
                        File(shotPhoto.path),
                        fit: BoxFit.cover,
                      )
                    : const Center(child: Text('No shot photo')),
                isSelected: selectedIndex.value == 1,
                onTap: () => selectedIndex.value = 1,
              ),
            ],
          ),
          const SizedBox(height: 16),
        ],
      ),
      bottomNavigationBar: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: onTapCancel,
                  child: const Text('Cancel'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton(
                  onPressed: () async {
                    await onTapGotIt();
                  },
                  child: const Text('Got it'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### ポイント
1. **selectedIndex**  
   - 0 なら `weaveTargetSpot.photoUrl` を、1 なら `shotPhoto.path` を表示するように管理。  
2. **上部の大きな画像**  
   - 選択されている方を `Expanded` ウィジェット内で横幅いっぱいに表示。  
3. **下部のサムネイル**  
   - `Row` で 2 つ並べ、タップされたら `selectedIndex` を変更して上部の表示を切り替え。  
   - 選択中の画像には `isSelected` を見て `Border.all(color: Colors.blue, width: 3)` を設定。  
4. **ネットワーク画像とファイル画像の両方を扱う**  
   - `Image.network()` と `Image.file()` でそれぞれエラーハンドリングなどを行う。

---

## 👤 User
*2025-01-16 18:36:21*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-8yZD5tEuc1LchuspwHmXbs",
  "size_bytes": 1964601,
  "width": 925,
  "height": 2048,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
色々修正して、以下の形になった。 選択している画像の上の部分であるが、画像を正方形の4ptの角丸で表示したい。
今のままだと添付した画像のように 選択している画像が縦長になってしまう。修正してほしい。

 import 'dart:io';
import 'package:dio/dio.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:http_parser/http_parser.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/photos/upload_photo.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/weave_spot.dart';
import 'package:snpit_guild_app/presentation/providers/on_pop_snap_confirm.dart';
import 'package:snpit_guild_app/presentation/providers/shot_photo.dart';
import 'package:snpit_guild_app/presentation/providers/weave_target_spot.dart';

class SnapConfirmPage extends HookConsumerWidget {
  const SnapConfirmPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final shotPhoto = ref.watch(shotPhotoNotifierProvider);
    final weaveTargetSpot = ref.watch(weaveTargetSpotNotifierProvider);

    // 0: weaveTargetSpot.photoUrl, 1: shotPhoto.path という想定で管理する
    final selectedIndex = useState(0);

    Future&lt;void&gt; onTapCancel() async {
      ref.read(shotPhotoNotifierProvider.notifier).clear();
      ref.read(onPopSnapConfirmNotifierProvider.notifier).trigger();
      context.pop();
    }

    Future&lt;void&gt; onTapGotIt() async {
      final weaveTargetSpot = ref.read(weaveTargetSpotNotifierProvider);
      final shotPhoto = ref.read(shotPhotoNotifierProvider);

      if (weaveTargetSpot == null) {
        debugPrint('Weave target spot ID is null');
        return;
      }

      if (shotPhoto == null) {
        debugPrint('No photo');
        return;
      }
      final file = File(shotPhoto.path);
      if (!file.existsSync()) {
        debugPrint('File does not exist');
        return;
      }

      final fileBytes = await file.readAsBytes();

      final multipartFile = MultipartFile.fromBytes(
        fileBytes,
        filename: 'image.jpeg',
        contentType: MediaType.parse('image/jpeg'),
      );

      final uploadPhotoNotifier =
          ref.read(uploadPhotoNotifierProvider.notifier);
      final weaveSpotNotifier = ref.read(weaveSpotNotifierProvider.notifier);
      try {
        final uploadedPhoto = await uploadPhotoNotifier.uploadPhoto(
          multipartFile,
          shotPhoto.location,
        );

        await weaveSpotNotifier.weaveSpot(
          weaveTargetSpot.spotId,
          shotPhoto.location,
          uploadedPhoto.url,
        );
        debugPrint('Weave Spot completed successfully');
        if (context.mounted) {
          // MapPage まで戻る
          Navigator.of(context).popUntil((route) =&gt; route.isFirst);
        }
      } on Exception catch (e, stackTrace) {
        debugPrint('Error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }

    // 選択中の画像ウィジェット
    Widget buildSelectedImage() {
      // 0 → weaveTargetSpot.photoUrl
      // 1 → shotPhoto.path
      if (selectedIndex.value == 0) {
        if (weaveTargetSpot == null) {
          return const Center(child: Text('No spot photo'));
        }
        return Image.network(
          weaveTargetSpot.photoUrl,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            return const Center(child: Text('No spot photo'));
          },
        );
      } else if (selectedIndex.value == 1) {
        if (shotPhoto == null) {
          return const Center(child: Text('No shot photo'));
        }
        return Image.file(
          File(shotPhoto.path),
          fit: BoxFit.cover,
        );
      } else {
        return const Center(child: Text('No photo'));
      }
    }

    // サムネイル用のウィジェット生成
    Widget buildThumbnail({
      required Widget child,
      required bool isSelected,
      required VoidCallback onTap,
    }) {
      return InkWell(
        onTap: onTap,
        child: SizedBox(
          width: 80,
          height: 80,
          // decoration: BoxDecoration(
          //   border: Border.all(
          //     color: isSelected ? ColorToken.primary : Colors.transparent,
          //     width: 3,
          //   ),
          // ),
          child: child,
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Snap'),
        automaticallyImplyLeading: false,
      ),
      body: Padding(
        padding: const EdgeInsets.all(8),
        child: Column(
          children: [
            Expanded(
              child: SizedBox(
                width: double.infinity,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(4),
                  child: AspectRatio(
                    aspectRatio: 1,
                    child: buildSelectedImage(),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                // Weave Target Spot Photo
                buildThumbnail(
                  child: weaveTargetSpot != null &&
                          weaveTargetSpot.photoUrl.isNotEmpty
                      ? Image.network(
                          weaveTargetSpot.photoUrl,
                          fit: BoxFit.cover,
                          errorBuilder: (context, error, stackTrace) {
                            return const Center(child: Text('No Photo'));
                          },
                        )
                      : const Center(child: Text('No spot photo')),
                  isSelected: selectedIndex.value == 0,
                  onTap: () =&gt; selectedIndex.value = 0,
                ),
                const SizedBox(width: 16),
                // Shot Photo
                buildThumbnail(
                  child: shotPhoto != null
                      ? Image.file(
                          File(shotPhoto.path),
                          fit: BoxFit.cover,
                        )
                      : const Center(child: Text('No shot photo')),
                  isSelected: selectedIndex.value == 1,
                  onTap: () =&gt; selectedIndex.value = 1,
                ),
              ],
            ),
            const SizedBox(height: 16),
          ],
        ),
      ),
      bottomNavigationBar: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: onTapCancel,
                  child: const Text('Cancel'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton(
                  onPressed: () async {
                    await onTapGotIt();
                  },
                  child: const Text('Got it'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

---

## 🤖 Assistant
*2025-01-16 18:36:33*

To make the selected image a square with 4pt rounded corners, the provided `ClipRRect` and `AspectRatio` usage is correct, but it seems you are encountering an issue with aspect ratio not being applied effectively. I'll adjust the implementation to ensure proper scaling and alignment.

Here’s the updated code for displaying the selected image as a square with rounded corners:

### Changes Made:
1. **`AspectRatio`**: Ensures the image maintains a square aspect ratio.
2. **`ClipRRect`**: Used for the rounded corners (4pt radius).
3. **`BoxFit.cover`**: Ensures the image fills the square area while preserving its aspect ratio.

### Updated `buildSelectedImage` Implementation

```dart
Widget buildSelectedImage() {
  // Determine which image to display
  Widget imageWidget;
  if (selectedIndex.value == 0) {
    if (weaveTargetSpot == null || weaveTargetSpot.photoUrl.isEmpty) {
      return const Center(child: Text('No spot photo'));
    }
    imageWidget = Image.network(
      weaveTargetSpot.photoUrl,
      fit: BoxFit

---
