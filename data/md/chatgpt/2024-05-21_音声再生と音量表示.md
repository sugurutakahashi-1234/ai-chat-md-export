# éŸ³å£°å†ç”Ÿã¨éŸ³é‡è¡¨ç¤º

Date: 2024-05-21

---

## ğŸ‘¤ User
*2024-05-21 18:29:38*

Swiftã§éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®éŸ³é‡ã‚’å†ç”Ÿã—ãªãŒã‚‰è¡¨ç¾ã—ãŸã„

---

## ğŸ¤– Assistant
*2024-05-21 18:30:16*

Swiftã§éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†ç”Ÿã—ãªãŒã‚‰éŸ³é‡ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã¯ã€`AVAudioPlayer`ã‚’ä½¿ç”¨ã—ã¦éŸ³å£°ã‚’å†ç”Ÿã—ã€ãã®éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—ã—ã¦è¡¨ç¤ºã™ã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã«ã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®å†ç”Ÿã¨éŸ³é‡ãƒ¬ãƒ™ãƒ«ã®å–å¾—ã‚’è¡Œã†åŸºæœ¬çš„ãªã‚³ãƒ¼ãƒ‰ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

ã¾ãšã€å¿…è¦ãªãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚

```swift
import UIKit
import AVFoundation
```

æ¬¡ã«ã€`AVAudioPlayer`ã‚’ä½¿ã£ã¦éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†ç”Ÿã—ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§å–å¾—ã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¾ã™ã€‚

```swift
class AudioPlayerViewController: UIViewController, AVAudioPlayerDelegate {
    var audioPlayer: AVAudioPlayer?
    var timer: Timer?
    
    let volumeLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.font = UIFont.systemFont(ofSize: 24)
        label.textColor = .black
        return label
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        setupUI()
        setupAudioPlayer()
    }
    
    func setupUI() {
        view.addSubview(volumeLabel)
        NSLayoutConstraint.activate([
            volumeLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            volumeLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor)
        ])
    }
    
    func setupAudioPlayer() {
        guard let url = Bundle.main.url(forResource: "audio", withExtension: "mp3") else {
            print("Audio file not found")
            return
        }
        
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.delegate = self
            audioPlayer?.isMeteringEnabled = true
            audioPlayer?.prepareToPlay()
            audioPlayer?.play()
            
            startVolumeMetering()
        } catch {
            print("Audio player error: \(error.localizedDescription)")
        }
    }
    
    func startVolumeMetering() {
        timer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(updateVolumeMeter), userInfo: nil, repeats: true)
    }
    
    @objc func updateVolumeMeter() {
        guard let audioPlayer = audioPlayer else { return }
        audioPlayer.updateMeters()
        
        let averagePower = audioPlayer.averagePower(forChannel: 0)
        let peakPower = audioPlayer.peakPower(forChannel: 0)
        let normalizedAveragePower = normalizedPowerLevel(fromDecibels: averagePower)
        let normalizedPeakPower = normalizedPowerLevel(fromDecibels: peakPower)
        
        volumeLabel.text = String(format: "Avg: %.2f, Peak: %.2f", normalizedAveragePower, normalizedPeakPower)
    }
    
    func normalizedPowerLevel(fromDecibels decibels: Float) -> Float {
        if decibels < -80 {
            return 0.0
        } else if decibels >= 0 {
            return 1.0
        } else {
            return (pow(10.0, (0.05 * decibels)) * 2.0).clamped(to: 0...1)
        }
    }
}

extension Float {
    func clamped(to range: ClosedRange<Float>) -> Float {
        return min(max(self, range.lowerBound), range.upperBound)
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`AVAudioPlayer`ã‚’ä½¿ç”¨ã—ã¦éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†ç”Ÿã—ã€`Timer`ã‚’ä½¿ã£ã¦0.1ç§’ã”ã¨ã«éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—ã—ã¦è¡¨ç¤ºã—ã¾ã™ã€‚`updateVolumeMeter`ãƒ¡ã‚½ãƒƒãƒ‰ã§ã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®å¹³å‡ãƒ‘ãƒ¯ãƒ¼ã¨ãƒ”ãƒ¼ã‚¯ãƒ‘ãƒ¯ãƒ¼ã‚’å–å¾—ã—ã€ãã‚Œã‚‰ã‚’æ¨™æº–åŒ–ã—ã¦ãƒ©ãƒ™ãƒ«ã«è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚

ã“ã®ä¾‹ã§ã¯ã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ã‚’ `"audio.mp3"` ã¨ã—ã¦ãŠã‚Šã€ã‚¢ãƒ—ãƒªã®ãƒãƒ³ãƒ‰ãƒ«ã«å«ã¾ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ã¨æ‹¡å¼µå­ã‚’é©å®œå¤‰æ›´ã—ã¦ãã ã•ã„ã€‚

---

## ğŸ‘¤ User
*2024-05-21 18:32:28*

ã¡ãªã¿ã«æœ€å¤§ã¯ã„ãã¤ã§æœ€å°ã¯ã„ãã¤ãªã®ã‹ï¼Ÿ

---

## ğŸ¤– Assistant
*2024-05-21 18:33:05*

`AVAudioPlayer`ã®ãƒ¡ãƒ¼ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹éš›ã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹éŸ³é‡ãƒ¬ãƒ™ãƒ«ã«ã¯ç¯„å›²ãŒã‚ã‚Šã¾ã™ã€‚ãƒ‡ã‚·ãƒ™ãƒ«(dB)å€¤ã¯ã€éŸ³ã®å¤§ãã•ã‚’æ¸¬å®šã™ã‚‹ãŸã‚ã®å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ã§ã‚ã‚Šã€æ¬¡ã®ã‚ˆã†ãªç¯„å›²ã«ãªã‚Šã¾ã™ã€‚

- **æœ€å°å€¤**: -160 dB
- **æœ€å¤§å€¤**: 0 dB

0 dBã¯æœ€ã‚‚å¤§ããªéŸ³é‡ã‚’æ„å‘³ã—ã€-160 dBã¯éå¸¸ã«å°ã•ãªéŸ³é‡ã‚’æ„å‘³ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å€¤ã‚’æ¨™æº–åŒ–ã™ã‚‹å ´åˆã€é€šå¸¸ã¯0ã‹ã‚‰1ã®ç¯„å›²ã«å¤‰æ›ã—ã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€å…ˆã»ã©ã®ã‚³ãƒ¼ãƒ‰ã«ãŠã„ã¦ã“ã®æƒ…å ±ã‚’åæ˜ ã•ã›ãŸä¿®æ­£ä¾‹ã§ã™ã€‚

```swift
import UIKit
import AVFoundation

class AudioPlayerViewController: UIViewController, AVAudioPlayerDelegate {
    var audioPlayer: AVAudioPlayer?
    var timer: Timer?
    
    let volumeLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.font = UIFont.systemFont(ofSize: 24)
        label.textColor = .black
        return label
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        setupUI()
        setupAudioPlayer()
    }
    
    func setupUI() {
        view.addSubview(volumeLabel)
        NSLayoutConstraint.activate([
            volumeLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            volumeLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor)
        ])
    }
    
    func setupAudioPlayer() {
        guard let url = Bundle.main.url(forResource: "audio", withExtension: "mp3") else {
            print("Audio file not found")
            return
        }
        
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.delegate = self
            audioPlayer?.isMeteringEnabled = true
            audioPlayer?.prepareToPlay()
            audioPlayer?.play()
            
            startVolumeMetering()
        } catch {
            print("Audio player error: \(error.localizedDescription)")
        }
    }
    
    func startVolumeMetering() {
        timer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(updateVolumeMeter), userInfo: nil, repeats: true)
    }
    
    @objc func updateVolumeMeter() {
        guard let audioPlayer = audioPlayer else { return }
        audioPlayer.updateMeters()
        
        let averagePower = audioPlayer.averagePower(forChannel: 0)
        let peakPower = audioPlayer.peakPower(forChannel: 0)
        let normalizedAveragePower = normalizedPowerLevel(fromDecibels: averagePower)
        let normalizedPeakPower = normalizedPowerLevel(fromDecibels: peakPower)
        
        volumeLabel.text = String(format: "Avg: %.2f, Peak: %.2f", normalizedAveragePower, normalizedPeakPower)
    }
    
    func normalizedPowerLevel(fromDecibels decibels: Float) -> Float {
        if decibels < -160 {
            return 0.0
        } else if decibels >= 0 {
            return 1.0
        } else {
            return pow(10.0, (0.05 * decibels))
        }
    }
}
```

ã“ã®ä¿®æ­£ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã§ã¯ã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã®ç¯„å›²ã‚’è€ƒæ…®ã—ã€`normalizedPowerLevel(fromDecibels:)`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’0ã‹ã‚‰1ã®ç¯„å›²ã«å¤‰æ›ã—ã¾ã™ã€‚éŸ³é‡ãƒ¬ãƒ™ãƒ«ã¯ã“ã‚Œã§æ¨™æº–åŒ–ã•ã‚Œã€0.0ãŒæœ€å°éŸ³é‡ï¼ˆ-160 dBï¼‰ã€1.0ãŒæœ€å¤§éŸ³é‡ï¼ˆ0 dBï¼‰ã‚’è¡¨ã—ã¾ã™ã€‚

---

## ğŸ‘¤ User
*2024-05-21 18:33:22*

ã“ã®è¡¨ç¾ã¯ä¸€èˆ¬çš„ãªã®ã‹ï¼Ÿ

---

## ğŸ¤– Assistant
*2024-05-21 18:33:55*

éŸ³å£°ãƒ¡ãƒ¼ã‚¿ãƒªãƒ³ã‚°ã®ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’0ã‹ã‚‰1ã®ç¯„å›²ã«æ­£è¦åŒ–ã™ã‚‹æ–¹æ³•ã¯ã€ç‰¹ã«è¦–è¦šçš„ã«éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¡¨ç¾ã™ã‚‹å ´åˆã«ã¯ä¸€èˆ¬çš„ã§ã™ã€‚ã“ã®æ–¹æ³•ã¯ã€éŸ³å£°ã®ãƒ€ã‚¤ãƒŠãƒŸã‚¯ã‚¹ã‚’ç°¡å˜ã«è¦–è¦šåŒ–ã—ã€UIã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç›´æ„Ÿçš„ã«ç†è§£ã•ã›ã‚‹ãŸã‚ã«åºƒãä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

ä»¥ä¸‹ã«ã€éŸ³å£°ãƒ¡ãƒ¼ã‚¿ãƒªãƒ³ã‚°ã®ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’æ­£è¦åŒ–ã™ã‚‹æ–¹æ³•ã«é–¢ã™ã‚‹ã„ãã¤ã‹ã®ãƒã‚¤ãƒ³ãƒˆã‚’ç¤ºã—ã¾ã™ï¼š

1. **ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã®ç¯„å›²**ï¼š
   - `AVAudioPlayer`ã‚„ä»–ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªAPIã§æ¸¬å®šã•ã‚Œã‚‹ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã¯é€šå¸¸ã€-160 dBã‹ã‚‰0 dBã®ç¯„å›²ã«ãªã‚Šã¾ã™ã€‚
   - 0 dBã¯æœ€ã‚‚å¤§ããªéŸ³é‡ã‚’æ„å‘³ã—ã€-160 dBã¯ã»ã¨ã‚“ã©ç„¡éŸ³ã‚’æ„å‘³ã—ã¾ã™ã€‚

2. **æ­£è¦åŒ–ã®å¿…è¦æ€§**ï¼š
   - ãƒ‡ã‚·ãƒ™ãƒ«ã‚¹ã‚±ãƒ¼ãƒ«ã¯å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ã§ã‚ã‚Šã€äººé–“ã®è´è¦šã®æ„Ÿåº¦ã«è¿‘ã„ã§ã™ã€‚å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ã¯åºƒã„ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãƒ¬ãƒ³ã‚¸ã‚’åŠ¹ç‡çš„ã«è¡¨ç¾ã§ãã¾ã™ãŒã€è¦–è¦šçš„ã«ç†è§£ã—ã‚„ã™ã„å½¢å¼ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
   - æ­£è¦åŒ–ã™ã‚‹ã“ã¨ã§ã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’ç·šå½¢ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆ0ã‹ã‚‰1ã®ç¯„å›²ï¼‰ã«å¤‰æ›ã—ã€éŸ³é‡ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚„ä»–ã®è¦–è¦šçš„ãªè¡¨ç¤ºã«é©ç”¨ã§ãã¾ã™ã€‚

3. **ä¸€èˆ¬çš„ãªæ­£è¦åŒ–æ‰‹æ³•**ï¼š
   - ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’0ã‹ã‚‰1ã®ç¯„å›²ã«æ­£è¦åŒ–ã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå¯¾æ•°å¤‰æ›ã‚’ç”¨ã„ã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ï¼š

     ```swift
     func normalizedPowerLevel(fromDecibels decibels: Float) -> Float {
         let minDb: Float = -160.0
         let maxDb: Float = 0.0
         
         if decibels < minDb {
             return 0.0
         } else if decibels >= maxDb {
             return 1.0
         } else {
             // ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’0ã‹ã‚‰1ã®ç¯„å›²ã«å¤‰æ›
             return pow(10.0, (0.05 * decibels))
         }
     }
     ```

4. **è¦–è¦šçš„è¡¨ç¾**ï¼š
   - éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¦–è¦šåŒ–ã™ã‚‹ãŸã‚ã«ã€é€²æ—ãƒãƒ¼ã‚„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§éŸ³é‡ã‚’è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
   - æ­£è¦åŒ–ã•ã‚ŒãŸéŸ³é‡å€¤ï¼ˆ0ã‹ã‚‰1ï¼‰ã¯ã€UIè¦ç´ ã®ã‚¹ã‚±ãƒ¼ãƒ«ã¨ã—ã¦ç›´æ¥ä½¿ç”¨ã§ãã¾ã™ã€‚

5. **å®Ÿéš›ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä¾‹**ï¼š
   - ãƒŸãƒ¥ãƒ¼ã‚¸ãƒƒã‚¯ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚¢ãƒ—ãƒªã‚„ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªéŒ²éŸ³ã‚¢ãƒ—ãƒªã§ã€éŸ³é‡ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒãƒˆãƒ©ãƒƒã‚¯ã®éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¦–è¦šçš„ã«è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚
   - ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªç·¨é›†ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã§ã‚‚ã€é¡ä¼¼ã®æ­£è¦åŒ–æ‰‹æ³•ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

ã“ã®æ–¹æ³•ã¯å¤šãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚„ãƒ„ãƒ¼ãƒ«ã§æ¡ç”¨ã•ã‚Œã¦ãŠã‚Šã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã®ç¯„å›²ã‚’è¦–è¦šçš„ã«ç†è§£ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã®åŠ¹æœçš„ãªæ‰‹æ®µã§ã™ã€‚

---

## ğŸ‘¤ User
*2024-05-21 18:36:16*

éŒ²éŸ³ä¸­ã¨å†ç”Ÿä¸­ã®ä¸¡æ–¹ã§0ã‹ã‚‰1ã§è¡¨ã—ãŸéŸ³é‡ã‚’Viewã§è¡¨ç¾ã—ãŸã„

ã„ã„æ„Ÿã˜ã«å…±é€šåŒ–ã§ããªã„ã‹ï¼Ÿ

---

## ğŸ¤– Assistant
*2024-05-21 18:37:06*

éŒ²éŸ³ä¸­ã¨å†ç”Ÿä¸­ã®ä¸¡æ–¹ã§éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’0ã‹ã‚‰1ã®ç¯„å›²ã§è¡¨ã—ã€ãã‚Œã‚’Viewã§è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã€å…±é€šåŒ–ã•ã‚ŒãŸéŸ³é‡ãƒ¡ãƒ¼ã‚¿ãƒªãƒ³ã‚°ã®ä»•çµ„ã¿ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã«ã€`AVAudioRecorder`ã¨`AVAudioPlayer`ã®ä¸¡æ–¹ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®å…±é€šã®ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã€ãã‚Œã‚’ä½¿ã£ã¦éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

ã¾ãšã€éŸ³é‡ãƒ¡ãƒ¼ã‚¿ãƒªãƒ³ã‚°ã®ãŸã‚ã®å…±é€šã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¾ã™ã€‚

```swift
import UIKit
import AVFoundation

class AudioMetering {
    private var audioRecorder: AVAudioRecorder?
    private var audioPlayer: AVAudioPlayer?
    private var timer: Timer?

    var meteringUpdateHandler: ((Float) -> Void)?

    func startRecording(withURL url: URL) {
        let settings: [String: Any] = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: url, settings: settings)
            audioRecorder?.isMeteringEnabled = true
            audioRecorder?.prepareToRecord()
            audioRecorder?.record()
            startMetering()
        } catch {
            print("Audio recorder error: \(error.localizedDescription)")
        }
    }

    func stopRecording() {
        audioRecorder?.stop()
        stopMetering()
    }

    func startPlaying(withURL url: URL) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.isMeteringEnabled = true
            audioPlayer?.prepareToPlay()
            audioPlayer?.play()
            startMetering()
        } catch {
            print("Audio player error: \(error.localizedDescription)")
        }
    }

    func stopPlaying() {
        audioPlayer?.stop()
        stopMetering()
    }

    private func startMetering() {
        timer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(updateMeter), userInfo: nil, repeats: true)
    }

    private func stopMetering() {
        timer?.invalidate()
    }

    @objc private func updateMeter() {
        if let recorder = audioRecorder {
            recorder.updateMeters()
            let normalizedPower = normalizedPowerLevel(fromDecibels: recorder.averagePower(forChannel: 0))
            meteringUpdateHandler?(normalizedPower)
        } else if let player = audioPlayer {
            player.updateMeters()
            let normalizedPower = normalizedPowerLevel(fromDecibels: player.averagePower(forChannel: 0))
            meteringUpdateHandler?(normalizedPower)
        }
    }

    private func normalizedPowerLevel(fromDecibels decibels: Float) -> Float {
        let minDb: Float = -160.0
        let maxDb: Float = 0.0

        if decibels < minDb {
            return 0.0
        } else if decibels >= maxDb {
            return 1.0
        } else {
            return pow(10.0, (0.05 * decibels))
        }
    }
}
```

æ¬¡ã«ã€`UIViewController`ã§éŒ²éŸ³ã¨å†ç”Ÿã‚’åˆ¶å¾¡ã—ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
import UIKit
import AVFoundation

class AudioViewController: UIViewController {
    let audioMetering = AudioMetering()
    var isRecording = false

    let volumeLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.font = UIFont.systemFont(ofSize: 24)
        label.textColor = .black
        return label
    }()

    let toggleButton: UIButton = {
        let button = UIButton(type: .system)
        button.translatesAutoresizingMaskIntoConstraints = false
        button.setTitle("Start Recording", for: .normal)
        button.addTarget(self, action: #selector(toggleRecording), for: .touchUpInside)
        return button
    }()

    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        setupUI()

        audioMetering.meteringUpdateHandler = { [weak self] volume in
            DispatchQueue.main.async {
                self?.volumeLabel.text = String(format: "Volume: %.2f", volume)
            }
        }
    }

    func setupUI() {
        view.addSubview(volumeLabel)
        view.addSubview(toggleButton)
        NSLayoutConstraint.activate([
            volumeLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            volumeLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor),
            toggleButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            toggleButton.topAnchor.constraint(equalTo: volumeLabel.bottomAnchor, constant: 20)
        ])
    }

    @objc func toggleRecording() {
        if isRecording {
            audioMetering.stopRecording()
            toggleButton.setTitle("Start Recording", for: .normal)
        } else {
            let url = FileManager.default.temporaryDirectory.appendingPathComponent("recording.m4a")
            audioMetering.startRecording(withURL: url)
            toggleButton.setTitle("Stop Recording", for: .normal)
        }
        isRecording.toggle()
    }

    @objc func startPlaying() {
        let url = FileManager.default.temporaryDirectory.appendingPathComponent("recording.m4a")
        audioMetering.startPlaying(withURL: url)
    }

    @objc func stopPlaying() {
        audioMetering.stopPlaying()
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`AudioMetering`ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦éŒ²éŸ³ã¨å†ç”Ÿã®ä¸¡æ–¹ã®ãƒ¡ãƒ¼ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã„ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å…±é€šã®æ–¹æ³•ã§å–å¾—ã—ã¦è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚`UIViewController`å†…ã§éŒ²éŸ³ã¨å†ç”Ÿã®åˆ‡ã‚Šæ›¿ãˆã‚’è¡Œã„ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’ãƒ©ãƒ™ãƒ«ã«è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã®è¨­è¨ˆã«ã‚ˆã‚Šã€éŒ²éŸ³ä¸­ã¨å†ç”Ÿä¸­ã®éŸ³é‡ãƒ¬ãƒ™ãƒ«ã®å‡¦ç†ãŒå…±é€šåŒ–ã•ã‚Œã€ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ User
*2024-05-21 18:37:30*

SwiftUIã§è¡¨ç¾ã—ã¦ã»ã—ã„

---

## ğŸ¤– Assistant
*2024-05-21 18:38:17*

SwiftUIã§éŒ²éŸ³ä¸­ã¨å†ç”Ÿä¸­ã®ä¸¡æ–¹ã§éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã§ãã¾ã™ã€‚`AudioMetering`ã‚¯ãƒ©ã‚¹ã‚’åˆ©ç”¨ã—ã¦ã€SwiftUIã®ãƒ“ãƒ¥ãƒ¼ã§éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«è¡¨ç¤ºã—ã¾ã™ã€‚

ã¾ãšã€`AudioMetering`ã‚¯ãƒ©ã‚¹ã‚’ãã®ã¾ã¾ä½¿ç”¨ã—ã¾ã™ï¼ˆå¤‰æ›´ã¯ä¸è¦ã§ã™ï¼‰ã€‚

æ¬¡ã«ã€SwiftUIã®ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¦éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹éƒ¨åˆ†ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```swift
import SwiftUI
import AVFoundation

class AudioMetering: ObservableObject {
    private var audioRecorder: AVAudioRecorder?
    private var audioPlayer: AVAudioPlayer?
    private var timer: Timer?
    
    @Published var volumeLevel: Float = 0.0

    func startRecording(withURL url: URL) {
        let settings: [String: Any] = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: url, settings: settings)
            audioRecorder?.isMeteringEnabled = true
            audioRecorder?.prepareToRecord()
            audioRecorder?.record()
            startMetering()
        } catch {
            print("Audio recorder error: \(error.localizedDescription)")
        }
    }

    func stopRecording() {
        audioRecorder?.stop()
        stopMetering()
    }

    func startPlaying(withURL url: URL) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.isMeteringEnabled = true
            audioPlayer?.prepareToPlay()
            audioPlayer?.play()
            startMetering()
        } catch {
            print("Audio player error: \(error.localizedDescription)")
        }
    }

    func stopPlaying() {
        audioPlayer?.stop()
        stopMetering()
    }

    private func startMetering() {
        timer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(updateMeter), userInfo: nil, repeats: true)
    }

    private func stopMetering() {
        timer?.invalidate()
    }

    @objc private func updateMeter() {
        if let recorder = audioRecorder {
            recorder.updateMeters()
            let normalizedPower = normalizedPowerLevel(fromDecibels: recorder.averagePower(forChannel: 0))
            DispatchQueue.main.async {
                self.volumeLevel = normalizedPower
            }
        } else if let player = audioPlayer {
            player.updateMeters()
            let normalizedPower = normalizedPowerLevel(fromDecibels: player.averagePower(forChannel: 0))
            DispatchQueue.main.async {
                self.volumeLevel = normalizedPower
            }
        }
    }

    private func normalizedPowerLevel(fromDecibels decibels: Float) -> Float {
        let minDb: Float = -160.0
        let maxDb: Float = 0.0

        if decibels < minDb {
            return 0.0
        } else if decibels >= maxDb {
            return 1.0
        } else {
            return pow(10.0, (0.05 * decibels))
        }
    }
}

struct ContentView: View {
    @StateObject private var audioMetering = AudioMetering()
    @State private var isRecording = false
    @State private var isPlaying = false

    var body: some View {
        VStack {
            Text(String(format: "Volume: %.2f", audioMetering.volumeLevel))
                .font(.largeTitle)
                .padding()

            HStack {
                Button(action: toggleRecording) {
                    Text(isRecording ? "Stop Recording" : "Start Recording")
                        .padding()
                        .background(isRecording ? Color.red : Color.green)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .padding()

                Button(action: togglePlaying) {
                    Text(isPlaying ? "Stop Playing" : "Start Playing")
                        .padding()
                        .background(isPlaying ? Color.red : Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .padding()
            }
        }
        .padding()
    }

    private func toggleRecording() {
        if isRecording {
            audioMetering.stopRecording()
        } else {
            let url = FileManager.default.temporaryDirectory.appendingPathComponent("recording.m4a")
            audioMetering.startRecording(withURL: url)
        }
        isRecording.toggle()
    }

    private func togglePlaying() {
        if isPlaying {
            audioMetering.stopPlaying()
        } else {
            let url = FileManager.default.temporaryDirectory.appendingPathComponent("recording.m4a")
            audioMetering.startPlaying(withURL: url)
        }
        isPlaying.toggle()
    }
}

@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€SwiftUIã®`ContentView`ã§éŒ²éŸ³ã¨å†ç”Ÿã®åˆ‡ã‚Šæ›¿ãˆã‚’è¡Œã„ã€`AudioMetering`ã‚¯ãƒ©ã‚¹ã‹ã‚‰å–å¾—ã—ãŸéŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’ãƒ©ãƒ™ãƒ«ã«è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚`@StateObject`ã‚’ä½¿ç”¨ã—ã¦`AudioMetering`ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç®¡ç†ã—ã€`@Published`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’é€šã˜ã¦éŸ³é‡ãƒ¬ãƒ™ãƒ«ã®å¤‰åŒ–ã‚’ç›£è¦–ã—ã¾ã™ã€‚

`toggleRecording`ã¨`togglePlaying`é–¢æ•°ã¯ã€ãã‚Œãã‚ŒéŒ²éŸ³ã¨å†ç”Ÿã®é–‹å§‹/åœæ­¢ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚éŒ²éŸ³ã¨å†ç”Ÿã®éŸ³é‡ãƒ¬ãƒ™ãƒ«ã¯å…±é€šã®`AudioMetering`ã‚¯ãƒ©ã‚¹ã«ã‚ˆã£ã¦ç®¡ç†ã•ã‚Œã€SwiftUIãƒ“ãƒ¥ãƒ¼ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

---

## ğŸ‘¤ User
*2024-05-21 18:38:28*

MVVM ã§è¡¨ç¾ã—ã¦ã»ã—ã„ã®ã¨ã•ã‚‰ã«è²¬å‹™ã‚’åˆ†å‰²ã—ã¦Av foundationã®å‡¦ç†ã¯ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨ã„ã†ã‚¯ãƒ©ã‚¹ã«ãªã‚‹ã¹ãã¾ã¨ã‚ã¦ã»ã—ã„

---

## ğŸ¤– Assistant
*2024-05-21 18:39:22*

User is working on implementing audio playback and recording functionalities in SwiftUI using MVVM architecture, with responsibilities divided into an AudioManager class for AVFoundation processing.

---

## ğŸ”§ Tool
*2024-05-21 18:39:22*

Model set context updated.

---

## ğŸ¤– Assistant
*2024-05-21 18:39:22*

MVVMã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§SwiftUIã‚’ä½¿ç”¨ã—ã€AVFoundationã®å‡¦ç†ã‚’`AudioManager`ã‚¯ãƒ©ã‚¹ã«ã¾ã¨ã‚ã‚‹å½¢ã§å®Ÿè£…ã‚’è¡Œã„ã¾ã™ã€‚

ã¾ãšã€`AudioManager`ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã€AVFoundationã®å‡¦ç†ã‚’ç®¡ç†ã—ã¾ã™ã€‚

```swift
import Foundation
import AVFoundation

class AudioManager: ObservableObject {
    private var audioRecorder: AVAudioRecorder?
    private var audioPlayer: AVAudioPlayer?
    private var timer: Timer?
    
    @Published var volumeLevel: Float = 0.0

    func startRecording(withURL url: URL) {
        let settings: [String: Any] = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: url, settings: settings)
            audioRecorder?.isMeteringEnabled = true
            audioRecorder?.prepareToRecord()
            audioRecorder?.record()
            startMetering()
        } catch {
            print("Audio recorder error: \(error.localizedDescription)")
        }
    }

    func stopRecording() {
        audioRecorder?.stop()
        stopMetering()
    }

    func startPlaying(withURL url: URL) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.isMeteringEnabled = true
            audioPlayer?.prepareToPlay()
            audioPlayer?.play()
            startMetering()
        } catch {
            print("Audio player error: \(error.localizedDescription)")
        }
    }

    func stopPlaying() {
        audioPlayer?.stop()
        stopMetering()
    }

    private func startMetering() {
        timer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(updateMeter), userInfo: nil, repeats: true)
    }

    private func stopMetering() {
        timer?.invalidate()
    }

    @objc private func updateMeter() {
        if let recorder = audioRecorder {
            recorder.updateMeters()
            let normalizedPower = normalizedPowerLevel(fromDecibels: recorder.averagePower(forChannel: 0))
            DispatchQueue.main.async {
                self.volumeLevel = normalizedPower
            }
        } else if let player = audioPlayer {
            player.updateMeters()
            let normalizedPower = normalizedPowerLevel(fromDecibels: player.averagePower(forChannel: 0))
            DispatchQueue.main.async {
                self.volumeLevel = normalizedPower
            }
        }
    }

    private func normalizedPowerLevel(fromDecibels decibels: Float) -> Float {
        let minDb: Float = -160.0
        let maxDb: Float = 0.0

        if decibels < minDb {
            return 0.0
        } else if decibels >= maxDb {
            return 1.0
        } else {
            return pow(10.0, (0.05 * decibels))
        }
    }
}
```

æ¬¡ã«ã€`AudioViewModel`ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã€`AudioManager`ã¨é€£æºã—ã¾ã™ã€‚

```swift
import Foundation

class AudioViewModel: ObservableObject {
    @Published var volumeLevel: Float = 0.0
    private var audioManager = AudioManager()
    
    private var isRecording = false
    private var isPlaying = false

    init() {
        audioManager.$volumeLevel
            .receive(on: DispatchQueue.main)
            .assign(to: &$volumeLevel)
    }

    func toggleRecording() {
        if isRecording {
            audioManager.stopRecording()
        } else {
            let url = FileManager.default.temporaryDirectory.appendingPathComponent("recording.m4a")
            audioManager.startRecording(withURL: url)
        }
        isRecording.toggle()
    }

    func togglePlaying() {
        if isPlaying {
            audioManager.stopPlaying()
        } else {
            let url = FileManager.default.temporaryDirectory.appendingPathComponent("recording.m4a")
            audioManager.startPlaying(withURL: url)
        }
        isPlaying.toggle()
    }
}
```

æœ€å¾Œã«ã€SwiftUIã®ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã€`AudioViewModel`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```swift
import SwiftUI

struct ContentView: View {
    @StateObject private var viewModel = AudioViewModel()

    var body: some View {
        VStack {
            Text(String(format: "Volume: %.2f", viewModel.volumeLevel))
                .font(.largeTitle)
                .padding()

            HStack {
                Button(action: viewModel.toggleRecording) {
                    Text(viewModel.isRecording ? "Stop Recording" : "Start Recording")
                        .padding()
                        .background(viewModel.isRecording ? Color.red : Color.green)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .padding()

                Button(action: viewModel.togglePlaying) {
                    Text(viewModel.isPlaying ? "Stop Playing" : "Start Playing")
                        .padding()
                        .background(viewModel.isPlaying ? Color.red : Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .padding()
            }
        }
        .padding()
    }
}

@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

ã“ã®å®Ÿè£…ã§ã¯ã€`AudioManager`ãŒAVFoundationã®å‡¦ç†ã‚’æ‹…å½“ã—ã€`AudioViewModel`ãŒãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç®¡ç†ã—ã¾ã™ã€‚SwiftUIã®`ContentView`ã¯`AudioViewModel`ã‚’ä½¿ç”¨ã—ã¦UIã‚’æ›´æ–°ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç®¡ç†ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€è²¬å‹™ãŒæ˜ç¢ºã«åˆ†å‰²ã•ã‚Œã€ä¿å®ˆæ€§ã®é«˜ã„ã‚³ãƒ¼ãƒ‰ãŒå®Ÿç¾ã§ãã¾ã™ã€‚

---

## ğŸ‘¤ User
*2024-05-21 18:39:46*

ã•ã‚‰ã«ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ™‚ã‚‚éŸ³é‡ã®ãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚’è¡¨ç¾ã—ã¦ã»ã—ã„

---

## ğŸ¤– Assistant
*2024-05-21 18:40:48*

ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ™‚ã‚‚éŸ³é‡ã®ãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ã€`AudioManager`ã‚¯ãƒ©ã‚¹ã®éŸ³é‡ãƒ¡ãƒ¼ã‚¿ãƒªãƒ³ã‚°ã‚’æ´»ç”¨ã—ã€SwiftUIã®ãƒ“ãƒ¥ãƒ¼ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«éŸ³é‡ã‚’è¡¨ç¤ºã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä»¥ä¸‹ã«ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®å…¨ä½“çš„ãªå®Ÿè£…ã‚’ç¤ºã—ã¾ã™ã€‚

### AudioManagerã‚¯ãƒ©ã‚¹

```swift
import Foundation
import AVFoundation

class AudioManager: ObservableObject {
    private var audioRecorder: AVAudioRecorder?
    private var audioPlayer: AVAudioPlayer?
    private var timer: Timer?
    
    @Published var volumeLevel: Float = 0.0

    func startRecording(withURL url: URL) {
        let settings: [String: Any] = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 12000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: url, settings: settings)
            audioRecorder?.isMeteringEnabled = true
            audioRecorder?.prepareToRecord()
            audioRecorder?.record()
            startMetering()
        } catch {
            print("Audio recorder error: \(error.localizedDescription)")
        }
    }

    func stopRecording() {
        audioRecorder?.stop()
        stopMetering()
    }

    func startPlaying(withURL url: URL) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.isMeteringEnabled = true
            audioPlayer?.prepareToPlay()
            audioPlayer?.play()
            startMetering()
        } catch {
            print("Audio player error: \(error.localizedDescription)")
        }
    }

    func stopPlaying() {
        audioPlayer?.stop()
        stopMetering()
    }

    private func startMetering() {
        timer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(updateMeter), userInfo: nil, repeats: true)
    }

    private func stopMetering() {
        timer?.invalidate()
    }

    @objc private func updateMeter() {
        if let recorder = audioRecorder {
            recorder.updateMeters()
            let normalizedPower = normalizedPowerLevel(fromDecibels: recorder.averagePower(forChannel: 0))
            DispatchQueue.main.async {
                self.volumeLevel = normalizedPower
            }
        } else if let player = audioPlayer {
            player.updateMeters()
            let normalizedPower = normalizedPowerLevel(fromDecibels: player.averagePower(forChannel: 0))
            DispatchQueue.main.async {
                self.volumeLevel = normalizedPower
            }
        }
    }

    private func normalizedPowerLevel(fromDecibels decibels: Float) -> Float {
        let minDb: Float = -160.0
        let maxDb: Float = 0.0

        if decibels < minDb {
            return 0.0
        } else if decibels >= maxDb {
            return 1.0
        } else {
            return pow(10.0, (0.05 * decibels))
        }
    }
}
```

### AudioViewModelã‚¯ãƒ©ã‚¹

```swift
import Foundation

class AudioViewModel: ObservableObject {
    @Published var volumeLevel: Float = 0.0
    @Published var isRecording = false
    @Published var isPlaying = false
    private var audioManager = AudioManager()

    init() {
        audioManager.$volumeLevel
            .receive(on: DispatchQueue.main)
            .assign(to: &$volumeLevel)
    }

    func toggleRecording() {
        if isRecording {
            audioManager.stopRecording()
        } else {
            let url = FileManager.default.temporaryDirectory.appendingPathComponent("recording.m4a")
            audioManager.startRecording(withURL: url)
        }
        isRecording.toggle()
    }

    func togglePlaying() {
        if isPlaying {
            audioManager.stopPlaying()
        } else {
            let url = FileManager.default.temporaryDirectory.appendingPathComponent("recording.m4a")
            audioManager.startPlaying(withURL: url)
        }
        isPlaying.toggle()
    }
}
```

### ContentViewã‚¯ãƒ©ã‚¹

```swift
import SwiftUI

struct ContentView: View {
    @StateObject private var viewModel = AudioViewModel()

    var body: some View {
        VStack {
            Text(String(format: "Volume: %.2f", viewModel.volumeLevel))
                .font(.largeTitle)
                .padding()

            HStack {
                Button(action: viewModel.toggleRecording) {
                    Text(viewModel.isRecording ? "Stop Recording" : "Start Recording")
                        .padding()
                        .background(viewModel.isRecording ? Color.red : Color.green)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .padding()

                Button(action: viewModel.togglePlaying) {
                    Text(viewModel.isPlaying ? "Stop Playing" : "Start Playing")
                        .padding()
                        .background(viewModel.isPlaying ? Color.red : Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .padding()
            }

            // Optional: Add a visual representation of the volume level, such as a progress bar
            ProgressBar(value: viewModel.volumeLevel)
                .frame(height: 20)
                .padding()
        }
        .padding()
    }
}

struct ProgressBar: View {
    var value: Float
    
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                Rectangle()
                    .frame(width: geometry.size.width, height: geometry.size.height)
                    .opacity(0.3)
                    .foregroundColor(.gray)

                Rectangle()
                    .frame(width: min(CGFloat(self.value) * geometry.size.width, geometry.size.width), height: geometry.size.height)
                    .foregroundColor(.blue)
                    .animation(.linear)
            }
            .cornerRadius(45.0)
        }
    }
}

@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

ã“ã®å®Ÿè£…ã§ã¯ã€éŒ²éŸ³ä¸­ã‚‚å†ç”Ÿä¸­ã‚‚éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ã€éŸ³é‡ãƒ¡ãƒ¼ã‚¿ãƒªãƒ³ã‚°ã®çµæœã‚’`ProgressBar`ã¨ã—ã¦è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚`AudioManager`ã‚¯ãƒ©ã‚¹ã¯AVFoundationã®å‡¦ç†ã‚’ç®¡ç†ã—ã€`AudioViewModel`ã‚¯ãƒ©ã‚¹ãŒãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã¨ãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†ã‚’è¡Œã„ã¾ã™ã€‚`ContentView`ã¯UIã®æ§‹ç¯‰ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®æ›´æ–°ã‚’æ‹…å½“ã—ã¦ã„ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ãŒãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è¦–è¦šçš„ã«è¡¨ç¾ã•ã‚Œã€éŒ²éŸ³ã¨å†ç”Ÿã®ã©ã¡ã‚‰ã®æ“ä½œä¸­ã§ã‚‚åŒã˜æ–¹æ³•ã§éŸ³é‡ã‚’è¡¨ç¤ºã§ãã¾ã™ã€‚

---
