# Mapãƒªã‚»ãƒƒãƒˆæ–¹æ³• iOS

Date: 2025-02-05

---

## ğŸ‘¤ User
*2025-02-05 13:44:43*

mapæƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹æ–¹æ³•ã¯ã‚ã‚‹ã‹ï¼Ÿ
ãªãœã‹iOSã ã¨GoogleMapã«è¡¨ç¤ºã•ã‚Œã‚‹ä½ç½®æƒ…å ±ã«animateCameraã§ç§»å‹•ã•ã›ã‚‹ã¤ã‚‚ã‚ŠãŒã€å…¨ç„¶é•ã†ç®‡æ‰€ã«ç§»å‹•ã—ã¦ã—ã¾ã„ã€GoogleMapè‡ªä½“ã‚’ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã•ã›ãŸã„ã‚“ã ã€‚

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/spot_type.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/entities/extensions/convert_to_domain.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/flavor_provider.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/location_access_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/item_box_icon.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_icon.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/location_utils.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

/// é€†ä¸‰è§’å½¢ã‚’æç”»ã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãª Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // å·¦ä¸Š
      ..lineTo(size.width, 0) // å³ä¸Š
      ..lineTo(size.width / 2, size.height) // åº•è¾ºã®ä¸­å¤®
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final flavor = ref.watch(flavorProvider);
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isLoadingState = useState(false);

    Future&lt;void&gt; zoomToFitCircle({
      required LatLng center,
      required double radiusMeters,
    }) async {
      // 1km â‰ˆ 0.009åº¦ (å³å¯†ã§ãªãã¦OK)
      // ä»Šå›ã¯ 1~10km ç¨‹åº¦ãªã®ã§ã“ã‚Œã§ååˆ†
      final radiusKm = radiusMeters / 1000.0;
      final delta = 0.009 * radiusKm;

      // å—è¥¿ç«¯ã¨åŒ—æ±ç«¯ã‚’ã–ã£ãã‚Šæ±ºã‚ã‚‹
      final southwest = LatLng(
        center.latitude - delta,
        center.longitude - delta,
      );
      final northeast = LatLng(
        center.latitude + delta,
        center.longitude + delta,
      );

      // LatLngBounds ã‚’ä½œæˆ
      final bounds = LatLngBounds(southwest: southwest, northeast: northeast);

      const padding = 72.0; // ç”»é¢å››éš…ã¨ã®ä½™ç™½
      final cameraUpdate = CameraUpdate.newLatLngBounds(bounds, padding);

      if (!context.mounted) {
        return;
      }

      await googleMapControllerState.value?.animateCamera(cameraUpdate);
    }

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              SpotIcon(spotType: spotType),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final rarity = itemBox.rarity?.domainRarity;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: ItemBoxIcon(
                        rarity: rarity,
                        size: 64,
                      ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(242, 275),
        waitToRender: const Duration(milliseconds: 10),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 10),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    Future&lt;void&gt; refreshAllMarkers({
      required List&lt;GuildSpotDTO&gt; newSpotList,
      required List&lt;ItemBoxDTO&gt; newItemBoxList,
      required String? myGuildId,
    }) async {
      final currentMarkers = markersState.value.toSet();

      final neededMarkerIds = &lt;String&gt;{};
      for (final spot in newSpotList) {
        final spotId = spot.spotId ?? '';
        neededMarkerIds.add('spot_$spotId');
      }
      for (final box in newItemBoxList) {
        final boxId = box.itemBoxId ?? '';
        neededMarkerIds.add('itemBox_$boxId');
      }

      // æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ã€Œä¸è¦ã«ãªã£ãŸã‚‚ã®ã€ã‚’å‰Šé™¤ã™ã‚‹
      currentMarkers.removeWhere(
        (marker) =&gt; !neededMarkerIds.contains(marker.markerId.value),
      );

      if (!context.mounted) {
        return;
      }

      // ã„ã£ãŸã‚“å‰Šé™¤çµæœã‚’åæ˜ (ä¸è¦ãƒãƒ¼ã‚«ãƒ¼ãŒæ¶ˆãˆã‚‹)
      markersState.value = {...currentMarkers};

      // Spot ã®ãƒªã‚¹ãƒˆã‚’é †ã«å‡¦ç†ã—ã€1ã¤ãšã¤å†æç”»ã—ã¦åæ˜ 
      for (final spot in newSpotList) {
        final markerId = MarkerId('spot_${spot.spotId}');
        // buildSpotMarker (å¿…ãšå†ç”Ÿæˆã—ã¦å†æç”»ã™ã‚‹)
        final newMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // æ—¢å­˜ã«åŒã˜ ID ã®ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        // æ–°ãŸã«è¿½åŠ ã•ã‚Œã‚‹ or æ›´æ–°ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼ã‚’ã™ãåæ˜ 
        markersState.value = {...currentMarkers};

        // UI ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã«ããã™ã‚‹ãŸã‚ã«å°‘ã—å¾…æ©Ÿ
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox ã‚‚åŒæ§˜ã«å‡¦ç†
      for (final itemBox in newItemBoxList) {
        final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
        final newMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (box) async {
            await onTapItemBoxMarker(box);
          },
        );

        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        markersState.value = {...currentMarkers};

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

    Future&lt;void&gt; onTapNearMe() async {
      try {
        final currentLocation = await getCurrentLocation(flavor: flavor);

        if (googleMapControllerState.value == null) {
          return;
        }

        await googleMapControllerState.value?.animateCamera(
          CameraUpdate.newLatLng(currentLocation),
        );
      } on PlatformException catch (error) {
        // ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸èƒ½ã®ãŸã‚ã‚¹ãƒ«ãƒ¼
        debugPrint('Error: $error');
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; startExploring(OnExploringState exploringState) async {
      try {
        final currentLocation = await getCurrentLocation(flavor: flavor);

        // range ã¯ km å˜ä½ãªã®ã§ã€ãƒ¡ãƒ¼ãƒˆãƒ«ã«æ›ç®—ï¼ˆÃ—1000ï¼‰
        final explorerRangeKm = exploringState.explorer?.range ?? 0;
        final rangeInMeters = explorerRangeKm * 1000.0;

        final circle = Circle(
          circleId: const CircleId('explorerCircle'),
          center: currentLocation,
          radius: rangeInMeters,
          strokeColor: const Color(0xFF004DFF), // ãƒ–ãƒ«ãƒ¼
          strokeWidth: 1,
          fillColor: const Color(0x40004DFF), // 25%ãã‚‰ã„é€éã®ãƒ–ãƒ«ãƒ¼
        );

        if (!context.mounted) {
          return;
        }

        circlesState.value = {circle};

        await zoomToFitCircle(
          center: currentLocation,
          radiusMeters: rangeInMeters,
        );
      } on PlatformException catch (error) {
        // ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸èƒ½ã®ãŸã‚ã‚¹ãƒ«ãƒ¼
        debugPrint('Error: $error');
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; endExploring() async {
      if (!context.mounted) {
        return;
      }

      circlesState.value = {};
      final explodedSpotList = ref.read(explodedSpotListNotifierProvider);
      final spotPhotoItems = explodedSpotList
              ?.where((spot) =&gt; spot.photoUrl != null)
              .map(
                (spot) =&gt; SpotPhotoItem(
                  photoId: spot.photoId ?? '',
                  spotPhotoUrl: spot.photoUrl ?? '',
                  spotOwnership: spot.guildId == null
                      ? SpotOwnership.neutral
                      : spot.guildId == myGuildIdState.value
                          ? SpotOwnership.owner
                          : SpotOwnership.enemy,
                ),
              )
              .toList() ??
          [];

      ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) =&gt; ExploredResultDialog(
          spotPhotoItemList: spotPhotoItems,
        ),
      );

      ref.read(explodedSpotListNotifierProvider.notifier).clear();
    }

    Future&lt;void&gt; onRefresh() async {
      try {
        if (!context.mounted) {
          return;
        }

        isLoadingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        if (!context.mounted) {
          return;
        }

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshAllMarkers(
            newSpotList: spotList,
            newItemBoxList: itemBoxList,
            myGuildId: myGuildId,
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        if (context.mounted) {
          isLoadingState.value = false;
        }
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await onRefresh();
        });
        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!isLoadingState.value) {
          // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°
          await onRefresh();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          await startExploring(next);
        } else {
          await endExploring();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                if (context.mounted) {
                  googleMapControllerState.value = controller;
                }
              },
              markers: markersState.value,
              circles: circlesState.value,
            ),
            if (isLoadingState.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTapNearMe();
                        },
                        child: const Icon(
                          Icons.near_me,
                          size: 24,
                          color: ColorToken.secondaryDark,
                        ),
                      ),
                    ),
                    // Explore ãƒªã‚¹ãƒˆ
                    SizedBox(
                      width: 138,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: onExploringStateValue.isExploring
                            ? null
                            : () async {
                                await onTapExplorer();
                              },
                        backgroundColor: onExploringStateValue.isExploring
                            ? ColorPallet.gray800.withValues(alpha: 0.8)
                            : Theme.of(context)
                                .floatingActionButtonTheme
                                .backgroundColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: BorderSide(
                            color: onExploringStateValue.isExploring
                                ? Colors.transparent
                                : ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(left: 4),
                              child: onExploringStateValue.isExploring
                                  ? Transform.translate(
                                      offset: const Offset(4, 0),
                                      child: const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        ),
                                      ),
                                    )
                                  : Image.asset(
                                      Assets.images.explorerIconFig.path,
                                      width: 40,
                                      height: 40,
                                    ),
                            ),
                            const Spacer(),
                            Text(
                              onExploringStateValue.isExploring
                                  ? 'Exploring...'
                                  : 'Explore',
                              style: TextStyle(
                                fontSize: 16,
                                color: onExploringStateValue.isExploring
                                    ? ColorToken.text
                                    : ColorToken.secondaryDark,
                              ),
                            ),
                            const Spacer(),
                          ],
                        ),
                      ),
                    ),
                    // Spot ãƒªã‚¹ãƒˆ
                    spotListAsyncValue.when(
                      data: (spotList) {
                        // ä¸Šä½2ã¤ã‚’å–ã‚Šå‡ºã—ã€é †åºã‚’é€†ã«ã™ã‚‹
                        final displaySpotList =
                            (spotList?.take(2).toList() ?? [])
                                .reversed
                                .toList();
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            backgroundColor: Colors.transparent,
                            shape: const RoundedRectangleBorder(
                              side: BorderSide(
                                color: Colors.transparent,
                              ),
                            ),
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: Transform.translate(
                              offset: const Offset(4, 4),
                              child: Stack(
                                clipBehavior: Clip.none,
                                alignment: Alignment.bottomRight,
                                children: [
                                  for (var i = 0; i &lt; 2; i++)
                                    if (i &lt; displaySpotList.length)
                                      Positioned(
                                        left: i * -4.0,
                                        top: i * -4.0,
                                        child: SizedBox(
                                          width: 44,
                                          height: 44,
                                          child: DecoratedBox(
                                            decoration: BoxDecoration(
                                              border: Border.all(
                                                color: ColorToken.bgWhite,
                                                width: 2,
                                              ),
                                              borderRadius:
                                                  BorderRadius.circular(4),
                                            ),
                                            child: Padding(
                                              padding: const EdgeInsets.all(2),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: SquareImage(
                                                  imageUrl: displaySpotList[i]
                                                      .photoUrl,
                                                  size: 44,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                      loading: () {
                        return const SizedBox.shrink();
                      },
                      error: (error, _) {
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            heroTag: 'ErrorShowSpotListButton',
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: const Icon(
                              Icons.photo,
                              size: 24,
                              color: ColorToken.secondaryDark,
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Padding(
            padding: const EdgeInsets.all(24),
            child: Center(
              child: ElevatedButton(
                onPressed: () async {
                  await showDialog&lt;void&gt;(
                    context: context,
                    builder: (_) {
                      return const LocationAccessDialog();
                    },
                  );
                },
                child: const Text(
                  'Please enable location access',
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## ğŸ”§ Tool
*2025-02-05 13:45:03*

**æ¢ã‚‹æ–¹æ³•ã‚’è¦‹ã¤ã‘ã‚‹**

Flutterã‚¢ãƒ—ãƒªã®GoogleMapã§ä½ç½®ã‚’èª¤ã‚‹å•é¡Œã«ç›´é¢ã—ã€ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆãƒ„ãƒªãƒ¼ã‹ã‚‰ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’å¼·åˆ¶çš„ã«é™¤å»ã—ã€æ–°ã—ã„ã‚­ãƒ¼ã§å†ãƒ“ãƒ«ãƒ‰ã™ã‚‹æ–¹æ³•ã‚’æ¤œè¨ã—ã¦ã„ã‚‹ã€‚

**ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆå†æ§‹ç¯‰ã®æ‰‹é †**

GoogleMapã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã®çŠ¶æ…‹ã‚’å®Œå…¨ã«å†åˆæœŸåŒ–ã™ã‚‹ãŸã‚ã«ã€`UniqueKey`ã‚’ä½¿ã£ã¦ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’å†ãƒ“ãƒ«ãƒ‰ã—ã€å¼·åˆ¶çš„ã«æ–°ã—ã„çŠ¶æ…‹ã‚’é©ç”¨ã—ã¦ã„ã‚‹ã€‚

**ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆå†åˆæœŸã®æ–¹æ³•ã‚’æ¨¡ç´¢**

GoogleMapã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã®æƒ…å ±ãƒªã‚»ãƒƒãƒˆæ–¹æ³•ã‚’æ¢ã—ã€å…¬å¼ãªæ–¹æ³•ã¯ãªãã€ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’å‰Šé™¤ã—å†åˆæœŸåŒ–ã™ã‚‹ã®ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã‚‹ã¨æŒ‡æ‘˜ã—ã¦ã„ã‚‹ã€‚

---

## ğŸ¤– Assistant
*2025-02-05 13:45:03*

Flutterå…¬å¼ã® `google_maps_flutter` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã¯ã€Œãƒãƒƒãƒ—ã®çŠ¶æ…‹ãã®ã‚‚ã®ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹APIã€ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚  
ã¨ã¯ã„ãˆã€Œã¾ã£ã•ã‚‰ãªçŠ¶æ…‹ã«è¿‘ã„å½¢ã§åœ°å›³ã‚’ä½œã‚Šç›´ã™ã€ã“ã¨ã¯ã€**ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã”ã¨ç ´æ£„ãƒ»å†ç”Ÿæˆ**ã™ã‚‹ã“ã¨ã§å®Ÿç¾ã§ãã¾ã™ã€‚

---

## ãƒãƒƒãƒ—ã‚’å¼·åˆ¶çš„ã«å†ç”Ÿæˆã™ã‚‹æ–¹æ³•

`GoogleMap` ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã« `Key` ã‚’ä»˜ä¸ã—ã€  
ã€Œå¿…è¦ã«å¿œã˜ã¦ `Key` ã‚’å¤‰ãˆã¦ã‚„ã‚‹ã€â†’ã€Œã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆãŒå·®ã—æ›¿ã‚ã‚Šï¼ˆï¼dispose & å†buildï¼‰ã€  
ã¨ã„ã†æ‰‹é †ã‚’è¸ã‚ã°ã€å®Ÿè³ªçš„ã«ã€Œãƒãƒƒãƒ—ã‚’åˆæœŸåŒ–ã€ã«è¿‘ã„æŒ™å‹•ã‚’ã—ã¾ã™ã€‚

### ä¾‹: `key` ã« `UniqueKey()` ã‚’ä½¿ã†

```dart
import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';

class MapScreen extends StatefulWidget {
  const MapScreen({Key? key}) : super(key: key);

  @override
  State<MapScreen> createState() => _MapScreenState();
}

class _MapScreenState extends State<MapScreen> {
  GoogleMapController? _controller;

  // ã“ã“ã§ mapKey ã‚’æŒã¤
  Key _mapKey = UniqueKey();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Map Reset Demo'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              // ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰ UniqueKey ã‚’å·®ã—æ›¿ãˆã¦ãƒãƒƒãƒ—ã‚’å†ç”Ÿæˆ
              setState(() {
                _mapKey = UniqueKey();
                _controller = null; // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚‚ç ´æ£„ã—ã¦ãŠã
              });
            },
          ),
        ],
      ),
      body: GoogleMap(
        key: _mapKey,
        onMapCreated: (controller) {
          _controller = controller;
        },
        initialCameraPosition: const CameraPosition(
          target: LatLng(35.6804, 139.7690), // æ±äº¬é§…ä»˜è¿‘
          zoom: 15,
        ),
      ),
    );
  }
}
```

ä¸Šè¨˜ã®ã‚ˆã†ã«ã€  
- `GoogleMap` ã® `key` ã« `_mapKey` ã‚’æŒ‡å®š  
- `_mapKey` ã« `UniqueKey()` ã‚’å†ä»£å…¥  
ã—ã¦ `setState` ã‚’å‘¼ã¶ã¨ã€Flutter ã¯ã€Œã‚­ãƒ¼ãŒå¤‰ã‚ã£ãŸï¼ã¾ã£ãŸãåˆ¥ç‰©ã®ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã€ã¨ã¿ãªã—ã¦ã„ã£ãŸã‚“ç ´æ£„ã—ã€æ–°ã—ã„ `GoogleMap` ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’ä½œã‚Šç›´ã—ã¾ã™ã€‚  
ã“ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å†…éƒ¨ã®ãƒã‚¤ãƒ†ã‚£ãƒ–åœ°å›³ã‚¨ãƒ³ã‚¸ãƒ³ã‚„çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆã•ã‚Œã€åˆæœŸåŒ–ã¨ã»ã¼åŒã˜å‡¦ç†ãŒèµ°ã‚Šã¾ã™ã€‚

---

## ãªãœ iOS ã ã‘ã€Œæ„å›³ã¨é•ã†å ´æ‰€ã€ã«ç§»å‹•ã—ã¦ã—ã¾ã†ã®ã‹ï¼Ÿ

åŸå› ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚„ã‚³ãƒ¼ãƒ‰ã®è©³ç´°ã«ã‚ˆã‚Šã¾ã™ãŒã€ä¾‹ãˆã°:

1. **`LatLng` ãŒé€†è»¢ã—ã¦ã„ã‚‹**  
   - çµŒåº¦ãƒ»ç·¯åº¦ã‚’å…¥ã‚Œæ›¿ãˆã¦æ¸¡ã—ã¦ã—ã¾ã£ã¦ã„ã‚‹  
   - ã‚‚ã—ãã¯åº¦â†’åº¦åˆ†ç§’ãªã©ã®å¤‰æ›ãƒŸã‚¹  
2. **`animateCamera` ã®åº§æ¨™ãƒ»ã‚ºãƒ¼ãƒ å€¤ã‚’UIæç”»ã®éƒ½åˆã§è¤‡æ•°å›å‘¼ã‚“ã§ã—ã¾ã£ã¦ã„ã‚‹**  
   - iOS å›ºæœ‰ã§ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒãšã‚Œã€çµæœçš„ã«æœ€å¾Œã«å‘¼ã°ã‚ŒãŸåº§æ¨™ãŒæ„å›³ã¨ã‚ºãƒ¬ã¦ã—ã¾ã†  
3. **ã€Œç¯„å›²ã‚’æŒ‡å®šã—ã¦è‡ªå‹•ã‚ºãƒ¼ãƒ ã€ã—ã¦ã„ã‚‹**  
   - `LatLngBounds` ãªã©ã§ç¯„å›²ã‚’è¨ˆç®—ã—ãŸã‚«ãƒ¡ãƒ©ç§»å‹•ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã•ã›ãŸã‚ã¨ã€å†åº¦ `animateCamera` ãŒèµ°ã£ã¦ã—ã¾ã„ã€æƒ³å®šå¤–ã®ä½ç½®ã«ç§»å‹•ã—ã¦ã„ã‚‹

ãªã©ãŒã‚ˆãã‚ã‚‹ä¾‹ã§ã™ã€‚

### å¯¾ç­–ä¾‹

- **ã‚¢ãƒ—ãƒªå´ã§ãƒ­ã‚°å‡ºåŠ›**ã—ã¦ã€é€ã‚‹åº§æ¨™ãŒæ­£ã—ã„ã‹ã‚’ç¢ºèªã™ã‚‹
- `onMapCreated` ã®ã‚ã¨ã™ãã« `animateCamera` ã‚’é€£ç¶šå‘¼ã³å‡ºã—ã™ã‚‹ã®ã§ã¯ãªãã€ä¸€åº¦ãƒ“ãƒ«ãƒ‰ã‚’å¾…ã£ã¦ã‹ã‚‰ï¼ˆ`WidgetsBinding.instance.addPostFrameCallback` ãªã©ï¼‰å‘¼ã¶ã‚ˆã†ã«ã™ã‚‹
- ç¯„å›²æŒ‡å®šãªã©ã‚’ã—ã¦ã„ã‚‹å ´åˆã¯ã€  
  - iOS ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿/å®Ÿæ©Ÿã ã¨ç«¯æœ«ã®ç”»é¢ã‚µã‚¤ã‚ºæ¯”ç‡ãŒç•°ãªã‚‹  
  - `newLatLngBounds` ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ãƒ»çŸ©å½¢è¨ˆç®—ãŒå¤±æ•—ã—ã¦ã„ã‚‹  
  ãªã©ã®å¯èƒ½æ€§ã«æ³¨æ„ã™ã‚‹

---

## ã¾ã¨ã‚

- Flutter ã® `google_maps_flutter` ã«ã¯ã€**ãƒãƒƒãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹APIã¯å­˜åœ¨ã—ãªã„**  
- åœ°å›³ã‚’ã€ŒåˆæœŸçŠ¶æ…‹ã€ã«æˆ»ã™ã«ã¯ã€**`GoogleMap` ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆãã®ã‚‚ã®ã‚’ã‚­ãƒ¼å·®ã—æ›¿ãˆã§å†ç”Ÿæˆ**ã™ã‚‹ã®ãŒæœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªæ‰‹æ®µã§ã™ã€‚  
- iOS ã§åº§æ¨™ãŒã‚ºãƒ¬ã‚‹å ´åˆã¯ã€`LatLng` ã®å€¤ã‚„ã‚«ãƒ¡ãƒ©ç§»å‹•ã®å‘¼ã³å‡ºã—ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãªã©ã‚’æ”¹ã‚ã¦ç¢ºèªã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚  

ã“ã‚Œã‚‰ã®å¯¾å¿œã§ã‚‚å•é¡ŒãŒè§£æ±ºã—ãªã„å ´åˆã¯ã€å®Ÿéš›ã«å‘¼ã³å‡ºã—ã¦ã„ã‚‹åº§æ¨™å€¤ãƒ»ãƒ­ã‚°ãªã©ã‚’è¿½ã„ã‹ã‘ãªãŒã‚‰ã€  
ã€Œæœ¬å½“ã« `LatLng(35.0, 135.0)` ï¼ˆä¾‹ï¼‰ã‚’æ¸¡ã—ã¦ã„ã‚‹ã®ã«å…¨ãé•ã†å ´æ‰€ã«é£›ã°ã•ã‚Œã‚‹ã®ã‹ï¼Ÿã€ã‚’åˆ‡ã‚Šåˆ†ã‘ã‚‹ã¨åŸå› ãŒçµã‚Šã‚„ã™ã„ã§ã™ã€‚

---
