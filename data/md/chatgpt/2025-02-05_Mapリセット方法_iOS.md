# Mapリセット方法 iOS

Date: 2025-02-05

---

## 👤 User
*2025-02-05 13:44:43*

map情報をリセットする方法はあるか？
なぜかiOSだとGoogleMapに表示される位置情報にanimateCameraで移動させるつもりが、全然違う箇所に移動してしまい、GoogleMap自体をリフレッシュさせたいんだ。

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/spot_type.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/entities/extensions/convert_to_domain.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/flavor_provider.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/location_access_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/item_box_icon.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_icon.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/location_utils.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

/// 逆三角形を描画するシンプルな Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // 左上
      ..lineTo(size.width, 0) // 右上
      ..lineTo(size.width / 2, size.height) // 底辺の中央
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final flavor = ref.watch(flavorProvider);
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isLoadingState = useState(false);

    Future&lt;void&gt; zoomToFitCircle({
      required LatLng center,
      required double radiusMeters,
    }) async {
      // 1km ≈ 0.009度 (厳密でなくてOK)
      // 今回は 1~10km 程度なのでこれで十分
      final radiusKm = radiusMeters / 1000.0;
      final delta = 0.009 * radiusKm;

      // 南西端と北東端をざっくり決める
      final southwest = LatLng(
        center.latitude - delta,
        center.longitude - delta,
      );
      final northeast = LatLng(
        center.latitude + delta,
        center.longitude + delta,
      );

      // LatLngBounds を作成
      final bounds = LatLngBounds(southwest: southwest, northeast: northeast);

      const padding = 72.0; // 画面四隅との余白
      final cameraUpdate = CameraUpdate.newLatLngBounds(bounds, padding);

      if (!context.mounted) {
        return;
      }

      await googleMapControllerState.value?.animateCamera(cameraUpdate);
    }

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              SpotIcon(spotType: spotType),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final rarity = itemBox.rarity?.domainRarity;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: ItemBoxIcon(
                        rarity: rarity,
                        size: 64,
                      ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(242, 275),
        waitToRender: const Duration(milliseconds: 10),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 10),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    Future&lt;void&gt; refreshAllMarkers({
      required List&lt;GuildSpotDTO&gt; newSpotList,
      required List&lt;ItemBoxDTO&gt; newItemBoxList,
      required String? myGuildId,
    }) async {
      final currentMarkers = markersState.value.toSet();

      final neededMarkerIds = &lt;String&gt;{};
      for (final spot in newSpotList) {
        final spotId = spot.spotId ?? '';
        neededMarkerIds.add('spot_$spotId');
      }
      for (final box in newItemBoxList) {
        final boxId = box.itemBoxId ?? '';
        neededMarkerIds.add('itemBox_$boxId');
      }

      // 既存マーカーから「不要になったもの」を削除する
      currentMarkers.removeWhere(
        (marker) =&gt; !neededMarkerIds.contains(marker.markerId.value),
      );

      if (!context.mounted) {
        return;
      }

      // いったん削除結果を反映(不要マーカーが消える)
      markersState.value = {...currentMarkers};

      // Spot のリストを順に処理し、1つずつ再描画して反映
      for (final spot in newSpotList) {
        final markerId = MarkerId('spot_${spot.spotId}');
        // buildSpotMarker (必ず再生成して再描画する)
        final newMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // 既存に同じ ID のマーカーがあれば削除してから追加
        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        // 新たに追加される or 更新されたマーカーをすぐ反映
        markersState.value = {...currentMarkers};

        // UI をブロックしにくくするために少し待機
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox も同様に処理
      for (final itemBox in newItemBoxList) {
        final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
        final newMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (box) async {
            await onTapItemBoxMarker(box);
          },
        );

        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        markersState.value = {...currentMarkers};

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

    Future&lt;void&gt; onTapNearMe() async {
      try {
        final currentLocation = await getCurrentLocation(flavor: flavor);

        if (googleMapControllerState.value == null) {
          return;
        }

        await googleMapControllerState.value?.animateCamera(
          CameraUpdate.newLatLng(currentLocation),
        );
      } on PlatformException catch (error) {
        // ハンドリング不能のためスルー
        debugPrint('Error: $error');
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; startExploring(OnExploringState exploringState) async {
      try {
        final currentLocation = await getCurrentLocation(flavor: flavor);

        // range は km 単位なので、メートルに換算（×1000）
        final explorerRangeKm = exploringState.explorer?.range ?? 0;
        final rangeInMeters = explorerRangeKm * 1000.0;

        final circle = Circle(
          circleId: const CircleId('explorerCircle'),
          center: currentLocation,
          radius: rangeInMeters,
          strokeColor: const Color(0xFF004DFF), // ブルー
          strokeWidth: 1,
          fillColor: const Color(0x40004DFF), // 25%ぐらい透過のブルー
        );

        if (!context.mounted) {
          return;
        }

        circlesState.value = {circle};

        await zoomToFitCircle(
          center: currentLocation,
          radiusMeters: rangeInMeters,
        );
      } on PlatformException catch (error) {
        // ハンドリング不能のためスルー
        debugPrint('Error: $error');
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; endExploring() async {
      if (!context.mounted) {
        return;
      }

      circlesState.value = {};
      final explodedSpotList = ref.read(explodedSpotListNotifierProvider);
      final spotPhotoItems = explodedSpotList
              ?.where((spot) =&gt; spot.photoUrl != null)
              .map(
                (spot) =&gt; SpotPhotoItem(
                  photoId: spot.photoId ?? '',
                  spotPhotoUrl: spot.photoUrl ?? '',
                  spotOwnership: spot.guildId == null
                      ? SpotOwnership.neutral
                      : spot.guildId == myGuildIdState.value
                          ? SpotOwnership.owner
                          : SpotOwnership.enemy,
                ),
              )
              .toList() ??
          [];

      ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) =&gt; ExploredResultDialog(
          spotPhotoItemList: spotPhotoItems,
        ),
      );

      ref.read(explodedSpotListNotifierProvider.notifier).clear();
    }

    Future&lt;void&gt; onRefresh() async {
      try {
        if (!context.mounted) {
          return;
        }

        isLoadingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        if (!context.mounted) {
          return;
        }

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshAllMarkers(
            newSpotList: spotList,
            newItemBoxList: itemBoxList,
            myGuildId: myGuildId,
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        if (context.mounted) {
          isLoadingState.value = false;
        }
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await onRefresh();
        });
        // フォアグラウンド復帰で位置情報再取得
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // マーカーの更新中はスキップ
        if (!isLoadingState.value) {
          // マーカーの更新
          await onRefresh();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          await startExploring(next);
        } else {
          await endExploring();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                if (context.mounted) {
                  googleMapControllerState.value = controller;
                }
              },
              markers: markersState.value,
              circles: circlesState.value,
            ),
            if (isLoadingState.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // 現在地へ戻るボタン
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTapNearMe();
                        },
                        child: const Icon(
                          Icons.near_me,
                          size: 24,
                          color: ColorToken.secondaryDark,
                        ),
                      ),
                    ),
                    // Explore リスト
                    SizedBox(
                      width: 138,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: onExploringStateValue.isExploring
                            ? null
                            : () async {
                                await onTapExplorer();
                              },
                        backgroundColor: onExploringStateValue.isExploring
                            ? ColorPallet.gray800.withValues(alpha: 0.8)
                            : Theme.of(context)
                                .floatingActionButtonTheme
                                .backgroundColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: BorderSide(
                            color: onExploringStateValue.isExploring
                                ? Colors.transparent
                                : ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(left: 4),
                              child: onExploringStateValue.isExploring
                                  ? Transform.translate(
                                      offset: const Offset(4, 0),
                                      child: const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        ),
                                      ),
                                    )
                                  : Image.asset(
                                      Assets.images.explorerIconFig.path,
                                      width: 40,
                                      height: 40,
                                    ),
                            ),
                            const Spacer(),
                            Text(
                              onExploringStateValue.isExploring
                                  ? 'Exploring...'
                                  : 'Explore',
                              style: TextStyle(
                                fontSize: 16,
                                color: onExploringStateValue.isExploring
                                    ? ColorToken.text
                                    : ColorToken.secondaryDark,
                              ),
                            ),
                            const Spacer(),
                          ],
                        ),
                      ),
                    ),
                    // Spot リスト
                    spotListAsyncValue.when(
                      data: (spotList) {
                        // 上位2つを取り出し、順序を逆にする
                        final displaySpotList =
                            (spotList?.take(2).toList() ?? [])
                                .reversed
                                .toList();
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            backgroundColor: Colors.transparent,
                            shape: const RoundedRectangleBorder(
                              side: BorderSide(
                                color: Colors.transparent,
                              ),
                            ),
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: Transform.translate(
                              offset: const Offset(4, 4),
                              child: Stack(
                                clipBehavior: Clip.none,
                                alignment: Alignment.bottomRight,
                                children: [
                                  for (var i = 0; i &lt; 2; i++)
                                    if (i &lt; displaySpotList.length)
                                      Positioned(
                                        left: i * -4.0,
                                        top: i * -4.0,
                                        child: SizedBox(
                                          width: 44,
                                          height: 44,
                                          child: DecoratedBox(
                                            decoration: BoxDecoration(
                                              border: Border.all(
                                                color: ColorToken.bgWhite,
                                                width: 2,
                                              ),
                                              borderRadius:
                                                  BorderRadius.circular(4),
                                            ),
                                            child: Padding(
                                              padding: const EdgeInsets.all(2),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: SquareImage(
                                                  imageUrl: displaySpotList[i]
                                                      .photoUrl,
                                                  size: 44,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                      loading: () {
                        return const SizedBox.shrink();
                      },
                      error: (error, _) {
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            heroTag: 'ErrorShowSpotListButton',
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: const Icon(
                              Icons.photo,
                              size: 24,
                              color: ColorToken.secondaryDark,
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Padding(
            padding: const EdgeInsets.all(24),
            child: Center(
              child: ElevatedButton(
                onPressed: () async {
                  await showDialog&lt;void&gt;(
                    context: context,
                    builder: (_) {
                      return const LocationAccessDialog();
                    },
                  );
                },
                child: const Text(
                  'Please enable location access',
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## 🔧 Tool
*2025-02-05 13:45:03*

**探る方法を見つける**

FlutterアプリのGoogleMapで位置を誤る問題に直面し、ウィジェットツリーからウィジェットを強制的に除去し、新しいキーで再ビルドする方法を検討している。

**ウィジェット再構築の手順**

GoogleMapウィジェットの状態を完全に再初期化するために、`UniqueKey`を使ってウィジェットを再ビルドし、強制的に新しい状態を適用している。

**ウィジェット再初期の方法を模索**

GoogleMapウィジェットの情報リセット方法を探し、公式な方法はなく、ウィジェットを削除し再初期化するのが推奨されていると指摘している。

---

## 🤖 Assistant
*2025-02-05 13:45:03*

Flutter公式の `google_maps_flutter` パッケージには「マップの状態そのものをリセットするAPI」はありません。  
とはいえ「まっさらな状態に近い形で地図を作り直す」ことは、**ウィジェットごと破棄・再生成**することで実現できます。

---

## マップを強制的に再生成する方法

`GoogleMap` ウィジェットに `Key` を付与し、  
「必要に応じて `Key` を変えてやる」→「ウィジェットが差し替わり（＝dispose & 再build）」  
という手順を踏めば、実質的に「マップを初期化」に近い挙動をします。

### 例: `key` に `UniqueKey()` を使う

```dart
import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';

class MapScreen extends StatefulWidget {
  const MapScreen({Key? key}) : super(key: key);

  @override
  State<MapScreen> createState() => _MapScreenState();
}

class _MapScreenState extends State<MapScreen> {
  GoogleMapController? _controller;

  // ここで mapKey を持つ
  Key _mapKey = UniqueKey();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Map Reset Demo'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              // ボタンが押されたら UniqueKey を差し替えてマップを再生成
              setState(() {
                _mapKey = UniqueKey();
                _controller = null; // コントローラも破棄しておく
              });
            },
          ),
        ],
      ),
      body: GoogleMap(
        key: _mapKey,
        onMapCreated: (controller) {
          _controller = controller;
        },
        initialCameraPosition: const CameraPosition(
          target: LatLng(35.6804, 139.7690), // 東京駅付近
          zoom: 15,
        ),
      ),
    );
  }
}
```

上記のように、  
- `GoogleMap` の `key` に `_mapKey` を指定  
- `_mapKey` に `UniqueKey()` を再代入  
して `setState` を呼ぶと、Flutter は「キーが変わった＝まったく別物のウィジェット」とみなしていったん破棄し、新しい `GoogleMap` ウィジェットを作り直します。  
このタイミングで内部のネイティブ地図エンジンや状態もリセットされ、初期化とほぼ同じ処理が走ります。

---

## なぜ iOS だけ「意図と違う場所」に移動してしまうのか？

原因はプロジェクトやコードの詳細によりますが、例えば:

1. **`LatLng` が逆転している**  
   - 経度・緯度を入れ替えて渡してしまっている  
   - もしくは度→度分秒などの変換ミス  
2. **`animateCamera` の座標・ズーム値をUI描画の都合で複数回呼んでしまっている**  
   - iOS 固有でタイミングがずれ、結果的に最後に呼ばれた座標が意図とズレてしまう  
3. **「範囲を指定して自動ズーム」している**  
   - `LatLngBounds` などで範囲を計算したカメラ移動をアニメーションさせたあと、再度 `animateCamera` が走ってしまい、想定外の位置に移動している

などがよくある例です。

### 対策例

- **アプリ側でログ出力**して、送る座標が正しいかを確認する
- `onMapCreated` のあとすぐに `animateCamera` を連続呼び出しするのではなく、一度ビルドを待ってから（`WidgetsBinding.instance.addPostFrameCallback` など）呼ぶようにする
- 範囲指定などをしている場合は、  
  - iOS シミュレータ/実機だと端末の画面サイズ比率が異なる  
  - `newLatLngBounds` のパディング・矩形計算が失敗している  
  などの可能性に注意する

---

## まとめ

- Flutter の `google_maps_flutter` には、**マップをリセットするAPIは存在しない**  
- 地図を「初期状態」に戻すには、**`GoogleMap` ウィジェットそのものをキー差し替えで再生成**するのが最もシンプルな手段です。  
- iOS で座標がズレる場合は、`LatLng` の値やカメラ移動の呼び出しタイミングなどを改めて確認してみましょう。  

これらの対応でも問題が解決しない場合は、実際に呼び出している座標値・ログなどを追いかけながら、  
「本当に `LatLng(35.0, 135.0)` （例）を渡しているのに全く違う場所に飛ばされるのか？」を切り分けると原因が絞りやすいです。

---
