# Notifier分割と共通処理

日付: 2024-12-23

---

## 👤 ユーザー
*2024/12/23 16:53:44*

UpdateGuildMemberRequestDtoMemberStatusがLEFT, KICKED, REQUESTED, APPROVED は別々の画面で呼ばれる。どのようにメソッドを生やしたり便利関数を増やしたり、Notifierの分割などを検討したい。

import 'package:flutter/foundation.dart';
import 'package:riverpod\_annotation/riverpod\_annotation.dart';

import 'package:snpit\_guild\_app/infrastructure/snapit\_guild\_api/snapit\_guild\_api.openapi.dart';
import 'package:snpit\_guild\_app/presentation/providers/api\_client/guild\_api\_provider.dart';

part 'update\_guild\_member.g.dart';

@riverpod
class UpdateGuildMemberNotifier extends \_$UpdateGuildMemberNotifier {
  @override
  Future&lt;String?&gt; build() async =&gt; null;

  Future&lt;void&gt; executeRequest({
    required String guildId,
    required String userId,
    required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
  }) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildApiProvider.future);
      final response = await api.guildControllerUpdateGuildMember(
        UpdateGuildMemberRequestDto(
          updateStatus: true,
          memberStatus: memberStatus,
        ),
        guildId: guildId,
        userId: userId,
      );
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      state = AsyncValue.data(response.data?.data);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error in UpdateGuildMemberNotifier: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

enum UpdateGuildMemberRequestDtoMemberStatus {
  @JsonValue('INVITED')
  INVITED,
  @JsonValue('JOINED')
  JOINED,
  @JsonValue('LEFT')
  LEFT,
  @JsonValue('KICKED')
  KICKED,
  @JsonValue('REQUESTED')
  REQUESTED,
  @JsonValue('APPROVED')
  APPROVED,
}

---

## 🤖 アシスタント
*2024/12/23 16:54:19*

以下のように、`UpdateGuildMemberNotifier` を分割したり、メソッドやユーティリティ関数を追加することで、`UpdateGuildMemberRequestDtoMemberStatus` の各ステータスに応じた異なる画面やロジックに対応しやすくできます。

### アプローチ

#### 1. **Notifier の分割**
各ステータス（`LEFT`, `KICKED`, `REQUESTED`, `APPROVED`）ごとに `Notifier` を分割します。それぞれの画面やロジックで特化した `Notifier` を利用できます。

#### 2. **共通のユーティリティ関数**
共通の API 呼び出しロジックを `Notifier` の外にユーティリティ関数として切り出します。これにより、コードの再利用性が向上します。

#### 3. **各ステータスに対応するメソッド**
1つの `Notifier` 内で、各ステータスに対応するメソッドを用意します。

以下は具体例です。

---

### 実装例

#### 共通ユーティリティ関数

```dart
Future<String?> updateGuildMember({
  required GuildApi api,
  required String guildId,
  required String userId,
  required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
}) async {
  final response = await api.guildControllerUpdateGuildMember(
    UpdateGuildMemberRequestDto(
      updateStatus: true,
      memberStatus: memberStatus,
    ),
    guildId: guildId,
    userId: userId,
  );
  return response.data?.data;
}
```

#### Notifier の分割

```dart
@riverpod
class LeaveGuildNotifier extends _$LeaveGuildNotifier {
  @override
  Future<String?> build() async => null;

  Future<void> leaveGuild({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildApiProvider.future);
      final result = await updateGuildMember(
        api: api,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.LEFT,
      );
      state = AsyncValue.data(result);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

@riverpod
class KickGuildMemberNotifier extends _$KickGuildMemberNotifier {
  @override
  Future<String?> build() async => null;

  Future<void> kickMember({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildApiProvider.future);
      final result = await updateGuildMember(
        api: api,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.KICKED,
      );
      state = AsyncValue.data(result);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }
}
```

#### 一つの Notifier にまとめる場合

```dart
@riverpod
class UpdateGuildMemberNotifier extends _$UpdateGuildMemberNotifier {
  @override
  Future<String?> build() async => null;

  Future<void> updateMember({
    required String guildId,
    required String userId,
    required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
  }) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildApiProvider.future);
      final result = await updateGuildMember(
        api: api,
        guildId: guildId,
        userId: userId,
        memberStatus: memberStatus,
      );
      state = AsyncValue.data(result);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }

  Future<void> leaveGuild(String guildId, String userId) =>
      updateMember(guildId: guildId, userId: userId, memberStatus: UpdateGuildMemberRequestDtoMemberStatus.LEFT);

  Future<void> kickMember(String guildId, String userId) =>
      updateMember(guildId: guildId, userId: userId, memberStatus: UpdateGuildMemberRequestDtoMemberStatus.KICKED);

  Future<void> requestMembership(String guildId, String userId) =>
      updateMember(guildId: guildId, userId: userId, memberStatus: UpdateGuildMemberRequestDtoMemberStatus.REQUESTED);

  Future<void> approveMembership(String guildId, String userId) =>
      updateMember(guildId: guildId, userId: userId, memberStatus: UpdateGuildMemberRequestDtoMemberStatus.APPROVED);
}
```

---

### 利点
- **Notifier を分割**: 画面ごとに異なる `Notifier` を使うことで責務が分離され、保守性が向上します。
- **共通ロジックの切り出し**: API 呼び出し部分をユーティリティ関数として共通化することで、コードが簡潔になります。
- **柔軟性**: 状況に応じて `Notifier` を分割または統合する選択肢があります。

このアプローチを参考に、要件に最適な方法を選んでください！

---

## 👤 ユーザー
*2024/12/23 16:54:54*

Notifier を分割して、共通ユーティリティ関数を作る方向でいきたい。

---

## 🤖 アシスタント
*2024/12/23 16:55:29*

了解しました！Notifier を分割し、共通のユーティリティ関数を利用する実装例を以下に示します。

---

### 共通ユーティリティ関数

まず、API 呼び出し部分を共通化するために、ユーティリティ関数を作成します。

```dart
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';

Future<String?> updateGuildMember({
  required GuildApi api,
  required String guildId,
  required String userId,
  required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
}) async {
  final response = await api.guildControllerUpdateGuildMember(
    UpdateGuildMemberRequestDto(
      updateStatus: true,
      memberStatus: memberStatus,
    ),
    guildId: guildId,
    userId: userId,
  );
  return response.data?.data;
}
```

---

### Notifier の分割

各ステータス（`LEFT`, `KICKED`, `REQUESTED`, `APPROVED`）ごとに専用の `Notifier` を作成します。

#### `LeaveGuildNotifier`

```dart
@riverpod
class LeaveGuildNotifier extends _$LeaveGuildNotifier {
  @override
  Future<String?> build() async => null;

  Future<void> leaveGuild({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildApiProvider.future);
      final result = await updateGuildMember(
        api: api,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.LEFT,
      );
      state = AsyncValue.data(result);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }
}
```

#### `KickGuildMemberNotifier`

```dart
@riverpod
class KickGuildMemberNotifier extends _$KickGuildMemberNotifier {
  @override
  Future<String?> build() async => null;

  Future<void> kickMember({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildApiProvider.future);
      final result = await updateGuildMember(
        api: api,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.KICKED,
      );
      state = AsyncValue.data(result);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }
}
```

#### `RequestMembershipNotifier`

```dart
@riverpod
class RequestMembershipNotifier extends _$RequestMembershipNotifier {
  @override
  Future<String?> build() async => null;

  Future<void> requestMembership({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildApiProvider.future);
      final result = await updateGuildMember(
        api: api,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.REQUESTED,
      );
      state = AsyncValue.data(result);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }
}
```

#### `ApproveMembershipNotifier`

```dart
@riverpod
class ApproveMembershipNotifier extends _$ApproveMembershipNotifier {
  @override
  Future<String?> build() async => null;

  Future<void> approveMembership({
    required String guildId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(guildApiProvider.future);
      final result = await updateGuildMember(
        api: api,
        guildId: guildId,
        userId: userId,
        memberStatus: UpdateGuildMemberRequestDtoMemberStatus.APPROVED,
      );
      state = AsyncValue.data(result);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }
}
```

---

### 利点

1. **責務の明確化**  
   各 `Notifier` が単一の目的に特化しており、役割が明確になります。

2. **再利用性の向上**  
   共通の API 呼び出しロジックをユーティリティ関数に抽出することで、同じ処理を複数箇所で簡単に再利用可能になります。

3. **テスト容易性**  
   各 `Notifier` が単純化されるため、個別のテストが容易になります。

---

### 使用例

それぞれの画面や状態に応じて適切な `Notifier` を利用します。

```dart
final leaveGuildNotifier = ref.watch(leaveGuildNotifierProvider.notifier);
final kickGuildNotifier = ref.watch(kickGuildNotifierProvider.notifier);
// 必要に応じて他の Notifier も同様に利用
```

---

これにより、コードが整理され、保守性や拡張性が向上します。追加の要件があればお知らせください！

---

## 👤 ユーザー
*2024/12/23 16:55:47*

ユーティリティー関数は、クラスにした方がいいのか？

---

## 🤖 アシスタント
*2024/12/23 16:56:16*

ユーティリティ関数をクラスにするかどうかは、次のような要件や用途によって決定されます。

---

### クラスにした方が良い場合

1. **状態管理が必要な場合**
   - ユーティリティ関数が内部で状態を持ち、再利用やコンテキストごとに異なる振る舞いが求められる場合。
   - 例: 認証トークンや設定値を持つ場合。

2. **複数の関連する機能をまとめたい場合**
   - 共通のコンテキストで複数の関数を整理したい場合。
   - 例: API クライアントや特定のエンティティに関連する操作。

3. **依存関係が必要な場合**
   - ユーティリティ関数が他のサービスやプロバイダへの依存を持つ場合。
   - 例: `Riverpod` の `ref` を必要とする場合。

4. **インターフェースやテスト性を向上させたい場合**
   - ユーティリティ関数を抽象化してインターフェースを定義し、異なる実装を切り替え可能にしたい場合。
   - 例: `GuildMemberUpdater` インターフェースを作成し、実装を差し替え可能にする。

---

### クラスにしなくて良い場合（関数のままで良い場合）

1. **シンプルなロジックの場合**
   - 状態や依存関係を持たない、単純な機能の再利用が目的の場合。
   - 例: API 呼び出しやデータのフォーマット変換。

2. **1つだけの汎用機能の場合**
   - 独立した小さな関数として使用される場合。
   - 例: `updateGuildMember` のように、単一の責務を持つ関数。

3. **静的関数として十分な場合**
   - 特定の文脈や状態に依存せず、どこからでも同じように利用できる場合。
   - 例: 共通的な計算処理やデータ操作。

---

### クラスを利用した実装例

以下は、ユーティリティ関数をクラスに移行した例です。

```dart
class GuildMemberService {
  final GuildApi api;

  GuildMemberService(this.api);

  Future<String?> updateGuildMember({
    required String guildId,
    required String userId,
    required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
  }) async {
    final response = await api.guildControllerUpdateGuildMember(
      UpdateGuildMemberRequestDto(
        updateStatus: true,
        memberStatus: memberStatus,
      ),
      guildId: guildId,
      userId: userId,
    );
    return response.data?.data;
  }
}
```

#### 使用例
```dart
final guildApi = ref.watch(guildApiProvider.future);
final service = GuildMemberService(guildApi);

await service.updateGuildMember(
  guildId: 'exampleGuildId',
  userId: 'exampleUserId',
  memberStatus: UpdateGuildMemberRequestDtoMemberStatus.LEFT,
);
```

---

### 静的クラスとして定義する場合

状態を持つ必要がなく、どこからでも使える場合は静的メソッドを持つクラスにする方法もあります。

```dart
class GuildMemberUtils {
  static Future<String?> updateGuildMember({
    required GuildApi api,
    required String guildId,
    required String userId,
    required UpdateGuildMemberRequestDtoMemberStatus memberStatus,
  }) async {
    final response = await api.guildControllerUpdateGuildMember(
      UpdateGuildMemberRequestDto(
        updateStatus: true,
        memberStatus: memberStatus,
      ),
      guildId: guildId,
      userId: userId,
    );
    return response.data?.data;
  }
}
```

#### 使用例
```dart
await GuildMemberUtils.updateGuildMember(
  api: api,
  guildId: 'exampleGuildId',
  userId: 'exampleUserId',
  memberStatus: UpdateGuildMemberRequestDtoMemberStatus.LEFT,
);
```

---

### 結論

- **シンプルな関数なら**: 関数のままで十分。
- **複数の関連する処理があり、整理したいなら**: クラスにする。
- **状態や依存関係が必要なら**: クラスにしてインスタンス化。

`updateGuildMember` のようなシンプルな API 呼び出しの場合、静的関数またはユーティリティ関数として維持するのがおすすめです。ただし、依存関係が増えたり、ロジックが複雑になる場合はクラスに移行するのが適切です。

---
