# ÂÜÜ„ÅÆÊèèÁîªÊñπÊ≥ï

Êó•‰ªò: 2025-01-18

---

## üë§ „É¶„Éº„Ç∂„Éº
*2025/1/18 23:24:52*

onTapExplorer„Çí„Çø„ÉÉ„Éó„Åó„Åü„Å®„Åç„Å´ÁèæÂú®Âú∞„Çí‰∏≠ÂøÉ„Å´100m„ÅÆÁØÑÂõ≤„Å´ÂÜÜ„ÇíË°®Á§∫„Åï„Åõ„Åü„ÅÑ„ÄÇ#004DFF00 „Å® #004DFF4D „ÅÆÊîæÂ∞ÑÁä∂„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Åß„ÇÑ„Çä„Åü„ÅÑ„ÄÇ
ÊîæÂ∞ÑÁä∂„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Åå„Åß„Åç„Å™„Åã„Å£„Åü„ÇâÂçòËâ≤„Åß„ÅÑ„ÅÑ„ÄÇ‚Ä®‚Ä®import 'package:flutter/material.dart';
import 'package:flutter\_hooks/flutter\_hooks.dart';
import 'package:google\_maps\_flutter/google\_maps\_flutter.dart';
import 'package:hooks\_riverpod/hooks\_riverpod.dart';
import 'package:permission\_handler/permission\_handler.dart';
import 'package:snpit\_guild\_app/domain/design/color\_pallet.dart';
import 'package:snpit\_guild\_app/domain/design/color\_token.dart';
import 'package:snpit\_guild\_app/gen/assets.gen.dart';
import 'package:snpit\_guild\_app/infrastructure/snapit\_guild\_api/snapit\_guild\_api.openapi.dart';
import 'package:snpit\_guild\_app/presentation/providers/api\_client/accounts/get\_account.dart';
import 'package:snpit\_guild\_app/presentation/providers/api\_client/guilds/get\_guild.dart';
import 'package:snpit\_guild\_app/presentation/providers/api\_client/guilds/get\_guild\_spot\_list.dart';
import 'package:snpit\_guild\_app/presentation/providers/api\_client/item\_boxes/get\_item\_box\_list.dart';
import 'package:snpit\_guild\_app/presentation/providers/current\_location.dart';
import 'package:snpit\_guild\_app/presentation/providers/show\_explorer\_list.dart';
import 'package:snpit\_guild\_app/presentation/providers/show\_item\_box\_detail.dart';
import 'package:snpit\_guild\_app/presentation/providers/show\_our\_spot\_detail.dart';
import 'package:snpit\_guild\_app/presentation/providers/show\_shootable\_spot\_detail.dart';
import 'package:snpit\_guild\_app/presentation/providers/show\_spot\_list.dart';
import 'package:widget\_to\_marker/widget\_to\_marker.dart';

enum SpotType {
  noneGuild, // spotGuildId == null
  myGuild, // spotGuildId == myGuildId
  enemyGuild // spotGuildId != myGuildId
}

/// ÈÄÜ‰∏âËßíÂΩ¢„ÇíÊèèÁîª„Åô„Çã„Ç∑„É≥„Éó„É´„Å™ Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // Â∑¶‰∏ä
      ..lineTo(size.width, 0) // Âè≥‰∏ä
      ..lineTo(size.width / 2, size.height) // Â∫ïËæ∫„ÅÆ‰∏≠Â§Æ
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final googleMapController = useState&lt;GoogleMapController?&gt;(null);
    final currentLocationState = ref.watch(currentLocationNotifierProvider);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markers = useState&lt;Set&lt;Marker&gt;&gt;({});
    final isMarkersBuilding = useState(false);

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      ref.read(showItemBoxDetailNotifierProvider.notifier).show(itemBox);
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);
      final photoUrl = spot.photoUrl;
      Widget content;

      switch (spotType) {
        case SpotType.noneGuild:
          content = DecoratedBox(
            decoration: BoxDecoration(
              border: Border.all(
                color: ColorPallet.white,
                width: 4,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: (photoUrl != null && photoUrl.isNotEmpty)
                    ? Image.network(
                        photoUrl,
                        fit: BoxFit.cover,
                        width: 64,
                        height: 64,
                        errorBuilder: (context, error, stackTrace) {
                          return Container(
                            width: 64,
                            height: 64,
                            color: ColorToken.bgDark,
                            child: const Icon(
                              Icons.broken\_image\_outlined,
                              size: 48,
                              color: ColorToken.text,
                            ),
                          );
                        },
                      )
                    : Container(
                        width: 64,
                        height: 64,
                        color: ColorToken.bgDark,
                        child: const Icon(
                          Icons.hide\_image\_outlined,
                          size: 48,
                          color: ColorToken.text,
                        ),
                      ),
              ),
            ),
          );

        case SpotType.myGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorPallet.green500,
              child: Icon(
                Icons.flag,
                color: ColorPallet.green100,
                size: 24,
              ),
            ),
          );

        case SpotType.enemyGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorToken.bgEnemy,
              child: Icon(
                Icons.flag,
                color: ColorToken.enemy,
                size: 24,
              ),
            ),
          );
      }

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: \[
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            \],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: \[
              content,
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            \],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      // TODO: \[Item\] ÁîªÂÉè„Å´URL„Åå‰ªò„ÅÑ„Å¶„Åè„Çã„ÅØ„Åö
      const String? photoUrl = null;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: \[
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            \],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: \[
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: (photoUrl != null)
                        ? Image.network(
                            photoUrl,
                            fit: BoxFit.cover,
                            width: 64,
                            height: 64,
                            errorBuilder: (context, error, stackTrace) {
                              return Container(
                                width: 64,
                                height: 64,
                                color: ColorToken.bgDark,
                                child: const Icon(
                                  Icons.broken\_image\_outlined,
                                  size: 48,
                                  color: ColorToken.text,
                                ),
                              );
                            },
                          )
                        : Container(
                            width: 64,
                            height: 64,
                            color: ColorToken.secondary,
                            child: const Icon(
                              Icons.card\_giftcard\_rounded,
                              size: 48,
                              color: ColorToken.text,
                            ),
                          ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            \],
          ),
        ),
      );
    }

    Future&lt;Set&lt;Marker&gt;&gt; buildAllMarkers({
      required List&lt;GuildSpotDTO&gt; spotList,
      required List&lt;ItemBoxDTO&gt; itemBoxList,
      required String? myGuildId,
    }) async {
      final markerSet = &lt;Marker&gt;{};

      // ---- Spot „Éû„Éº„Ç´„ÉºÁîüÊàê ----
      for (final spot in spotList) {
        final lat = spot.spotLatitude?.toDouble() ?? 0;
        final lng = spot.spotLongitude?.toDouble() ?? 0;
        final spotId = spot.spotId ?? '';
        final spotType = getSpotType(spot.guildId, myGuildId);
        final widget = buildSpotMarkerWidget(spot, myGuildId);

        // widget\_to\_marker „ÅßÂ§âÊèõ
        final iconDescriptor = await widget.toBitmapDescriptor(
          logicalSize: const Size(88, 100),
          imageSize: spotType == SpotType.noneGuild
              ? const Size(198, 225)
              : const Size(242, 275),
          waitToRender: const Duration(milliseconds: 500),
        );

        markerSet.add(
          Marker(
            markerId: MarkerId('spot\_$spotId'),
            position: LatLng(lat, lng),
            icon: iconDescriptor,
            onTap: () async {
              await onTapSpotMarker(spotId, spotType);
            },
          ),
        );
      }

      // ---- ItemBox „Éû„Éº„Ç´„ÉºÁîüÊàê ----
      for (final itemBox in itemBoxList) {
        final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
        final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
        final itemBoxId = itemBox.itemBoxId ?? '';
        final widget = buildItemBoxMarkerWidget(itemBox);

        // widget\_to\_marker „ÅßÂ§âÊèõ
        final iconDescriptor = await widget.toBitmapDescriptor(
          logicalSize: const Size(88, 100),
          imageSize: const Size(198, 225),
          waitToRender: const Duration(milliseconds: 500),
        );

        markerSet.add(
          Marker(
            markerId: MarkerId('itemBox\_$itemBoxId'),
            position: LatLng(lat, lng),
            icon: iconDescriptor,
            onTap: () async {
              await onTapItemBoxMarker(itemBox);
            },
          ),
        );
      }

      return markerSet;
    }

    Future&lt;void&gt; refreshMarkers(
      List&lt;GuildSpotDTO&gt; spotList,
      List&lt;ItemBoxDTO&gt; itemBoxList,
    ) async {
      try {
        isMarkersBuilding.value = true;
        final newMarkers = await buildAllMarkers(
          spotList: spotList,
          itemBoxList: itemBoxList,
          myGuildId: myGuildIdState.value,
        );
        markers.value = newMarkers;
      } finally {
        isMarkersBuilding.value = false;
      }
    }

    Future&lt;void&gt; onTanNearMe() async {
      final refreshedLocation =
          await ref.read(currentLocationNotifierProvider.future);
      final controller = googleMapController.value;
      if (controller != null) {
        await controller.animateCamera(
          CameraUpdate.newLatLng(refreshedLocation),
        );
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    useEffect(
      () {
        Future.microtask(() async {
          try {
            await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();
            final myAccount = await ref
                .read(getMyAccountNotifierProvider.notifier)
                .getMyAccount();
            myGuildIdState.value = myAccount.guildId;

            final itemBoxList = await ref
                .read(getItemBoxListNotifierProvider.notifier)
                .getItemBoxList();

            final myGuildId = myGuildIdState.value;
            if (myGuildId != null) {
              final spotList = await ref
                  .read(getGuildSpotListNotifierProvider.notifier)
                  .getGuildSpotList(myGuildId);

              await refreshMarkers(spotList, itemBoxList);
            }
          } on Exception catch (e) {
            debugPrint('Error: $e');
          }
        });

        // „Éï„Ç©„Ç¢„Ç∞„É©„Ç¶„É≥„ÉâÂæ©Â∏∞„Åß‰ΩçÁΩÆÊÉÖÂ†±ÂÜçÂèñÂæó
        final observer = \_LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);

        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      \[\],
    );

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) =&gt; Stack(
          children: \[
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapController.value = controller;
              },
              markers: markers.value,
            ),
            if (isMarkersBuilding.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: \[
                    // ÁèæÂú®Âú∞„Å∏Êàª„Çã„Éú„Çø„É≥
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTanNearMe();
                        },
                        child: const Icon(
                          Icons.near\_me,
                          size: 24,
                        ),
                      ),
                    ),
                    // Explore „É™„Çπ„Éà
                    SizedBox(
                      width: 130,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: () async {
                          await onTapExplorer();
                        },
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: const BorderSide(
                            color: ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: \[
                            Transform.translate(
                              offset: const Offset(-12, 0),
                              child: Image.asset(
                                Assets.images.explorerIconFig.path,
                                width: 40,
                                height: 40,
                              ),
                            ),
                            const Text(
                              'Explore',
                              style: TextStyle(fontSize: 16),
                            ),
                          \],
                        ),
                      ),
                    ),
                    // Spot „É™„Çπ„Éà
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowSpotListButton',
                        onPressed: () async {
                          await onTapSpotList();
                        },
                        child: const Icon(Icons.photo),
                      ),
                    ),
                  \],
                ),
              ),
            ),
          \],
        ),
        loading: () =&gt; const Center(child: CircularProgressIndicator()),
        error: (error, stack) =&gt; Center(
          child: ElevatedButton(
            onPressed: () async {
              await openAppSettings();
            },
            child: const Text('Ë®≠ÂÆö„Ç¢„Éó„É™„Åã„Çâ‰ΩçÁΩÆÊÉÖÂ†±ÂèñÂæó„ÇíON„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ'),
          ),
        ),
      ),
    );
  }
}

class \_LifecycleObserver extends WidgetsBindingObserver {
  \_LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## üîß „ÉÑ„Éº„É´
*2025/1/18 23:25:44*

\*\*Adding a feature\*\*

I‚Äôm adding a circle around the current location on Google Maps with a 100m radius and a radial gradient. If the gradient isn‚Äôt feasible, I‚Äôll use a single color. This enhances map visualization, though custom methods might be needed.

\*\*Mapping out the options\*\*

I'm exploring creating a circle with a radial gradient in a widget, converting it to BitmapDescriptor, and using it as a ground overlay for Google Maps Flutter.

\*\*Identifying the color\*\*

I'm thinking through the hex code #004DFF00, interpreting it as ARGB with alpha=0, red=77, green=255, blue=0. It seems to indicate a non-visible or transparent color.

\*\*Clarifying the color\*\*

I‚Äôm confirming that #004DFF00 is fully transparent and #004DFF4D is a bright green. If the radial gradient isn‚Äôt feasible, a single fill color for circles on Google Map will suffice.

\*\*Setting up circle parameters\*\*

I‚Äôm detailing how to create a circle around the current location in Google Maps Flutter, using a constant fill color with alpha and adjusting the `circles` property for potential interactions.

\*\*Evaluating overlay options\*\*

I‚Äôm assessing creating a gradient circle ground overlay using custom overlays or polygons with partial alpha fill. Ultimately, a single-color solution is presented due to practical constraints.

\*\*Implementing a circle feature\*\*

I‚Äôm detailing the creation of a circle feature on Google Maps, focusing on state management and rendering the circle with specified parameters like radius and fill color.

\*\*Prioritizing the single color approach\*\*

I'm focusing on the single color method for the circle feature, considering it the most practical solution. This simplifies the code and enhances the feature's functionality.

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2025/1/18 23:25:44*

Flutter„ÅÆÂÖ¨Âºè„ÅÆ `google_maps_flutter` „Éó„É©„Ç∞„Ç§„É≥„Åß„ÅØ„ÄåÂÜÜ (Circle)„Äç„ÅÆÂ°ó„Çä„Å§„Å∂„Åó„Å´„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Çí„Åã„Åë„ÇãÊâãÊÆµ„ÅØÁî®ÊÑè„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ  
„Åù„ÅÆ„Åü„ÇÅ„ÄÅ**„Äå„ÇÇ„ÅóÊîæÂ∞ÑÁä∂„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„ÅåÂøÖÈ†à„Åß„ÅÇ„Çå„Å∞„ÄÅGroundOverlay „ÇÑ TileOverlay „Å™„Å©„ÇíËá™Ââç„ÅßÂÆüË£Ö„Åô„Çã„Åó„Åã„Å™„Åè„ÄÅÁµêÊßãÂ§ßÂ§â„Äç**„Å®„ÅÑ„ÅÜ„ÅÆ„ÅåÁµêË´ñ„Åß„Åô„ÄÇ  
‰∏ÄÊñπ„Åß„ÄÅ**„ÄåÂçòËâ≤„Åß„Çà„Åë„Çå„Å∞ÂÜÜ (Circle) „ÇíÊèèÁîª„Åô„Çã„Å†„Åë„Äç**„ÅßÂÆüÁèæ„Åß„Åç„Åæ„Åô„ÄÇ

--- 

## 1. ÂçòËâ≤„ÅÆÂÜÜ„ÇíË°®Á§∫„Åó„Åü„ÅÑÂ†¥Âêà

GoogleMap „Ç¶„Ç£„Ç∏„Çß„ÉÉ„Éà„Å´„ÅØ `circles: Set<Circle>` „Éó„É≠„Éë„ÉÜ„Ç£„Åå„ÅÇ„Çä„ÄÅ„Åì„Åì„Å´ÂÜÜ„ÇíÊèèÁîª„Åô„ÇãÊÉÖÂ†±„ÇíÊ∏°„Åõ„Å∞OK„Åß„Åô„ÄÇ  
100m ÁØÑÂõ≤„ÅÆÂÜÜ„ÇíÊèèÁîª„Åô„ÇãÊúÄ„ÇÇÁ∞°Âçò„Å™‰æã„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ

```dart
import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';

class MapPage extends StatefulWidget {
  const MapPage({super.key});

  @override
  State<MapPage> createState() => _MapPageState();
}

class _MapPageState extends State<MapPage> {
  GoogleMapController? _controller;
  // ÂÜÜ„ÇíÁÆ°ÁêÜ„Åô„Çã„Åü„ÇÅ„ÅÆ State
  Set<Circle> _circles = {};

  // ‰ªÆ„ÅÆÁèæÂú®Âú∞
  LatLng _currentLocation = const LatLng(35.6804, 139.7690); // Êù±‰∫¨ÈßÖ„ÅÇ„Åü„Çä

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GoogleMap(
        initialCameraPosition: CameraPosition(
          target: _currentLocation,
          zoom: 17,
        ),
        onMapCreated: (controller) {
          _controller = controller;
        },
        // circles „Å´ÂÜÜ„ÇíÊ∏°„Åô
        circles: _circles,
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _onTapExplorer,
        child: const Icon(Icons.travel_explore),
      ),
    );
  }

  Future<void> _onTapExplorer() async {
    // ÂÆüÈöõ„Å´„ÅØ Provider Á≠â„Åã„Çâ currentLocation „ÇíÂèñÂæó„Åó„Å¶„ÇÇOK
    // final currentLocation = await ref.read(currentLocationNotifierProvider.future);

    final newCircle = Circle(
      circleId: const CircleId("explorerCircle"),
      center: _currentLocation,
      // ÂçäÂæÑ 100m
      radius: 100,
      // strokeColor „ÅØËº™ÈÉ≠„ÅÆËâ≤
      strokeColor: Colors.transparent,
      strokeWidth: 0,
      // fillColor „ÅÆ ARGB ÂÄ§„ÇíÊåáÂÆö (‰æã: 80% „Åè„Çâ„ÅÑ„ÅÆ‰∏çÈÄèÊòéÂ∫¶„ÅßÈùí„Å£„ÅΩ„ÅÑËâ≤)
      // #004DFF00 „Å® #004DFF4D „ÅØ„ÄåÊîæÂ∞ÑÁä∂„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Åß‰Ωø„ÅÑ„Åü„Åã„Å£„ÅüËâ≤„Äç„ÅÆ„Çà„ÅÜ„Å™„ÅÆ„Åß„ÄÅ
      // ÂçòËâ≤„Å´„Åô„ÇãÂ†¥Âêà„ÅØ„Åì„Çå„Çâ„ÅÆ‰∏≠ÈñìËâ≤„Åã„ÅäÂ•Ω„Åø„ÅÆÊøÉÂ∫¶„ÅÆ„ÇÇ„ÅÆ„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
      fillColor: const Color(0x40004DFF), // 0x40 ‚âí 25% „Ç¢„É´„Éï„Ç°, 0x80 „Å™„Çâ 50% „Å™„Å©
    );

    setState(() {
      // „Çª„ÉÉ„Éà„ÅóÁõ¥„Åô
      _circles = {newCircle};
    });

    // ÂøÖË¶Å„Å´Âøú„Åò„Å¶„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅßÂÜÜ„ÅÆ‰∏≠ÂøÉ„Å∏ÁßªÂãï
    await _controller?.animateCamera(
      CameraUpdate.newLatLng(_currentLocation),
    );
  }
}
```

‰∏äË®ò„ÅÆ‰æã„Åß„ÅØ `floatingActionButton` „ÇíÊäº„Åô„Åü„Å≥„Å´ `_circles` „Çí‰∏äÊõ∏„Åç„Åó„Å¶„ÄÅ  
`explorerCircle` „Å®„ÅÑ„ÅÜ ID „ÅÆÂÜÜ„Çí1ÂÄã„Å†„ÅëË°®Á§∫„Åó„Åæ„Åô„ÄÇ  
Ôºà„ÇÇ„ÅóË§áÊï∞Èáç„Å≠„ÇãÁ≠â„Çí„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅ`_circles` „Å´Âà•„ÅÆ `CircleId` „ÇíË∂≥„Åõ„Å∞OK„Åß„ÅôÔºâ

### „Ç´„É©„Éº„Ç≥„Éº„Éâ„Å´„Å§„ÅÑ„Å¶

- Flutter/Dart „Åß„ÅØ‰∏ÄËà¨ÁöÑ„Å´ **ARGB** (8Ê°Å) „ÅÆ 16ÈÄ≤Êï∞„Çí `0xAARRGGBB` „ÅÆÈ†ÜÁï™„ÅßÊåáÂÆö„Åó„Åæ„Åô„ÄÇ  
  - ‰æã: `Color(0xFFFF0000)` „ÅØ„Ç¢„É´„Éï„Ç°=255, R=255, G=0, B=0 „Å™„ÅÆ„ÅßÁúü„Å£Ëµ§„ÄÇ  
- Ë≥™Âïè„ÅßÊõ∏„Åã„Çå„Å¶„ÅÑ„Åü `#004DFF00` „Çí„Åù„ÅÆ„Åæ„Åæ 8 Ê°Å„Å´ÂàÜËß£„Åô„Çã„Å®„ÄÅ  
  - `#00` (alpha=0 = ÂÆåÂÖ®„Å´ÈÄèÊòé)  
  - `4D` (77)  
  - `FF` (255)  
  - `00` (0)  
  - „Å®„ÅÑ„ÅÜÈ†ÜÁï™„Å™„ÅÆ„Åß„ÄÅÂÆüÈöõ„Å´Â°ó„Çä„Å§„Å∂„Åù„ÅÜ„Å®„Åó„Å¶„ÇÇ**ÂÆåÂÖ®„Å´ÈÄèÈÅé**„Åó„Å¶„Åó„Åæ„ÅÑ„Åæ„Åô„ÄÇ  
- „ÇÇ„Åó„ÄåR=0, G=77, B=255„Äç„Å´„Åó„Åü„ÅÑ„Å™„Çâ„ÄÅ8Ê°ÅÂâçÊèê„ÅÆ ARGB „Ç≥„Éº„Éâ„ÅØ `0xFF004DFF` „Å™„Å©„ÅåÊ≠£„Åó„ÅÑË°®Ë®ò„Å´„Å™„Çä„Åæ„Åô„ÄÇ(alpha=FF „Åß‰∏çÈÄèÊòé)  
- „Ç¢„É´„Éï„Ç°ÂÄ§„ÇÇËæº„ÇÅ„Å¶„ÅäÂ•Ω„Åø„ÅÆÈÄèÈÅéÂ∫¶„Å´„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅ`0xAA004DFF` „ÅÆ„Çà„ÅÜ„Å´È†≠2Ê°Å„ÇíË™øÊï¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ  
  - „Åü„Å®„Åà„Å∞ `0x40004DFF` „Å™„Çâ„Ç¢„É´„Éï„Ç°=64(Á¥Ñ25%„ÅÆ‰∏çÈÄèÊòéÂ∫¶)„ÄÅ  
    `0x80004DFF` „Å™„Çâ„Ç¢„É´„Éï„Ç°=128(50%) „Å™„Å©„ÄÇ

--- 

## 2. ÊîæÂ∞ÑÁä∂„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Çí„Å©„ÅÜ„Åó„Å¶„ÇÇ„ÇÑ„Çä„Åü„ÅÑÂ†¥Âêà

ÊÆãÂøµ„Å™„Åå„Çâ `google_maps_flutter` „Å´Ê®ôÊ∫ñÊê≠Ëºâ„ÅÆ„ÄåCircle„Äç„ÄåPolygon„Äç„Å™„Å©„Å´„ÅØ„ÄÅÂçòËâ≤ („ÇÇ„Åó„Åè„ÅØÂçòËâ≤Ôºã„Ç¢„Ç¶„Éà„É©„Ç§„É≥) „ÅÆÂ°ó„ÇäÂàÜ„Åë„Åó„Åã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ  
ÊîæÂ∞ÑÁä∂„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Å´„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™ÊâãÊÆµ„ÅåËÄÉ„Åà„Çâ„Çå„Åæ„Åô„Åå„ÄÅ„Å©„Çå„ÇÇ**„Åã„Å™„ÇäÂ§ßÂ§â**„Åß„Åô„ÄÇ

1. **ÁîªÂÉè„ÇíÁî®„ÅÑ„Åü GroundOverlay „Åæ„Åü„ÅØ TileOverlay**  
   - Android / iOS „ÅÆ„Éç„Ç§„ÉÜ„Ç£„Éñ API „Å´„ÅØ ‚ÄúGroundOverlay‚Äù „Å®Âëº„Å∞„Çå„ÇãÂú∞Âõ≥‰∏ä„Å´ÁîªÂÉè„ÇíÈáç„Å≠„ÇãÊâãÊÆµ„Åå„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ`google_maps_flutter` „Åß„ÅØ„Åæ„Å†ÂÖ¨Âºè„Åß„ÅØ„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÔºà‚Äª „ÅÑ„Åè„Å§„Åã„Çµ„Éº„Éâ„Éë„Éº„ÉÜ„Ç£„ÅåÊã°Âºµ„Åó„Åü Plugin „ÅØ„ÅÇ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„ÇìÔºâ  
   - „ÇÇ„Åó GroundOverlay Áõ∏ÂΩì„ÅåÊâ±„Åà„Çå„Å∞„ÄÅ„Äå‰∏≠ÂøÉ„ÅåÈÄèÊòé„ÄÅÂ§ñÂÅ¥„ÅåÊøÉ„ÅÑËâ≤(or ÈÄÜ)„Äç„ÅÆÂÜÜÂΩ¢„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥PNG„ÇíÁî®ÊÑè„Åó„Å¶„ÄÅÂú∞Âõ≥‰∏ä„Å´Ë≤º„Çä‰ªò„Åë„Çã„Åì„Å®„ÅßÁñë‰ººÁöÑ„Å´ÂÆüÁèæ„Åß„Åç„Åæ„Åô„ÄÇ  
   - „ÇÇ„Å°„Çç„Çì„Ç∫„Éº„É†„Ç§„É≥„Éª„Ç∫„Éº„É†„Ç¢„Ç¶„Éà„Åó„Åü„Å®„Åç„ÅÆÊåôÂãï„Å™„Å©„ÇÇËÄÉÊÖÆ„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ

2. **Polygon „ÇíÁ¥∞„Åã„ÅèÂàÜÂâ≤„Åó„Å¶„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Å£„ÅΩ„ÅèË¶ã„Åõ„Çã**  
   - ÂçäÂæÑ100m „ÅÆÂÜÜ„ÇíË§áÊï∞„ÅÆÂêåÂøÉÂÜÜ„Éù„É™„Ç¥„É≥„Å´Á¥∞„Åã„ÅèÂå∫Âàá„Å£„Å¶„ÄÅÂÜÖÂÅ¥„Åª„Å©ËñÑ„ÅÑËâ≤„ÄÅÂ§ñÂÅ¥„Åª„Å©ÊøÉ„ÅÑËâ≤‚Ä¶„Å™„Å©„Å®ÊÆµÈöéÁöÑ„Å´Â°ó„Çä„Å§„Å∂„Åô„Åì„Å®„Åß„Äå„Åº„Åã„Åó„Äç„ÇíË°®Áèæ„Åô„Çã„Ç¢„Ç§„Éá„Ç¢„Åß„Åô„ÄÇ  
   - „Åü„Å†„ÅóÊÆµÊï∞„ÅåÂ§ö„Åè„Å™„Çã„Åª„Å©È†ÇÁÇπ„ÇÇÂ§ßÈáè„Å´ÁîüÊàê„Åó„Å™„Åë„Çå„Å∞„Å™„Çâ„Åö„ÄÅ„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Å´ÂΩ±Èüø„ÅåÂá∫„ÇãÊÅê„Çå„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ

ÂÆüÈöõ„Å´„ÅØ‰∏äË®ò„ÅÆ„Çà„ÅÜ„Å´„Äå„ÇÑ„Çä„Åü„ÅÑ„Åì„Å®„Äç„Å´ÂØæ„Åó„Å¶**„Éè„Éº„Éâ„É´„ÅåÈ´ò„ÅÑ**„ÅÆ„Åß„ÄÅ  
**„ÄåFlutter „ÅÆ GoogleMap „Åß„ÅØÊîæÂ∞ÑÁä∂„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„ÅØË´¶„ÇÅ„Å¶ÂçòËâ≤„Åß‰ª£Áî®„Åô„Çã„Äç**„Å®„ÅÑ„ÅÜÊñπ„ÅåÁèæÂÆüÁöÑ„Åß„Åô„ÄÇ

---

## „Åæ„Å®„ÇÅ

- **ÂçòËâ≤ÂÜÜ„Å™„Çâ** `circles` „Å´ `Circle` „ÇíÊ∏°„Åô„Å†„Åë„ÅßÁ∞°Âçò„Å´ÊèèÁîª„Åß„Åç„Çã„ÄÇ  
- **ÊîæÂ∞ÑÁä∂„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„ÅØ GoogleMap „ÅÆÊ®ôÊ∫ñÊ©üËÉΩ„Å´ÁÑ°„ÅÑ**„ÅÆ„Åß„ÄÅ„Åã„Å™„ÇäÁâπÊÆä„Å™ÂÆüË£Ö„Çí„Åó„Å™„ÅÑÈôê„ÇäÈõ£„Åó„ÅÑ„ÄÇ  
- „ÇÑ„ÇÄ„ÇíÂæó„Åö„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Çí‰Ωø„ÅÜÂ†¥Âêà„ÅØ„ÄÅGroundOverlay „ÇÑ „Çø„Ç§„É´„Ç™„Éº„Éê„Éº„É¨„Ç§Á≠â„ÇíËá™‰Ωú„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åå„ÄÅÂÆüË£Ö„Ç≥„Çπ„Éà„ÅØÂ§ß„Åç„ÅÑ„ÄÇ

„Å≤„Å®„Åæ„Åö„ÄåonTapExplorer„Çí„Çø„ÉÉ„Éó„Åó„Åü„Å®„Åç„Å´„ÄÅÁèæÂú®Âú∞„Çí‰∏≠ÂøÉ„Å´ÂçäÂæÑ100m„ÅÆÂÜÜ„ÇíÂçòËâ≤„ÅßË°®Á§∫„Åô„Çã„Äç„Å†„Åë„Å™„Çâ„ÄÅ‰∏äË®ò `Circle` „ÅÆ‰æã„ÇíÂèÇËÄÉ„Å´ÂÆüË£Ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

---

## üë§ „É¶„Éº„Ç∂„Éº
*2025/1/18 23:27:45*

ÂçòËâ≤„Åß„ÅÑ„ÅÑ„ÅÆ„ÅßÁèæÂÆüË£Ö„Å´ÂΩì„Å¶„ÅØ„ÇÅ„Å¶ÂÆüË£Ö„Åó„Å¶„Åª„Åó„ÅÑ„ÄÇ‰∏çË¶Å„Å™ÈÉ®ÂàÜ„ÅØÁúÅÁï•„Åó„Å¶„ÅÑ„ÅÑ„Çà„ÄÇ

---

## üîß „ÉÑ„Éº„É´
*2025/1/18 23:28:13*

\*\*Enhancing map functionality\*\*

I‚Äôm planning to integrate a circle into the provided code by adding a `Set&lt;Circle&gt;` property and integrating it into the `onTapExplorer` method. This involves refining the map's visual elements.

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2025/1/18 23:28:13*

‰ª•‰∏ã„ÅØ„ÄÅ**„ÄåonTapExplorer „ÅåÊäº„Åï„Çå„Åü„Å®„Åç„Å´ÁèæÂú®Âú∞„Çí‰∏≠ÂøÉ„Å´ÂçäÂæÑ 100m „ÅÆÂçòËâ≤ÂÜÜ„ÇíË°®Á§∫„Åô„Çã„Äç**ÂÆüË£Ö„Çí‰æãÁ§∫„Åó„Åü„ÇÇ„ÅÆ„Åß„Åô„ÄÇ  
‰∏çË¶Å„Å™ÈÉ®ÂàÜ„ÇíÁúÅ„Åç„Å§„Å§„ÄÅÊúÄÂ∞èÈôê„ÅßÂãï„Åè„Çà„ÅÜ„Å´Êõ∏„ÅÑ„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆüÈöõ„Å´„ÅØ„ÅîËá™Ë∫´„ÅÆ„Ç≥„Éº„Éâ„Éô„Éº„Çπ„Å´Âêà„Çè„Åõ„Å¶Â∑Æ„ÅóÊõø„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

/// ‰æã: currentLocationNotifierProvider „Åã„Çâ LatLng „ÇíÂèñÂæó„Åô„Çã„Éó„É≠„Éê„Ç§„ÉÄ
final currentLocationNotifierProvider =
    FutureProvider<LatLng>((ref) async {
  // ÂÆüÈöõ„Å´„ÅØ‰ΩçÁΩÆÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Å¶Ëøî„Åô„Ç≥„Éº„Éâ„ÇíÊõ∏„Åè
  return const LatLng(35.6804, 139.7690); // ‰ªÆ: Êù±‰∫¨ÈßÖ„ÅÇ„Åü„Çä
});

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapController „ÇíÁÆ°ÁêÜ„Åô„Çã„Åü„ÇÅ„ÅÆ State
    final googleMapController = useState<GoogleMapController?>(null);

    // Marker „ÇíÁÆ°ÁêÜ„Åô„Çã‰æã (ÁúÅÁï•ÂèØËÉΩ)
    final markers = useState<Set<Marker>>({});

    // ÂÜÜ„ÇíÁÆ°ÁêÜ„Åô„Çã State
    final circles = useState<Set<Circle>>({});

    // ÁèæÂú®Âú∞„ÇíÁõ£Ë¶ñ (AsyncValue)
    final currentLocationState = ref.watch(currentLocationNotifierProvider);

    Future<void> onTapExplorer() async {
      // „Åì„Åì„Åß„ÄåExplore„Äç„É™„Çπ„Éà„ÇíË°®Á§∫„Åô„Çã„Å™„Å©„ÅÆÂá¶ÁêÜ
      // ref.read(showExplorerListNotifierProvider.notifier).show();
      // ----------------------------

      // ÁèæÂú®Âú∞„ÅåÂèñÂæó„Åß„Åç„Å¶„ÅÑ„Å™„Åë„Çå„Å∞‰Ωï„ÇÇ„Åó„Å™„ÅÑ
      final loc = currentLocationState.asData?.value;
      if (loc == null) return;

      // ÂÜÜ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
      final circle = Circle(
        circleId: const CircleId('explorerCircle'),
        center: loc,        // ÁèæÂú®Âú∞„Çí‰∏≠ÂøÉ„Å´
        radius: 100,        // ÂçäÂæÑ 100m
        strokeColor: Colors.transparent, // Êû†Á∑ö„ÅØÈÄèÊòé
        strokeWidth: 0,                  // Êû†Á∑ö„ÅÆÂπÖ
        // fillColor „ÅØ ARGB „ÅÆ 16ÈÄ≤Êï∞„ÅßÊåáÂÆö (0xAA004DFF „Å™„Å©)
        fillColor: const Color(0x40004DFF), // 25%„Åê„Çâ„ÅÑÈÄèÈÅé„ÅÆ„Éñ„É´„Éº
      );

      // „Åô„Åß„Å´‰ªñ„ÅÆÂÜÜ„Åå„ÅÇ„Çã„Å™„Çâ‰∏äÊõ∏„Åç or ËøΩÂä†
      circles.value = {circle};

      // Âú∞Âõ≥„Çí„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅßÂÜÜ„ÅÆ‰∏≠ÂøÉ„Åæ„ÅßÁßªÂãï„Åó„Åü„ÅÑÂ†¥Âêà
      await googleMapController.value?.animateCamera(
        CameraUpdate.newLatLng(loc),
      );
    }

    return Scaffold(
      body: currentLocationState.when(
        data: (currentLocation) {
          return Stack(
            children: [
              GoogleMap(
                // ÂàùÊúü‰ΩçÁΩÆ„ÇíÁèæÂú®Âú∞„Å´
                initialCameraPosition: CameraPosition(
                  target: currentLocation,
                  zoom: 17,
                ),
                onMapCreated: (controller) {
                  googleMapController.value = controller;
                },
                myLocationEnabled: true,
                myLocationButtonEnabled: false,
                markers: markers.value,
                // circles „Å´ÊèèÁîª„Åó„Åü„ÅÑÂÜÜ„ÇíÊ∏°„Åô
                circles: circles.value,
              ),
              // ÁîªÈù¢‰∏ãÈÉ®„Å™„Å©„Å´ FloatingActionButton „ÇíÈÖçÁΩÆ„Åó„Å¶„ÄÅ
              // onTapExplorer „ÇíÂëº„Å≥Âá∫„Åô‰æã
              Positioned(
                bottom: 16,
                right: 16,
                child: FloatingActionButton(
                  onPressed: onTapExplorer,
                  child: const Icon(Icons.travel_explore),
                ),
              ),
            ],
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Text('‰ΩçÁΩÆÊÉÖÂ†±„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü: $error'),
        ),
      ),
    );
  }
}
```

### Ëß£Ë™¨

1. **`circles` „ÅÆÁÆ°ÁêÜ**  
   - `final circles = useState<Set<Circle>>({});` „Åß `Set<Circle>` „Çí‰ΩúÊàê„Åó„ÄÅGoogleMap „ÅÆ `circles` „Éó„É≠„Éë„ÉÜ„Ç£„Å´ÊµÅ„ÅóËæº„Åø„Åæ„Åô„ÄÇ  
   - „ÄåÂÜÜ„ÇíËøΩÂä†„ÉªÂâäÈô§„Äç„Åó„Åü„ÅÑ„Å®„Åç„ÅØ„ÄÅ„Åì„ÅÆ `circles.value` „ÇíÂ∑Æ„ÅóÊõø„Åà„Åæ„Åô„ÄÇ  

2. **`onTapExplorer()` ÂÜÖ„Åß Circle ÁîüÊàê**  
   - `CircleId('explorerCircle')` „ÅØ„É¶„Éã„Éº„ÇØ„Å™ID (ÊñáÂ≠óÂàó) „Åß„ÅÇ„Çå„Å∞‰Ωï„Åß„ÇÇOK„ÄÇ  
   - `center` „ÅåÂÜÜ„ÅÆ‰∏≠ÂøÉ„ÄÇ  
   - `radius` „ÅåÂçò‰Ωç„É°„Éº„Éà„É´„ÅÆÂçäÂæÑ„ÄÇ  
   - `fillColor` „ÅØ„Ç¢„É´„Éï„Ç°ÔºãRGB „ÅÆ 8Ê°Å„ÅÆ16ÈÄ≤Êï∞„ÅßÊåáÂÆö„Åó„Åæ„Åô„ÄÇ  
     - `0x40004DFF` „ÅØ„Äå„Ç¢„É´„Éï„Ç°=0x40 (64) „ÅßÁ¥Ñ25%„ÅÆ‰∏çÈÄèÊòéÂ∫¶„Äç„ÄåËâ≤= 0x004DFF (ÈùíÁ≥ª)„Äç„Å®„ÅÑ„ÅÜÊÑèÂë≥„Åß„Åô„ÄÇ  
   - `strokeColor` / `strokeWidth` „ÅßÊû†Á∑ö„ÅÆËâ≤„ÉªÂ§™„Åï„ÇíÊåáÂÆö„Åß„Åç„Åæ„Åô„Åå„ÄÅ„Åì„Åì„Åß„ÅØÈÄèÊòé„Å´„Åó„Å¶Êû†Á∑ö„ÇíÁÑ°„Åè„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ

3. **Âú∞Âõ≥„ÇíÁèæÂú®Âú∞„Å∏ÁßªÂãï** („Ç™„Éó„Ç∑„Éß„É≥)  
   - `googleMapController.value?.animateCamera(...)` „Åß‰∏≠ÂøÉÂ∫ßÊ®ô„ÇíÂãï„Åã„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ  
   - ‰∏çË¶Å„Åß„ÅÇ„Çå„Å∞ÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„Åì„Çå„Åß„ÄÅ„ÄåExplore „Éú„Çø„É≥„ÇíÊäº„Åó„Åü„Å®„Åç„Å´„ÄÅÁèæÂú®Âú∞„Çí‰∏≠ÂøÉ„Å´ÂçäÂæÑ100m„ÉªÈÄèÊòéÂ∫¶25%„Åè„Çâ„ÅÑ„ÅÆÈùí„ÅÑÂÜÜ„ÇíË°®Á§∫„Åô„Çã„ÄçÂãï„Åç„Åå„Åß„Åç„Åæ„Åô„ÄÇ

---
