# ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«å†ç”ŸUI

æ—¥ä»˜: 2024-05-10

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 13:38:33*

ã“ã®ç”»é¢ã«å†ç”Ÿä¸­ã¯ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤ºã—ã¦å†ç”Ÿæ™‚é–“ã¨å†ç”Ÿä¸­ã®seek barã‚’è¨­å®šã—ãŸã„ã€‚
ã©ã†ã™ã‚Œã°ã„ã„ã‹ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ã—ã¦ã»ã—ã„


import SwiftUI
import AVFoundation

@MainActor
struct AudioListView: View {
    @StateObject private var presenter: AudioListPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            if presenter.audioDatas.isEmpty {
                Text("ã‚¨ãƒ©ãƒ¼ï¼ å³ä¸Šã‹ã‚‰å‰Šé™¤ã—ã¦ãã ã•ã„")
                    .isHidden(presenter.appError.isNil, remove: true)
                Text("ãƒ‡ãƒ¼ã‚¿ãŒ1ä»¶ã‚‚ã‚ã¾ã›ã‚“")
                    .isHidden(presenter.appError.isNotNil, remove: true)
            } else {
                ForEach(presenter.searchedAudioDatas) { audioData in
                    DisclosureGroup {
                        HStack {
                            Text("Date")
                            Spacer()
                            Text(audioData.createdAt.asISO8601)
                        }
                        HStack {
                            Text("Time")
                            Spacer()
                            Text(audioData.duration.mmss)
                        }
                        HStack {
                            Text("Size")
                            Spacer()
                            Text(audioData.fileSize.formattedSize)
                        }
                        HStack {
                            Text("Extension")
                            Spacer()
                            Text(audioData.fileUrl.pathExtension)
                        }
                    } label: {
                        Button {
                            presenter.onTapAudio(audioData: audioData)
                        } label: {
                            Text(audioData.fileUrl.lastPathComponent)
                        }
                    }
                }
            }
        }
        .searchable(text: $presenter.searchText) {}
        .toolbar {
            ToolbarItemGroup(placement: .topBarTrailing) {
                Button {
                    presenter.onTapTrash()
                } label: {
                    SFSymbols.trash.image
                        .foregroundStyle(.red)
                }
            }
        }
        .navigationTitle("Audio List")
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: false)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError, onOk: { _ in
            presenter.onTapOkDelete()
        })
        .task {
            await presenter.onAppear()
        }
    }
}

#Preview {
    AudioListView()
        .navigationStacked()
}


import Foundation
import AVFoundation

@MainActor
final class AudioListPresenter: ObservableObject {
    @Published private(set) var audioFiles: [URL] = []
    private(set) var audioDatas: [AudioData] = []
    @Published private(set) var searchedAudioDatas: [AudioData] = []
    @Published var searchText: String = ""
    
    @Published var isLoading: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false

    private let fileManageDriver: FileManageDriver = .init()
    private let audioFileManageDriver: AudioFileManageDriver = .init()

    var player: AVAudioPlayer?

    init() {
        $searchText
            .compactMap { [weak self] searchText in
                self?.audioDatas.filter { audioData in
                    searchText.isEmpty || "\(audioData.fileUrl.lastPathComponent)".localizedCaseInsensitiveContains(searchText)
                }
                .sorted(by: \.createdAt, order: .descending)
            }
            .assign(to: &$searchedAudioDatas)
    }

    func onAppear() async {
        isLoading = true
        defer {
            isLoading = false
        }

        do {
            let tmpPath = fileManageDriver.getDirectoryUrl(directoryType: .tmp)
            let audioFiles = try fileManageDriver.getFiles(directory: tmpPath, extensions: FileExtension.allCases)

            var fetchedAudioData: [AudioData] = []
            try await withThrowingTaskGroup(of: AudioData.self) { group in
                for fileUrl in audioFiles {
                    group.addTask {
                        try await self.audioFileManageDriver.metadataFromAudioFile(fileUrl: fileUrl)
                    }
                }

                for try await result in group {
                    fetchedAudioData.append(result)
                }
            }

            audioDatas = fetchedAudioData.sorted(by: \.createdAt, order: .descending)
            searchedAudioDatas = audioDatas
        } catch {
            OSLogger.errorLog("Failed to read audio files: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapAudio(audioData: AudioData) {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
            player = try AVAudioPlayer(contentsOf: audioData.fileUrl)
            player?.play()
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapTrash() {
        appError = .allDelete
        showAlert = true
    }

    func onTapOkDelete() {
        let tmpPath = fileManageDriver.getDirectoryUrl(directoryType: .tmp)
        do {
            try fileManageDriver.clearDirectoryContents(directory: tmpPath)
        } catch {
            OSLogger.errorLog("\(error)")
            appError = error.toAppError
            showAlert = true
        }
        
        // å†èª­ã¿è¾¼ã¿(æœ¬æ¥ã¯ onAppear ã§ã¯ãªãã¦åˆ¥å‡¦ç†ã§å‘¼ã³ãŸã„ãŒä¸€æ—¦)
        Task {
            await onAppear()
            appError = nil
        }
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 13:39:03*

SwiftUIã§éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®å†ç”Ÿä¸­ã«ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤ºã—ã€å†ç”Ÿæ™‚é–“ã¨ã‚·ãƒ¼ã‚¯ãƒãƒ¼ã‚’è¨­å®šã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¸ã‚€ã“ã¨ãŒåŠ¹æœçš„ã§ã™ï¼š

1. **ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ**: ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼ã¯é€šå¸¸ã€ç”»é¢ã®ä¸‹éƒ¨ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ“ãƒ¥ãƒ¼ã§ã™ã€‚ã“ã®ãƒ“ãƒ¥ãƒ¼ã«ã¯å†ç”Ÿæ™‚é–“ã¨ã‚·ãƒ¼ã‚¯ãƒãƒ¼ã‚’å«ã‚ã¾ã™ã€‚

2. **AudioPlayerã®çŠ¶æ…‹ç®¡ç†**: `AVAudioPlayer`ã®çŠ¶æ…‹ï¼ˆå†ç”Ÿä¸­ã€åœæ­¢ä¸­ãªã©ï¼‰ã‚’ç›£è¦–ã—ã€UIã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«`ObservableObject`ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

3. **ã‚·ãƒ¼ã‚¯ãƒãƒ¼ã®å®Ÿè£…**: å†ç”Ÿä¸­ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ã«å¿œã˜ã¦ã‚·ãƒ¼ã‚¯ãƒãƒ¼ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«ã€ã‚¿ã‚¤ãƒãƒ¼ã‚’ä½¿ç”¨ã—ã¦ç¾åœ¨ã®å†ç”Ÿä½ç½®ã‚’å®šæœŸçš„ã«å–å¾—ã—ã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€ã“ã‚Œã‚‰ã®æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®åŸºæœ¬çš„ãªã‚³ãƒ¼ãƒ‰ä¾‹ã§ã™ï¼š

```swift
import SwiftUI
import AVFoundation

struct HalfModalView: View {
    @Binding var audioPlayer: AVAudioPlayer?
    @State private var currentTime: TimeInterval = 0
    @State private var duration: TimeInterval = 0

    let timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()

    var body: some View {
        VStack {
            Slider(value: $currentTime, in: 0...duration, onEditingChanged: sliderEditingChanged)
            HStack {
                Text(formatTime(time: currentTime))
                Spacer()
                Text(formatTime(time: duration))
            }
        }
        .onReceive(timer) { _ in
            self.currentTime = audioPlayer?.currentTime ?? 0
            self.duration = audioPlayer?.duration ?? 0
        }
        .padding()
    }

    func sliderEditingChanged(editingStarted: Bool) {
        if editingStarted {
            timer.upstream.connect().cancel()
        } else {
            audioPlayer?.currentTime = currentTime
            timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
        }
    }

    func formatTime(time: TimeInterval) -> String {
        let minutes = Int(time) / 60 % 60
        let seconds = Int(time) % 60
        return String(format: "%02i:%02i", minutes, seconds)
    }
}

extension AudioListView {
    var modalView: some View {
        HalfModalView(audioPlayer: $presenter.player)
            .frame(height: 300)
            .background(Color(.systemBackground))
            .cornerRadius(10)
    }
}

// æ—¢å­˜ã®AudioListViewã®bodyå†…ã«ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹æ¡ä»¶ã‚’è¿½åŠ 
.sheet(isPresented: $presenter.isPlayerActive) {
    modalView
}
```

ã“ã®ä¾‹ã§ã¯ã€`HalfModalView` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½œæˆã—ã€ãã®ä¸­ã§ã‚·ãƒ¼ã‚¯ãƒãƒ¼ã¨æ™‚é–“è¡¨ç¤ºã‚’ç®¡ç†ã—ã¦ã„ã¾ã™ã€‚`AudioListView` ã«ã‚·ãƒ¼ãƒˆã¨ã—ã¦ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹æ¡ä»¶ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚`AVAudioPlayer` ã®å†ç”ŸçŠ¶æ…‹ã«åŸºã¥ã„ã¦ã€ã‚·ãƒ¼ãƒˆã®è¡¨ç¤ºã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 13:40:29*

var player: AVAudioPlayer? ã¯ã“ã®ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«å´ã«æŒãŸã›ã¦ã„ã„ã‚ˆã€‚

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 13:41:03*

ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼ã§ç›´æ¥ `AVAudioPlayer` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç®¡ç†ã™ã‚‹æ–¹æ³•ã‚’è€ƒãˆã‚‹ã¨ã€å†ç”Ÿåˆ¶å¾¡ã¨UIã®æ›´æ–°ã‚’ã‚ˆã‚ŠåŠ¹æœçš„ã«åŒæœŸã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å†ç”ŸçŠ¶æ…‹ã«å¿œã˜ãŸUIã®æ›´æ–°ãŒã‚¹ãƒ ãƒ¼ã‚ºã«è¡Œãˆã€ãƒ—ãƒ¬ã‚¼ãƒ³ã‚¿ãƒ¼ã‚„ãã®ä»–ã®ãƒ“ãƒ¥ãƒ¼ã§ã®ç®¡ç†ãŒæ¸›å°‘ã—ã¾ã™ã€‚ä»¥ä¸‹ã«ã€`AVAudioPlayer`ã‚’ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼ã§ç®¡ç†ã™ã‚‹ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

### ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼ã®æ›´æ–°
`AVAudioPlayer`ã‚’ç›´æ¥ãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼å†…ã§åˆæœŸåŒ–ã—ã€æ“ä½œã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
import SwiftUI
import AVFoundation

struct HalfModalView: View {
    @State private var player: AVAudioPlayer?
    @State private var currentTime: TimeInterval = 0
    @State private var duration: TimeInterval = 0
    var audioURL: URL

    let timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()

    var body: some View {
        VStack {
            Slider(value: $currentTime, in: 0...duration, onEditingChanged: sliderEditingChanged)
            HStack {
                Text(formatTime(time: currentTime))
                Spacer()
                Text(formatTime(time: duration))
            }
            Button("Play/Pause") {
                if player?.isPlaying == true {
                    player?.pause()
                } else {
                    player?.play()
                }
            }
        }
        .onAppear {
            setupAudioPlayer()
        }
        .onReceive(timer) { _ in
            self.currentTime = player?.currentTime ?? 0
            self.duration = player?.duration ?? 0
        }
        .padding()
    }

    private func setupAudioPlayer() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
            player = try AVAudioPlayer(contentsOf: audioURL)
            player?.prepareToPlay()
        } catch {
            print("Error initializing the audio player: \(error)")
        }
    }

    func sliderEditingChanged(editingStarted: Bool) {
        if editingStarted {
            timer.upstream.connect().cancel()
        } else {
            player?.currentTime = currentTime
            if player?.isPlaying == true {
                timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            }
        }
    }

    func formatTime(time: TimeInterval) -> String {
        let minutes = Int(time) / 60 % 60
        let seconds = Int(time) % 60
        return String(format: "%02i:%02i", minutes, seconds)
    }
}
```

### ä¸»ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰ã®ä½¿ç”¨
ä¸»ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰ `HalfModalView` ã‚’å‘¼ã³å‡ºã™ã¨ãã¯ã€å†ç”Ÿã™ã‚‹ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‚’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦æ¸¡ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```swift
.sheet(isPresented: $presenter.isPlayerActive) {
    HalfModalView(audioURL: someAudioFileURL)
}
```

ã“ã®æ§‹æˆã«ã‚ˆã‚Šã€å†ç”Ÿåˆ¶å¾¡ã¨UIã®æ›´æ–°ãŒãƒãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ“ãƒ¥ãƒ¼å†…ã§å®Œçµã—ã€ã‚ˆã‚Šã‚¯ãƒªãƒ¼ãƒ³ã§è²¬ä»»ã®æ˜ç¢ºãªã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 13:53:58*

mutating ã«ã—ãªã„ã‚ˆã†ã«è¦‹ç›´ã—ã¦ã»ã—ã„

import SwiftUI
import AVFoundation

struct AudioPlayerView: View {
    @State private var player: AVAudioPlayer?
    @State private var currentTime: TimeInterval = 0
    @State private var duration: TimeInterval = 0
    var audioUrl: URL

    var timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()

    var body: some View {
        VStack {
            Slider(value: $currentTime, in: 0...duration, onEditingChanged: sliderEditingChanged)
            HStack {
                Text(formatTime(time: currentTime))
                Spacer()
                Text(formatTime(time: duration))
            }
            Button("Play/Pause") {
                if player?.isPlaying == true {
                    player?.pause()
                } else {
                    player?.play()
                }
            }
        }
        .onAppear {
            setupAudioPlayer()
        }
        .onReceive(timer) { _ in
            self.currentTime = player?.currentTime ?? 0
            self.duration = player?.duration ?? 0
        }
        .padding()
    }

    private func setupAudioPlayer() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
            player = try AVAudioPlayer(contentsOf: audioUrl)
            player?.prepareToPlay()
        } catch {
            print("Error initializing the audio player: \(error)")
        }
    }

    mutating func sliderEditingChanged(editingStarted: Bool) {
        if editingStarted {
            timer.upstream.connect().cancel()
        } else {
            player?.currentTime = currentTime
            if player?.isPlaying == true {
                timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            }
        }
    }

    func formatTime(time: TimeInterval) -&gt; String {
        let minutes = Int(time) / 60 % 60
        let seconds = Int(time) % 60
        return String(format: "%02i:%02i", minutes, seconds)
    }
}

#Preview {
    AudioPlayerView(audioUrl: URL(string: "https://amachamusic.chagasi.com/mp3/ukiukilalala.mp3")!)
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 13:54:41*

SwiftUIã§ã¯ã€`View` ã¯ `struct` ã¨ã—ã¦å®šç¾©ã•ã‚Œã€ã“ã‚Œã¯ä¸å¤‰ã§ã‚ã‚‹ã¹ãã§ã™ã€‚`mutating` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ `struct` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å¤‰æ›´ã™ã‚‹å ´åˆã«ä½¿ç”¨ã—ã¾ã™ãŒã€`View` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã“ã‚Œã‚’ä½¿ç”¨ã™ã‚‹ã®ã¯ä¸€èˆ¬çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`View` ã®çŠ¶æ…‹ã¯ `@State` ã‚„ãã®ä»–ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’ä½¿ã£ã¦ç®¡ç†ã™ã¹ãã§ã™ã€‚

`sliderEditingChanged` é–¢æ•°ã§ `timer` ã‚’æ›´æ–°ã—ã¦ã„ã‚‹éƒ¨åˆ†ãŒ `mutating` ã‚’å¿…è¦ã¨ã™ã‚‹åŸå› ã§ã™ãŒã€ã“ã‚Œã‚’é¿ã‘ã‚‹ãŸã‚ã«ã¯ `timer` ã®å†å‰²ã‚Šå½“ã¦ã‚’åˆ¥ã®æ–¹æ³•ã§è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚SwiftUIã§ã¯ `Timer` ã®ç®¡ç†ã¯é€šå¸¸ã€`onReceive` ã‚’ä½¿ã£ã¦éç ´å£Šçš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£ã—ã¦ã€`sliderEditingChanged` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ `mutating` ã§ã‚ã‚‹å¿…è¦ãŒãªããªã‚‹ã‚ˆã†ã«ã§ãã¾ã™ï¼š

```swift
import SwiftUI
import AVFoundation

struct AudioPlayerView: View {
    @State private var player: AVAudioPlayer?
    @State private var currentTime: TimeInterval = 0
    @State private var duration: TimeInterval = 0
    var audioUrl: URL

    @State private var isEditing: Bool = false

    var body: some View {
        VStack {
            Slider(value: $currentTime, in: 0...duration, onEditingChanged: sliderEditingChanged)
            HStack {
                Text(formatTime(time: currentTime))
                Spacer()
                Text(formatTime(time: duration))
            }
            Button("Play/Pause") {
                if player?.isPlaying == true {
                    player?.pause()
                } else {
                    player?.play()
                }
            }
        }
        .onAppear {
            setupAudioPlayer()
        }
        .onReceive(timer) { _ in
            if !isEditing {
                self.currentTime = player?.currentTime ?? 0
            }
            self.duration = player?.duration ?? 0
        }
        .padding()
    }

    private func setupAudioPlayer() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
            player = try AVAudioPlayer(contentsOf: audioUrl)
            player?.prepareToPlay()
        } catch {
            print("Error initializing the audio player: \(error)")
        }
    }

    func sliderEditingChanged(editingStarted: Bool) {
        isEditing = editingStarted
        if !editingStarted {
            player?.currentTime = currentTime
        }
    }

    func formatTime(time: TimeInterval) -> String {
        let minutes = Int(time) / 60 % 60
        let seconds = Int(time) % 60
        return String(format: "%02i:%02i", minutes, seconds)
    }

    var timer: Publishers.Autoconnect<Timer.TimerPublisher> {
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
    }
}

// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
struct AudioPlayerView_Previews: PreviewProvider {
    static var previews: some View {
        AudioPlayerView(audioUrl: URL(string: "https://amachamusic.chagasi.com/mp3/ukiukilalala.mp3")!)
    }
}
```

ã“ã®ä¿®æ­£ã§ã¯ã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ç·¨é›†çŠ¶æ…‹ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã®æ–°ã—ã„ `@State` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ `isEditing` ã‚’è¿½åŠ ã—ã€ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°ã®éç ´å£Šçš„ãªç®¡ç†ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚ã¾ãŸã€ã‚¿ã‚¤ãƒãƒ¼è‡ªä½“ã¯ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦æä¾›ã—ã€å†æ¥ç¶šã¯ç·¨é›†ãŒçµ‚äº†ã—ãŸã¨ãã®ã¿è¡Œã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€`View` ã®ä¸å¤‰æ€§ã‚’ä¿ã¡ã¤ã¤ã€æœŸå¾…é€šã‚Šã®å‹•ä½œã‚’å®Ÿç¾ã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 13:55:12*

timer ã§ã‚„ã‚‹ã¹ãå‡¦ç†ãªã®ã‹ãŒç–‘å•ã§ã€playerã‹ã‚‰ã†ã¾ãå–å¾—ã—ã¦ã§ããªã„ã®ã‹ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 13:55:56*

SwiftUIã§`AVAudioPlayer`ã®ã‚ˆã†ãªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å†ç”Ÿä½ç½®ï¼ˆcurrentTimeï¼‰ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§UIã«åæ˜ ã•ã›ãŸã„å ´åˆã€ç¢ºã‹ã«ã‚¿ã‚¤ãƒãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã®ã¯ä¸€èˆ¬çš„ãªæ–¹æ³•ã§ã™ã€‚ãŸã ã—ã€ã‚‚ã†å°‘ã—åŠ¹ç‡çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’å–ã‚ŠãŸã„å ´åˆã¯ã€`AVAudioPlayer`ã®ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚’åˆ©ç”¨ã™ã‚‹æ–¹æ³•ã‚‚è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€SwiftUIã§ã¯ãƒ‡ãƒªã‚²ãƒ¼ãƒˆãƒ™ãƒ¼ã‚¹ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ãã®ã¾ã¾é©ç”¨ã™ã‚‹ã®ãŒé›£ã—ã„ãŸã‚ã€ã‚¿ã‚¤ãƒãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒç›´æ¥çš„ã§ã‚·ãƒ³ãƒ—ãƒ«ãªè§£æ±ºç­–ã¨ãªã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚

### ãªãœã‚¿ã‚¤ãƒãƒ¼ã‚’ä½¿ã†ã®ã‹ï¼Ÿ
`AVAudioPlayer`ã«ã¯ç¾åœ¨ã®å†ç”Ÿæ™‚é–“ã‚’è‡ªå‹•ã§ç›£è¦–ã™ã‚‹ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€å®šæœŸçš„ã«å†ç”Ÿæ™‚é–“ã‚’ãƒãƒ¼ãƒªãƒ³ã‚°ã™ã‚‹ãŸã‚ã«ã‚¿ã‚¤ãƒãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€UIã®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãŒå†ç”Ÿä¸­ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®ç¾åœ¨ä½ç½®ã‚’æ­£ç¢ºã«åæ˜ ã§ãã¾ã™ã€‚

### ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚’ä½¿ã£ãŸã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
ã‚‚ã—`AVAudioPlayer`ã®ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚’åˆ©ç”¨ã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒãƒ³ãƒ‰ãƒ«ã§ãã‚‹å ´åˆï¼ˆä¾‹ãˆã°ã€æ›²ãŒçµ‚äº†ã—ãŸæ™‚ãªã©ï¼‰ã€ãã®ã‚¤ãƒ™ãƒ³ãƒˆã«å¿œã˜ã¦UIã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã¯å¯èƒ½ã§ã™ãŒã€å†ç”Ÿä¸­ã®æ™‚é–“ã®æ›´æ–°ï¼ˆç§’ã”ã¨ãªã©ï¼‰ã‚’ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‹ã‚‰è¡Œã†ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã®ã‚µãƒãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€ã‚¿ã‚¤ãƒãƒ¼ã‚’ä½¿ã†æ–¹ãŒç›´æ¥çš„ã§ç¢ºå®Ÿã§ã™ã€‚

### ä»–ã®æ–¹æ³•
ã‚‚ã—`Combine`ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€`AVPlayer`ï¼ˆ`AVAudioPlayer`ã‚ˆã‚Šã‚‚ä¸€èˆ¬çš„ã«ãƒ“ãƒ‡ã‚ªã¨ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®ä¸¡æ–¹ã«ä½¿ã‚ã‚Œã‚‹ï¼‰ã¨çµ„ã¿åˆã‚ã›ã¦ã€`Publisher`ã‚’åˆ©ç”¨ã—ãŸæ™‚é–“ã®æ›´æ–°ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€`Timer`ã®ä½¿ç”¨ã‚’é¿ã‘ã€ã‚ˆã‚Šãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚`AVPlayer`ã¯å†ç”Ÿæ™‚é–“ã®å¤‰æ›´ã‚’ç›£è¦–ã™ã‚‹ãŸã‚ã®`Publisher`ã‚’æä¾›ã—ã¦ãŠã‚Šã€ã“ã‚Œã‚’SwiftUIã®ãƒ“ãƒ¥ãƒ¼ã«ç›´æ¥ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

```swift
import SwiftUI
import AVFoundation
import Combine

struct AudioPlayerView: View {
    private var player: AVPlayer
    private var timeObserverToken: Any?
    
    @State private var currentTime: TimeInterval = 0
    @State private var duration: TimeInterval = 0
    var audioUrl: URL
    
    init(audioUrl: URL) {
        self.audioUrl = audioUrl
        self.player = AVPlayer(url: audioUrl)
        self.duration = (player.currentItem?.asset.duration.seconds) ?? 0
    }
    
    var body: some View {
        VStack {
            Slider(value: $currentTime, in: 0...duration, onEditingChanged: sliderEditingChanged)
            HStack {
                Text(formatTime(time: currentTime))
                Spacer()
                Text(formatTime(time: duration))
            }
            Button("Play/Pause") {
                if player.timeControlStatus == .playing {
                    player.pause()
                } else {
                    player.play()
                }
            }
        }
        .onAppear {
            addPeriodicTimeObserver()
        }
        .onDisappear {
            if let token = timeObserverToken {
                player.removeTimeObserver(token)
                timeObserverToken = nil
            }
        }
        .padding()
    }
    
    func addPeriodicTimeObserver() {
        // Notify every half second
        let interval = CMTime(seconds: 0.5, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }
    }
    
    func sliderEditingChanged(editingStarted: Bool) {
        if editingStarted {
            player.pause()
        } else {
            let newTime = CMTime(seconds: currentTime, preferredTimes

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 13:56:31*

cale: 600)
            player.seek(to: newTime)
            player.play()
        }
    }

    func formatTime(time: TimeInterval) -> String {
        let minutes = Int(time) / 60 % 60
        let seconds = Int(time) % 60
        return String(format: "%02i:%02i", minutes, seconds)
    }
}
```

ã“ã®ã‚ˆã†ã«ã€`AVPlayer`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€å†ç”Ÿæ™‚é–“ã®æ›´æ–°ã‚’ã‚ˆã‚ŠåŠ¹ç‡çš„ã«è¡Œã†ã“ã¨ãŒå¯èƒ½ã§ã™ãŒã€ã“ã®å ´åˆã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚¡ã‚¤ãƒ«å°‚ç”¨ã§ã¯ãªããªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 13:59:24*

MVVMã£ã½ãã—ã¦ã»ã—ã„ã€‚æ™®é€šã®Combineã«ãªã‚‹ã¹ãã—ã¦ã»ã—ã„ã®ã¨ãªã‚‹ã¹ãSwift  Concurrencyã«å¯¾å¿œã—ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 14:00:00*

SwiftUIã¨Combineã‚’åˆ©ç”¨ã—ã¦ã€MVVMã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨Swift Concurrencyã«å¯¾å¿œã—ãŸã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ§‹ç¯‰æ–¹æ³•ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯ã€`ViewModel`ãŒãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã¨çŠ¶æ…‹ç®¡ç†ã‚’æ‹…å½“ã—ã€`View`ã¯UIã®è¡¨ç¤ºã®ã¿ã‚’è¡Œã„ã¾ã™ã€‚ã¾ãŸã€`Combine`ã¨`AVPlayer`ã‚’ä½¿ã£ã¦ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ã‚’ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ç®¡ç†ã—ã¾ã™ã€‚

### ViewModelã®è¨­è¨ˆ
`AudioPlayerViewModel`ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¦ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ã‚’ç®¡ç†ã—ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã¯`ObservableObject`ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®Ÿè£…ã—ã€`Published`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’é€šã˜ã¦ãƒ“ãƒ¥ãƒ¼ã«çŠ¶æ…‹ã®å¤‰åŒ–ã‚’é€šçŸ¥ã—ã¾ã™ã€‚

```swift
import Foundation
import Combine
import AVFoundation

class AudioPlayerViewModel: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []
    private var timeObserverToken: Any?

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        let interval = CMTime(seconds: 0.5, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }

    deinit {
        if let token = timeObserverToken {
            player?.removeTimeObserver(token)
        }
        player?.pause()
        cancellables.forEach { $0.cancel() }
    }
}
```

### Viewã®è¨­è¨ˆ
`ViewModel`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æŒã¡ã€ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤ºã«ã®ã¿é›†ä¸­ã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ“ä½œã«å¿œã˜ã¦`ViewModel`ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ãƒ“ãƒ¥ãƒ¼ã¨ãƒ¢ãƒ‡ãƒ«ã®è²¬ä»»ã‚’åˆ†é›¢ã—ã¾ã™ã€‚

```swift
import SwiftUI

struct AudioPlayerView: View {
    @StateObject private var viewModel: AudioPlayerViewModel

    init(audioUrl: URL) {
        _viewModel = StateObject(wrappedValue: AudioPlayerViewModel(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $viewModel.currentTime, in: 0...viewModel.duration) { editing in
                if editing {
                    viewModel.seek(to: viewModel.currentTime)
                }
            }
            HStack {
                Text(formatTime(time: viewModel.currentTime))
                Spacer()
                Text(formatTime(time: viewModel.duration))
            }
            Button(viewModel.isPlaying ? "Pause" : "Play") {
                viewModel.playPauseAction()
            }
        }
        .padding()
    }

    func formatTime(time: TimeInterval) -> String {
        let minutes = Int(time) / 60 % 60
        let seconds = Int(time) % 60
        return String(format: "%02i:%02i", minutes, seconds)
    }
}
```

ã“ã®è¨­è¨ˆã§ã¯ã€`ViewModel`ãŒAVPlayerã®åˆ¶å¾¡ã¨çŠ¶æ…‹ç®¡ç†ã‚’æ‹…å½“ã—ã€`View`ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®è¡¨ç¤ºã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®å—ã‘å–ã‚Šã«å°‚å¿µã—ã¾ã™ã€‚ã¾ãŸã€Combineã‚’ä½¿ç”¨ã—ã¦ã€éåŒæœŸå‡¦ç†ã‚„çŠ¶æ…‹ã®

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 14:00:09*

å¤‰æ›´ã‚’åŠ¹ç‡çš„ã«æ‰±ã„ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 14:32:56*

ä¿®æ­£ã—ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ãŸã€‚ä»¥ä¸‹ã‚’å¯¾å¿œã—ã¦ã»ã—ã„ã€‚

ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’ã‚‚ã£ã¨æ»‘ã‚‰ã‹ã«ã—ã¦ã»ã—ã„ã€‚

æœ€å¾Œã¾ã§å†ç”Ÿã—ãŸã‚‰ã€å†ç”Ÿãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã—ã¦ã€å†ç”Ÿãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸã‚‰æœ€åˆã‹ã‚‰å†ç”Ÿã™ã‚‹ã‚ˆã†ã«ã—ã¦ã»ã—ã„ã€‚

ã¾ãŸã€å†ç”Ÿä¸­ã«seek barã‚’å‹•ã‹ã—ã¦é›¢ã—ãŸã‚‰ã€é›¢ã—ãŸã¨ã“ã‚ã‹ã‚‰å†ç”Ÿã—ã¦ã»ã—ã„ã€‚
ãƒãƒ¼ã‚ºä¸­ã«seek barã‚’å‹•ã‹ã—ã¦é›¢ã—ã¦ã‚‚å†ç”Ÿã¯é–‹å§‹ã—ãªã„ã§ã»ã—ã„ã€‚

import Foundation
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    private var timeObserverToken: Any?

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.audioUrl = audioUrl
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        let interval = CMTime(seconds: 0.5, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}

import SwiftUI

@MainActor
struct AudioPlayerView: View {
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $presenter.currentTime, in: 0...presenter.duration) { editing in
                if editing {
                    presenter.seek(to: presenter.currentTime)
                }
            }
            HStack {
                Text(presenter.currentTime.mmss)
                Spacer()
                Text(presenter.duration.mmss)
            }
            Spacer()
            Button {
                presenter.playPauseAction()
            } label: {
                if presenter.isPlaying {
                    SFSymbols.pauseFill.image
                        .font(.largeTitle)
                } else {
                    SFSymbols.playFill.image
                        .font(.largeTitle)
                }
            }
        }
        .padding()
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
    }
}

#Preview {
    AudioPlayerView(audioUrl: URL(string: "https://amachamusic.chagasi.com/mp3/ukiukilalala.mp3")!)
        .navigationStacked()
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 14:33:35*

The requirements you outlined involve making the slider interaction smoother and managing playback states effectively, particularly after seeking and when playback finishes. I'll provide a detailed solution to handle these specific requirements in your `AudioPlayerPresenter` and `AudioPlayerView`:

### Modifications in `AudioPlayerPresenter`

1. **Making Slider Smoother**: Reduce the update interval for the time observer to make the slider update more smoothly.
2. **Handling Playback Completion**: Detect when playback has completed and update the `isPlaying` state accordingly.
3. **Enhanced Seeking Logic**: Implement logic to handle playback continuation based on whether the playback was paused or playing before seeking started.

Here's how you can modify the `AudioPlayerPresenter`:

```swift
import Foundation
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    private let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []
    private var timeObserverToken: Any?
    private var wasPlayingBeforeSeek = false

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
        let item = AVPlayerItem(url: audioUrl)
        self.player = AVPlayer(playerItem: item)
        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        let interval = CMTime(seconds: 0.1, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .sink { [weak self] _ in
                self?.isPlaying = false
                self?.player?.seek(to: .zero) { _ in
                    self?.currentTime = 0
                }
            }
            .store(in: &cancellables)

        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func seek(to time: TimeInterval, shouldPlayAfterSeek: Bool) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime) { [weak self] _ in
            if shouldPlayAfterSeek {
                self?.player?.play()
                self?.isPlaying = true
            }
        }
    }
}
```

### Modifications in `AudioPlayerView`

The view needs to update to handle the logic of when to continue playing after seeking and managing button states based on playback status.

```swift
import SwiftUI

@MainActor
struct AudioPlayerView: View {
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $presenter.currentTime, in: 0...presenter.duration, onEditingChanged: handleSliderEditingChanged)
            HStack {
                Text(presenter.currentTime.mmss)
                Spacer()
                Text(presenter.duration.mmss)
            }
            Spacer()
            Button {
                presenter.playPauseAction()
            } label: {
                Image(systemName: presenter.isPlaying ? "pause.fill" : "play.fill")
                    .font(.largeTitle)
            }
        }
        .padding()
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
    }

    private func handleSliderEditingChanged(editingStarted: Bool) {
        if editingStarted {
            presenter.wasPlayingBeforeSeek = presenter.isPlaying
            if presenter.isPlaying {
                presenter.player?.pause()
            }
        } else {
            presenter.seek(to: presenter.currentTime, shouldPlayAfterSeek: presenter.wasPlayingBeforeSeek)
        }
    }
}
```

These modifications include:
- A smoother slider update frequency.
- Handling completion of playback by resetting the playback position and updating the UI to show the play button.
- Enhanced seek logic that respects whether playback was active before seeking started, and only resumes playing if it was previously playing.

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 14:34:09*

AudioPlayerView å´ã«ã¯ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å…¥ã‚ŒãŸããªã„ã€‚handleSliderEditingChangedã®ã‚ˆã†ãªå‡¦ç†ã¯presenterã«ç§»è¡Œã—ã¦ã»ã—ã„ã€‚

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 14:34:49*

To adhere to the principles of the MVVM pattern and keep the `AudioPlayerView` free from business logic, you can transfer the responsibility of managing slider interactions, including determining if playback should resume after seeking, directly to the `AudioPlayerPresenter`. Here's how you can refactor the code to move the `handleSliderEditingChanged` logic into the `Presenter`:

### Updated `AudioPlayerPresenter`

You will enhance the `AudioPlayerPresenter` by introducing a new method to manage the seek behavior and encapsulate the decision about whether to resume playing after the seek completes.

```swift
import Foundation
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    private let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []
    private var timeObserverToken: Any?
    private var wasPlayingBeforeSeek = false

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
        let item = AVPlayerItem(url: audioUrl)
        self.player = AVPlayer(playerItem: item)
        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        let interval = CMTime(seconds: 0.1, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .sink { [weak self] _ in
                self?.isPlaying = false
                self?.player?.seek(to: .zero) { _ in
                    self?.currentTime = 0
                }
            }
            .store(in: &cancellables)

        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func handleSeek(sliderEditingStarted: Bool, desiredTime: TimeInterval) {
        if sliderEditingStarted {
            wasPlayingBeforeSeek = isPlaying
            player?.pause()
        } else {
            let cmTime = CMTime(seconds: desiredTime, preferredTimescale: 600)
            player?.seek(to: cmTime) { [weak self] _ in
                if self?.wasPlayingBeforeSeek == true {
                    self?.player?.play()
                    self?.isPlaying = true
                }
            }
        }
    }
}
```

### Updated `AudioPlayerView`

With the `AudioPlayerPresenter` handling all business logic, `AudioPlayerView` can be streamlined to simply call these methods without needing to know the details of the audio playback state management.

```swift
import SwiftUI

@MainActor
struct AudioPlayerView: View {
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $presenter.currentTime, in: 0...presenter.duration, onEditingChanged: presenter.handleSeek)
            HStack {
                Text(presenter.currentTime.mmss)
                Spacer()
                Text(presenter.duration.mmss)
            }
            Spacer()
            Button {
                presenter.playPauseAction()
            } label: {
                Image(systemName: presenter.isPlaying ? "pause.fill" : "play.fill")
                    .font(.largeTitle)
            }
        }
        .padding()
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
    }
}
```

This refactoring ensures that `AudioPlayerView` remains focused solely on rendering the UI based on the state managed by `AudioPlayerPresenter`, with no business logic within the view itself. The view now simply calls the appropriate methods on the presenter based on user interactions.

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 14:35:26*

timeObserverToken ã£ã¦å¿…è¦ãªã®ã‹ãªï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 14:35:51*

The `timeObserverToken` in your `AudioPlayerPresenter` serves a specific purpose in managing resources related to updating the playback time in your audio player. It's particularly important when using the `addPeriodicTimeObserver(forInterval:queue:using:)` method of `AVPlayer`. Here's why it's needed and how it functions:

### Purpose of `timeObserverToken`

1. **Resource Management**: The token represents a periodic observer added to an `AVPlayer` instance. This observer is called at the specified intervals to update the UI (in your case, updating the `currentTime` of the playback). The `timeObserverToken` ensures that you have a handle to this observer so you can remove it when it's no longer needed, preventing potential memory leaks or unintended updates when the view or view model is disposed of.

2. **Removing Observer**: Without properly removing the observer using this token, the observer might continue to be called even after the player or its view/model is no longer in use. This can lead to crashes or unexpected behaviors, as the observer might try to update state on an object that has been deallocated or is in an invalid state.

### Is `timeObserverToken` Necessary?

Yes, it's necessary if you are adding a periodic time observer to `AVPlayer`. Hereâ€™s how you typically manage it:

- **Add Observer**: When you set up the player and add the observer, you store the returned value (the token) so that you can reference this specific observer later.
  
- **Remove Observer**: When your view or view model is about to be deallocated or when you're done with the player (e.g., user navigates away from the view or the player is no longer needed), you use this token to remove the observer from the `AVPlayer`. This is typically done in the `deinit` method of your view model or before you set the player to nil.

Here's a refined example to emphasize how `timeObserverToken` is managed:

```swift
deinit {
    if let token = timeObserverToken {
        player?.removeTimeObserver(token)
    }
    player?.pause()
    cancellables.forEach { $0.cancel() }
}
```

### Conclusion

If you are managing the player's state or need to update the UI in real-time with the progress of audio or video playback, then managing `timeObserverToken` properly is essential for clean and safe code. It prevents the continuation of unnecessary computations and updates, aligning with best practices for resource management in iOS development. If you decide to remove this functionality, make sure to address any potential resource leaks or dangling pointers that might occur as a result.

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 14:36:15*

timeObserverToken ã¯ Combineã§cancellables ã«çµ±ä¸€ã§ããªã„ã®ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 14:36:42*

In the context of `AVPlayer` and its usage with Combine in Swift, the management of `timeObserverToken` cannot be directly integrated into a `Combine` `cancellables` set. This is due to the nature of the observer and how it is managed within the AVFoundation framework.

### Why `timeObserverToken` Cannot Be Managed by `Combine`'s `Cancellables`

1. **Different Management Mechanisms**: The `timeObserverToken` returned by `AVPlayer.addPeriodicTimeObserver(forInterval:queue:using:)` is not a `Combine` `Subscription`. Instead, it's an opaque type that represents a registered observer within the `AVPlayer`. This observer must be explicitly removed by calling `AVPlayer.removeTimeObserver(_:)` using this token.

2. **Type Mismatch**: `Combine`'s `AnyCancellable` handles instances of `Subscription`, which conform to the `Cancellable` protocol. The `timeObserverToken` does not conform to this protocol and cannot be directly added to the `cancellables` set.

### Workaround to Manage `timeObserverToken` Alongside `Combine`'s `Cancellables`

However, you can still manage the lifecycle of your `timeObserverToken` in a way that aligns with the lifecycle management of your `Combine` subscriptions. You can wrap the removal of the observer in a `Cancellable` closure that can be stored in your `cancellables` set:

```swift
import Combine
import AVFoundation

class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []
    private var timeObserverToken: Any?

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.player = AVPlayer(playerItem: item)
        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        let interval = CMTime(seconds: 0.1, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

        // Ensure the observer is removed when the view model is deallocated
        AnyCancellable {
            [weak player, timeObserverToken] in
            if let token = timeObserverToken {
                player?.removeTimeObserver(token)
            }
        }.store(in: &cancellables)
    }

    deinit {
        player?.pause()
        cancellables.forEach { $0.cancel() }
    }

    // Additional methods...
}
```

### Explanation

In this setup, when you create the `timeObserverToken`, you also create an `AnyCancellable` that captures this token. The closure for removing the time observer is stored in your `cancellables` set. When the `cancellables` are cancelled (such as in the `deinit` method or when explicitly clearing the set), it will execute the closure that removes the time observer.

This approach allows you to manage both your `Combine` subscriptions and the `AVPlayer` time observer in a unified way, leveraging the automatic cancellation mechanism provided by `Combine` to ensure all resources are cleaned up appropriately.

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 15:14:56*

preferredTimescale ã¨ã¯ä½•ã‹ã¤ã„ã¦æ•™ãˆã¦ã»ã—ã„



import Foundation
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false
    private var isEnded: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    private var timeObserverToken: Any?

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.audioUrl = audioUrl
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        let interval = CMTime(seconds: 0.05, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.isPlaying = false
                self?.isEnded = true
            }
            .store(in: &cancellables)

        // å†ç”Ÿæº–å‚™ãŒå®Œäº†ã—ãŸã‚‰å†ç”Ÿæ™‚é–“ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                switch status {
                case .readyToPlay:
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                case .unknown, .failed:
                    break
                @unknown default:
                    break
                }
            }
            .store(in: &cancellables)
    }

    func onTapPlay() {
        if isEnded {
            player?.seek(to: .zero)
        }
        player?.play()
        isPlaying = true
    }
    
    func onTapPause() {
        player?.pause()
        isPlaying = false
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}

import SwiftUI

@MainActor
struct AudioPlayerView: View {
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $presenter.currentTime, in: 0...presenter.duration) { editing in
                if editing {
                    presenter.seek(to: presenter.currentTime)
                }
            }
            
            HStack {
                Text(presenter.currentTime.mmss)
                Spacer()
                Text(presenter.duration.mmss)
            }
            
            Spacer()

            if presenter.isPlaying {
                Button {
                    presenter.onTapPause()
                } label: {
                    SFSymbols.pauseFill.image
                            .font(.largeTitle)
                }
            } else {
                Button {
                    presenter.onTapPlay()
                } label: {
                    SFSymbols.playFill.image
                        .font(.largeTitle)
                }
            }
        }
        .padding()
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
    }
}

#Preview {
    AudioPlayerView(audioUrl: URL(string: "https://amachamusic.chagasi.com/mp3/ukiukilalala.mp3")!)
        .navigationStacked()
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 15:15:01*

In the context of `AVFoundation` and particularly when working with `CMTime`, the `preferredTimescale` parameter is a critical part of how you specify the time value's precision and accuracy. Here's an explanation of what `preferredTimescale` is and why it's important:

### What is `preferredTimescale`?

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 15:15:06*

æ—¥æœ¬èªã§ãŠé¡˜ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 15:15:40*

`preferredTimescale`ï¼ˆå„ªå…ˆã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã¯ã€`AVFoundation` ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å†…ã® `CMTime` æ§‹é€ ä½“ã§ä½¿ç”¨ã•ã‚Œã‚‹æ¦‚å¿µã§ã€æ™‚é–“ã®ç²¾åº¦ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ç”¨ã„ã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€1ç§’ã‚’ã©ã‚Œã ã‘ã®å˜ä½ã§åˆ†å‰²ã™ã‚‹ã‹ã‚’ç¤ºã—ã¾ã™ã€‚

### `preferredTimescale` ã®å½¹å‰²ã¨é‡è¦æ€§

1. **æ™‚é–“ã®ç²¾åº¦**: `preferredTimescale` ã®å€¤ãŒå¤§ãã„ã»ã©ã€ã‚ˆã‚Šé«˜ç²¾åº¦ãªæ™‚é–“è¡¨ç¾ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€`preferredTimescale` ãŒ 600 ã§ã‚ã‚Œã°ã€1ç§’ã¯600ã®å˜ä½ã«åˆ†å‰²ã•ã‚Œã€å„å˜ä½ã¯1/600ç§’ã‚’è¡¨ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€éå¸¸ã«çŸ­ã„æ™‚é–“é–“éš”ã§ã®æ“ä½œãŒå¯èƒ½ã«ãªã‚Šã€ç‰¹ã«ãƒ“ãƒ‡ã‚ªã‚„ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®ç·¨é›†ã€å‡¦ç†ã«ãŠã„ã¦ç²¾åº¦ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹å ´åˆã«æœ‰åŠ¹ã§ã™ã€‚

2. **å‹•ç”»ã‚„ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®åŒæœŸ**: é«˜ã„ã‚¿ã‚¤ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€å‹•ç”»ã‚„ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ­£ç¢ºã«åŒæœŸã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€ç·¨é›†ã‚„å†ç”Ÿã«ãŠã„ã¦ãƒ•ãƒ¬ãƒ¼ãƒ å˜ä½ã§æ­£ç¢ºãªä½ç½®ã‚’ç‰¹å®šã™ã‚‹éš›ã«é‡è¦ã§ã™ã€‚

3. **`AVPlayer` ã®ä½¿ç”¨ä¾‹**: `AVPlayer` ã§ç‰¹å®šã®æ™‚é–“ã«ã‚·ãƒ¼ã‚¯ã™ã‚‹å ´åˆã‚„ã€å‹•ç”»ã®ç‰¹å®šã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹éš›ã« `CMTime` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã®ã¨ãã€`preferredTimescale` ã‚’é©åˆ‡ã«è¨­å®šã™ã‚‹ã“ã¨ã§ã€æ±‚ã‚ã¦ã„ã‚‹æ™‚é–“ã‚„ãƒ•ãƒ¬ãƒ¼ãƒ ã«æ­£ç¢ºã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

### å®Ÿè£…ä¾‹

ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ä¾‹ã§ã¯ã€`preferredTimescale` ã‚’ `NSEC_PER_SEC`ï¼ˆãƒŠãƒç§’å˜ä½ã€ã™ãªã‚ã¡ 1 ç§’ = 10å„„ï¼‰ã¨è¨­å®šã—ã¦ã„ã‚‹å ´æ‰€ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯éå¸¸ã«é«˜ç²¾åº¦ã§æ™‚é–“ã‚’æ‰±ã†ãŸã‚ã®è¨­å®šã§ã‚ã‚Šã€éå¸¸ã«çŸ­ã„é–“éš”ã§æ›´æ–°ã‚„ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚‹å ´åˆã«é©ã—ã¦ã„ã¾ã™ã€‚ã¾ãŸã€åˆ¥ã®ç®‡æ‰€ã§ 600 ã‚’ä½¿ç”¨ã—ã¦ãŠã‚Šã€ã“ã‚Œã¯1ç§’ã‚’600ç­‰åˆ†ã™ã‚‹è¨­å®šã§ã€å¤šãã®ãƒ“ãƒ‡ã‚ªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§æ¨™æº–çš„ã«ç”¨ã„ã‚‰ã‚Œã‚‹å€¤ã§ã™ã€‚

ã“ã‚Œã‚‰ã®å€¤ã‚’é¸ã¶éš›ã«ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¦æ±‚ã™ã‚‹ç²¾åº¦ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãƒãƒ©ãƒ³ã‚¹ã‚’è€ƒæ…®ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚éå¸¸ã«é«˜ã„ç²¾åº¦ã‚’è¨­å®šã™ã‚‹ã¨ã€å‡¦ç†ã«å¿…è¦ãªãƒªã‚½ãƒ¼ã‚¹ãŒå¢—åŠ ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 15:50:55*

ã“ã†ãªã£ãŸã€‚ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å‹•ã‹ã—ã¦ã‚‚å†ç”Ÿæ™‚é–“ãŒå¤‰æ›´ã•ã‚Œãªã‹ã£ãŸã€‚ã©ã†ã™ã‚Œã°ã„ã„ã®ã‹ï¼Ÿ

import Foundation
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isLoading: Bool = false
    @Published var isPlaying: Bool = false
    private var isEnded: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    private var timeObserverToken: Any?

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }
    
    func onApper() {
        isLoading = true
        defer {
            isLoading = false
        }
        
        let item = AVPlayerItem(url: audioUrl)
        player = AVPlayer(playerItem: item)
        duration = item.asset.duration.seconds

        let interval = CMTime(seconds: 0.1, preferredTimescale: 600)
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                self?.isPlaying = false
                self?.isEnded = true
            }
            .store(in: &cancellables)

        // å†ç”Ÿæº–å‚™ãŒå®Œäº†ã—ãŸã‚‰å†ç”Ÿæ™‚é–“ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                switch status {
                case .readyToPlay:
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                case .unknown, .failed:
                    break
                @unknown default:
                    break
                }
            }
            .store(in: &cancellables)
    }

    func onTapPlay() {
        if isEnded {
            player?.seek(to: .zero)
        }
        player?.play()
        isPlaying = true
    }
    
    func onTapPause() {
        player?.pause()
        isPlaying = false
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}

import SwiftUI

@MainActor
struct AudioPlayerView: View {
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $presenter.currentTime, in: 0...presenter.duration) {
                EmptyView()
            } minimumValueLabel: {
                Text(presenter.currentTime.mmss)
            } maximumValueLabel: {
                Text(presenter.duration.mmss)
            } onEditingChanged: { editing in
                if editing {
                    presenter.seek(to: presenter.currentTime)
                }
            }

            Spacer()

            if presenter.isPlaying {
                Button {
                    presenter.onTapPause()
                } label: {
                    SFSymbols.pauseFill.image
                            .font(.largeTitle)
                }
            } else {
                Button {
                    presenter.onTapPlay()
                } label: {
                    SFSymbols.playFill.image
                        .font(.largeTitle)
                }
                .disabled(presenter.isLoading)
            }
        }
        .padding()
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
        .onAppear {
            presenter.onApper()
        }
    }
}

#Preview {
    AudioPlayerView(audioUrl: URL(string: "https://amachamusic.chagasi.com/mp3/ukiukilalala.mp3")!)
        .navigationStacked()
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 15:51:39*

ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å‹•ã‹ã—ã¦ã‚‚å†ç”Ÿæ™‚é–“ãŒå¤‰æ›´ã•ã‚Œãªã„å•é¡Œã«ã¤ã„ã¦ã€ã„ãã¤ã‹ã®ç‚¹ã‚’ç¢ºèªãŠã‚ˆã³ä¿®æ­£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¸»ã«ã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å‹•ä½œã‚’ãƒˆãƒªã‚¬ã™ã‚‹æ™‚ã«æ­£ç¢ºã«ã‚·ãƒ¼ã‚¯å‡¦ç†ãŒè¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®å‡¦ç†ã®èª¿æ•´ãŒå¿…è¦ã§ã™ã€‚

### 1. `onEditingChanged`ã®ä¿®æ­£
ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ãŒå¤‰æ›´ã•ã‚Œã‚‹ãŸã³ã«`seek(to:)`ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã¯ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ“ä½œãŒçµ‚äº†ã—ãŸæ™‚ã ã‘ã«é™å®šã™ã‚‹ã¹ãã§ã™ã€‚ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®æ“ä½œä¸­ã«ä½•åº¦ã‚‚ã‚·ãƒ¼ã‚¯ã‚’è¡Œã†ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å½±éŸ¿ã‚’åŠã¼ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’é›¢ã—ãŸã¨ãã®ä½ç½®ã«æ­£ç¢ºã«ã‚·ãƒ¼ã‚¯ã™ã‚‹æ–¹ãŒç›´æ„Ÿçš„ã§ã™ã€‚

### 2. `seek(to:)` ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè¡Œæ¡ä»¶
ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®æ“ä½œãŒçµ‚äº†ã—ãŸã¨ãï¼ˆ`editing`ãŒ`false`ã«ãªã£ãŸã¨ãï¼‰ã«ã®ã¿ã‚·ãƒ¼ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ä¿®æ­£ã—ã¾ã™ã€‚

### 3. `seek(to:)` ãƒ¡ã‚½ãƒƒãƒ‰ã®æ”¹å–„
ã‚·ãƒ¼ã‚¯æ“ä½œå¾Œã€ç‰¹ã«ã‚·ãƒ¼ã‚¯æ“ä½œãŒå®Œäº†ã™ã‚‹å‰ã«`currentTime`ãŒæ›´æ–°ã•ã‚Œã‚‹ã“ã¨ãŒãªã„ã‚ˆã†ã«ã€`player?.seek(to:cmTime, completionHandler:)`ã‚’ä½¿ç”¨ã—ã¦ã€ã‚·ãƒ¼ã‚¯ãŒå®Œäº†ã—ãŸã“ã¨ã‚’ç¢ºèªã—ã¦ã‹ã‚‰`currentTime`ã‚’æ›´æ–°ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

ä»¥ä¸‹ã«ä¿®æ­£å¾Œã®ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
func seek(to time: TimeInterval) {
    let cmTime = CMTime(seconds: time, preferredTimescale: 600)
    player?.seek(to: cmTime, toleranceBefore: .zero, toleranceAfter: .zero) { [weak self] completed in
        if completed {
            DispatchQueue.main.async {
                self?.currentTime = time
            }
        }
    }
}
```

### SwiftUIãƒ“ãƒ¥ãƒ¼ã®æ›´æ–°

```swift
Slider(value: $presenter.currentTime, in: 0...presenter.duration) {
    EmptyView()
} minimumValueLabel: {
    Text(presenter.currentTime.mmss)
} maximumValueLabel: {
    Text(presenter.duration.mmss)
} onEditingChanged: { editing in
    if !editing {  // ç·¨é›†ãŒçµ‚äº†ã—ãŸã¨ãã«ã®ã¿ã‚·ãƒ¼ã‚¯ã‚’å®Ÿè¡Œ
        presenter.seek(to: presenter.currentTime)
    }
}
```

ã“ã®ä¿®æ­£ã«ã‚ˆã‚Šã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®æ“ä½œãŒçµ‚äº†ã—ãŸã¨ãã«ã®ã¿ã‚·ãƒ¼ã‚¯ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã€ã‚ˆã‚Šæ»‘ã‚‰ã‹ã§æ­£ç¢ºãªã‚·ãƒ¼ã‚¯æ“ä½œãŒå¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚ã¾ãŸã€`seek(to:)`ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã‚·ãƒ¼ã‚¯ã®å®Œäº†ã‚’ç¢ºèªã—ã¦ã‹ã‚‰æ™‚é–“ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæœŸå¾…ã™ã‚‹æŒ™å‹•ã¨ä¸€è‡´ã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/10 16:02:03*

toleranceBefore: .zero, toleranceAfter: .zero ã¯ã©ã†ã„ã†æ„å‘³ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/10 16:02:35*

`toleranceBefore: .zero` ã¨ `toleranceAfter: .zero` ã®è¨­å®šã¯ã€`AVFoundation`ã®`AVPlayer`ã§ç‰¹å®šã®æ™‚é–“ã«ãƒ¡ãƒ‡ã‚£ã‚¢ã‚’ã‚·ãƒ¼ã‚¯ã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ã‚·ãƒ¼ã‚¯æ“ä½œã®ç²¾åº¦ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ç”¨ã„ã¾ã™ã€‚

### æ„å‘³ã¨æ©Ÿèƒ½

- **toleranceBefore**: ã‚·ãƒ¼ã‚¯ã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ™‚é–“ã®å‰ã«è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§æ™‚é–“ã§ã™ã€‚ä¾‹ãˆã°ã€`toleranceBefore: .zero` ã¨è¨­å®šã™ã‚‹ã¨ã€æŒ‡å®šã—ãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ™‚é–“ã‚ˆã‚Šå‰ã«ã¯ã‚·ãƒ¼ã‚¯ã—ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚é€†ã«ã€ã‚‚ã—5ç§’ã®è¨±å®¹ç¯„å›²ã‚’è¨­å®šã—ãŸå ´åˆï¼ˆ`toleranceBefore: CMTime(seconds: 5, preferredTimescale: 1)`ï¼‰ã€ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ™‚é–“ã®æœ€å¤§5ç§’å‰ã«ä½ç½®ã™ã‚‹é©åˆ‡ãªãƒ•ãƒ¬ãƒ¼ãƒ ã«ã‚·ãƒ¼ã‚¯ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

- **toleranceAfter**: ã‚·ãƒ¼ã‚¯ã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ™‚é–“ã®å¾Œã«è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§æ™‚é–“ã§ã™ã€‚`toleranceAfter: .zero` ã§è¨­å®šã™ã‚‹ã¨ã€æŒ‡å®šã—ãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ™‚é–“ã‚ˆã‚Šå¾Œã«ã¯ã‚·ãƒ¼ã‚¯ã—ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ã“ã®è¨±å®¹ç¯„å›²ã‚‚æ‹¡å¤§ã™ã‚‹ã“ã¨ã§ã€ã‚·ã‚¹ãƒ†ãƒ ãŒã‚ˆã‚Šæ—©ãå†ç”Ÿã‚’é–‹å§‹ã§ãã‚‹é©åˆ‡ãªãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒè¨±ã•ã‚Œã¾ã™ã€‚

### åˆ©ç”¨ã®ãƒ¡ãƒªãƒƒãƒˆ

ã“ã‚Œã‚‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ `zero` ã«è¨­å®šã™ã‚‹ã“ã¨ã§ã€`AVPlayer`ã¯æŒ‡å®šã—ãŸæ­£ç¢ºãªæ™‚é–“ã«å¯èƒ½ãªé™ã‚Šè¿‘ã„å ´æ‰€ã§å†ç”Ÿã‚’é–‹å§‹ã—ã‚ˆã†ã¨è©¦ã¿ã¾ã™ã€‚ã“ã‚Œã¯ç‰¹ã«ã€æ­£ç¢ºãªã‚·ãƒ¼ãƒ³ã‚„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆä¾‹ãˆã°ã€ãƒ“ãƒ‡ã‚ªç·¨é›†ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚„ã€ç‰¹å®šã®ç¬é–“ã‚’æ­£ç¢ºã«ãƒˆãƒªãƒŸãƒ³ã‚°ã™ã‚‹æ©Ÿèƒ½ï¼‰ã«ã¨ã£ã¦é‡è¦ã§ã™ã€‚

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¸ã®å½±éŸ¿

ãŸã ã—ã€`zero`ã«è¨­å®šã™ã‚‹ã“ã¨ã§ã€ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ãŒæ­£ç¢ºãªãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ¢ã™ãŸã‚ã«è¿½åŠ ã®æ™‚é–“ã‚’è¦ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ã‚„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–¹æ³•ã€ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜å ´æ‰€ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰ã«ã‚ˆã£ã¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãã®ãŸã‚ã€ã‚·ãƒ¼ã‚¯ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ã¨ç²¾åº¦ã®ãƒãƒ©ãƒ³ã‚¹ã‚’è€ƒæ…®ã—ã¦ã€è¨±å®¹ç¯„å›²ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ç·ã˜ã¦ã€ã“ã‚Œã‚‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã©ã®ã‚ˆã†ã«è¨­å®šã™ã‚‹ã‹ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦æ±‚ã«åŸºã¥ã„ã¦æ¤œè¨ã™ã‚‹ã¹ãã§ã™ã€‚

---
