# Dart enum 連想値

日付: 2025-01-17

---

## 👤 ユーザー
*2025/1/17 21:30:52*

Flutter って Swiftのように別々の連想値を持つ enumを定義できないの？

---

## 🤖 アシスタント
*2025/1/17 21:31:19*

Flutter（Dart）では、Swiftのように直接的に連想値を持つ`enum`はサポートされていません。ただし、以下の方法で同様の効果を実現できます。

### 1. クラスを使った実装
Dartでは、`sealed class`（または`abstract class`）を使って、複数の型や値を持つ列挙に似た構造を作成できます。

```dart
// Sealed class風の実装
sealed class AppState {}

class LoadingState extends AppState {}

class SuccessState extends AppState {
  final String message;
  SuccessState(this.message);
}

class ErrorState extends AppState {
  final String errorMessage;
  ErrorState(this.errorMessage);
}

// 使用例
void main() {
  AppState state = SuccessState("データ取得成功!");

  if (state is SuccessState) {
    print(state.message); // データ取得成功!
  } else if (state is ErrorState) {
    print(state.errorMessage);
  } else {
    print("ロード中...");
  }
}
```

### 2. EnumとMapの組み合わせ
`enum`には連想値を持たせられませんが、対応するデータを`Map`で管理できます。

```dart
enum AppStatus { loading, success, error }

void main() {
  Map<AppStatus, String> statusMessages = {
    AppStatus.loading: "ロード中...",
    AppStatus.success: "成功!",
    AppStatus.error: "エラー発生!"
  };

  AppStatus currentStatus = AppStatus.success;

  print(statusMessages[currentStatus]); // 成功!
}
```

### 3. Dart 3の`pattern matching`を活用
Dart 3以降では、パターンマッチングが追加されたので、状態管理に柔軟性が生まれます。

```dart
sealed class AppState {
  const AppState();
}

class Loading extends AppState {}

class Success extends AppState {
  final String message;
  const Success(this.message);
}

class Error extends AppState {
  final String error;
  const Error(this.error);
}

void main() {
  AppState state = const Success("データ取得成功!");

  switch (state) {
    case Loading():
      print("ロード中...");
      break;
    case Success(:var message):
      print("成功: $message");
      break;
    case Error(:var error):
      print("エラー: $error");
      break;
  }
}
```

### Swiftとの比較
Swiftの`enum`のように、直接的に連想値を持つ構造はありませんが、Dartの`sealed class`や`pattern matching`を使えば、同様の機能を柔軟に実現できます。Dart 3以降では、パターンマッチングの導入により、さらにスムーズにSwiftのようなコードが書けます。

---
