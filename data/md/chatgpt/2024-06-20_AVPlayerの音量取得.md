# AVPlayerã®éŸ³é‡å–å¾—

æ—¥ä»˜: 2024-06-20

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:13:48*

AVPlayer ã§å†ç”Ÿä¸­ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®éŸ³é‡ã‚’å–å¾—ã™ã‚‹æ–¹æ³•

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:14:15*

`AVPlayer` ã§å†ç”Ÿä¸­ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®éŸ³é‡ã‚’ç›´æ¥å–å¾—ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ãŒã€å†ç”Ÿã™ã‚‹ `AVPlayerItem` ã®éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯ã®ãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚’èª¿æ•´ã™ã‚‹ãŸã‚ã® `AVAudioMix` ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã®æ‰‹é †ã§ã€`AVPlayer` ã®éŸ³é‡ã‚’ç®¡ç†ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

1. `AVAudioMix` ã‚’è¨­å®šã—ã¦éŸ³é‡ã‚’å¤‰æ›´ã™ã‚‹æ–¹æ³•ï¼š

```swift
import AVFoundation

// AVPlayer ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
let player = AVPlayer()

// å†ç”Ÿã™ã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¨­å®š
if let url = URL(string: "https://www.example.com/audio.mp3") {
    let playerItem = AVPlayerItem(url: url)
    player.replaceCurrentItem(with: playerItem)
    
    // AVAudioMix ã‚’ä½¿ã£ã¦éŸ³é‡ã‚’è¨­å®š
    let audioMix = AVMutableAudioMix()
    let inputParameters = AVMutableAudioMixInputParameters(track: playerItem.tracks.first?.assetTrack)
    inputParameters.setVolume(0.5, at: CMTime.zero) // 0.5 ã¯éŸ³é‡ã®ä¾‹
    audioMix.inputParameters = [inputParameters]
    
    playerItem.audioMix = audioMix
}

// ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’å†ç”Ÿ
player.play()
```

2. `AVAudioSession` ã‹ã‚‰éŸ³é‡ã‚’å–å¾—ã™ã‚‹æ–¹æ³•ï¼š

```swift
import AVFoundation

let audioSession = AVAudioSession.sharedInstance()

do {
    try audioSession.setActive(true)
    let currentVolume = audioSession.outputVolume
    print("Current volume: \(currentVolume)")
} catch {
    print("Error activating audio session: \(error)")
}
```

`AVAudioSession` ã® `outputVolume` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ã†ã¨ã€ã‚·ã‚¹ãƒ†ãƒ ã®å‡ºåŠ›éŸ³é‡ã‚’å–å¾—ã§ãã¾ã™ã€‚ãŸã ã—ã€ã“ã‚Œã¯ãƒ‡ãƒã‚¤ã‚¹å…¨ä½“ã®éŸ³é‡ã§ã‚ã‚Šã€ç‰¹å®šã® `AVPlayer` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®éŸ³é‡ã‚’ç›´æ¥åæ˜ ã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ä¸Šè¨˜ã®æ–¹æ³•ã‚’çµ„ã¿åˆã‚ã›ã¦ã€`AVPlayer` ã®éŸ³é‡èª¿æ•´ã¨ç¾åœ¨ã®å‡ºåŠ›éŸ³é‡ã®ç®¡ç†ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚ç‰¹å®šã® `AVPlayer` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®éŸ³é‡ã‚’çŸ¥ã‚ŠãŸã„å ´åˆã¯ã€ã‚¢ãƒ—ãƒªã®ãƒ­ã‚¸ãƒƒã‚¯ã§ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€å†ç”Ÿæ™‚ã«è¨­å®šã™ã‚‹éŸ³é‡ã‚’è¿½è·¡ã™ã‚‹å¤‰æ•°ã‚’ä½œæˆã—ã€ãã‚Œã‚’ä½¿ç”¨ã—ã¦éŸ³é‡ã‚’ç¢ºèªã—ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:14:50*

ã“ã‚Œã¯ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è‡ªä½“ã®éŸ³é‡ï¼Ÿãã‚Œã¨ã‚‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®éŸ³é‡ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:15:28*

ä¸Šè¨˜ã®æ–¹æ³•ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®éŸ³é‡ï¼ˆ`AVPlayer` ã¾ãŸã¯ `AVAudioSession` ã®éŸ³é‡ï¼‰ã‚’åˆ¶å¾¡ãŠã‚ˆã³å–å¾—ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è‡ªä½“ã®éŸ³é‡ï¼ˆã¤ã¾ã‚Šã€å†ç”Ÿä¸­ã®ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«ã®éŸ³é‡ãƒ¬ãƒ™ãƒ«ï¼‰ã‚’ç›´æ¥å–å¾—ã™ã‚‹æ–¹æ³•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

å†ç”Ÿä¸­ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®éŸ³é‡ãƒ¬ãƒ™ãƒ«ï¼ˆéŸ³é‡ã®å¤§ãã•ï¼‰ã‚’å–å¾—ã—ãŸã„å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ã« `AVPlayer` ã¨ `AVAudioEngine` ã‚’çµ„ã¿åˆã‚ã›ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

### 1. `AVPlayer` ã¨ `AVAudioEngine` ã®è¨­å®š
`AVPlayer` ã‚’ `AVAudioEngine` ã«æ¥ç¶šã—ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’æ¸¬å®šã™ã‚‹ãŸã‚ã® `AVAudioNode` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```swift
import AVFoundation

class AudioPlayer {
    private var player: AVPlayer?
    private let audioEngine = AVAudioEngine()
    private let playerNode = AVAudioPlayerNode()
    private var meterTimer: Timer?

    init(url: URL) {
        let playerItem = AVPlayerItem(url: url)
        self.player = AVPlayer(playerItem: playerItem)

        setupAudioEngine()
    }

    private func setupAudioEngine() {
        guard let player = player else { return }

        let audioFormat = AVAudioFormat(standardFormatWithSampleRate: 44100, channels: 2)!
        audioEngine.attach(playerNode)
        audioEngine.connect(playerNode, to: audioEngine.mainMixerNode, format: audioFormat)

        let playerItem = player.currentItem!
        let asset = playerItem.asset
        let assetTracks = asset.tracks(withMediaType: .audio)

        guard let assetTrack = assetTracks.first else { return }

        do {
            let audioFile = try AVAudioFile(forReading: assetTrack.asset.url, commonFormat: .pcmFormatFloat32, interleaved: false)
            playerNode.scheduleFile(audioFile, at: nil, completionHandler: nil)
        } catch {
            print("Error reading audio file: \(error)")
        }

        startAudioEngine()
    }

    private func startAudioEngine() {
        do {
            try audioEngine.start()
            playerNode.play()
            startMetering()
        } catch {
            print("Error starting audio engine: \(error)")
        }
    }

    private func startMetering() {
        meterTimer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(updateMeters), userInfo: nil, repeats: true)
    }

    @objc private func updateMeters() {
        let node = audioEngine.mainMixerNode
        node.installTap(onBus: 0, bufferSize: 1024, format: node.outputFormat(forBus: 0)) { buffer, _ in
            buffer.frameLength = 1024
            let samples = buffer.floatChannelData![0]
            var avgValue: Float = 0

            for i in 0..<Int(buffer.frameLength) {
                avgValue += abs(samples[i])
            }
            avgValue = avgValue / Float(buffer.frameLength)

            DispatchQueue.main.async {
                print("Average Volume: \(avgValue)")
            }
        }
    }

    func play() {
        player?.play()
    }

    func stop() {
        player?.pause()
        meterTimer?.invalidate()
    }
}
```

### ä½¿ç”¨æ–¹æ³•
```swift
if let url = URL(string: "https://www.example.com/audio.mp3") {
    let audioPlayer = AudioPlayer(url: url)
    audioPlayer.play()
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ `AVPlayer` ã‚’ `AVAudioEngine` ã«æ¥ç¶šã—ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ¸¬å®šã—ã¾ã™ã€‚`updateMeters` ãƒ¡ã‚½ãƒƒãƒ‰ã§å®šæœŸçš„ã«éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—ã—ã¦ã€ç¾åœ¨ã®éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å†ç”Ÿä¸­ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:16:41*

ã‚ã‚ŠãŒã¨ã†ã€ä»¥ä¸‹ã® AudioPlayDriver ã® recordingVolumeLevelsSubject ã‚’æ›´æ–°ã™ã‚‹å‡¦ç†ã«ã†ã¾ãçµ„ã¿è¾¼ã‚“ã§ã»ã—ã„ã€‚


public final class AudioPlayDriver: AudioPlayDriverProtocol {
    private nonisolated(unsafe) var player: AVPlayer?
    private nonisolated(unsafe) var cancellables: Set&lt;AnyCancellable&gt; = \[\]
    private nonisolated(unsafe) let errorSubject = PassthroughSubject&lt;AppError, Never&gt;()
    private nonisolated(unsafe) let currentTimeSubject = CurrentValueSubject&lt;TimeInterval, Never&gt;(0.0)
    private nonisolated(unsafe) let durationSubject = CurrentValueSubject&lt;TimeInterval, Never&gt;(0.0)
    private nonisolated(unsafe) let isPlayingSubject = CurrentValueSubject&lt;Bool, Never&gt;(false)
    private nonisolated(unsafe) var recordingVolumeLevelsSubject = CurrentValueSubject&lt;Double, Never&gt;(0.0)

    private nonisolated(unsafe) let meteringTimerInterval: TimeInterval = 0.05
    private nonisolated(unsafe) var meteringTimer = Set&lt;AnyCancellable&gt;()

    public var errorPublisher: AnyPublisher&lt;AppError, Never&gt; {
        errorSubject.eraseToAnyPublisher()
    }

    public var currentTimePublisher: AnyPublisher&lt;TimeInterval, Never&gt; {
        currentTimeSubject.eraseToAnyPublisher()
    }

    public var durationPublisher: AnyPublisher&lt;TimeInterval, Never&gt; {
        durationSubject.eraseToAnyPublisher()
    }

    public var isPlayingPublisher: AnyPublisher&lt;Bool, Never&gt; {
        isPlayingSubject.eraseToAnyPublisher()
    }

    public var recordingVolumeLevelsPublisher: AnyPublisher&lt;Double, Never&gt; {
        recordingVolumeLevelsSubject.eraseToAnyPublisher()
    }

    public nonisolated(unsafe) let isSeekingSubject = CurrentValueSubject&lt;Bool, Never&gt;(false)

    public init() {
        OSLogger.initLog()
    }

    deinit {
        OSLogger.deinitLog()
    }

    public func prepareToPlay(url: URL) {
        let item = AVPlayerItem(url: url)
        player = AVPlayer(playerItem: item)

        // 0.1 ç§’ã”ã¨ã«å†ç”Ÿæ™‚åˆ»ã‚’é€šçŸ¥
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest(isPlayingSubject, isSeekingSubject)
            .filter { \_, isPlaying, isSeeking in
                isPlaying && !isSeeking // å†ç”Ÿä¸­ã‹ã¤seekã—ã¦ã„ãªã„ã¨ãã®ã¿æ›´æ–°
            }
            .map { \[weak self\] \_, \_, \_ in
                self?.player?.currentTime().seconds ?? 0
            }
            .assign(to: \\.value, on: currentTimeSubject)
            .store(in: &cancellables)

        // å†ç”Ÿæº–å‚™ãŒå®Œäº†ã—ãŸã‚‰å†ç”Ÿæ™‚é–“ã‚’é€šçŸ¥
        player?.currentItem?.publisher(for: \\.status)
            .receive(on: RunLoop.main)
            .compactMap { \[weak self\] status in
                switch status {
                case .readyToPlay:
                    return self?.player?.currentItem?.duration.seconds
                default:
                    return nil
                }
            }
            .assign(to: \\.value, on: durationSubject)
            .store(in: &cancellables)

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆ
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .sink { \[weak self\] \_ in
                guard let self else {
                    return
                }
                stopMeteringTimer()
                player?.seek(to: .zero)
                isPlayingSubject.send(false)
            }
            .store(in: &cancellables)

        // å†ç”Ÿã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­å®š
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \\(error)")
            errorSubject.send(error.toAppError)
        }
    }

    public func play() {
        startMeteringTimer()

        player?.play()
        isPlayingSubject.send(true)
    }

    public func pause() {
        stopMeteringTimer()

        player?.pause()
        isPlayingSubject.send(false)
    }

    public func seek(to time: TimeInterval) {
        isSeekingSubject.send(true)
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime) { \[weak self\] completed in
            guard let self else {
                return
            }
            if completed {
                currentTimeSubject.send(time)
                isSeekingSubject.send(false)
            } else {
                OSLogger.errorLog("seek failed")
                errorSubject.send(.customError("seek failed"))
                isSeekingSubject.send(false)
            }
        }
    }

    private func startMeteringTimer() {
        recordingVolumeLevelsSubject.value = 0.0

        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { \[weak self\] \_ in
                guard let self else {
                    return nil
                }
                // TODO: ãŸã ã—ãéŸ³é‡ã‚’å–ã‚‹ã‚ˆã†ã«ã™ã‚‹
                return nil
            }
            .assign(to: \\.value, on: recordingVolumeLevelsSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:17:49*

`AudioPlayDriver` ã‚¯ãƒ©ã‚¹ã«éŸ³é‡ãƒ¬ãƒ™ãƒ«ã®å–å¾—å‡¦ç†ã‚’çµ„ã¿è¾¼ã‚€ã«ã¯ã€`AVAudioEngine` ã¨ `AVAudioPlayerNode` ã‚’ä½¿ç”¨ã—ã¦ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä»¥ä¸‹ã®ã‚ˆã†ã« `AudioPlayDriver` ã‚¯ãƒ©ã‚¹ã‚’æ›´æ–°ã—ã¾ã™ã€‚

```swift
import AVFoundation
import Combine

public final class AudioPlayDriver: AudioPlayDriverProtocol {
    private nonisolated(unsafe) var player: AVPlayer?
    private nonisolated(unsafe) var cancellables: Set<AnyCancellable> = []
    private nonisolated(unsafe) let errorSubject = PassthroughSubject<AppError, Never>()
    private nonisolated(unsafe) let currentTimeSubject = CurrentValueSubject<TimeInterval, Never>(0.0)
    private nonisolated(unsafe) let durationSubject = CurrentValueSubject<TimeInterval, Never>(0.0)
    private nonisolated(unsafe) let isPlayingSubject = CurrentValueSubject<Bool, Never>(false)
    private nonisolated(unsafe) var recordingVolumeLevelsSubject = CurrentValueSubject<Double, Never>(0.0)
    private nonisolated(unsafe) let meteringTimerInterval: TimeInterval = 0.05
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()
    
    private let audioEngine = AVAudioEngine()
    private let playerNode = AVAudioPlayerNode()
    private var meterTimer: Timer?

    public var errorPublisher: AnyPublisher<AppError, Never> {
        errorSubject.eraseToAnyPublisher()
    }

    public var currentTimePublisher: AnyPublisher<TimeInterval, Never> {
        currentTimeSubject.eraseToAnyPublisher()
    }

    public var durationPublisher: AnyPublisher<TimeInterval, Never> {
        durationSubject.eraseToAnyPublisher()
    }

    public var isPlayingPublisher: AnyPublisher<Bool, Never> {
        isPlayingSubject.eraseToAnyPublisher()
    }

    public var recordingVolumeLevelsPublisher: AnyPublisher<Double, Never> {
        recordingVolumeLevelsSubject.eraseToAnyPublisher()
    }

    public nonisolated(unsafe) let isSeekingSubject = CurrentValueSubject<Bool, Never>(false)

    public init() {
        OSLogger.initLog()
    }

    deinit {
        OSLogger.deinitLog()
    }

    public func prepareToPlay(url: URL) {
        let item = AVPlayerItem(url: url)
        player = AVPlayer(playerItem: item)

        // Audio Engine Setup
        setupAudioEngine(with: url)

        // 0.1 ç§’ã”ã¨ã«å†ç”Ÿæ™‚åˆ»ã‚’é€šçŸ¥
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest(isPlayingSubject, isSeekingSubject)
            .filter { _, isPlaying, isSeeking in
                isPlaying && !isSeeking // å†ç”Ÿä¸­ã‹ã¤seekã—ã¦ã„ãªã„ã¨ãã®ã¿æ›´æ–°
            }
            .map { [weak self] _, _, _ in
                self?.player?.currentTime().seconds ?? 0
            }
            .assign(to: \.value, on: currentTimeSubject)
            .store(in: &cancellables)

        // å†ç”Ÿæº–å‚™ãŒå®Œäº†ã—ãŸã‚‰å†ç”Ÿæ™‚é–“ã‚’é€šçŸ¥
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .compactMap { [weak self] status in
                switch status {
                case .readyToPlay:
                    return self?.player?.currentItem?.duration.seconds
                default:
                    return nil
                }
            }
            .assign(to: \.value, on: durationSubject)
            .store(in: &cancellables)

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆ
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .sink { [weak self] _ in
                guard let self = self else { return }
                self.stopMeteringTimer()
                self.player?.seek(to: .zero)
                self.isPlayingSubject.send(false)
            }
            .store(in: &cancellables)

        // å†ç”Ÿã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­å®š
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            errorSubject.send(error.toAppError)
        }
    }

    public func play() {
        startMeteringTimer()
        player?.play()
        isPlayingSubject.send(true)
    }

    public func pause() {
        stopMeteringTimer()
        player?.pause()
        isPlayingSubject.send(false)
    }

    public func seek(to time: TimeInterval) {
        isSeekingSubject.send(true)
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime) { [weak self] completed in
            guard let self = self else { return }
            if completed {
                self.currentTimeSubject.send(time)
                self.isSeekingSubject.send(false)
            } else {
                OSLogger.errorLog("seek failed")
                self.errorSubject.send(.customError("seek failed"))
                self.isSeekingSubject.send(false)
            }
        }
    }

    private func setupAudioEngine(with url: URL) {
        let audioFormat = AVAudioFormat(standardFormatWithSampleRate: 44100, channels: 2)!
        audioEngine.attach(playerNode)
        audioEngine.connect(playerNode, to: audioEngine.mainMixerNode, format: audioFormat)

        do {
            let audioFile = try AVAudioFile(forReading: url)
            playerNode.scheduleFile(audioFile, at: nil, completionHandler: nil)
        } catch {
            OSLogger.errorLog("Error reading audio file: \(error)")
        }

        do {
            try audioEngine.start()
        } catch {
            OSLogger.errorLog("Error starting audio engine: \(error)")
        }
    }

    private func startMeteringTimer() {
        recordingVolumeLevelsSubject.value = 0.0

        audioEngine.mainMixerNode.installTap(onBus: 0, bufferSize: 1024, format: audioEngine.mainMixerNode.outputFormat(forBus: 0)) { [weak self] buffer, _ in
            guard let self = self else { return }
            buffer.frameLength = 1024
            let samples = buffer.floatChannelData![0]
            var avgValue: Float = 0

            for i in 0..<Int(buffer.frameLength) {
                avgValue += abs(samples[i])
            }
            avgValue = avgValue / Float(buffer.frameLength)

            DispatchQueue.main.async {
                self.recordingVolumeLevelsSubject.send(Double(avgValue))
            }
        }
        
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .sink { _ in }
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
        audioEngine.mainMixerNode.removeTap(onBus: 0)
    }
}
```

ã“ã®å®Ÿè£…ã§ã¯ã€`AVAudioEngine` ã¨ `AVAudioPlayerNode` ã‚’ä½¿ç”¨ã—ã¦ã€`AudioPlayDriver` ã® `recordingVolumeLevelsSubject` ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ›´æ–°ã—ã¾ã™ã€‚`startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰ã§ `AVAudioEngine` ã®ã‚¿ãƒƒãƒ—ã‚’è¨­å®šã—ã€ãƒãƒƒãƒ•ã‚¡ã‹ã‚‰éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—ã—ã¦ `recordingVolumeLevelsSubject` ã«é€ä¿¡ã—ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:22:11*

ã¡ãªã¿ã« Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect() ã®é–“éš”ã§ä»¥ä¸‹ã®ã‚ˆã†ãªå‡¦ç†ã‚’ã—ãŸã‹ã£ãŸã‚“ã ã‘ã©ã€‚

public enum AudioUtils {
    /// 0.0 ... 1.0
    public static func normalized(decibel: Double) -&gt; Double {
        let minDecibel: Double = -80.0 // -80dB ã‚’æœ€å°å€¤ã¨ã—ã¦ä½¿ç”¨
        let maxDecibel: Double = 0.0 // 0dB ã‚’æœ€å¤§å€¤ã¨ã—ã¦ä½¿ç”¨

        // åˆ†æ¯ãŒ0ã«ãªã‚‹ã‚±ãƒ¼ã‚¹ã‚’é¿ã‘ã‚‹
        guard abs(maxDecibel) != abs(minDecibel) else {
            return 0.0
        }

        // æ¯”ç‡ã®è¨ˆç®—
        let linearValue = (abs(decibel) - abs(minDecibel)) / (abs(maxDecibel) - abs(minDecibel))

        // æŒ‡æ•°é–¢æ•°çš„ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
        // å¤‰å½¢ã€å¯¾æ•°ã€æŒ‡æ•°ã§ã®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚’æ¯”è¼ƒã—ãŸã¨ã“ã‚ã€æŒ‡æ•°é–¢æ•°çš„ã‚¹ã‚±ãƒ¼ãƒ«ãŒå¤‰åŒ–ãŒã‚ã‹ã‚Šã‚„ã™ã‹ã£ãŸ
        let scaledValue = pow(linearValue, 2.0)

        // ä¸Šé™ã¨ä¸‹é™ã‚’è¨­å®šã—ã¦è¿”å´
        return max(0.0, min(1.0, scaledValue))
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:23:29*

äº†è§£ã—ã¾ã—ãŸã€‚`AudioPlayDriver` ã® `startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰ã« `AudioUtils` ã® `normalized(decibel:)` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦éŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’æ­£è¦åŒ–ã™ã‚‹å‡¦ç†ã‚’è¿½åŠ ã—ã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€`AudioPlayDriver` ã‚¯ãƒ©ã‚¹ã®æ›´æ–°ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã§ã™ï¼š

```swift
import AVFoundation
import Combine

public final class AudioPlayDriver: AudioPlayDriverProtocol {
    private nonisolated(unsafe) var player: AVPlayer?
    private nonisolated(unsafe) var cancellables: Set<AnyCancellable> = []
    private nonisolated(unsafe) let errorSubject = PassthroughSubject<AppError, Never>()
    private nonisolated(unsafe) let currentTimeSubject = CurrentValueSubject<TimeInterval, Never>(0.0)
    private nonisolated(unsafe) let durationSubject = CurrentValueSubject<TimeInterval, Never>(0.0)
    private nonisolated(unsafe) let isPlayingSubject = CurrentValueSubject<Bool, Never>(false)
    private nonisolated(unsafe) var recordingVolumeLevelsSubject = CurrentValueSubject<Double, Never>(0.0)
    private nonisolated(unsafe) let meteringTimerInterval: TimeInterval = 0.05
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()
    
    private let audioEngine = AVAudioEngine()
    private let playerNode = AVAudioPlayerNode()
    private var meterTimer: Timer?

    public var errorPublisher: AnyPublisher<AppError, Never> {
        errorSubject.eraseToAnyPublisher()
    }

    public var currentTimePublisher: AnyPublisher<TimeInterval, Never> {
        currentTimeSubject.eraseToAnyPublisher()
    }

    public var durationPublisher: AnyPublisher<TimeInterval, Never> {
        durationSubject.eraseToAnyPublisher()
    }

    public var isPlayingPublisher: AnyPublisher<Bool, Never> {
        isPlayingSubject.eraseToAnyPublisher()
    }

    public var recordingVolumeLevelsPublisher: AnyPublisher<Double, Never> {
        recordingVolumeLevelsSubject.eraseToAnyPublisher()
    }

    public nonisolated(unsafe) let isSeekingSubject = CurrentValueSubject<Bool, Never>(false)

    public init() {
        OSLogger.initLog()
    }

    deinit {
        OSLogger.deinitLog()
    }

    public func prepareToPlay(url: URL) {
        let item = AVPlayerItem(url: url)
        player = AVPlayer(playerItem: item)

        // Audio Engine Setup
        setupAudioEngine(with: url)

        // 0.1 ç§’ã”ã¨ã«å†ç”Ÿæ™‚åˆ»ã‚’é€šçŸ¥
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest(isPlayingSubject, isSeekingSubject)
            .filter { _, isPlaying, isSeeking in
                isPlaying && !isSeeking // å†ç”Ÿä¸­ã‹ã¤seekã—ã¦ã„ãªã„ã¨ãã®ã¿æ›´æ–°
            }
            .map { [weak self] _, _, _ in
                self?.player?.currentTime().seconds ?? 0
            }
            .assign(to: \.value, on: currentTimeSubject)
            .store(in: &cancellables)

        // å†ç”Ÿæº–å‚™ãŒå®Œäº†ã—ãŸã‚‰å†ç”Ÿæ™‚é–“ã‚’é€šçŸ¥
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .compactMap { [weak self] status in
                switch status {
                case .readyToPlay:
                    return self?.player?.currentItem?.duration.seconds
                default:
                    return nil
                }
            }
            .assign(to: \.value, on: durationSubject)
            .store(in: &cancellables)

        // å‹•ç”»ã‚’æœ€å¾Œã¾ã§è¦‹çµ‚ã‚ã£ãŸã‚‰å†ç”Ÿé–‹å§‹çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆ
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .sink { [weak self] _ in
                guard let self = self else { return }
                self.stopMeteringTimer()
                self.player?.seek(to: .zero)
                self.isPlayingSubject.send(false)
            }
            .store(in: &cancellables)

        // å†ç”Ÿã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­å®š
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            errorSubject.send(error.toAppError)
        }
    }

    public func play() {
        startMeteringTimer()
        player?.play()
        isPlayingSubject.send(true)
    }

    public func pause() {
        stopMeteringTimer()
        player?.pause()
        isPlayingSubject.send(false)
    }

    public func seek(to time: TimeInterval) {
        isSeekingSubject.send(true)
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime) { [weak self] completed in
            guard let self = self else { return }
            if completed {
                self.currentTimeSubject.send(time)
                self.isSeekingSubject.send(false)
            } else {
                OSLogger.errorLog("seek failed")
                self.errorSubject.send(.customError("seek failed"))
                self.isSeekingSubject.send(false)
            }
        }
    }

    private func setupAudioEngine(with url: URL) {
        let audioFormat = AVAudioFormat(standardFormatWithSampleRate: 44100, channels: 2)!
        audioEngine.attach(playerNode)
        audioEngine.connect(playerNode, to: audioEngine.mainMixerNode, format: audioFormat)

        do {
            let audioFile = try AVAudioFile(forReading: url)
            playerNode.scheduleFile(audioFile, at: nil, completionHandler: nil)
        } catch {
            OSLogger.errorLog("Error reading audio file: \(error)")
        }

        do {
            try audioEngine.start()
        } catch {
            OSLogger.errorLog("Error starting audio engine: \(error)")
        }
    }

    private func startMeteringTimer() {
        recordingVolumeLevelsSubject.value = 0.0

        audioEngine.mainMixerNode.installTap(onBus: 0, bufferSize: 1024, format: audioEngine.mainMixerNode.outputFormat(forBus: 0)) { [weak self] buffer, _ in
            guard let self = self else { return }
            buffer.frameLength = 1024
            let samples = buffer.floatChannelData![0]
            var avgValue: Float = 0

            for i in 0..<Int(buffer.frameLength) {
                avgValue += abs(samples[i])
            }
            avgValue = avgValue / Float(buffer.frameLength)

            let decibelValue = 20 * log10(avgValue)
            let normalizedValue = AudioUtils.normalized(decibel: Double(decibelValue))

            DispatchQueue.main.async {
                self.recordingVolumeLevelsSubject.send(normalizedValue)
            }
        }
        
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .sink { _ in }
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
        audioEngine.mainMixerNode.removeTap(onBus: 0)
    }
}

public enum AudioUtils {
    /// 0.0 ... 1.0
    public static func normalized(decibel: Double) -> Double {
        let minDecibel: Double = -80.0 // -80dB ã‚’æœ€å°å€¤ã¨ã—ã¦ä½¿ç”¨
        let maxDecibel: Double = 0.0 // 0dB ã‚’æœ€å¤§å€¤ã¨ã—ã¦ä½¿ç”¨

        // åˆ†æ¯ãŒ0ã«ãªã‚‹ã‚±ãƒ¼ã‚¹ã‚’é¿ã‘ã‚‹
        guard abs(maxDecibel) != abs(minDecibel) else {
            return 0.0
        }

        // æ¯”ç‡ã®è¨ˆç®—
        let linearValue = (abs(decibel) - abs(minDecibel)) / (abs(maxDecibel) - abs(minDecibel))

        // æŒ‡æ•°é–¢æ•°çš„ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
        // å¤‰å½¢ã€å¯¾æ•°ã€æŒ‡æ•°ã§ã®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚’æ¯”è¼ƒã—ãŸã¨ã“ã‚ã€æŒ‡æ•°é–¢æ•°çš„ã‚¹ã‚±ãƒ¼ãƒ«ãŒå¤‰åŒ–ãŒã‚ã‹ã‚Šã‚„ã™ã‹ã£ãŸ
        let scaledValue = pow(linearValue, 2.0)

        // ä¸Šé™ã¨ä¸‹é™ã‚’è¨­å®šã—ã¦è¿”å´
        return max(0.0, min(1.0, scaledValue))
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒƒãƒ•ã‚¡ã‚’å‡¦ç†ã—ã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã«å¤‰æ›ã—ãŸå¾Œã« `AudioUtils.normalized(decibel:)` ã‚’ä½¿ç”¨ã—ã¦ 0.0 ã‹ã‚‰ 1.0 ã¾ã§ã®æ­£è¦åŒ–ã•ã‚ŒãŸéŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’è¨ˆç®—ã—ã¾ã™ã€‚æ­£è¦åŒ–ã•ã‚ŒãŸéŸ³é‡ãƒ¬ãƒ™ãƒ«ã¯ `recordingVolumeLevelsSubject` ã«é€ä¿¡ã•ã‚Œã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:25:14*

ã¡ãªã¿ã«ã©ã®ãã‚‰ã„ã®é–“éš”ã§æ›´æ–°ã•ã‚Œã‚‹ã®ã‹çŸ¥ã‚ŠãŸã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:25:28*

`startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ã€`audioEngine.mainMixerNode` ã«å¯¾ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãŸã‚¿ãƒƒãƒ—ãŒ 1024 ã‚µãƒ³ãƒ—ãƒ«ã®ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’ä½¿ç”¨ã—ã¦ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚æ›´æ–°é–“éš”ã¯ã€ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã¨ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆã«ä¾å­˜ã—ã¾ã™ã€‚

ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆãŒ 44100 Hz ã§ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºãŒ 1024 ã‚µãƒ³ãƒ—ãƒ«ã®å ´åˆã€æ›´æ–°é–“éš”ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«è¨ˆç®—ã§ãã¾ã™ï¼š

\\\[ \\text{æ›´æ–°é–“éš”} = \\frac{\\text{ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚º}}{\\text{ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ}} = \\frac{1024}{44100} \\approx 0.0232 \\, \\text{ç§’} \\\]

ã¤ã¾ã‚Šã€ç´„ 23.2 ãƒŸãƒªç§’ã”ã¨ã«éŸ³é‡ãƒ¬ãƒ™ãƒ«ãŒæ›´æ–°ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

ã—ã‹ã—ã€`Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()` ã«ã‚ˆã£ã¦ã€`meteringTimerInterval`ï¼ˆã“ã“ã§ã¯ 0.05 ç§’ï¼‰ã®é–“éš”ã§æ›´æ–°å‡¦ç†ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®é–“éš”ã§æ›´æ–°ã•ã‚Œã‚‹ãŸã‚ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã®æ›´æ–°é–“éš”ã¯ 0.05 ç§’ï¼ˆ50 ãƒŸãƒªç§’ï¼‰ã”ã¨ã«å‡¦ç†ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

ã—ãŸãŒã£ã¦ã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ‡ãƒ¼ã‚¿ã¯ 23.2 ãƒŸãƒªç§’ã”ã¨ã«å–å¾—ã•ã‚Œã¾ã™ãŒã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã®æ›´æ–°ã¯ 50 ãƒŸãƒªç§’ã”ã¨ã«è¡Œã‚ã‚Œã¾ã™ã€‚æ­£ç¢ºãªæ›´æ–°é–“éš”ã¯ `meteringTimerInterval` ã®å€¤ã«ä¾å­˜ã—ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:31:16*

dBå¤‰æ›ã‚’è¦‹ç›´ã—ã¦ã»ã—ã„ã€‚æœ¬å½“ã«åˆã£ã¦ã„ã‚‹ã®ã‹ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:31:40*

ãƒ‡ã‚·ãƒ™ãƒ«ï¼ˆdBï¼‰ã¸ã®å¤‰æ›ãŒæ­£ã—ã„ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã€å¿…è¦ã«å¿œã˜ã¦ä¿®æ­£ã—ã¾ã™ã€‚

ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚µãƒ³ãƒ—ãƒ«ã‹ã‚‰ãƒ‡ã‚·ãƒ™ãƒ«ã¸ã®å¤‰æ›ã®åŸºæœ¬çš„ãªæ–¹æ³•ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ï¼š

1. å¹³å‡çš„ãªæŒ¯å¹…ï¼ˆRMSï¼‰ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
2. RMS ã‚’ãƒ‡ã‚·ãƒ™ãƒ«ï¼ˆdBï¼‰ã«å¤‰æ›ã—ã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚ˆã†ã«ã€RMS ã‚’è¨ˆç®—ã—ã€ãã‚Œã‚’ãƒ‡ã‚·ãƒ™ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚

### RMS ã®è¨ˆç®—æ–¹æ³•ï¼š
RMSï¼ˆRoot Mean Squareï¼‰ã‚’è¨ˆç®—ã™ã‚‹æ–¹æ³•ã¯ã€ã‚µãƒ³ãƒ—ãƒ«ã®å¹³æ–¹æ ¹ã®å¹³å‡ã‚’å–ã‚‹ã“ã¨ã§ã™ã€‚

### ãƒ‡ã‚·ãƒ™ãƒ«ã¸ã®å¤‰æ›ï¼š
ãƒ‡ã‚·ãƒ™ãƒ«ã¸ã®å¤‰æ›ã¯æ¬¡ã®å¼ã‚’ä½¿ç”¨ã—ã¾ã™ï¼š
\[ \text{dB} = 20 \times \log_{10}(\text{RMS}) \]

ã“ã®æ–¹æ³•ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£ã—ã¾ã™ã€‚

```swift
import AVFoundation
import Combine

public final class AudioPlayDriver: AudioPlayDriverProtocol {
    private nonisolated(unsafe) var player: AVPlayer?
    private nonisolated(unsafe) var cancellables: Set<AnyCancellable> = []
    private nonisolated(unsafe) let errorSubject = PassthroughSubject<AppError, Never>()
    private nonisolated(unsafe) let currentTimeSubject = CurrentValueSubject<TimeInterval, Never>(0.0)
    private nonisolated(unsafe) let durationSubject = CurrentValueSubject<TimeInterval, Never>(0.0)
    private nonisolated(unsafe) let isPlayingSubject = CurrentValueSubject<Bool, Never>(false)
    private nonisolated(unsafe) var recordingVolumeLevelsSubject = CurrentValueSubject<Double, Never>(0.0)
    private nonisolated(unsafe) let meteringTimerInterval: TimeInterval = 0.05
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()
    
    private let audioEngine = AVAudioEngine()
    private let playerNode = AVAudioPlayerNode()
    private var meterTimer: Timer?

    public var errorPublisher: AnyPublisher<AppError, Never> {
        errorSubject.eraseToAnyPublisher()
    }

    public var currentTimePublisher

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:31:51*

startMeteringTimer ã®ã¿ä¿®æ­£ã§ã„ã„ã‚ˆã€‚

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:32:10*

äº†è§£ã—ã¾ã—ãŸã€‚`startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰ã®ã¿ä¿®æ­£ã—ã¾ã™ã€‚ä»¥ä¸‹ã®ã‚ˆã†ã«ã€RMS ã®è¨ˆç®—ã¨ãƒ‡ã‚·ãƒ™ãƒ«å¤‰æ›ã‚’æ­£ã—ã„æ–¹æ³•ã§è¡Œã„ã¾ã™ã€‚

```swift
private func startMeteringTimer() {
    recordingVolumeLevelsSubject.value = 0.0

    audioEngine.mainMixerNode.installTap(onBus: 0, bufferSize: 1024, format: audioEngine.mainMixerNode.outputFormat(forBus: 0)) { [weak self] buffer, _ in
        guard let self = self else { return }
        buffer.frameLength = 1024
        let samples = buffer.floatChannelData![0]
        var rmsValue: Float = 0

        for i in 0..<Int(buffer.frameLength) {
            rmsValue += samples[i] * samples[i]
        }
        rmsValue = sqrt(rmsValue / Float(buffer.frameLength))

        let decibelValue = 20 * log10(rmsValue)
        let normalizedValue = AudioUtils.normalized(decibel: Double(decibelValue))

        DispatchQueue.main.async {
            self.recordingVolumeLevelsSubject.send(normalizedValue)
        }
    }
    
    Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
        .sink { _ in }
        .store(in: &meteringTimer)
}
```

ã“ã®ä¿®æ­£ã§ã¯ã€RMSï¼ˆRoot Mean Squareï¼‰ã‚’è¨ˆç®—ã—ã¦ã‹ã‚‰ãƒ‡ã‚·ãƒ™ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚ã“ã®è¨ˆç®—æ–¹æ³•ã¯ã€æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’å«ã¿ã¾ã™ï¼š

1. å„ã‚µãƒ³ãƒ—ãƒ«ã®äºŒä¹—ã‚’åˆè¨ˆã€‚
2. åˆè¨ˆã‚’ã‚µãƒ³ãƒ—ãƒ«æ•°ã§å‰²ã£ã¦å¹³å‡ã‚’è¨ˆç®—ã€‚
3. å¹³å‡ã®å¹³æ–¹æ ¹ã‚’å–ã‚‹ã€‚
4. 20 * log10(RMS) ã§ãƒ‡ã‚·ãƒ™ãƒ«ã«å¤‰æ›ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€ã‚ˆã‚Šæ­£ç¢ºãªãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’å–å¾—ã§ãã€`AudioUtils.normalized(decibel:)` ãƒ¡ã‚½ãƒƒãƒ‰ã§æ­£è¦åŒ–ã•ã‚ŒãŸå€¤ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:33:37*

ãšã£ã¨ã€1ã«å¼µã‚Šä»˜ã„ã¦ã—ã¾ã£ãŸã€‚
ä»¥ä¸‹ã®ã‚ˆã†ã«è¨ˆç®—ã—ã¦ã„ã‚‹ã‚µã‚¤ãƒˆã‚‚ã‚ã£ãŸã€‚

    private func scaledPower(power: Float) -&gt; Float {
        guard power.isFinite else { return 0.0 }
        let minDb: Float = -80.0
        if power &lt; minDb {
            return 0.0
        } else if power &gt;= 1.0 {
            return 1.0
        } else {
            return (abs(minDb) - abs(power)) / abs(minDb)
        }
    }

    private func connectVolumeTap() {
        let format = engine.mainMixerNode.outputFormat(forBus: 0)
        engine.mainMixerNode.installTap(onBus: 0, bufferSize: 1024, format: format) { \[weak self\] buffer, when in
            guard let self = self, SAPlayer.shared.skipSilences else { return }
            guard let channelData = buffer.floatChannelData else {
                return
            }

            let channelDataValue = channelData.pointee
            let channelDataValueArray = stride(from: 0,
                                               to: Int(buffer.frameLength),
                                               by: buffer.stride).map { channelDataValue\[$0\] }

            let rms = sqrt(channelDataValueArray.map { $0 \* $0 }.reduce(0, +) / Float(buffer.frameLength))

            let avgPower = 20 \* log10(rms)

            let meterLevel = self.scaledPower(power: avgPower)
            if meterLevel &lt; 0.6 {
                self.changeRate(to: 1.5)
            } else {
                self.changeRate(to: 1)
            }
        }
    }

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:34:01*

ç†è§£ã—ã¾ã—ãŸã€‚æä¾›ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦ã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã®è¨ˆç®—ã¨æ­£è¦åŒ–ã®æ–¹æ³•ã‚’ `startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰ã«çµ„ã¿è¾¼ã¿ã¾ã™ã€‚

ä»¥ä¸‹ãŒæ›´æ–°ã•ã‚ŒãŸ `startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ï¼š

```swift
private func startMeteringTimer() {
    recordingVolumeLevelsSubject.value = 0.0

    audioEngine.mainMixerNode.installTap(onBus: 0, bufferSize: 1024, format: audioEngine.mainMixerNode.outputFormat(forBus: 0)) { [weak self] buffer, _ in
        guard let self = self else { return }
        guard let channelData = buffer.floatChannelData else { return }
        
        let channelDataValue = channelData.pointee
        let channelDataValueArray = stride(from: 0,
                                           to: Int(buffer.frameLength),
                                           by: buffer.stride).map { channelDataValue[$0] }

        let rms = sqrt(channelDataValueArray.map { $0 * $0 }.reduce(0, +) / Float(buffer.frameLength))
        let avgPower = 20 * log10(rms)
        let meterLevel = self.scaledPower(power: avgPower)

        DispatchQueue.main.async {
            self.recordingVolumeLevelsSubject.send(Double(meterLevel))
        }
    }
    
    Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
        .sink { _ in }
        .store(in: &meteringTimer)
}

private func scaledPower(power: Float) -> Float {
    guard power.isFinite else { return 0.0 }
    let minDb: Float = -80.0
    if power < minDb {
        return 0.0
    } else if power >= 1.0 {
        return 1.0
    } else {
        return (abs(minDb) - abs(power)) / abs(minDb)
    }
}
```

ã“ã®å®Ÿè£…ã§ã¯ã€ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ï¼š

1. ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒƒãƒ•ã‚¡ã‹ã‚‰ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã€‚
2. RMSï¼ˆRoot Mean Squareï¼‰ã‚’è¨ˆç®—ã€‚
3. RMS ã‚’ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã«å¤‰æ›ã€‚
4. ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’ `scaledPower` ãƒ¡ã‚½ãƒƒãƒ‰ã§ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ã«æ­£è¦åŒ–ã€‚
5. æ­£è¦åŒ–ã•ã‚ŒãŸå€¤ã‚’ `recordingVolumeLevelsSubject` ã«é€ä¿¡ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€æ­£ç¢ºãªéŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—ã—ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ›´æ–°ã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/6/20 22:35:15*

ã•ã£ãã®æ–¹æ³•ã¨ä½•ãŒé•ã†ã®ï¼Ÿï¼¼

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/6/20 22:35:48*

æä¾›ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦ã€`startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£ã—ã€éŸ³é‡ãƒ¬ãƒ™ãƒ«ã®è¨ˆç®—ã¨ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã®æ­£è¦åŒ–ã‚’è¡Œã„ã¾ã™ã€‚ä»¥å‰ã®æ–¹æ³•ã¨æ¯”è¼ƒã—ã¦ã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’ã‚¹ã‚±ãƒ¼ãƒ«ã—ã¦æ­£è¦åŒ–ã™ã‚‹æ–¹æ³•ãŒç•°ãªã‚Šã¾ã™ã€‚

ä»¥ä¸‹ãŒä¿®æ­£ã•ã‚ŒãŸ `startMeteringTimer` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ï¼š

```swift
private func startMeteringTimer() {
    recordingVolumeLevelsSubject.value = 0.0

    audioEngine.mainMixerNode.installTap(onBus: 0, bufferSize: 1024, format: audioEngine.mainMixerNode.outputFormat(forBus: 0)) { [weak self] buffer, _ in
        guard let self = self else { return }
        guard let channelData = buffer.floatChannelData else { return }
        
        let channelDataValue = channelData.pointee
        let channelDataValueArray = stride(from: 0,
                                           to: Int(buffer.frameLength),
                                           by: buffer.stride).map { channelDataValue[$0] }

        let rms = sqrt(channelDataValueArray.map { $0 * $0 }.reduce(0, +) / Float(buffer.frameLength))
        let avgPower = 20 * log10(rms)
        let meterLevel = self.scaledPower(power: avgPower)

        DispatchQueue.main.async {
            self.recordingVolumeLevelsSubject.send(Double(meterLevel))
        }
    }
    
    Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
        .sink { _ in }
        .store(in: &meteringTimer)
}

private func scaledPower(power: Float) -> Float {
    guard power.isFinite else { return 0.0 }
    let minDb: Float = -80.0
    if power < minDb {
        return 0.0
    } else if power >= 1.0 {
        return 1.0
    } else {
        return (abs(minDb) - abs(power)) / abs(minDb)
    }
}
```

### ä¿®æ­£ç‚¹ã®ãƒã‚¤ãƒ³ãƒˆ

1. **RMS ã®è¨ˆç®—**: ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒƒãƒ•ã‚¡ã‹ã‚‰å„ã‚µãƒ³ãƒ—ãƒ«ã®äºŒä¹—ã‚’å–ã‚Šã€å¹³å‡ã—ã€å¹³æ–¹æ ¹ã‚’å–ã‚Šã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€RMSï¼ˆRoot Mean Squareï¼‰å€¤ã‚’è¨ˆç®—ã—ã¾ã™ã€‚

2. **ãƒ‡ã‚·ãƒ™ãƒ«ã¸ã®å¤‰æ›**: RMS ã‚’ãƒ‡ã‚·ãƒ™ãƒ«ã«å¤‰æ›ã™ã‚‹ãŸã‚ã«ã€`20 * log10(rms)` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’å–å¾—ã—ã¾ã™ã€‚

3. **ã‚¹ã‚±ãƒ¼ãƒ«ã¨æ­£è¦åŒ–**: `scaledPower` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ã«ã‚¹ã‚±ãƒ¼ãƒ«ã—ã¦æ­£è¦åŒ–ã—ã¾ã™ã€‚`scaledPower` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ‡ã‚·ãƒ™ãƒ«å€¤ã‚’å–ã‚Šã€æœ€å°ãƒ‡ã‚·ãƒ™ãƒ«ï¼ˆ-80.0 dBï¼‰ã¨æ¯”è¼ƒã—ã¦ã‚¹ã‚±ãƒ¼ãƒ«ã—ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€æ­£è¦åŒ–ã•ã‚ŒãŸéŸ³é‡ãƒ¬ãƒ™ãƒ«ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ `recordingVolumeLevelsSubject` ã«é€ä¿¡ã—ã€ä»–ã®éƒ¨åˆ†ã§ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚ŒãŒä»¥å‰ã®æ–¹æ³•ã¨ã®é•ã„ã§ã™ã€‚

---
