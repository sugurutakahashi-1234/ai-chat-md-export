# アクセストークン保存処理

日付: 2025-01-15

---

## 👤 ユーザー
*2025/01/15 19:41:59*

VerifyCodeNotifier の verifyCode を読んでアクセストークンを保存したい

class AuthCredentials {
  AuthCredentials({required this.accessToken});

  final String accessToken;
}

@riverpod
class VerifyCodeNotifier extends _$VerifyCodeNotifier {
  @override
  Future&lt;AuthCredentials?&gt; build() async =&gt; null;

  Future&lt;AuthCredentials&gt; verifyCode(String email, num code) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(authApiProvider.future);
      final response = await api.authControllerLogin(
        AuthLoginDTO(email: email, code: code),
      );
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      final responseData = response.data?.data;
      if (responseData == null) {
        throw Exception('Photo upload failed: response data is null');
      }
      // final authCredentials = AuthCredentials(
      //   accessToken: responseData.accessToken,
      // );
      final authCredentials = AuthCredentials(
        accessToken:
            // ignore: lines_longer_than_80_chars
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1dWlkIjoiMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwIiwiYWNjZXNzVG9rZW4iOiJ1c2VyMUBleGFtcGxlLmNvbSIsImlzc3VlZEF0IjoxNzM2NDc3NzUxOTg5LCJpYXQiOjE3MzY0Nzc3NTEsImV4cCI6MTczOTA2OTc1MX0.blJd4GIRkobRS6rNatg6IRJINBzq6lr0E3lLDFwfRJY',
      );
      state = AsyncValue.data(authCredentials);
      return authCredentials;
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
      rethrow;
    }
  }
}

@Riverpod(keepAlive: true)
class AccessTokenNotifier extends _$AccessTokenNotifier {
  @override
  Future&lt;String?&gt; build() async {
    final storage = ref.read(flutterSecureStorageProvider);
    return storage.read(key: SecureStorageKey.accessToken.name);
  }

  Future&lt;void&gt; save(String accessToken) async {
    final storage = ref.read(flutterSecureStorageProvider);
    await storage.write(
      key: SecureStorageKey.accessToken.name,
      value: accessToken,
    );
    state = AsyncData(accessToken);
  }

  Future&lt;void&gt; delete() async {
    final storage = ref.read(flutterSecureStorageProvider);
    await storage.delete(key: SecureStorageKey.accessToken.name);
    state = const AsyncData(null);
  }
}

---

## 🤖 アシスタント
*2025/01/15 19:42:21*

`VerifyCodeNotifier` の `verifyCode` メソッドで認証トークンを取得し、それを `AccessTokenNotifier` に保存するには、`AccessTokenNotifier` を参照して保存操作を実行する必要があります。そのために、`AccessTokenNotifier` を `verifyCode` メソッド内で使用するように以下のようにコードを修正できます。

修正後の `verifyCode` メソッドは以下の通りです。

### 修正後のコード

```dart
Future<AuthCredentials> verifyCode(String email, num code) async {
  state = const AsyncValue.loading();
  try {
    final api = await ref.watch(authApiProvider.future);
    final response = await api.authControllerLogin(
      AuthLoginDTO(email: email, code: code),
    );
    debugPrint('Response Body: ${response.data}');
    debugPrint('Response Body.data: ${response.data?.data}');
    final responseData = response.data?.data;
    if (responseData == null) {
      throw Exception('Photo upload failed: response data is null');
    }
    final authCredentials = AuthCredentials(
      accessToken: responseData.accessToken,
    );

    // AccessTokenNotifier に保存
    await ref.read(accessTokenNotifierProvider.notifier).save(authCredentials.accessToken);

    state = AsyncValue.data(authCredentials);
    return authCredentials;
  } on Exception catch (e, stackTrace) {
    debugPrint('Error: $e');
    debugPrint('StackTrace: $stackTrace');
    state = AsyncValue.error(e, stackTrace);
    rethrow;
  }
}
```

### 修正ポイント

1. **AccessTokenNotifier の呼び出し**:
   `ref.read(accessTokenNotifierProvider.notifier).save` を用いて、`AccessTokenNotifier` にアクセストークンを保存します。この呼び出しにより、`flutterSecureStorage` にトークンが保存され、アプリ全体で再利用可能になります。

2. **エラーハンドリング**:
   保存操作に失敗する可能性も考慮し、トークン保存時にエラーが発生した場合はログを出力するか適切な対応を行う必要があります。

### 使用例

以下のようにプロバイダーを登録していることを確認してください。

```dart
final verifyCodeNotifierProvider = 
    AutoDisposeAsyncNotifierProvider<VerifyCodeNotifier, AuthCredentials?>(
  VerifyCodeNotifier.new,
);

final accessTokenNotifierProvider =
    AsyncNotifierProvider<AccessTokenNotifier, String?>(
  AccessTokenNotifier.new,
);
```

この変更により、認証トークンを安全に保存し、必要に応じて後で使用することが可能になります。

---
