# 非メインスレッドの値公開エラー

Date: 2023-05-23

---

## 👤 User
*2023-05-23 22:59:28*

Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates. のエラーの場合の対応方法をおしえてほしい

---

## 🤖 Assistant
*2023-05-23 23:00:10*

あなたがこのエラーメッセージに直面しているということは、SwiftUIかCombineフレームワークを使用していると推測します。このエラーメッセージは、非メインスレッドから値を公開しようとしたときに発生します。UIの更新はメインスレッドで行われるべきなので、これは避けられないエラーです。

このエラーを修正するためには、UIの更新（またはモデルの更新）をメインスレッド上で行うようにする必要があります。これはSwiftUIとCombineの `receive(on:)`オペレータを使用して行うことができます。

以下に一例を示します：

```swift
backgroundPublisher
    .receive(on: DispatchQueue.main)
    .assign(to: &$modelValue)
```

上記のコードは、非メインスレッドで生成された値をメインスレッドに移動させ、`$modelValue`に割り当てます。

この方法でエラーが解消されるはずです。非メインスレッドからUIを更新しようとすると、アプリが予期せぬ動作をしたりクラッシュする可能性があるため、メインスレッドでUIの更新を行うことは非常に重要です。

---

## 👤 User
*2023-05-23 23:00:23*

async 関数の中で @Published な変数を更新しているときによばれているんだ

---

## 🤖 Assistant
*2023-05-23 23:01:55*

Swift 5.5から非同期処理のために導入された`async/await`パターンは、SwiftUIとの統合が深まっています。しかし、非同期タスクはメインスレッドとは異なるスレッドで実行される可能性があるため、非同期関数内で `@Published` な変数を更新するとエラーが発生します。

この問題を解決する一つの方法は、`DispatchQueue.main.async` を使用して非同期タスクをメインスレッドで実行するようにすることです。しかし、Swift 5.5以降では、非同期関数の中でUIを更新するときには、`Task`と `@MainActor` を使用してメインスレッドで処理を行うようにすることが推奨されています。

以下に一例を示します：

```swift
import SwiftUI

class MyViewModel: ObservableObject {
    @Published var myData = ""

    func fetchData() async {
        do {
            let newData = await someAsyncFunction()
            await MainActor.run {
                self.myData = newData
            }
        } catch {
            print(error)
        }
    }
}

func someAsyncFunction() async -> String {
    // 非同期操作
    return "New Data"
}
```

この例では、`someAsyncFunction`から非同期にデータを取得し、そのデータを`MyViewModel`の`myData`に設定します。データ設定は`MainActor.run`内で行われるため、これはメインスレッドで行われます。

このように`Task`と `@MainActor` を使用することで、非同期タスクの結果をメインスレッドでUIに反映させることができます。

---

## 👤 User
*2023-05-23 23:10:30*

ViewModel 側で @MainActor をどこにつけて良いかがわからない

---

## 🤖 Assistant
*2023-05-23 23:11:17*

`@MainActor`を使用して、特定のクラスまたは構造体が常にメインスレッドで実行されるように指定することができます。これは、そのクラスまたは構造体がUIを更新する責任を持つ場合に特に有用です。`@MainActor`をクラスや構造体全体に適用することで、その中のすべてのメソッドとプロパティがメインスレッドで実行されるようになります。

たとえば、`ViewModel`がUIを更新する場合は、以下のように`@MainActor`をクラス全体に適用できます。

```swift
@MainActor
class MyViewModel: ObservableObject {
    @Published var myData = ""

    func fetchData() async {
        do {
            let newData = await someAsyncFunction()
            self.myData = newData
        } catch {
            print(error)
        }
    }
}

func someAsyncFunction() async -> String {
    // 非同期操作
    return "New Data"
}
```

このようにすると、`fetchData()`メソッドは常にメインスレッドで実行され、`@Published`プロパティを更新するときにエラーが発生しなくなります。

ただし、すべてのメソッドやプロパティがメインスレッドで実行されることを強制するため、この方法ではパフォーマンスに影響が出る可能性があります。そのため、`@MainActor`を適用するのはUIの更新など、メインスレッドで実行する必要が明確にある箇所に限定することをお勧めします。

---

## 👤 User
*2023-05-23 23:11:48*

クラスに@MainActorをつけたくない場合はどのような記述になるの？

---

## 🤖 Assistant
*2023-05-23 23:12:32*

もしクラス全体に`@MainActor`を適用したくないのであれば、必要なメソッドやプロパティに対して個別に`@MainActor`を付与することができます。

例えば、ViewModelがUIを更新する責任を持つ`@Published`プロパティの更新だけをメインスレッドで行いたい場合は、以下のように書くことができます。

```swift
import SwiftUI

class MyViewModel: ObservableObject {
    @Published var myData = ""

    func fetchData() async {
        do {
            let newData = await someAsyncFunction()
            await updateUI(newData: newData)
        } catch {
            print(error)
        }
    }
    
    @MainActor
    private func updateUI(newData: String) {
        self.myData = newData
    }
}

func someAsyncFunction() async -> String {
    // 非同期操作
    return "New Data"
}
```

この例では、非同期にデータを取得した後で`updateUI(newData:)`メソッドを呼び出し、その中で`@Published`プロパティを更新しています。`updateUI(newData:)`メソッドは`@MainActor`が付与されているため、メインスレッドで実行されます。

なお、Swift 5.5以降では非同期関数でも`await`を使用して同期関数を呼び出すことができます。そのため、`updateUI(newData:)`メソッドを`await`を使用して呼び出しています。

このように、`@MainActor`を適用する範囲を制限することで、メインスレッドでの実行を必要とする操作とそうでない操作を分離することができ、パフォーマンスに影響を及ぼす可能性を減らすことができます。

---
