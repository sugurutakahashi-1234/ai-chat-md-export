# OpenAPIサーバーコード生成

日付: 2025-03-07

---

## 👤 ユーザー
*2025/03/07 19:28:09*

nestjsを使っていて、スワっガーのsdkを使ってOpenAPIのyamlを生成している。
クライアント側はそのyamlからapiの呼び出しコードを生成しているが、それと同じようにサーバー側のコードもyamlの定義に合わせた実装をしたい。
どうすればいいのか。

---

## 🔧 ツール
*2025/03/07 19:28:10*

**生成サーバーコードの向き合い方を探る**

OpenAPI仕様からNestJSサーバーを生成する方法を模索している。NPMパッケージでTypeScriptコードを生成し、詳細を慎重に選んでいる。

**コード整合性を保つ**

クライアントとサーバーの真理の統一を目指し、NestJS CLIでSwagger Yamlからクラスを生成してサーバーコードをYAMLと一致させる方法を検討中。

**定義し生成し導入**

コントローラのデコレーターを使ってNestJSのSwaggerプラグインでOpenAPI仕様を作成し、NestJS CLIでSwagger Yamlからクラスを生成する方法を検討中。

**スピード感を持つ**

OpenAPI仕様を直接生成し、それをSwaggerデコレーターでNestJSコードに反映させ、サーバーコードとクライアントコードの間に一貫性を維持している。

---

## 🤖 アシスタント
*2025/03/07 19:28:10*

NestJS まわりの OpenAPI（Swagger）との付き合い方としては、大きく分けて以下の2つのアプローチがあります。

1. **「コードファースト」(Code First) で NestJS のデコレーターから自動生成する**  
2. **「スキーマファースト」(Schema First) で OpenAPI (yaml/json) を元にコード生成する**

ご質問のように、
&gt; クライアント側はそのyamlからapiの呼び出しコードを生成しているが、それと同じようにサーバー側のコードもyamlの定義に合わせた実装をしたい
という場合は、「スキーマファースト」のアプローチを取って、
- **OpenAPI 仕様 (YAML) をソースの単一真実源 (Single Source of Truth) にする**
- そこからサーバー側とクライアント側のコードを生成する

というワークフローにすると、サーバー／クライアント間の定義ズレを防ぎやすくなります。

---

## 1. コードファースト (Code First) から入る場合

NestJS で一般的に利用されているのは「コードファースト」アプローチです。  
- コントローラや DTO に `@ApiProperty()` / `@ApiResponse()` / `@ApiTags()` といった Swagger 用デコレーターを付与していく  
- `@nestjs/swagger` の `SwaggerModule.createDocument()` で OpenAPI スキーマを自動生成  
- 生成された YAML/JSON をクライアントが使ってコード生成

ただしこの方法では、**生成された Swagger のスキーマを元に、さらにサーバーサイドのコードを生成する**という使い方はあまり一般的ではありません。というのも元コード（NestJSのコントローラ等）から既にスキーマを自動生成しているので、「自前のコントローラなど NestJS 側のコード」→「Swagger定義」という流れになりやすく、逆方向に戻すメリットが小さいためです。

コードファーストでやりたいのであれば、

- **サーバーサイドはエンジニアが NestJS のコントローラ・DTO 実装**  
- **Swagger スキーマは実装から自動生成**  
- **そのスキーマをクライアントだけが利用してコード生成**

というワークフローが一般的となります。

---

## 2. スキーマファースト (Schema First) でサーバーを生成する

一方で「スキーマファースト」アプローチは、**先に OpenAPI (YAML/JSON) を書いて決定し、それに沿ったサーバー・クライアント実装を生成する**という手法です。Java 等で利用されることが多いですが、もちろん TypeScript + NestJS でも可能です。

### やり方の例

1. **OpenAPI Generator の CLI** や **Swagger Codegen** を利用する
2. 事前に作った `openapi.yaml` (あるいは `openapi.json`) を「単一の真実源」として用意
3. `openapi-generator-cli generate -g typescript-nestjs ...` のように、**NestJS 用テンプレート**を指定してサーバー側コードを生成  
   - 公式の OpenAPI Generator には `typescript-nestjs` という generator オプションがあります  
   - これにより、NestJS のコントローラクラス・DTO（model）・サービスなどが生成されます
4. 必要に応じて、そこにビジネスロジックを追加実装する  
   - 生成されるのは骨格（コントローラのメソッド / DTO）なので、中身の処理(ビジネスロジック)は埋める必要がある

この方法ならクライアントと同様に、サーバーも OpenAPI スキーマ（YAML）から自動生成するため、**スキーマとサーバー実装の不整合が起こりにくい**です。  
ただし注意点としては、

- スキーマを変更するたびにサーバー実装を再生成する必要がある  
- 再生成時にコードが上書きされるため、ロジック部分は**自前で手を入れないようなスカフォールド構成**にしておく等の工夫が必要  
  - たとえば生成物の構造を踏まえて、ビジネスロジック部分は別ファイルや継承クラス等で管理する方法が考えられます

---

## どちらのアプローチをとるか

- **「サーバー実装」→「OpenAPIスキーマ」→「クライアント生成」** という順番で生成が回る方が多い（NestJS＋Typescript での一般的なやり方）  
- **「OpenAPIスキーマ」→「サーバー実装／クライアント実装」** というスキーマファーストは、コンシューマドリブン（外部のシステムから API 仕様がまず決まる）場合や、仕様ファースト開発を強く推進したいチーム等で選ばれる  

ご質問のように「クライアントとサーバーを同じ YAML に合わせて合わせたい」という要望が強いのであれば、**スキーマファースト & OpenAPI Generator でサーバーコードを出力する**のがシンプルかつわかりやすいです。

### まとめ

1. **OpenAPI スキーマ (YAML) を単一の真実源として管理する**  
2. クライアント側は従来どおりスキーマからコード生成  
3. **サーバー側も `openapi-generator-cli` などで “`typescript-nestjs`” を指定して骨格を生成**  
4. 生成されたコントローラや DTO を元に、ビジネスロジックを実装する

これによってクライアントとサーバーが同じ定義でズレなく動くようになります。

---

## 👤 ユーザー
*2025/03/07 19:30:57*

コードファースト (Code First) だけど、それを使ってテストコードを自動生成することで、インターフェースの担保などはできないのか？

---

## 🔧 ツール
*2025/03/07 19:30:58*

**生成と確保の考慮**

コードファーストアプローチからテストコードを生成するのは可能ですが、自動生成は通常行われません。OpenAPI generatorを使うこともありますが、テストの場合はその限りではない。

**考慮材料を挙げる**

インテグレーションテストやe2eテストはツールなしで自動生成が難しい。特定のツールも事例として挙げられているが、公式ライブラリはない。

**オープンAPI検証のアプローチを探る**

オープンAPI仕様を生成し、クライアントコードやテストコードを生成してサーバーをテストする方法が考えられる。ただし、公式のテストコードジェネレーターはない。典型的な方法は、生成したオープンAPI仕様をもとに契約テストを行うこと。

**契約テストの実行**

インターフェースの正確性を確保するために、契約テストや統合テストを行うのが一般的だが、自動生成は簡単ではない。

---

## 🤖 アシスタント
*2025/03/07 19:30:57*

結論からいうと、**コードファーストの NestJS から出力される OpenAPI スキーマを使って「テストコードを自動生成」し、それによってサーバー実装のインターフェースを完全に担保する**というのは、あまり一般的ではありません。  
以下ではその理由と、もしアプローチを取るのであればどうすればよいか、という話をまとめます。

---

## コードファーストで生成される OpenAPI スキーマ

NestJS（+ `@nestjs/swagger`）のコードファースト方式では、次のような流れになります。

1. **NestJS のコントローラ／DTO にデコレーターを付与**  
2. `SwaggerModule.createDocument()` などを利用して **OpenAPI スキーマ** (JSON/YAML) を自動生成
3. そのスキーマを使って **クライアントコードの生成** や **API ドキュメントの公開** などを行う

このとき、「サーバー側のテストコードを自動生成する」用途でこのスキーマを使うのはあまり一般的ではありません。理由としては

- **テストのロジック（どう振る舞うと正しいか）** は Swagger からは分からない  
  - スキーマはエンドポイントの入出力や型情報、レスポンスコードなどを定義しますが、「正しい状態をどう検証するか」までは定義していない  
  - 例えば「認証が必要なときに認証エラーを返す」などのビジネスロジック的な要件はスキーマだけでは不十分
- **API の利用を想定したテスト“クライアント”のコードなら生成しやすいが、サーバーサイドのテスト自体を自動化するのは難しい**  
  - スキーマをもとにしたテストクライアントは（クライアント側の SDK と同様に）生成できます。が、サーバー内部のテスト（ユニットテストや一部の E2E テスト）を完全に自動化するのは厳しい  
  - 結局は「どういうパラメータで呼び出して、どんな状態を検証したいのか」を手動で書く必要がある

---

## もし「スキーマに沿ったテスト」自体をやりたい場合

### 1. スキーマを元に「クライアントテストコード」を生成する

- OpenAPI Generator には `typescript-axios` や `typescript-fetch` などのテンプレートがあり、**クライアント**として API をコールするコードを生成可能です。  
- 生成したクライアントを e2e テスト（`jest + supertest` のようなテストツールと組み合わせ）で使えば、**「API 定義どおりに動いているか」**を確認しやすくなる。  
- ただし、テストコード（Describe や it、アサーションを書く部分）まで完全自動生成するのは難しいため、**生成されたクライアントを使いつつ手動でテストケースを書く**という流れになります。

### 2. コントラクトテスト／コンシューマドリブン契約テスト

- OpenAPI のスキーマや、Pact などのツールを用いて **「API のインターフェース契約を守っているか」** を検証するコントラクトテストというアプローチがあります。  
- これによってサーバー・クライアント間の取り決めがズレていないかを継続的にチェックできますが、こちらも「テストコードが丸ごと自動生成」というよりは、契約ファイルを参考にしたテストをサーバー側で書く／クライアント側で書くスタイルになることが多いです。

### 3. スキーマファースト + サーバー骨格自動生成（参考）

ご質問から少し逸れますが、もし「API スキーマが先に定まっており、その実装を担保したい」という場合は、**スキーマファースト + サーバー骨格の自動生成**という手段があります。  
OpenAPI Generator で `typescript-nestjs` という generator を指定すると、**NestJS のコントローラや DTO の雛形コード**が生成できます。  
- そこにビジネスロジックだけを追記していくため、**「スキーマと乖離した実装」**が入り込みにくい  
- ただし、**テストコードはやはり自動生成されない**（そもそもビジネスロジックの仕様に踏み込めないので、どう振る舞うべきかまでは書けない）  
- 生成された骨格を使い、実装やテストを足していく形になります

---

## まとめ

- **NestJS のコードファースト**で生成された Swagger (OpenAPI) はあくまで「API仕様のドキュメント」「クライアント用 SDK の生成元」として使うことがメイン  
- スキーマから「サーバーのテストコード」を**全面的に**自動生成するのは難しく、あまり一般的でない  
- どうしてもスキーマを用いてサーバーの仕様やテストを担保したい場合は  
  - **(1)** スキーマ由来の **クライアント側コード**を使って手動で e2e テストを書く  
  - **(2)** コントラクトテスト（Pact など）で「インターフェースどおりに動いているか」を検証する  
  - **(3)** いっそ「スキーマファースト＋NestJS 骨格生成」で実装を作る  
- いずれにせよ、「ビジネスロジック部分の振る舞い」をどこまで検証するかは人手でテストケースを設計・実装する必要がある

というのが現状です。  

&gt; 「OpenAPI で自動生成したテストでインターフェース担保」が理想的に見えても、実際には仕様の詳細（認可やドメイン要件など）は OpenAPI の範囲外にある場合が多く、自動化のメリットが薄いのが実情です。

---

## 👤 ユーザー
*2025/03/07 19:32:46*

1,と2を具体的に教えてほしい

---

## 🔧 ツール
*2025/03/07 19:32:48*

**スキーマと生成**

スキーマからOpenAPI Generatorを使ってクライアントコードを生成し、JestでE2Eテストを行う方法を探っています。

**契約観点の契約テスト**

Pactを使って、消費者が契約の期待をパクトファイルにキャプチャし、プロバイダーが契約に一致するレスポンスを確認する方法を説明している。

**他の選択肢の探索**

Dredd、Prism、Schemathesisなどのツールを使って、OpenAPI仕様に基づく契約テストを行う方法を探っている。

---

## 🤖 アシスタント
*2025/03/07 19:32:47*

NestJS（コードファースト）で生成した OpenAPI スキーマを使って「サーバー側がちゃんと定義どおりに動いているか」をテストしたい、という場合に考えられる手法として挙げた

1. **スキーマを元に「クライアントテストコード」を生成する**  
2. **コントラクトテスト（コンシューマドリブン契約テスト）**  

の2つについて、もう少し具体的な例や利用ツールなどをご紹介します。

---

# 1. スキーマを元に「クライアントテストコード」を生成する

## 全体像

1. **NestJS コードファースト**で生成した `openapi.yaml` または `openapi.json` がある  
2. **OpenAPI Generator** などを用いて、**クライアント用の SDK**（TypeScript のクライアントライブラリ）を生成  
3. そのクライアント SDK を使って、**サーバーに対する E2E テスト**を書く  

これによって、  
- **API のエンドポイントや DTO 型定義**がスキーマの通りかどうか  
- **エンドポイントを叩いたときに期待するレスポンスが返ってくるか**  

を、ある程度機械的にチェックしやすくなります。

### 必要な準備
- `openapi-generator-cli` (もしくは同等ツール)  
- 生成されたクライアントを呼び出せる E2E テスト環境（例: Jest + Supertest など）

### やり方の例

1. **OpenAPI スキーマを生成**  
   - NestJS + `@nestjs/swagger` を使い、`SwaggerModule.createDocument()` などで `openapi.json`（あるいは `openapi.yaml`）を出力  
2. **クライアントコードを生成**  
   - 例: TypeScript 用の Fetch ベースのクライアントを生成するとき  
     ```bash
     npx openapi-generator-cli generate \
       -i openapi.yaml \
       -g typescript-fetch \
       -o ./generated-client \
       --additional-properties=typescriptThreePlus=true
     ```
   - これで `./generated-client` にクライアントライブラリ (API呼び出し用クラスなど) が生成される
3. **テストコードで生成クライアントを使う**  
   - Jest を想定した例 (E2E テスト):  

     ```typescript
     // e2e/app.e2e-spec.ts (例)
     import { INestApplication } from '@nestjs/common';
     import { Test } from '@nestjs/testing';
     import { AppModule } from '../src/app.module';
     import { Configuration, DefaultApi } from '../generated-client'; 
       // ↑ openapi-generator で生成したクライアントを import

     describe('E2E tests using generated client', () => {
       let app: INestApplication;
       let apiClient: DefaultApi;

       beforeAll(async () => {
         const moduleRef = await Test.createTestingModule({
           imports: [AppModule],
         }).compile();

         app = moduleRef.createNestApplication();
         await app.init();
         await app.listen(3000);

         // NestJSを起動した localhost:3000 を叩くためのクライアント設定
         apiClient = new DefaultApi(
           new Configuration({
             basePath: 'http://localhost:3000',
           }),
         );
       });

       afterAll(async () => {
         await app.close();
       });

       it('should get list of users', async () => {
         const users = await apiClient.getUsers(); 
         // ← openapi.yaml の "paths: /users" 定義に対応したメソッド
         expect(Array.isArray(users)).toBe(true);
         expect(users.length).toBeGreaterThanOrEqual(1);
       });
     });
     ```
   - これにより、**生成されたメソッド群を呼び出して、サーバー実装がスキーマ通りか簡易チェック**できる

#### メリット・デメリット
- **メリット**  
  - スキーマどおりの引数・レスポンスを呼び出せるため、**サーバーとクライアントの定義ズレを検知しやすい**  
  - クライアント側 SDK と同じものを使うので、「実際のクライアントからの呼び出し」に近いテストを書ける
- **デメリット**  
  - テストのシナリオやアサーション内容は手動で書く必要がある（スキーマだけでは「どういう状態をテストすべきか」が分からない）  
  - 依存関係や認証など複雑なシナリオは、一部手動で補う必要がある

---

# 2. コントラクトテスト（コンシューマドリブン契約テスト）

## 全体像

**コントラクトテスト**とは、**API 提供者 (Provider) と利用者 (Consumer) の間で取り決めた契約 (Contract) を満たしているかを検証する**テスト手法です。

- 「コンシューマ（クライアント）の観点で、こう呼び出すとこう返してほしい」というシナリオを定義  
- その定義どおりにサーバーが応答を返すかどうかをサーバー側で検証  

### ツールの例

- **Pact（pact.io）**  
  - JavaScript/TypeScript 向けにも Pact JS が用意されている  
  - コンシューマサイドで「こう呼び出したらこう返ってきてほしい」を Pact ファイルとして出力し、プロバイダサイドでそれを読み込んで検証を行う  
- **Dredd**  
  - OpenAPI/Swagger を読み込んで、自動的にエンドポイントを叩く → レスポンスが定義と一致しているかをチェック  
  - [Dredd 公式ドキュメント](https://dredd.org/en/latest/) にもあるように、`dredd openapi.yaml http://localhost:3000` のような感じで実行するだけで、**OpenAPI と実際のレスポンスの整合性を検証**してくれます。
  - e2e テストに近い形で、**スキーマとサーバーが乖離していないか**をチェック

#### Pact を用いたコントラクトテスト(簡易例)

1. **クライアント側テスト**（Consumer Test）:  
   - クライアント側が想定するリクエスト/レスポンスを **Pact** として記録する  
   - 例: `pact --consumer "MyFrontend" --provider "MyAPI" ...`  
   - 結果として `pact` ファイル (JSON) が生成される
2. **プロバイダ側テスト**（Provider Test）:  
   - 先の `pact` ファイルを読み込み  
   - サーバー（NestJS）を立ち上げて、**実際にエンドポイントを叩いて**レスポンスが「Pact ファイルにある契約どおりか」検証  
   - OK なら「契約を満たしている」と判断できる

#### Dredd を用いたコントラクトテスト(簡易例)

1. **OpenAPI スキーマ (openapi.yaml)** を用意  
2. **Dredd をインストール**  
   ```bash
   npm install --save-dev dredd
   ```
3. **設定ファイル (.dredd.yml) や package.json のスクリプトを用意して実行**  
   ```yaml
   # .dredd.yml の例
   swagger: './openapi.yaml'
   endpoint: 'http://localhost:3000'
   ```  
   ```bash
   npx dredd
   ```
4. Dredd は `openapi.yaml` に定義された全エンドポイントを順番に呼び出し、  
   - **リクエスト/レスポンスの形式**  
   - **ステータスコード**  
   - **レスポンスボディ** が「OpenAPI の定義どおりか」  
   をチェックします。

### メリット・デメリット

- **メリット**  
  - **クライアント側が期待する挙動**（あるいは OpenAPI の定義）と**サーバー実装**がズレていないかを客観的にテストできる  
  - 「通り一遍の動作確認」であれば、かなり自動的に検証可能
- **デメリット**  
  - Pact: 「クライアントが想定するリクエスト/レスポンス」を作り込む必要がある  
  - Dredd: 生成されるリクエストに対してデータ内容を細かく指定するのは難しく、ビジネスルールや認証が複雑になると十分なテストにならない場合がある  
  - 結局は**ビジネスロジック的な検証**は、より詳細なシナリオテストを手書きしなければいけない

---

# まとめ

- **コードファースト**で NestJS から生成された OpenAPI スキーマを用いて「サーバーがスキーマ通りか」をテストするには、大きく分けて下記2パターンがあります。  
  1. **スキーマからクライアント用 SDK を生成し、それを使った E2E テストを書く**  
     - 手動でテストシナリオは書く必要があるが、クライアント視点で「型・エンドポイント」を厳密にチェック可能  
  2. **コントラクトテスト（Pact や Dredd など）で契約の整合を検証する**  
     - スキーマまたはクライアントが期待するリクエスト/レスポンスを自動で叩いて、一通りのエンドポイントが定義通り動作するかを確認  
     - 複雑なビジネスロジックは別途で手動テストやユニットテストが必要

- 完全な「自動テストの生成」にはならず、どうしても**ビジネス要件の部分は手動で補う**形になりますが、  
  - **API インターフェースの型・入出力**がスキーマに沿っているか  
  - **エンドポイント一覧の漏れがないか**  
  を効率よく検証する仕組みとしては有効です。

---
