# Swiftのイニシャライザと継承

日付: 2023-09-15

---

## 👤 ユーザー
*2023/9/15 16:08:55*

以下をQiitaの記事にして欲しい

// 伝えたいこと
// - 継承元の class の convenience initializer は継承先で super.init() で呼び出すことができない
// - イニシャライザの設定値の優先度は  convenience init &gt; デフォルト引数 
// - 以下の場合は super.init() の記述を省略することができる（というよりは勝手に super.init() で呼ばれてしまう）
//   - 継承元の class のイニシャライザの引数がないとき
//   - すべての継承元のイニシャライザの引数を設定しているとき
//   - ※ ただし、引数なしのイニシャライザを用意しても、他にイニシャライザを設定したり、convenience initializer を用意した場合

// そもそも Swift は class の多重継承が禁止されている、つまり、なるべくプロトコルで表現しようということなので、多重継承する前にプロトコルで解決できないかを検討した方が良いかもしれない。
// → `super.init()` が出てきた時点で、それはプロトコルで書くことができないかを考えた方がよさそう


// イニシャライザのデフォルト引数は convenience init で書き直すことができる
// (1) デフォルト引数の場合
class DefaultHogeClass {
    var moge: Int
    var fuga: Int

    init(moge: Int = 0, fuga: Int = 0) {
        self.moge = moge
        self.fuga = fuga
    }
}

// やりたいのは以下の2つ
let defaultHogeClass1: DefaultHogeClass = .init() // moge: 0, fuga: 0
let defaultHogeClass2: DefaultHogeClass = .init(moge: 1, fuga: 2) // moge: 1, fuga: 2

// 以下はできても嬉しくない HogeClass のイニシャライズ
let defaultHogeClass3: DefaultHogeClass = .init(moge: 1) // moge: 1, fuga: 0
let defaultHogeClass4: DefaultHogeClass = .init(fuga: 2) // moge: 0, fuga: 2

// 上記のように、意図とは異なる HogeClass イニシャライザが存在して、予期せぬイニシャライズがうまれてしまう
// 特に、多くの引数をとるような init でデフォルト引数を設定していると、抜けに気づきにくい


// (2) convenience init の場合
class ConvenienceHogeClass {
    var moge: Int
    var fuga: Int
    
    init(moge: Int, fuga: Int) {
        self.moge = moge
        self.fuga = fuga
    }
    
    convenience init() {
        self.init(moge: 0, fuga: 0)
    }
}

////// やりたいのは以下の2つ
//let hogeClass1: ConvenienceHogeClass = .init() // moge: 0, fuga: 0
//let hogeClass2: ConvenienceHogeClass = .init(moge: 1, fuga: 2) // moge: 1, fuga: 2
//
//// 以下はコンパイルエラーになる
////let hogeClass3: ConvenienceHogeClass = .init(moge: 1) // ❌ Missing argument for parameter 'fuga' in call
////let hogeClass4: ConvenienceHogeClass = .init(fuga: 2) // ❌ Missing argument for parameter 'fuga' in call


class DoubleInitHogeClass {
    var moge: Int
    var fuga: Int
    
    init(moge: Int, fuga: Int) {
        self.moge = moge
        self.fuga = fuga
    }

    init() {
        self.moge = 0
        self.fuga = 0
    }
}


//// やりたいのは以下の2つ
let doubleInitHogeClass1: DoubleInitHogeClass = .init() // moge: 0, fuga: 0
let doubleInitHogeClass2: DoubleInitHogeClass = .init(moge: 1, fuga: 2) // moge: 1, fuga: 2

// あれ、、、どっちでもよくね？

// コンパイルエラー
//class SubDoubleInitHogeClass: DoubleInitHogeClass {
//    var piyo: Int
//
//    init(piyo: Int) {
//        self.piyo = piyo
//    } // ❌ 'super.init' isn't called on all paths before returning from initializer
//}

class SubDoubleInitHogeClass1: DoubleInitHogeClass {
    var piyo: Int
    
    init(piyo: Int) {
        self.piyo = piyo

        // print("moge: \\(self.moge)") // ❌ 'self' used in property access 'moge' before 'super.init' call
        // print("fuga: \\(self.fuga)") // ❌ 'self' used in property access 'fuga' before 'super.init' call

        super.init(moge: 1, fuga: 2)

        print("moge: \\(self.moge)") // moge: 1
        print("fuga: \\(self.fuga)") // fuga: 2
    }
}

class SubDoubleInitHogeClass2: DoubleInitHogeClass {
    var piyo: Int
    
    init(piyo: Int) {
        self.piyo = piyo

        // print("moge: \\(self.moge)") // ❌ 'self' used in property access 'moge' before 'super.init' call
        // print("fuga: \\(self.fuga)") // ❌ 'self' used in property access 'fuga' before 'super.init' call

        super.init()

        print("moge: \\(self.moge)") // moge: 0
        print("fuga: \\(self.fuga)") // fuga: 0
    }
}

// 以下はコンパイルエラー
//class SubConvenienceHogeClass: ConvenienceHogeClass {
//    var piyo: Int
//
//    init(piyo: Int) {
//        self.piyo = piyo
//    } // ❌ 'super.init' isn't called on all paths before returning from initializer
//}

// どちらともOK


class SubConvenienceHogeClass1: ConvenienceHogeClass {
    var piyo: Int
    
    init(piyo: Int) {
        self.piyo = piyo

        // print("moge: \\(self.moge)") // ❌ 'self' used in property access 'moge' before 'super.init' call
        // print("fuga: \\(self.fuga)") // ❌ 'self' used in property access 'fuga' before 'super.init' call

        super.init(moge: 1, fuga: 2)
        
        print("moge: \\(self.moge)") // moge: 1
        print("fuga: \\(self.fuga)") // fuga: 2
    }
}

// コンパイルエラー
//class SubConvenienceHogeClass2: ConvenienceHogeClass {
//    var piyo: Int
//
//    init(piyo: Int) {
//        self.piyo = piyo
//        super.init() // ❌ Must call a designated initializer of the superclass 'ConvenienceHogeClass'
//    }
//}

// 継承させる場合は convenience initializer 呼べない
// → convenience initializer は、あくまでもその class 限定での簡易的なイニシャライザである

// convenience ではなく、イニシャライザを複数持つ場合は、そのクラスの仕様を意味していることになる（initの初期値を外部から指定する方法が複数あることを意味する）

// これは怒らなれない!!
class SubDefaultHogeClass: DefaultHogeClass {
    var piyo: Int
    
    init(piyo: Int) {
        self.piyo = piyo
    }
}

// なんで？

// moge と fuga の両方でデフォルト引数とっていたのを fuga だけにする

class DefaultHogeClass2 {
    var moge: Int
    var fuga: Int

    init(moge: Int, fuga: Int = 0) {
        self.moge = moge
        self.fuga = fuga
    }
}

// コンパイルエラー
//class SubDefaultHogeClass2: DefaultHogeClass2 {
//    var piyo: Int
//
//    init(piyo: Int) {
//        self.piyo = piyo
//    } // 'super.init' isn't called on all paths before returning from initializer
//}

// どうやらすべてのイニシャライザの引数のデフォルト値が設定している場合のみ、その super class を継承したときに super.init の省略が可能になる（というよりも、勝手に super.init() の処理を行うらしい）

class DefaultHogeClass3 {
    var moge: Int
    var fuga: Int

    init(moge: Int, fuga: Int) {
        self.moge = moge
        self.fuga = fuga
    }
}

// コンパイルエラー
//class SubDefaultHogeClass3: DefaultHogeClass3 {
//    var piyo: Int
//
//    init(piyo: Int) {
//        self.piyo = piyo
//    } // 'super.init' isn't called on all paths before returning from initializer
//}

class DefaultHogeClass4 {
    var moge: Int = 0
    var fuga: Int = 0
}

// コンパイルエラーにならない！
class SubDefaultHogeClass4: DefaultHogeClass4 {
    var piyo: Int

    init(piyo: Int) {
        self.piyo = piyo
    } // 'super.init' isn't called on all paths before returning from initializer
}


class DefaultHogeClass4\_2 {
    var moge: Int
    var fuga: Int
    
    init() {
        moge = 0
        fuga = 0
    }
}

// コンパイルエラーにならない！
class SubDefaultHogeClass4\_2: DefaultHogeClass4\_2 {
    var piyo: Int

    init(piyo: Int) {
        self.piyo = piyo
    } // 'super.init' isn't called on all paths before returning from initializer
}


class SubDefaultHogeClass5: DefaultHogeClass {
    var piyo: Int
    
    init(piyo: Int) {
        self.piyo = piyo

        // print("moge: \\(self.moge)") // ❌ 'self' used in property access 'moge' before 'super.init' call
        // print("fuga: \\(self.fuga)") // ❌ 'self' used in property access 'fuga' before 'super.init' call

        super.init(moge: 1, fuga: 2)

        print("moge: \\(self.moge)") // moge: 1
        print("fuga: \\(self.fuga)") // fuga: 2
    }
}



class SubDefaultHogeClass6: DefaultHogeClass {
    var piyo: Int
    
    init(piyo: Int) {
        self.piyo = piyo

        // print("moge: \\(self.moge)") // ❌ 'self' used in property access 'moge' before 'super.init' call
        // print("fuga: \\(self.fuga)") // ❌ 'self' used in property access 'fuga' before 'super.init' call

        super.init()

        print("moge: \\(self.moge)") // moge: 0
        print("fuga: \\(self.fuga)") // fuga: 0
    }
}



// (2) デフォルト値 vs デフォルト引数 vs convenience init
class ConvenienceHogeClassHogeHoge {
    var moge: Int = 0
    var fuga: Int = 0
    
    init(moge: Int = 1, fuga: Int = 2) {
        self.moge = moge
        self.fuga = fuga
    }
    
    convenience init() {
        self.init(moge: 3, fuga: 4)
    }
}

//
let piyo = ConvenienceHogeClassHogeHoge()
print(piyo.moge) // コンビニエンスinitが優先される

// 優先度がデフォルト引数 &gt; デフォルト値の話はこちらで実験
// ちなみに優先度は convenience init &gt; デフォルト引数 &gt; デフォルト値


struct HogeStruct {
    var moge: Int
    var fuga: Int

    init(moge: Int, fuga: Int) {
        self.moge = moge
        self.fuga = fuga
    }
    
//    convenience init() { // ❌ Initializers in structs are not marked with 'convenience'
//        self.init(moge: 0, fuga: 0)
//    }

    init() {
        self.init(moge: 0, fuga: 0)
    }
}

---

## 🤖 アシスタント
*2023/9/15 16:10:04*

## Swiftにおける`super.init()`について

### 1. `convenience initializer` と `super.init()`
継承元の class の convenience initializer は継承先で `super.init()` で呼び出すことができない。これは、convenience initializerが、そのclass限定での簡易的なイニシャライザであるためです。

### 2. イニシャライザの設定値の優先度
イニシャライザの設定値の優先度は、`convenience init`がデフォルト引数よりも高い。

### 3. `super.init()`の省略
以下の場合は `super.init()` の記述を省略することができる。

- 継承元の class のイニシャライザの引数がないとき
- すべての継承元のイニシャライザの引数を設定しているとき

ただし、引数なしのイニシャライザを用意しても、他にイニシャライザを設定したり、convenience initializer を用意した場合は例外です。

### 4. Swiftと多重継承
Swiftはclassの多重継承が禁止されている。これは、Swiftがプロトコルベースのデザインを推奨しているためです。したがって、`super.init()`が必要とされる場面で、プロトコルを使って問題を解決できないかを検討することが推奨されています。

### 5. イニシャライザのデフォルト引数 vs convenience init
デフォルト引数を使用したイニシャライザは、意図しないイニシャライザの呼び出しを許容する可能性があります。特に多くの引数を持つinitでデフォルト引数を設定していると、抜けやミスに気づきにくくなります。この問題は、convenience initを使用することで解決できます。

### まとめ
Swiftにおけるイニシャライザは多様であり、それぞれの特性を理解することが重要です。継承時の`super.init()`の動作や、convenience initializer、デフォルト引数など、Swift特有の振る舞いを知ることで、より安全で読みやすいコードを書くことができます。

---
