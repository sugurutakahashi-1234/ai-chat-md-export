# クリーンアーキテクチャSwiftサンプル

日付: 2024-03-01

---

## 👤 ユーザー
*2024/3/1 13:24:20*

クリーンアーテクチャーの sampleアプリをSwiftで考えている。

二つのドライバー(マネージャー)を使ったUseCaseのコードを考えているのだけれでも、シンプルな候補を考えてほしい。

---

## 🤖 アシスタント
*2024/3/1 13:25:17*

クリーンアーテクチャーをSwiftで実装する際に、2つのドライバー（例えば、データベースマネージャーとネットワークマネージャー）を使用するシンプルなUseCaseのサンプルを考えてみましょう。この例では、ユーザー情報を取得して表示する基本的な機能を想定します。

### プロジェクトの構造

- **Entities**: ドメインオブジェクト（例: User）
- **Use Cases**: アプリケーションのビジネスロジック（例: FetchUserInfoUseCase）
- **Interface Adapters**: データ変換やプレゼンター（例: UserPresenter）
- **Frameworks & Drivers**: 外部との通信やデータ管理（例: DatabaseManager, NetworkManager）

### ステップバイステップ

#### 1. Entitiesの定義

```swift
struct User {
    let id: Int
    let name: String
    let email: String
}
```

#### 2. データソースプロトコルの定義

データベースとネットワーク操作のためのプロトコルを定義します。

```swift
protocol UserDataRepository {
    func fetchUserFromDB(completion: @escaping (User?) -> Void)
    func fetchUserFromNetwork(completion: @escaping (User?) -> Void)
}
```

#### 3. Use Caseの実装

ユーザー情報を取得するUseCaseを実装します。まず、データベースからユーザー情報を取得し、それが失敗した場合はネットワークから取得します。

```swift
class FetchUserInfoUseCase {
    private let repository: UserDataRepository
    
    init(repository: UserDataRepository) {
        self.repository = repository
    }
    
    func execute(completion: @escaping (User?) -> Void) {
        repository.fetchUserFromDB { user in
            if let user = user {
                completion(user)
            } else {
                self.repository.fetchUserFromNetwork(completion: completion)
            }
        }
    }
}
```

#### 4. データソースの実装

`UserDataRepository`プロトコルに従って、データベースとネットワークマネージャーを実装します。

```swift
class DataManager: UserDataRepository {
    func fetchUserFromDB(completion: @escaping (User?) -> Void) {
        // データベースからユーザー情報を取得するロジック
        // 例: completion(User(id: 1, name: "John Doe", email: "john@example.com"))
    }
    
    func fetchUserFromNetwork(completion: @escaping (User?) -> Void) {
        // ネットワークからユーザー情報を取得するロジック
        // 例: completion(User(id: 1, name: "John Doe", email: "john@example.com"))
    }
}
```

#### 5. Use Caseの使用

最後に、UseCaseを実際に使用してみます。例えば、あるViewControllerからこのUseCaseを呼び出す場合です。

```swift
class UserViewController: UIViewController {
    var useCase: FetchUserInfoUseCase!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let dataManager = DataManager()
        self.useCase = FetchUserInfoUseCase(repository: dataManager)
        
        useCase.execute { [weak self] user in
            DispatchQueue.main.async {
                // UIを更新する
                // 例: self?.nameLabel.text = user?.name
            }
        }
    }
}
```

このサンプルは、クリーンアーキテクチャの基本的な概念をSwiftで実装したものです。実際のプロジェクトでは、エラーハンドリング、非同期処理の詳細、依存性注入のフレームワークの使用など、さらに多くの考慮が必要になります。

---

## 👤 ユーザー
*2024/3/1 13:30:24*

いい案だね。
SwiftUIのMVVMでVMのイニシャライザで
Firebase remote config取得ドライバーとバージョン判定ドライバーを渡して、
強制アップデート判定を行ってほしい

各ドライバーはprotocolを作ってほしい。
View側では強制アップデートが必要であれば強制アップデートが必要ですという文言を表示して、必要でなければ強制アップデートは必要ではありません。と表示してほしい。

---

## 🤖 アシスタント
*2024/3/1 13:31:11*

SwiftUIとMVVMアーキテクチャを使用して、Firebase Remote Configとアプリのバージョンをチェックする強制アップデートのロジックを実装する方法を説明します。まず、Firebase Remote Config取得ドライバーとバージョン判定ドライバーのためのプロトコルを定義し、それからViewModelでこれらのドライバーを使用して強制アップデートが必要かどうかを判定します。最後に、View側でこの判定結果に基づいてユーザーにメッセージを表示します。

### Step 1: ドライバープロトコルの定義

#### Firebase Remote Configドライバー

```swift
protocol FirebaseRemoteConfigFetching {
    func fetchRemoteConfig(completion: @escaping (Result<String, Error>) -> Void)
}
```

#### アプリバージョン判定ドライバー

```swift
protocol AppVersionChecking {
    func getCurrentAppVersion() -> String
    func getMinimumSupportedVersion(completion: @escaping (String) -> Void)
}
```

### Step 2: ViewModelの実装

ViewModelでは、これらのプロトコルを使用して強制アップデートが必要かどうかを判定します。

```swift
import Foundation
import Combine

class UpdateViewModel: ObservableObject {
    @Published var updateMessage: String = ""
    
    private var firebaseRemoteConfigFetcher: FirebaseRemoteConfigFetching
    private var appVersionChecker: AppVersionChecking
    
    init(firebaseRemoteConfigFetcher: FirebaseRemoteConfigFetching, appVersionChecker: AppVersionChecking) {
        self.firebaseRemoteConfigFetcher = firebaseRemoteConfigFetcher
        self.appVersionChecker = appVersionChecker
        checkForForcedUpdate()
    }
    
    private func checkForForcedUpdate() {
        appVersionChecker.getMinimumSupportedVersion { [weak self] minimumVersion in
            let currentVersion = self?.appVersionChecker.getCurrentAppVersion() ?? ""
            if currentVersion.compare(minimumVersion, options: .numeric) == .orderedAscending {
                // 現在のバージョンがサポートされている最小バージョンよりも小さい場合
                DispatchQueue.main.async {
                    self?.updateMessage = "強制アップデートが必要です"
                }
            } else {
                // アップデートが必要ない場合
                DispatchQueue.main.async {
                    self?.updateMessage = "強制アップデートは必要ではありません。"
                }
            }
        }
    }
}
```

### Step 3: Viewの実装

ViewModelを使用して、ユーザーに適切なメッセージを表示します。

```swift
import SwiftUI

struct UpdateView: View {
    @StateObject var viewModel: UpdateViewModel
    
    var body: some View {
        Text(viewModel.updateMessage)
            .onAppear() {
                // ViewModelの初期化やその他のロジックが必要な場合はここに記述
            }
    }
}
```

### Step 4: ViewModelとViewの接続

実際にViewModelをViewに接続するために、適切なドライバーの実装を提供し、ViewModelを初期化してViewに渡します。この部分はアプリの起動ロジックや依存性注入のセットアップに依存しますが、基本的なアイデアは以下のようになります。

```swift
// FirebaseRemoteConfigFetcherとAppVersionCheckerの具体的な実装を提供する必要があります。
let firebaseRemoteConfigFetcher = FirebaseRemoteConfigFetcherImpl()
let appVersionChecker = AppVersionCheckerImpl()

// ViewModelの初期化
let updateViewModel = UpdateViewModel(firebaseRemoteConfigFetcher: firebaseRemoteConfigFetcher, appVersionChecker: appVersionChecker)

// Viewの初期化とViewModelの注入
let updateView = UpdateView(viewModel: updateViewModel)
```

この例では、`FirebaseRemoteConfigFetcherImpl`と`AppVersionCheckerImpl`は、それぞれ`FirebaseRemoteConfigFetching`と`AppVersionChecking`プロトコルの具体的な実装を提供するクラスです。これらのクラスはFirebase Remote ConfigのAPIとアプリのバージョン情報を扱うロジックを実装する必要があります。

このアプローチにより、SwiftUIとMVVMを使用して、アプリ内で強制アップデートのロジックをクリーンに実装できます。

---

## 👤 ユーザー
*2024/3/1 14:12:37*

ちょっとイメージが違う。
バージョン判定ドライバーはバージョン判定処理のみで取得はできない。
むしろリモートコンフィグドライバーはリモートコンフィグの取得しかできないイメージです。

---

## 🤖 アシスタント
*2024/3/1 14:13:52*

了解しました。それでは、Firebase Remote Configから最小サポートバージョンを取得するドライバーと、アプリの現在のバージョンを判断するだけのバージョン判定ドライバーに分けて、それぞれの役割を明確に分離しましょう。

### Step 1: ドライバープロトコルの再定義

#### Firebase Remote Configドライバー

```swift
protocol FirebaseRemoteConfigFetching {
    func fetchMinimumSupportedVersion(completion: @escaping (Result<String, Error>) -> Void)
}
```

#### アプリバージョン判定ドライバー

```swift
protocol AppVersionChecking {
    func isUpdateRequired(currentVersion: String, minimumSupportedVersion: String) -> Bool
}
```

### Step 2: ViewModelの再実装

ViewModelで、Firebase Remote Configから取得した最小サポートバージョンと現在のアプリバージョンを比較して、アップデートが必要かどうかを判断します。

```swift
import Foundation
import Combine

class UpdateViewModel: ObservableObject {
    @Published var updateMessage: String = ""
    
    private var firebaseRemoteConfigFetcher: FirebaseRemoteConfigFetching
    private var appVersionChecker: AppVersionChecking
    
    init(firebaseRemoteConfigFetcher: FirebaseRemoteConfigFetching, appVersionChecker: AppVersionChecking) {
        self.firebaseRemoteConfigFetcher = firebaseRemoteConfigFetcher
        self.appVersionChecker = appVersionChecker
        checkForForcedUpdate()
    }
    
    private func checkForForcedUpdate() {
        firebaseRemoteConfigFetcher.fetchMinimumSupportedVersion { [weak self] result in
            switch result {
            case .success(let minimumVersion):
                let currentVersion = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? ""
                if self?.appVersionChecker.isUpdateRequired(currentVersion: currentVersion, minimumSupportedVersion: minimumVersion) == true {
                    DispatchQueue.main.async {
                        self?.updateMessage = "強制アップデートが必要です"
                    }
                } else {
                    DispatchQueue.main.async {
                        self?.updateMessage = "強制アップデートは必要ではありません。"
                    }
                }
            case .failure(_):
                DispatchQueue.main.async {
                    self?.updateMessage = "バージョン情報の取得に失敗しました。"
                }
            }
        }
    }
}
```

### Step 3: Viewの実装

ViewModelを使用して、ユーザーに適切なメッセージを表示します。

```swift
import SwiftUI

struct UpdateView: View {
    @StateObject var viewModel = UpdateViewModel(
        firebaseRemoteConfigFetcher: FirebaseRemoteConfigFetcherImpl(),
        appVersionChecker: AppVersionCheckerImpl()
    )
    
    var body: some View {
        Text(viewModel.updateMessage)
    }
}
```

### ドライバーの具体的な実装

Firebase Remote Configとアプリバージョン判定の具体的な実装は、プロジェクトの要件やFirebase SDKのバージョンによって異なります。以下は、それぞれのプロトコルに対する簡単な実装例です。

#### Firebase Remote Configドライバーの実装例

Firebase Remote Configから最小サポートバージョンを取得する実装です。Firebase SDKのセットアップとRemote Configの設定が必要です。

```swift
class FirebaseRemoteConfigFetcherImpl: FirebaseRemoteConfigFetching {
    func fetchMinimumSupportedVersion(completion: @escaping (Result<String, Error>) -> Void) {
        // Firebase Remote Configのセットアップと最小サポートバージョンの取得ロジック
    }
}
```

#### アプリバージョン判定ドライバーの実装例

```swift
class AppVersionCheckerImpl: AppVersionChecking {
    func isUpdateRequired(currentVersion: String, minimumSupportedVersion: String) -> Bool {
        return currentVersion.compare(minimumSupportedVersion, options: .numeric) == .orderedAscending
    }
}
```

この設計により、各コンポーネントの責務が明確に分離され、テストや保守が容易になります。また、将来的に異なるバージョン判定ロジックや設定取得方法に変更があった場合でも、影響範囲を最小限に抑えることができます。

---

## 👤 ユーザー
*2024/3/1 16:19:39*

バージョン判定ドライバーは2つの文字列を比較して、それがenumで大きい 小さい 同じの3つの種類を返すようなイメージ、もしくはコンペアブルな型に変換するイメージ。

---

## 🤖 アシスタント
*2024/3/1 16:20:04*

了解しました。バージョン判定ドライバーが2つのバージョン文字列を比較して、その結果を「大きい」「小さい」「同じ」の3つの状態を持つenumで返すように設計し直しましょう。このアプローチにより、バージョン比較の結果をより明確に扱えるようになります。

### Step 1: バージョン比較結果のEnum定義

まず、バージョン比較の結果を表すenumを定義します。

```swift
enum VersionComparisonResult {
    case older
    case same
    case newer
}
```

### Step 2: バージョン判定ドライバープロトコルの更新

バージョン判定ドライバーが2つのバージョン文字列を比較し、`VersionComparisonResult` enumを返すようにプロトコルを更新します。

```swift
protocol AppVersionChecking {
    func compareVersions(currentVersion: String, minimumSupportedVersion: String) -> VersionComparisonResult
}
```

### Step 3: バージョン判定ドライバーの具体的な実装

次に、`AppVersionChecking` プロトコルに従って、バージョン文字列を比較する具体的なロジックを実装します。

```swift
class AppVersionCheckerImpl: AppVersionChecking {
    func compareVersions(currentVersion: String, minimumSupportedVersion: String) -> VersionComparisonResult {
        let currentVersionArray = currentVersion.split(separator: ".").compactMap { Int($0) }
        let minimumVersionArray = minimumSupportedVersion.split(separator: ".").compactMap { Int($0) }
        
        for (current, minimum) in zip(currentVersionArray, minimumVersionArray) {
            if current < minimum {
                return .older
            } else if current > minimum {
                return .newer
            }
        }
        
        if currentVersionArray.count < minimumVersionArray.count {
            return .older
        } else if currentVersionArray.count > minimumVersionArray.count {
            return .newer
        }
        
        return .same
    }
}
```

### Step 4: ViewModelの更新

ViewModel内で、このバージョン判定ドライバーを使用して、アプリのバージョンがFirebase Remote Configで設定された最小サポートバージョンより古いかどうかを判断し、適切なメッセージをユーザーに表示します。

```swift
private func checkForForcedUpdate() {
    firebaseRemoteConfigFetcher.fetchMinimumSupportedVersion { [weak self] result in
        switch result {
        case .success(let minimumVersion):
            let currentVersion = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? ""
            let comparisonResult = self?.appVersionChecker.compareVersions(currentVersion: currentVersion, minimumSupportedVersion: minimumVersion)
            
            DispatchQueue.main.async {
                switch comparisonResult {
                case .older:
                    self?.updateMessage = "強制アップデートが必要です"
                case .same, .newer, .none:
                    self?.updateMessage = "強制アップデートは必要ではありません。"
                }
            }
        case .failure(_):
            DispatchQueue.main.async {
                self?.updateMessage = "バージョン情報の取得に失敗しました。"
            }
        }
    }
}
```

### Step 5: Viewの実装

ViewModelを使用して、ユーザーに適切なメッセージを表示します。この部分は前述の例と同様です。

この設計により、アプリのバージョンが最小サポートバージョンより古い、新しい、または同じであるかをより明確に判断でき、ユーザーに対して適切なアクションを促すことができます。

---
