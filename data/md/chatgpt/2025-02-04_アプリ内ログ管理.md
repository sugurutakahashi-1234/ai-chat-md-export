# アプリ内ログ管理

日付: 2025-02-04

---

## 👤 ユーザー
*2025/2/4 14:31:04*

Flutterでアプリ内で debugPrint によってログ出力している。
これをFlutterのアプリ内にデバッグ画面を作成して、そこから確認したり、全文をクリップボードにほぞんするようなことはできないか？

---

## 🔧 ツール
*2025/2/4 14:31:25*

\*\*Capturing debug logs\*\*

The user is curious about capturing debug logs in a Flutter app to display them on a debug screen and copy them to the clipboard, given debugPrint's typical console output.

---

## 🤖 アシスタント
*2025/2/4 14:31:25*

Flutter が標準で提供している `debugPrint` はコンソール（デバッガ）に文字列を出力するための機能であり、「アプリ内部で発生しているログをアプリ内の画面から閲覧したりコピーしたりできるようにする」機能は用意されていません。  
しかし「**自前でログを保持しつつコンソールにも出力する**」ような仕組みを作れば、アプリ内で好きなタイミングにログ閲覧画面を表示したり、全文をクリップボードにコピーすることが可能になります。

---

## 実現するためのアプローチ

### 1. グローバル/シングルトンでログリストを保持する
- ログを保持する `List<String>` や `StringBuffer` のような変数を用意し、そこにログを追記する。
- `debugPrint` で出力していたところを、**ラップしたカスタム関数**に置き換えて呼び出す。  
  - 置き換えたカスタム関数の中で「自前のリストに追記」→「コンソールに出力」という処理を行う。  
- そのリストをアプリ内のデバッグ画面で表示すればよい。  

#### 例: シンプルトンでログ管理する例

```dart
class LogManager {
  // シングルトンのインスタンス
  static final LogManager _instance = LogManager._internal();
  factory LogManager() => _instance;

  LogManager._internal();

  // ログを保持するバッファ
  final List<String> _logs = [];

  // ログを追記するメソッド
  void addLog(String message) {
    _logs.add(message);
  }

  // ログを取得する
  List<String> getLogs() {
    return List.unmodifiable(_logs);
  }

  // ログをクリアする
  void clearLogs() {
    _logs.clear();
  }
}
```

### 2. `debugPrint` を置き換える
Flutter では、`debugPrint` はグローバル変数として定義されているため、アプリ起動時に自前の関数に差し替えることが可能です。

```dart
void main() {
  // debugPrint を自前の関数に差し替える
  debugPrint = (String? message, {int? wrapWidth}) {
    if (message == null) return;
    // 自前のログ管理クラスに保存
    LogManager().addLog(message);

    // 実際にコンソールにも出力したい場合は print や、
    // Flutter 既定の debugPrint 代用で出力する。
    // ただし、debugPrint の元実装呼び出しは注意が必要なので
    // print を使うことをお勧めします（ループに陥る可能性があるため）。
    print(message);
  };

  runApp(const MyApp());
}
```

> **注意**: ここで `debugPrint` に対して元の実装を呼び出すのは、`debugPrint` 自身を再帰的に呼び出すことになるため注意が必要です。  
> ループにならないように、コンソールへの出力は `print` や `stderr.writeln` を使用するほうがシンプルです。

この方法であれば、`debugPrint("ログ出力");` を書いたタイミングで必ず `LogManager` にもログが溜まっていきます。

### 3. デバッグ画面を作成してログ表示 & クリップボードコピー
あとはログを表示する画面を用意して、`LogManager.getLogs()` で取得したログを `ListView` などで一覧表示すればよいです。  
たとえば以下の例では、  
- 画面に `ListView` でログを表示する
- 「全ログコピー」ボタンをタップするとクリップボードにコピーされる
- 「クリア」ボタンでログを消去

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // Clipboard を使うため

class DebugScreen extends StatefulWidget {
  const DebugScreen({Key? key}) : super(key: key);

  @override
  State<DebugScreen> createState() => _DebugScreenState();
}

class _DebugScreenState extends State<DebugScreen> {
  late List<String> _logs;

  @override
  void initState() {
    super.initState();
    _reloadLogs();
  }

  void _reloadLogs() {
    setState(() {
      _logs = LogManager().getLogs();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Debug Logs'),
        actions: [
          IconButton(
            icon: const Icon(Icons.copy),
            onPressed: () async {
              // 全文をクリップボードへコピー
              final allLogs = _logs.join('\n');
              await Clipboard.setData(ClipboardData(text: allLogs));
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('ログをコピーしました')),
                );
              }
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete),
            onPressed: () {
              LogManager().clearLogs();
              _reloadLogs();
            },
          ),
        ],
      ),
      body: _logs.isEmpty
          ? const Center(child: Text('ログはありません'))
          : ListView.builder(
              itemCount: _logs.length,
              itemBuilder: (context, index) {
                return ListTile(
                  title: Text(_logs[index]),
                );
              },
            ),
    );
  }
}
```

このようなデバッグ用画面を用意しておけば、ログの内容を**アプリ自体の中で**確認したり、コピーしたりできるようになります。

---

## その他の方法

1. **Logger パッケージ**を使う  
   [logger](https://pub.dev/packages/logger) や [logging](https://pub.dev/packages/logging) などのサードパーティパッケージを使うと、コンソール出力だけでなくファイル出力や独自の出力先など拡張しやすくなります。  
   - `Logger` パッケージを使ってログを記録しつつ、コンソールにも出力しつつ、メモリ（or ファイル）にも保存するようにカスタマイズして、同様にアプリ内に表示できるようにする。  

2. **別途ファイルに保存する**  
   アプリの内部ストレージ（`getApplicationDocumentsDirectory` など）にログを保存しておく方法もあります。  
   - ただし、ファイルとして扱う場合は、読み書きのオーバーヘッドや容量制限などの面倒を見る必要がある。  
   - デバッグ用途ならメモリ上のキューやリストに貯めるだけでも十分なことが多い。  

3. **Flutter DevTools でリリースビルドでもログを拾う**  
   いわゆるコンソールログを「アプリ内」ではなく、DevTools のログ機能で見る場合は、そもそもこのアプローチは不要ですが、リリースビルドなどでログ確認したい場合は、アプリに組み込んだ機能があると便利です。  

---

## まとめ

- Flutter 標準の `debugPrint` はあくまでコンソール出力専用。
- アプリ内部のデバッグ画面に表示するには、自前でログをバッファに蓄積しておく仕組みが必要。
- `debugPrint` そのものを上書きし、ログ管理クラスに保存するようにすると簡単。
- 保存したログをリスト表示＋クリップボードコピーなどの UI を付ければ、アプリ内でのログ閲覧画面が実装可能。

このように「ログを自前で保持する仕組み」を用意すれば、デバッグ目的の画面をアプリ内で開き、ログを直接確認・コピーしたりできるようになります。

---

## 👤 ユーザー
*2025/2/4 14:34:18*

log()での出力だったらアプリ内に表示することは可能なのか？

---

## 🔧 ツール
*2025/2/4 14:34:38*

\*\*Combining log analysis\*\*

I'm working through capturing dart:developer logs for in-app debugging, leaning towards custom log management with in-memory storage or using the logging package for interception.

\*\*Investigating options\*\*

Hm, that's interesting. I'm considering custom log aggregation or interception to manage in-app dart:developer logs, while noting 'log()' function's standard role in developer logging.

---

## 🤖 アシスタント
*2025/2/4 14:34:38*

結論から言うと、`dart:developer` の `log()` 関数を直接使っているだけでは、アプリ内で自動的にログを閲覧できる機能は備わっていません。`debugPrint` の場合と同様に、**自前でログを保持する仕組み**を用意しない限りは、コンソール（デバッガ）に出力されるだけで終わります。  

以下では、`log()` を使っているケースについてもう少し詳しく解説します。

---

## 1. `dart:developer` の `log()` とは？

- `log()` は Dart 標準ライブラリの [`dart:developer`](https://api.dart.dev/stable/dart-developer/dart-developer-library.html) パッケージに含まれており、  
  ```dart
  import 'dart:developer';
  
  void main() {
    log('ログメッセージ', name: 'myLogger');
  }
  ```
  のように呼び出すことができます。
- これはコンソールにメッセージを表示するとともに、タイムラインイベント（Observatory / DevTools）にログを吐くために使われる関数です。

Flutter アプリの中で `log()` を呼んでも、
- 通常はコンソール上に表示される  
- Flutter DevTools を使えば、**DevTools 上の Timeline などでも確認できる**  
というのが主な用途です。

しかし、あくまで **コンソールに出力する** or **Observatory/DevTools に情報を送る** ための仕組みなので、そのログを**アプリ内で表示する**ような仕組みは備わっていません。

---

## 2. `log()` をラップして自前で保持すればアプリ内表示も可能

`log()` 自体にはインターセプト用のコールバックが用意されているわけではないため、`debugPrint` の場合と同じように「**自分で `log()` 関数をラップする**」というアプローチになります。

### カスタム関数を作る例

```dart
import 'dart:developer' as dev;

class AppLogger {
  static final List<String> _logs = [];

  static void log(String message, {String name = 'AppLogger'}) {
    // 1. メモリに保持（アプリ内で閲覧用）
    _logs.add(message);

    // 2. 本来のdart:developerログも吐いておく
    dev.log(message, name: name);
  }

  static List<String> getLogs() => List.unmodifiable(_logs);

  static void clearLogs() {
    _logs.clear();
  }
}
```

- すべての `log()` 呼び出しを、この `AppLogger.log()` に置き換えるか、あるいは専用の呼び出しだけ差し替えるなどして使います。
- これで「アプリ内に溜めたログ一覧」と「コンソール表示・DevTools での確認」の両方ができます。

### アプリ内デバッグ画面の例

上記の `AppLogger` が提供する `getLogs()` を、`ListView` などで表示すればOKです。  

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class DebugLogScreen extends StatefulWidget {
  const DebugLogScreen({Key? key}) : super(key: key);

  @override
  State<DebugLogScreen> createState() => _DebugLogScreenState();
}

class _DebugLogScreenState extends State<DebugLogScreen> {
  late List<String> _logs;

  @override
  void initState() {
    super.initState();
    _logs = AppLogger.getLogs();
  }

  void _reloadLogs() {
    setState(() {
      _logs = AppLogger.getLogs();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Debug Log'),
        actions: [
          IconButton(
            icon: const Icon(Icons.copy),
            onPressed: () async {
              final allLogs = _logs.join('\n');
              await Clipboard.setData(ClipboardData(text: allLogs));
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('ログをコピーしました')),
                );
              }
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete),
            onPressed: () {
              AppLogger.clearLogs();
              _reloadLogs();
            },
          ),
        ],
      ),
      body: _logs.isEmpty
          ? const Center(child: Text('ログはありません'))
          : ListView.builder(
              itemCount: _logs.length,
              itemBuilder: (context, index) {
                return ListTile(
                  title: Text(_logs[index]),
                );
              },
            ),
    );
  }
}
```

---

## 3. `logging` パッケージでのインターセプトを利用する方法

もう一つの方法として、Dart/Flutter でよく使われる [`logging`](https://pub.dev/packages/logging) パッケージ（公式）があり、こちらには **ログ出力をリスナー（ハンドラ）で拾える機構** があります。  

```dart
import 'package:logging/logging.dart';

void main() {
  // ログを監視し、アプリ内で保持する
  Logger.root.level = Level.ALL;
  Logger.root.onRecord.listen((record) {
    // カスタムのリストに入れる
    // あるいはコンソール出力など
    print('[${record.loggerName}] ${record.level.name}: ${record.message}');
  });

  final myLogger = Logger('myLogger');

  myLogger.info('ログテスト');
  myLogger.warning('ちょっとやばいログ');
}
```

`log()` は `dart:developer` のメソッドですが、`logging` パッケージの `Logger` クラスに揃えることで、
- ログレベル（INFO, WARN, ERROR など）  
- ロガー名  
- スタックトレース  
なども含めて扱えるようになります。  
また、`Logger` で出力したものは `Logger.root.onRecord.listen(...)` で拾えるので、**それをアプリ内に保存**→**デバッグ画面で表示**という流れが比較的スムーズです。

> ※ もし `dart:developer.log()` に強く依存しているのであれば、`logging` パッケージへの乗り換えはすぐには難しい場合もあるかもしれませんが、将来的な可読性や拡張性を考えると `logging` パッケージの利用が一般的なことが多いです。  

---

## まとめ

- `log()` ( `dart:developer.log()` ) は基本的にコンソール出力＆DevTools へのログイベント用。アプリ内表示機能はない。
- アプリ内に表示したい場合、**ログを自前で保持するクラスやラッパ関数を設ける**必要がある。（`debugPrint` の場合と同じ発想）
- 代替として Dart の公式 `logging` パッケージを使い、**onRecord.listen** でログをインターセプト＆ストレージへ保存するのも便利。

要は、どんなログ出力APIを使っていても、**アプリ内部で閲覧したければ「メモリやファイルにため込む仕組み」を自前で用意する**のが原則になります。

---

## 👤 ユーザー
*2025/2/4 14:40:56*

loggingパッケージを使いたい。既存のdebugPrintのようにどこでも気軽ログ出力したく、それでかつ、アプリ内のデバッグ画面からタップすると内容をすべてクリップボードにコピーするようなデバックボタンを作成したい。Hooksやリバーポッドも使ってもいいので、なるべくシンプルなlog機能を実装して欲しい。リバーポッドを使う場合はアノテーションで生成してほしい。

---

## 🔧 ツール
*2025/2/4 14:41:39*

\*\*Setting up logging\*\*

I’m planning to create a minimal logging solution using Flutter Riverpod with an annotation-based approach. This involves defining a provider for logging and setting up a listener for logs.

\*\*Crafting the UI\*\*

I’m developing a Flutter screen to display logs from a provider. The screen will have a button for copying logs to the clipboard, and functions to manage log records.

\*\*Establishing the logger\*\*

I’m setting up a logger provider to intertwine with a logsNotifier. This creates a seamless flow from logging messages to updating the UI with the latest logs, including a feature to copy them to the clipboard.

\*\*Generating code snippets\*\*

I’m working on code generation with `build\_runner` and `riverpod\_generator` to simplify and streamline the creation of Riverpod-powered applications.

\*\*Generating Riverpod providers\*\*

I'm piecing together code snippets for generating Riverpod providers using `build\_runner` and `riverpod\_generator`. This involves creating a logger, logs provider, and a global logging function to streamline application evolution.

\*\*Creating universal logging\*\*

I’m emphasizing the use of a top-level function for logging, similar to `debugPrint`, simplifying widespread access. It’s this ease of use and consistency that drives the decision.

\*\*Displaying debug logs\*\*

I’m creating a Flutter debug screen to show logs, with options to copy them or clear them. I’m using Riverpod for state management.

\*\*Simplifying accessibility\*\*

I’m thinking about the simplicity of using `logger` in any context with a provider reference. Alternatively, a global function might offer even easier access.

\*\*Mapping out global logging\*\*

Choosing a global function approach, I’m aligning it with `riverpod\_annotation` for easy log access and storage, ensuring efficiency and maintainability across the application.

\*\*Streamlining the process\*\*

I’m mapping out a minimal, final code snippet for annotation-based generation with `riverpod\_annotation`, focusing on clarity and concise log management. Progress is steady and thoughtful.

---

## 🤖 アシスタント
*2025/2/4 14:41:39*

以下に、**logging パッケージ**+**Riverpod（アノテーションを使ったコード生成）**+**簡単なデバッグ画面**の例を示します。  

- `logging` パッケージ … ログレベル付きでログを出力/管理しやすい  
- Riverpod（`riverpod_annotation` + `build_runner`） … ログ一覧をどこでも参照できるようにする  
- デバッグ画面 … アプリ内でログを一覧表示＆クリップボードコピー  

最終的に、既存の `debugPrint` のように「どこでも簡単に `logger.info('hoge')`」と書けばログが出るようにしつつ、そのログをアプリ内のデバッグ画面でも確認できる流れを目指します。

---

# ディレクトリ構成例

```
lib/
  main.dart
  logger/
    app_logger.dart
    logs.dart
  debug/
    debug_screen.dart
```

このようにファイルを分けておくと見通しがよいですが、すべて `main.dart` にまとめても構いません。

## 1. `logs.dart` - ログ保持用の StateNotifier

```dart
// lib/logger/logs.dart
import 'package:logging/logging.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'logs.g.dart';

/// ログ一覧を管理するクラス
/// StateNotifier<List<LogRecord>> をラップする形で
/// Riverpodのコード生成 (@riverpod) を使っている
@riverpod
class Logs extends _$Logs {
  /// 初期状態は空のリスト
  @override
  List<LogRecord> build() {
    return [];
  }

  /// ログを1件追加
  void addLog(LogRecord record) {
    // 必要に応じて最大件数を制限したりなどの工夫も可能
    state = [...state, record];
  }

  /// ログを全消去
  void clear() {
    state = [];
  }
}
```

- `riverpod_annotation` の `@riverpod` を使うことで、`logsProvider` ( `AutoDisposeLogsProvider` ) などのプロバイダが生成されます。
- コマンド： `flutter pub run build_runner build --delete-conflicting-outputs` を実行すると `logs.g.dart` が生成されます。

## 2. `app_logger.dart` - `Logger` を提供するプロバイダ

```dart
// lib/logger/app_logger.dart
import 'package:logging/logging.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'logs.dart';

part 'app_logger.g.dart';

/// アプリ全体で使う Logger を提供する Riverpod
@riverpod
Logger appLogger(AppLoggerRef ref) {
  // logsProvider の StateNotifier を取得
  final logsNotifier = ref.watch(logsProvider.notifier);

  // もしルートロガー（Logger.root）で統一したいなら下記で設定
  // Logger.root.level = Level.ALL;
  // Logger.root.onRecord.listen(logsNotifier.addLog);

  // ここではアプリ専用の名前付きLoggerを作成
  final logger = Logger('MyApp')..level = Level.ALL;

  // Logger の onRecord を購読して、ログが出るたびに logsNotifier に保存
  logger.onRecord.listen(logsNotifier.addLog);

  return logger;
}
```

- これにより、`appLoggerProvider` を `ref.read` または `ref.watch` すれば Logger インスタンスが取得できます。
- 例えば `ref.read(appLoggerProvider).info('メッセージ')` とすれば、コンソール（デバッグビルドの場合）に加えて `logsProvider` にもログがたまります。

## 3. `debug_screen.dart` - デバッグ画面の実装

```dart
// lib/debug/debug_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../logger/logs.dart'; // logsProvider を使う

class DebugScreen extends ConsumerWidget {
  const DebugScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Logsクラスが保持しているログ一覧を取得
    final logRecords = ref.watch(logsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Debug Logs'),
        actions: [
          // すべてをコピーするボタン
          IconButton(
            icon: const Icon(Icons.copy),
            onPressed: () {
              // [INFO] メッセージ のような形式で1行ずつ連結
              final text = logRecords
                  .map((r) => '[${r.level.name}] ${r.time}: ${r.message}')
                  .join('\n');

              Clipboard.setData(ClipboardData(text: text));
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('ログをクリップボードにコピーしました')),
              );
            },
          ),
          // ログをクリアするボタン
          IconButton(
            icon: const Icon(Icons.delete),
            onPressed: () {
              ref.read(logsProvider.notifier).clear();
            },
          ),
        ],
      ),
      body: logRecords.isEmpty
          ? const Center(child: Text('ログはありません'))
          : ListView.builder(
              itemCount: logRecords.length,
              itemBuilder: (context, index) {
                final record = logRecords[index];
                return ListTile(
                  title: Text(
                    '[${record.level.name}] ${record.time.toIso8601String()}',
                    style: TextStyle(
                      color: record.level >= Level.WARNING
                          ? Colors.red
                          : Colors.black,
                    ),
                  ),
                  subtitle: Text(record.message),
                );
              },
            ),
    );
  }
}
```

- `logsProvider` を監視しているので、**ログが追加されると画面が自動的にリビルド**されます。
- タイムスタンプやログレベル、メッセージなどを自由に整形して表示できます。

## 4. `main.dart` - 動作確認

```dart
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'debug/debug_screen.dart';
import 'logger/app_logger.dart';

void main() {
  // Riverpodを使う場合は ProviderScope をルートに
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // アプリ起動時に1件ログ出力してみる
    ref.read(appLoggerProvider).info('App started!');

    return MaterialApp(
      title: 'Logging + Riverpod Demo',
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
          actions: [
            IconButton(
              icon: const Icon(Icons.bug_report),
              onPressed: () {
                // デバッグ画面へ遷移
                Navigator.of(context).push(
                  MaterialPageRoute(builder: (_) => const DebugScreen()),
                );
              },
            ),
          ],
        ),
        body: Center(
          child: ElevatedButton(
            onPressed: () {
              // ボタンタップでログを一件追加
              ref.read(appLoggerProvider).info('Button pressed!');
            },
            child: const Text('Log Something'),
          ),
        ),
      ),
    );
  }
}
```

- 右上の虫アイコンを押すと、デバッグ画面へ遷移。
- 「Log Something」 ボタンをタップするたびにログが追加される。
- デバッグ画面では一覧表示・コピー・クリアができる。

---

# ポイント解説

1. **loggingパッケージ**  
   - `Logger` クラスを使うと、`info()`, `warning()`, `severe()`, `log(level, message)` などログレベル付きでログを簡潔に出力できます。  
   - `logger.onRecord.listen(...)` でリスナーを設定すると、出力されたログを自由に処理（今回は Riverpod の StateNotifier に蓄積）できます。

2. **Riverpod（アノテーション + build_runner）**  
   - `@riverpod` アノテーションを付けたクラスや関数を定義し、 `flutter pub run build_runner build --delete-conflicting-outputs` を実行すると、`xxx.g.dart` ファイルが自動生成されます。  
   - これにより `logsProvider` / `appLoggerProvider` といったプロバイダが使えるようになります。  
   - StateNotifier でログをリスト管理しておけば、どこからでも `ref.read(appLoggerProvider).info('...')` のようにログ出力でき、同時にUIにも反映されます。

3. **アプリ内にデバッグ画面**  
   - `ListView` で `LogRecord` のリストを表示し、コピー & クリアのボタンを設置。  
   - これで「コンソールに出すだけでなく、アプリ内でもリアルタイムにチェックしたい」という要望を実現できます。

4. **どこでも気軽にログを出したい**  
   - 上記例のように「`ref.read(appLoggerProvider).info('hoge')`」を呼ぶだけでも十分簡単ですが、さらにシンプルにしたい場合はグローバル関数を作ってしまう手もあります。  
   - ただし Riverpod の場合は `ref` をどう参照するか注意が必要なので、Widget か StateNotifier 内で呼び出す形が自然です（グローバルに ProviderContainer を作る方法もありますが、スコープがずれるため注意）。

---

# まとめ

- **logging パッケージ**を使うと、ログレベルなどを含めた柔軟なログ出力が可能。
- **Riverpod (アノテーション生成)** と組み合わせて「ログをどこからでも貯めて閲覧する」仕組みをシンプルに構築できる。
- 上記のサンプルコードをベースに、デバッグ画面やログの扱い（ファイル出力、絞り込み検索、エラーだけフィルタなど）を拡張することも容易。

「既存の `debugPrint` 感覚で呼び出しつつ、アプリ内デバッグ画面からコピーもできる」環境ができあがるので、ぜひお試しください。

---

## 👤 ユーザー
*2025/2/4 14:43:24*

これでやりたい、もっと短い行で気軽にログ出力したい。また、refがなくてもログ出力できれば理想。

どこでも気軽にログを出したい
上記例のように「ref.read(appLoggerProvider).info('hoge')」を呼ぶだけでも十分簡単ですが、さらにシンプルにしたい場合はグローバル関数を作ってしまう手もあります。

---

## 🔧 ツール
*2025/2/4 14:44:01*

\*\*Establishing a global logger\*\*

Setting up a `ProviderContainer` globally to manage a logger, abstracting away the need for ref usage. This setup is especially useful in a Flutter tree with `ProviderScope`.

\*\*Evaluating approaches\*\*

I'm thinking through defining a `static final container` for a global provider, or leveraging a function to access `ProviderScope` globally, balancing efficiency with complexity.

\*\*Evaluating global setups\*\*

I'm considering if a global logging variable or a global setter for a ref is more suitable. The latter allows for synchronous access to the logger.

\*\*Setting up a global container\*\*

I’m piecing together a global container for logging, ensuring it aligns with the UI setup for seamless integration and efficient logging access within the app.

\*\*Aligning the setup\*\*

Integrating a global container for logging with the UI setup ensures logs are accessible on the debug screen, maintaining a streamlined and effective logging solution.

\*\*Creating a unified example\*\*

I’m pulling together a concise code snippet that combines `logs.dart`, `app\_logger.dart`, and `debug\_screen.dart` into a single file, showcasing a streamlined logging solution.

\*\*Creating unified solution\*\*

I’m thinking through an "all in one" code snippet, incorporating comments for clarity. This approach simplifies the setup while ensuring essential elements are included.

\*\*Implementing the logger\*\*

I'm setting up a global logging container with `Logger` and `appLoggerProvider`. The application includes a main UI flow and a debug screen for log management.

---

## 🤖 アシスタント
*2025/2/4 14:44:01*

以下に **loggingパッケージ** と **Riverpod** を組み合わせつつ、「どこでも `logInfo('メッセージ')` のように簡単にログ出力したい」「アプリ内デバッグ画面でログを閲覧・クリア・クリップボードコピーしたい」という用途を満たす**最小限のサンプル**を示します。

ポイントは、**「グローバルな ProviderContainer」を使って Logger を管理し、それにアクセスするトップレベル関数 ( `logInfo` など ) を用意する**ことです。これにより、画面ウィジェットなどから `ref` を渡さなくても、好きな場所で `logInfo("hoge")` が呼び出せます。

---

## 完成イメージ

1\. アプリ起動時に `main()` で `ProviderContainer` を1つ生成し、  
   - `UncontrolledProviderScope(container: globalContainer, child: MyApp())`  
   でアプリ全体に紐づけます。  
2\. `logInfo`, `logWarning`, `logError` といったトップレベル関数を用意。  
   - これらが `globalContainer.read(appLoggerProvider).info(...)` 等を実行し、ログを `logging` パッケージ経由で管理します。  
3\. アプリ内に「DebugScreen」を用意し、`ConsumerWidget` で `logsProvider` を読んで一覧表示。  
   - クリップボードコピーやクリアが可能。  

以下のサンプルを、そのまま `main.dart` にコピペして動かせます。

---

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logging/logging.dart';

//
// 1. グローバルなProviderContainerを用意 & ショートハンド関数を定義
//

// アプリ全体で使う「グローバルなコンテナ」
final globalContainer = ProviderContainer();

// ショートハンドでログを出せるトップレベル関数
// どのWidget / クラスからでもこれを呼ぶだけでログ出力できる
void logInfo(String message) => globalContainer.read(appLoggerProvider).info(message);
void logWarning(String message) => globalContainer.read(appLoggerProvider).warning(message);
void logError(String message) => globalContainer.read(appLoggerProvider).severe(message);

//
// 2. ログを保管する Riverpod の StateNotifier + Logger Provider
//

/// ログ一覧を管理する StateNotifier
class LogsNotifier extends StateNotifier<List<LogRecord>> {
  LogsNotifier() : super([]);

  void addLog(LogRecord record) {
    // 必要に応じて最大件数を制限などしてもOK
    state = [...state, record];
  }

  void clear() {
    state = [];
  }
}

/// ログ一覧を参照できる Provider
final logsProvider = StateNotifierProvider<LogsNotifier, List<LogRecord>>(
  (ref) => LogsNotifier(),
);

/// loggingパッケージのLoggerを提供する Provider
final appLoggerProvider = Provider<Logger>((ref) {
  final logsNotifier = ref.watch(logsProvider.notifier);

  // 名前付きLogger (MyApp) を作成し、ログが出るたびに logsNotifier に蓄積
  final logger = Logger('MyApp')..level = Level.ALL;
  logger.onRecord.listen(logsNotifier.addLog);

  return logger;
});

//
// 3. エントリーポイント
//

void main() {
  // UncontrolledProviderScopeに globalContainer を注入
  // → こうするとアプリ内でConsumerWidgetを使う際、同じContainerの状態を共有できます
  runApp(
    UncontrolledProviderScope(
      container: globalContainer,
      child: const MyApp(),
    ),
  );
}

//
// 4. アプリ本体
//

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // アプリ起動時に1件ログ出力
    logInfo('App started!');

    return MaterialApp(
      title: 'Logger + Riverpod Demo',
      home: HomeScreen(),
    );
  }
}

/// 適当なHome画面
class HomeScreen extends StatelessWidget {
  HomeScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Home'),
        actions: [
          // 虫アイコンを押してDebugScreenへ
          IconButton(
            icon: const Icon(Icons.bug_report),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const DebugScreen()),
              );
            },
          ),
        ],
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // ボタンタップでログを出力
            logInfo('Button Pressed!');
          },
          child: const Text('Log Something'),
        ),
      ),
    );
  }
}

/// アプリ内のデバッグログ一覧表示画面
class DebugScreen extends ConsumerWidget {
  const DebugScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // logsProviderの状態(=LogRecordのリスト)を監視
    final logs = ref.watch(logsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Debug Logs'),
        actions: [
          IconButton(
            icon: const Icon(Icons.copy),
            onPressed: () {
              // ログの内容を1行ずつ連結してクリップボードへコピー
              final allText = logs
                  .map((record) =>
                      '[${record.level.name}] ${record.time}: ${record.message}')
                  .join('\n');

              Clipboard.setData(ClipboardData(text: allText));
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('ログをコピーしました')),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete),
            onPressed: () {
              // ログを全消去
              ref.read(logsProvider.notifier).clear();
            },
          ),
        ],
      ),
      body: logs.isEmpty
          ? const Center(child: Text('No Logs yet'))
          : ListView.builder(
              itemCount: logs.length,
              itemBuilder: (context, index) {
                final record = logs[index];
                return ListTile(
                  title: Text(
                    '[${record.level.name}] ${record.time}',
                    style: TextStyle(
                      // 警告以上のレベルならテキストを赤くする等
                      color: record.level >= Level.WARNING ? Colors.red : null,
                    ),
                  ),
                  subtitle: Text(record.message),
                );
              },
            ),
    );
  }
}
```

---

## コードの流れ解説

1. **グローバルな `ProviderContainer`**  
   - `final globalContainer = ProviderContainer();` で1つ生成しておきます。  
   - `UncontrolledProviderScope(container: globalContainer)` をルートにかぶせることで、画面（ConsumerWidget）でも同じコンテナを参照でき、**ログを一覧で見られる**ようになります。

2. **トップレベル関数 `logInfo` / `logWarning` / `logError`**  
   - `globalContainer.read(appLoggerProvider).info(message);` のように呼び出し、ログを吐きます。  
   - これにより、**どこからでも** `logInfo('hoge')` と書くだけでOK。`ref` を受け取らなくても動作します。  

3. **ログの管理 (logging パッケージ × Riverpod)**  
   - `appLoggerProvider` で `Logger` を生成 → `onRecord.listen(...)` で `logsProvider` (StateNotifier) に記録。  
   - 記録された `LogRecord` 一覧は、`logsProvider` を `ref.watch` するだけでリアクティブに参照可能。  

4. **DebugScreen での表示・コピー・クリア**  
   - `ConsumerWidget` で `logsProvider` を `ref.watch` してリストを取得。  
   - `ListView.builder` でログを表示。  
   - コピーボタン → 全文を `Clipboard.setData` へ。  
   - 消去ボタン → `ref.read(logsProvider.notifier).clear()`.  

---

## さらに拡張するには

- **ログレベルでフィルタ**  
  例えば「INFO 以上だけ表示」「ERROR だけに絞る」などの UI を付ける。  
- **一時的にファイルやDBに保存**  
  大量のログが発生する場合は、StateNotifier に入れ続けるよりファイルなどにローテーション保存するほうが安全なケースもあります。  
- **ProviderScope を使う方式との違い**  
  本来、Riverpod を使う場合は `ProviderScope(...)` の中で `ref` を受け取って使うことが多いです。  
  しかし、「どこからでも `logInfo()` を呼び出したい」というニーズでは、今回のように **グローバルの `ProviderContainer`** を作ってしまうのがシンプル。  
  - このサンプルでは `UncontrolledProviderScope(container: globalContainer, ...)` を使い、画面からも同じ状態を共有できるようにしています。  

---

これで **「どこでも1行でログ出力」** + **「アプリ内デバッグ画面からクリップボードコピー」** の要望を満たしつつ、`logging` + `Riverpod` でのログ管理を実現できます。

---

## 👤 ユーザー
*2025/2/4 14:45:28*

globalContainerはあんまり使いたくないな。。。

---

## 🔧 ツール
*2025/2/4 14:46:12*

\*\*Weighing options\*\*

OK, let’s see. The user's goal is accessing provider data in top-level functions without relying on a global container. A static variable in an application class might be a viable solution here.

\*\*Mapping out alternatives\*\*

I'm considering whether defining a function or extension to access logs from the debug screen could work, or if storing them in a static variable is a more practical approach.

\*\*Refining logger access\*\*

I'm analyzing how to access logs without a global container, focusing on a static field in LoggerRepository or a top-level function with a referenced loggerRepository.

\*\*Setting up logging\*\*

OK, let me see. I'm piecing together how to set up logging without a global container by using ProviderScope with a top-level variable that references loggerRepository, sidestepping the need for a global ref.

\*\*Crafting `GlobalLogger`\*\*

I'm setting up `GlobalLogger` with loggerRepository via ProviderScope. This ensures a straightforward, top-level function for logging, maintaining user preferences.

\*\*Weighing options\*\*

I’m working through various ways to provide a logging function without a global container, including static methods in MyApp and a top-level function, mindful of potential initialization order issues.

\*\*Evaluating strategies\*\*

Mapping out top-level variables for leaner setups, considering pre-assignment risks or a singleton logger repository as a simpler alternative to avoid global container reliance.

\*\*Storing logger globally\*\*

Reading the logger in the main widget once and keeping it in a global variable seems the easiest way to ensure the debug screen can access logs seamlessly.

\*\*Crafting the logging system\*\*

I'm pulling together a cohesive logging system with state management, a dedicated logger, and a UI to view logs. This approach keeps things organized without depending on a global container.

---

## 🤖 アシスタント
*2025/2/4 14:46:12*

Riverpod で「アプリ内にデバッグ画面を用意しつつ、どこからでも `logInfo('hoge')` のように1行でログ出力したい」場合、**グローバルな `ProviderContainer`** を使わずとも、**アプリ起動後に1度だけ logger を初期化してトップレベルのログ関数を使う**方法がシンプルです。

以下のサンプルコードでは、

- `ProviderScope` を **通常どおり** ルートに配置（`globalContainer` は使わない）  
- アプリ起動後（`MyApp` の `build` のタイミング）で `ref.watch(appLoggerProvider)` を1度だけ呼んで **top-level な `logger` 変数** に代入  
- どこからでも呼べる `logInfo`, `logWarning`, `logError` 関数を定義  

することで、「Riverpod を使いながらも、`ref` なしで気軽にログ出力 + アプリ内で閲覧・コピー」が実現できます。

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logging/logging.dart';

//
// 1. ログ一覧を管理するStateNotifier + Provider
//
final logsProvider = StateNotifierProvider<LogsNotifier, List<LogRecord>>(
  (ref) => LogsNotifier(),
);

class LogsNotifier extends StateNotifier<List<LogRecord>> {
  LogsNotifier() : super([]);

  void addLog(LogRecord record) {
    // 必要なら最大件数を制限する等の処理も可能
    state = [...state, record];
  }

  void clear() {
    state = [];
  }
}

//
// 2. アプリ用の Logger を提供する Provider
//    → 出力されるログを logsProvider に取り込み
//
final appLoggerProvider = Provider<Logger>((ref) {
  final logsNotifier = ref.watch(logsProvider.notifier);

  final logger = Logger('MyApp')..level = Level.ALL;
  logger.onRecord.listen(logsNotifier.addLog);

  return logger;
});

//
// 3. どこからでも呼べるトップレベルのログ関数
//    （late 変数 logger に代入してから利用する）
//
late final Logger logger;

void logInfo(String message) => logger.info(message);
void logWarning(String message) => logger.warning(message);
void logError(String message) => logger.severe(message);

//
// 4. エントリポイント
//
void main() {
  // 普通に ProviderScope をルートに据える（globalContainer は使わない）
  runApp(const ProviderScope(child: MyApp()));
}

//
// 5. アプリ本体：MyApp
//    → 初回buildで logger を初期化
//
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 初回ビルド時に、Providerから Logger を取得し、top-level の logger 変数にセット
    logger = ref.watch(appLoggerProvider);

    // アプリ起動時に一度ログ出力
    logInfo('MyApp started!');

    return MaterialApp(
      home: const HomeScreen(),
    );
  }
}

//
// 6. 適当なホーム画面
//    → ボタン押下でログを出力
//    → Debug 画面に遷移
//
class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('HomeScreen'),
        actions: [
          IconButton(
            icon: const Icon(Icons.bug_report),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const DebugScreen()),
              );
            },
          ),
        ],
      ),
      body: Center(
        child: ElevatedButton(
          child: const Text('Log Something'),
          onPressed: () {
            logInfo('Button Pressed!');
          },
        ),
      ),
    );
  }
}

//
// 7. アプリ内でログを閲覧できる Debug 画面
//    → Riverpod で logsProvider を監視して表示
//    → 全コピー / クリア ボタン
//
class DebugScreen extends ConsumerWidget {
  const DebugScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final logs = ref.watch(logsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Debug Logs'),
        actions: [
          IconButton(
            icon: const Icon(Icons.copy),
            onPressed: () {
              // ログをまとめてクリップボードへコピー
              final text = logs
                  .map((r) =>
                      '[${r.level.name}] ${r.time.toIso8601String()}: ${r.message}')
                  .join('\n');

              Clipboard.setData(ClipboardData(text: text));
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('ログをコピーしました')),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete),
            onPressed: () {
              ref.read(logsProvider.notifier).clear();
            },
          ),
        ],
      ),
      body: logs.isEmpty
          ? const Center(child: Text('No logs yet'))
          : ListView.builder(
              itemCount: logs.length,
              itemBuilder: (context, index) {
                final record = logs[index];
                return ListTile(
                  title: Text(
                    '[${record.level.name}] ${record.time.toIso8601String()}',
                    style: TextStyle(
                      color: record.level >= Level.WARNING ? Colors.red : null,
                    ),
                  ),
                  subtitle: Text(record.message),
                );
              },
            ),
    );
  }
}
```

---

# 解説

1. **`ProviderScope` を普通に使う**  
   通常の Riverpod アプリ同様、`main()` で `ProviderScope` をルートに置きます。  
   - ここでは「`globalContainer` を自前で作って `UncontrolledProviderScope`」は使っていません。  

2. **`late final Logger logger;` とトップレベル関数**  
   - `late` 変数にすることで「アプリの起動後に1度だけ初期化したい」ニーズを満たしつつ、`ref` を介さないトップレベル関数を実装できます。  
   - `logInfo("hoge")` をどこからでも呼び出せるようになりますが、**MyApp の初回ビルドより前に呼ぶと未初期化**なので注意してください。  
     - 一般的な「画面やモデルから呼ぶ」タイミングであれば、問題なく初期化済みになっています。

3. **`appLoggerProvider` + `logsProvider`**  
   - `logging` パッケージの `Logger` を `appLoggerProvider` で提供。  
   - `Logger.onRecord.listen(...)` で流れてくる `LogRecord` を `logsProvider` ( `StateNotifier` ) に蓄積し、アプリ内で参照できるようにします。

4. **アプリ内デバッグ画面 ( `DebugScreen` )**  
   - `logsProvider` に入っているログ一覧を `ref.watch(logsProvider)` するだけでリアクティブに表示。  
   - 全コピー / クリア の操作も可能。

---

## なぜこの方法で「refがなくても」ログ出力できるのか

- Riverpod では通常「`ref.read(loggerProvider).info(...)`」のように書くため、`ref` が必要。  
- しかし、ここでは **1回だけ** 「`logger = ref.watch(appLoggerProvider)`」をセットしておき、その結果をグローバル（トップレベル）に保持しています。  
- すると、あとは単純に `logInfo('hoge') => logger.info('hoge')` と呼び出すだけで完結します。  

「**ビルド中に1度だけ取得し、グローバル変数に格納する**」という形で「グローバルコンテナ」も使っていませんし、`ref` も意識しなくて済むようにしています。

---

## 注意点

- **`late` 変数の初期化タイミング**  
  - `MyApp.build()` が呼ばれるより前に `logInfo()` を呼んでしまうと、`logger` はまだ初期化されていないためエラーになります。  
  - 通常は `MyApp` の起動前にログを吐かないなら問題ありません。  
  - もし起動直後（`main()` 実行中）にもログを吐きたい場合は、グローバルコンテナなど別手段が必要です。  

- **スレッドセーフ / テスト**  
  - 単純な Flutter アプリであれば問題ありませんが、**ユニットテスト** や **並列処理** などをする際は「いつ logger がセットされるか」を明確にしておく必要があります。  
  - テストで使う場合は `ProviderContainer` を明示的に用意し、そこから logger を取得してテスト用に使うケースが多いです。  

---

# まとめ

- **Riverpod を使いつつ、`ref` なしで「1行ログ出力」したい** → `late final Logger` とトップレベル関数で実現できる。  
- **グローバルコンテナ (`UncontrolledProviderScope`) は使わず**、通常の `ProviderScope` だけでもOK。  
- デバッグ画面では `logsProvider` を監視してログ一覧を表示し、クリップボードコピーやクリアが可能。  

これで「どこでも `logInfo('メッセージ')` でき、アプリ内でログを確認・コピーできる」仕組みがシンプルに構築できます。

---

## 👤 ユーザー
*2025/2/4 14:47:12*

いいと思うが、これはリバーポッドアノテーションは使えないの？基本的に今はリバーポッドアノテーションで色々作成しているのでそれに合わせたい

---

## 🔧 ツール
*2025/2/4 14:47:58*

\*\*Crafting solutions\*\*

I'm working through code generation with annotations. Notably, I'm deploying `StateNotifierProvider` and `Provider` directly, sidestepping `@riverpod`. Progress is steady, leveraging these direct forms.

\*\*Crafting logger functionality\*\*

I’m piecing together a logger using `riverpod\_annotation`, detailing set-up and log handling. The workflow includes setting up providers, configuring listeners, and leveraging `ProviderScope` for global access.

\*\*Setting up the logger\*\*

Mapping out a logger with `riverpod\_annotation`. Configuring `StateNotifierProvider` and implementing listeners for seamless log management within `MyApp` and an auxiliary function.

\*\*Streamlining setup\*\*

Taking a closer look at omitting the global container and simplifying provider definitions with `@riverpod`. Things might get a bit verbose due to code generation.

\*\*Shaping the approach\*\*

I’m mapping out a refined method using `@riverpod` for logging. This involves defining providers and functions, with a streamlined state-based notifier for logs and a function-based approach for logging.

---

## 🤖 アシスタント
*2025/2/4 14:47:58*

Riverpod Annotation を使ったコード生成（`riverpod_annotation` + `build_runner`）を活用しつつ、**「`ref` なしでどこでも `logInfo('hoge')` のように気軽にログ出力したい」** かつ **「アプリ内デバッグ画面でログを閲覧・コピーしたい」** という要望を満たすサンプルを示します。

- **アプリ内状態管理には Riverpod Annotation を使用**（`@riverpod` でプロバイダを生成）
- **トップレベル変数 `logger`** を最初の画面ビルド時に初期化 → **トップレベル関数** で簡単ログ出力を提供
- **`globalContainer` は使わない**（通常の `ProviderScope` のみ利用）

最小限のサンプルなので、ファイル分割なし・`main.dart` 一つで完結させています。  
適宜、実際のプロジェクト構成に合わせてファイル分割してください。

---

## コード全体

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logging/logging.dart';
// Riverpod Annotation 関連
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'main.g.dart'; // build_runnerで生成されるファイル

//
// 1. Logs 管理: @riverpod アノテーションでStateNotifierを生成
//
@riverpod
class Logs extends _$Logs {
  // 初期状態は空のリスト
  @override
  List<LogRecord> build() => [];

  // ログを1件追加
  void addLog(LogRecord record) {
    state = [...state, record];
  }

  // 全消去
  void clear() {
    state = [];
  }
}

//
// 2. Logger プロバイダ: アプリ全体のLoggerを@riverpodで提供
//
@riverpod
Logger appLogger(AppLoggerRef ref) {
  // logsProvider の StateNotifier を取得
  final logsNotifier = ref.watch(logsProvider.notifier);

  // 名前付きLoggerを生成し、ログ出力のたびに logsNotifier に蓄積
  final logger = Logger('MyApp')..level = Level.ALL;
  logger.onRecord.listen(logsNotifier.addLog);

  return logger;
}

//
// 3. トップレベルで利用する Logger 変数 & ログ出力関数
//
//   - Riverpodの provider は通常「ref.read/appLoggerProvider」を呼ぶ必要がある
//   - しかし「どこでも短いコードで logInfo('hoge') を呼びたい」要望に対応するため
//     ここでは `late final Logger logger` を用意し、MyApp の初回ビルド時に初期化する。
//   - その後、トップレベル関数 `logInfo()` 等で `logger` を呼び出す。
//
late final Logger logger;

// どこでも1行で呼べるログ関数
void logInfo(String message) => logger.info(message);
void logWarning(String message) => logger.warning(message);
void logError(String message) => logger.severe(message);

//
// 4. エントリーポイント
//
void main() async {
  // Riverpod Annotation を使うときは、通常の ProviderScope でOK
  runApp(const ProviderScope(child: MyApp()));
}

//
// 5. アプリ本体 (MyApp)
//
//    - 初回ビルド時に、ref.watch(appLoggerProvider) を呼び出して
//      logger をトップレベル変数に代入し、
//      すぐに1件ログを出力 (logInfo('App started!')) など。
//
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // RiverpodのappLoggerプロバイダを1度だけ取得し、top-levelのloggerにセット
    logger = ref.watch(appLoggerProviderProvider);
    // ↑
    //   appLoggerProvider と書きたいところですが、
    //   @riverpod で生成された場合、実際の変数名は appLoggerProviderProvider
    //   となるのがデフォルトの命名規則です（下記の「Generated Provider 名」に注意）。

    // アプリ起動時に一度ログ出力 (遅延初期化が終わった後)
    logInfo('App started!');

    return MaterialApp(
      title: 'Riverpod Annotation Logging Demo',
      home: const HomeScreen(),
    );
  }
}

//
// 6. 適当なホーム画面
//    - ボタンでログ出力
//    - DebugScreenへ遷移
//
class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('HomeScreen'),
        actions: [
          IconButton(
            icon: const Icon(Icons.bug_report),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const DebugScreen()),
              );
            },
          ),
        ],
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            logInfo('Button Pressed!');
          },
          child: const Text('Log Something'),
        ),
      ),
    );
  }
}

//
// 7. アプリ内デバッグ画面
//    - logsProvider の状態を表示
//    - 全コピー、クリア
//
class DebugScreen extends ConsumerWidget {
  const DebugScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // logsProvider は "logsProviderProvider" という名前に生成される
    final logRecords = ref.watch(logsProviderProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Debug Logs'),
        actions: [
          IconButton(
            icon: const Icon(Icons.copy),
            onPressed: () {
              final text = logRecords
                  .map((r) =>
                      '[${r.level.name}] ${r.time.toIso8601String()}: ${r.message}')
                  .join('\n');
              Clipboard.setData(ClipboardData(text: text));
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('ログをコピーしました')),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete),
            onPressed: () {
              ref.read(logsProviderProvider.notifier).clear();
            },
          ),
        ],
      ),
      body: logRecords.isEmpty
          ? const Center(child: Text('No logs yet'))
          : ListView.builder(
              itemCount: logRecords.length,
              itemBuilder: (context, index) {
                final record = logRecords[index];
                return ListTile(
                  title: Text('[${record.level.name}] ${record.time}'),
                  subtitle: Text(record.message),
                );
              },
            ),
    );
  }
}
```

### `build_runner` コマンド実行

```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

- これにより `main.g.dart` が生成され、`appLoggerProviderProvider` や `logsProviderProvider` などの自動生成コードが作られます。

---

## 生成される Provider の命名について

`@riverpod` を付ける際、以下のようなルールになります。

- **class 名**: `Logs` → 生成されるプロバイダは `logsProvider`  
  - ただし実際の変数名は `logsProviderProvider` となる（デフォルトで `Provider` が後ろに付く）  
  - しかし `part 'xxx.g.dart';` を使う際は、生成元を参照するときには `logsProviderProvider` になる、という点に注意が必要です。
- **function 名**: `appLogger` → 生成されるプロバイダは `appLoggerProvider`  
  - 同様に実際には `appLoggerProviderProvider` という名前。

> もし「`logsProviderProvider` のような二重命名が嫌だ」という場合、`@riverpod` の `name:` パラメータや `@Riverpod(keepName: true)` オプションなどを使うことで名前を調整できます。  
> 例:  
> ```dart
> @riverpod
> Logger myLogger(MyLoggerRef ref) {
>   // ...
> }
> ```  
>  であれば、生成されるプロバイダ名は `myLoggerProvider` となり、呼び出す側でも `ref.watch(myLoggerProvider)` のように書けます。

---

## 解説

1. **Logs クラス ( `@riverpod` )**  
   - `List<LogRecord>` を `state` で保持する `StateNotifier` 的なクラスをアノテーションで定義。  
   - `@riverpod` をクラスに付けると `_logs` → `logsProvider` が生成されます。  
   - 内部で `addLog`, `clear` を定義。

2. **appLogger ( `@riverpod` )**  
   - `Logger` を作成し、`onRecord.listen(...)` で `logsProvider` に蓄積。  
   - `@riverpod` を関数に付けた形で定義すると、「`appLoggerProvider`」が生成される。  

3. **トップレベル変数 `logger` + 関数 `logInfo`, `logWarning`, `logError`**  
   - `MyApp` の初回ビルド時に `ref.watch(appLoggerProviderProvider)` で取得 → `logger = ...;` として遅延初期化。  
   - それ以降、どこからでも `logInfo('msg')` でログ出力できる。

4. **アプリ起動**  
   - `ProviderScope(child: MyApp())` で起動し、`build_runner` で生成した `.g.dart` を利用。  
   - `MyApp.build()` 内で `logger` を初期化 → `logInfo('App started!')` のようにログを書き込む。

5. **DebugScreen**  
   - `logsProviderProvider` を `ref.watch` して取得した `List<LogRecord>` を表示。  
   - 全コピー、クリアの機能を実装。

---

## 注意点

- **初期化タイミング**  
  - `logger` は `MyApp.build` が呼ばれるまで初期化されないので、アプリ起動直後（`main()` 実行中など）にログ出力したい場合は注意が必要。  
  - 一般的には、最初の画面が描画される前にログ出力が必要でなければ問題ありません。  

- **二重の `Provider` 命名**  
  - `logsProvider` クラス → 生成される実体は `logsProviderProvider` となるのがデフォルトです。  
  - 名前をすっきりさせたい場合は `@Riverpod(keepName: true)` や `name:` パラメータを活用してください。  

- **ユニットテスト / マルチスコープ**  
  - この方法（トップレベル変数に格納）だと、「スコープごとに異なる logger を使う」「ユニットテストごとにリセットしたい」といった高度なシチュエーションは少し扱いが面倒になります。  
  - 単純にアプリ運用する分には十分かと思いますが、テストをする際には、テスト用に `ProviderContainer` を作って `ref.read(appLoggerProvider)` を直接呼んだほうがコントロールしやすいです。

---

# まとめ

- **Riverpod Annotation** でも、`@riverpod` で作ったプロバイダを **初回ビルド時だけ `ref.watch` → グローバル変数にセット** という方法なら、`ref` なしで「1行ログ出力」を実現できる。
- アプリ内デバッグ画面では `logsProvider` を利用してログ一覧を表示、コピー、クリアが可能。
- `globalContainer` を使わず、**通常の `ProviderScope`** で運用できるため、一般的なリバーポッド構成とも相性がよい。

これで「Riverpod Annotation を使いつつ、`logInfo('hoge')` で簡単にログ＋アプリ内で閲覧」の要望を満たせます。

---
