# 実装依頼とコード例

Date: 2025-01-11

---

## 👤 User
*2025-01-11 21:09:25*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-RNRSo38bR2w55k9WoKr6dh",
  "size_bytes": 71739,
  "width": 464,
  "height": 962,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
今の実装を一旦無視して、以下の画像の画面を作って欲しい。

(1)
Verification code has been sent to the SNPIT application. のところをタップすると別アプリを立ち上げるようにして欲しい。
また、タップ時にリップルが出るようにしてほしい。
また、少し目立つようなアニメーションやタップしたくなる工夫をしたい。

(2)
また、Velify では VerifyCodeNotifierの verifyCodeをコールしてほしい。
これはElevatedButtonで実装してほしい。
処理に成功した際は context.go(Screen.map.path); としてほしい。

(3)
Resend verification codeでは RequestCodeNotifierのrequestCodeをコールしてほしい
TextButtonで実装してほしい。
また、20秒ほどの期間で連打できないような工夫は入れたい。
連打できない期間はタップしてもスナックバーで伝えたい。

(4)
Resend verification code をタップして処理に成功した際は Verification code has been sent to the SNPIT application. のところが新しくなったようなアニメーションをいれたい。
また、スナックバーでコードが新しくなったので SNPIT アプリを立ち上げるように伝えたい。

(5) 
verifyCodeState や requestCodeState をuseStateで管理してハンドリングしたい。

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/screen.dart';

class VerificationCodePage extends HookConsumerWidget {
  const VerificationCodePage({super.key, required this.email});

  final String email;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(backgroundColor: Colors.transparent),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24),
        child: Center(
          child: TextButton(
            onPressed: () {
              context.go(Screen.map.path);
            },
            child: Text('Verify $email'),
          ),
        ),
      ),
    );
  }
}



import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';

part 'verify_code.g.dart';

@riverpod
class VerifyCodeNotifier extends _$VerifyCodeNotifier {
  @override
  Future&lt;LoginResponseDtoData?&gt; build() async =&gt; null;

  Future&lt;void&gt; verifyCode(String email, num code) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(authApiProvider.future);
      final response = await api.authControllerLogin(
        AuthLoginDTO(email: email, code: code),
      );
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');
      state = AsyncValue.data(response.data?.data);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}


import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/api_provider.dart';

part 'request_code.g.dart';

@riverpod
class RequestCodeNotifier extends _$RequestCodeNotifier {
  @override
  Future&lt;String?&gt; build() async =&gt; null;

  Future&lt;void&gt; requestCode(String email) async {
    state = const AsyncValue.loading();
    try {
      final api = await ref.watch(authApiProvider.future);
      final response = await api.authControllerSendCode(
        // AuthEamilDTO(email: email),
        // TODO: Remove this hard-coded email
        AuthEamilDTO(email: 'user1@example.com'),
      );
      debugPrint('Response Body: ${response.data}');
      debugPrint('Response Body.data: ${response.data?.data}');

      if (response.data?.code == -1) {
        debugPrint('Response Body.code: ${response.data?.code}');
        debugPrint(
          'Response Body.errorMessage: ${response.data?.errorMessage}',
        );
        throw Exception(response.data.toString());
      }

      state = AsyncValue.data(response.data?.data);
    } on Exception catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      state = AsyncValue.error(e, stackTrace);
    }
  }
}

---

## 🤖 Assistant
*2025-01-11 21:10:26*

以下は、いただいた要件を満たす形でサンプル実装したコード例です。ポイントごとに解説コメントを入れています。  
**大まかな流れ**  
1. 「Verification code has been sent...」部分はタップ可能にし、Ripple エフェクト付きで別アプリを起動する関数を呼び出しています。  
2. 「Velify」(ElevatedButton) で `VerifyCodeNotifier` の `verifyCode` を呼び出し、成功時に `context.go(Screen.map.path)` します。  
3. 「Resend verification code」(TextButton) で `RequestCodeNotifier` の `requestCode` を呼び出し、連打防止を 20 秒入れ、タップできない間は SnackBar を表示します。  
4. リクエスト成功後は「Verification code has been sent...」のテキストをアニメーションで“新しくなった”ように見せ、さらに SnackBar でも「SNPIT アプリを起動するように」と伝えます。  
5. `verifyCodeState`・`requestCodeState` は `useState` で管理し、画面内で非同期状態をハンドリングしています。

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/providers/verify_code.dart';
import 'package:snpit_guild_app/presentation/providers/request_code.dart';

class VerificationCodePage extends HookConsumerWidget {
  const VerificationCodePage({
    super.key,
    required this.email,
  });

  final String email;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // useState で verifyCodeState / requestCodeState を管理
    // 実際には ref.watch(verifyCodeNotifierProvider) などでも取得できますが、
    // “useStateで管理”というリクエストに沿ったサンプルにしています。
    final verifyCodeState = useState(ref.watch(verifyCodeNotifierProvider));
    final requestCodeState = useState(ref.watch(requestCodeNotifierProvider));

    // コード入力用 (任意の実装でOK: PIN入力やテキストフィールドなど)
    final codeController = useTextEditingController();

    // 「Resend verification code」連打防止用
    final canResend = useState(true);

    // Resend 成功後、「Verification code has been sent...」が新しくなったかどうか
    final hasResentCode = useState(false);

    // RequestCodeNotifier の状態をリッスンして useState に反映させる
    // 成功・失敗などに応じて画面側で SnackBar を出したりフラグを立てる
    useEffect(() {
      final sub = ref.listenManual(
        requestCodeNotifierProvider,
        (previous, next) {
          requestCodeState.value = next;
          // リクエスト完了時に状態をチェックして SnackBar の表示、アニメーション更新など
          next.when(
            data: (_) {
              // 成功した場合にだけアニメーション状態を切り替え
              hasResentCode.value = true;
              // “SNPITアプリを起動してね”という SnackBar を表示
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text(
                    'コードを再発行しました。SNPIT アプリを起動してください。'
                  ),
                ),
              );
            },
            error: (err, stack) {
              // 失敗時の SnackBar 表示など
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('リクエストに失敗しました: $err')),
              );
            },
            loading: () {
              // ローディング中のインジケータ等を表示したい場合はここで
            },
          );
        },
      );
      return sub.close;
    }, []);

    // VerifyCodeNotifier の状態をリッスンして useState に反映させる
    // 成功時に画面遷移させたいので、このタイミングで context.go
    useEffect(() {
      final sub = ref.listenManual(
        verifyCodeNotifierProvider,
        (previous, next) {
          verifyCodeState.value = next;
          next.when(
            data: (_) {
              // 成功したらマップ画面へ
              context.go(Screen.map.path);
            },
            error: (err, stack) {
              // 失敗時は SnackBar など
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('検証に失敗しました: $err')),
              );
            },
            loading: () {},
          );
        },
      );
      return sub.close;
    }, []);

    // 別アプリを起動する想定の関数（実際のリンク先などは適宜修正）
    void openOtherApp() {
      // 例：URLスキームで他アプリを開く
      // await launchUrlString('snapit://open');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('SNPITアプリを起動します（仮実装）')),
      );
    }

    // Resend button 押下処理
    Future<void> onTapResend() async {
      // 連打防止。false なら SnackBar 表示して return
      if (!canResend.value) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('時間をおいて再度お試しください。')),
        );
        return;
      }
      // リクエスト開始
      canResend.value = false; // 連打防止スタート
      // 20秒後に再タップを許可
      Timer(const Duration(seconds: 20), () {
        canResend.value = true;
      });

      await ref.read(requestCodeNotifierProvider.notifier)
          .requestCode(email);
    }

    // Verify ボタン押下処理
    Future<void> onTapVerify() async {
      final codeInt = int.tryParse(codeController.text) ?? 0;
      await ref.read(verifyCodeNotifierProvider.notifier)
          .verifyCode(email, codeInt);
    }

    return Scaffold(
      appBar: AppBar(backgroundColor: Colors.transparent),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            children: [
              const SizedBox(height: 16),

              // (1) Verification code has been sent to the SNPIT application.
              // アニメーションで表示を切り替える
              Material(
                color: Colors.transparent,
                child: InkWell(
                  // ここで ripple
                  onTap: openOtherApp,
                  child: AnimatedSwitcher(
                    duration: const Duration(milliseconds: 500),
                    child: hasResentCode.value
                        ? const Text(
                            'New verification code has been sent to the SNPIT application.',
                            key: ValueKey('resent'),
                            style: TextStyle(fontSize: 16),
                          )
                        : const Text(
                            'Verification code has been sent to the SNPIT application.',
                            key: ValueKey('initial'),
                            style: TextStyle(fontSize: 16),
                          ),
                  ),
                ),
              ),

              const SizedBox(height: 40),

              // (例) コード入力 UI
              const Text(
                'Verification Code',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              SizedBox(
                width: 200,
                child: TextField(
                  controller: codeController,
                  keyboardType: TextInputType.number,
                  textAlign: TextAlign.center,
                  decoration: const InputDecoration(
                    hintText: 'Enter 4 digits code',
                    border: OutlineInputBorder(),
                  ),
                ),
              ),

              const SizedBox(height: 24),

              // (2) Velify (ElevatedButton) => verifyCodeをコール
              ElevatedButton(
                onPressed: onTapVerify,
                child: const Text('Velify'),
              ),

              const SizedBox(height: 16),

              // (3) Resend verification code => requestCodeをコール
              TextButton(
                onPressed: onTapResend,
                child: const Text('Resend verification code'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### ポイント解説

1. **「Verification code has been sent...」をタップすると別アプリ起動 + Ripple**  
   - `Material + InkWell` でタップ時のリップルエフェクトを表示し、タップしたときに `openOtherApp()` を呼んでいます。実際の別アプリ起動は `launchUrlString('snapit://...')` などで実装してください。

2. **Velify (ElevatedButton) で `verifyCode` をコール**  
   - `onPressed` で `ref.read(verifyCodeNotifierProvider.notifier).verifyCode(...)` を呼び出しています。  
   - 成功時は `context.go(Screen.map.path);` したいので、`useEffect` で `verifyCodeNotifierProvider` の変更をリッスンし、`AsyncData` になったら `context.go` している実装にしています。

3. **「Resend verification code」(TextButton) で `requestCode` をコール & 連打防止**  
   - `canResend` を `useState(true)` で管理し、押下時に `false` にしてから `requestCode` をコール。成功/失敗に関わらず 20 秒後に `true` に戻しています。  
   - `canResend` が `false` の状態で押下された場合には、SnackBar で「時間をおいて再度お試しください」を表示し、実行をスキップしています。

4. **処理成功時のアニメーション + SnackBar**  
   - `AnimatedSwitcher` を使って、もともとのメッセージと「New verification code has been sent...」を切り替えています。  
   - `requestCode` 成功時に `hasResentCode` を `true` にセット → `AnimatedSwitcher` の `child` が切り替わることでアニメーション。  
   - また、処理成功時に SnackBar を出し、「SNPIT アプリを起動するように」と伝えています。

5. **`verifyCodeState` と `requestCodeState` を `useState` で管理**  
   - あえて `ref.watch(...)` をそのまま使わず、`useEffect` と `ref.listenManual` を組み合わせて「常時リッスン→useState へ反映する」形にしています。  
   - 非同期状態の変化を「画面上の SnackBar などでハンドリングしたい」という要望に応えるための例です。

上記の実装をベースに、画面デザインやアニメーション・SnackBar の文言等は自由にカスタマイズしてみてください。

---

## 👤 User
*2025-01-11 21:17:00*

(5)のverifyCodeState と requestCodeState を useState で管理は伝え間違いである。useEffectで宣言して欲しかっただけです。
そう思って修正してほしい。

また、(6)として、以下を追加したい。
遷移したときに自動的に数字を入力するキーボードが立ち上がるようにしたい

---

## 🤖 Assistant
*2025-01-11 21:17:28*

下記は、前回ご提示したサンプルから **(5)** の修正と **(6)** の追加を行ったコード例です。  

- **(5) 修正:**  
  - `verifyCodeState` / `requestCodeState` を `useState` で管理するのではなく、  
  - Provider の `AsyncValue` を `ref.watch(...)` で取得し、**`useEffect`** で状態変化をハンドリングする形に変更しました。  

- **(6) 追加:**  
  - ページ遷移直後に自動的に数字キーボードが立ち上がるように、`FocusNode` を用いて `TextField` に即フォーカスが当たるようにしています。  

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/providers/verify_code.dart';
import 'package:snpit_guild_app/presentation/providers/request_code.dart';

class VerificationCodePage extends HookConsumerWidget {
  const VerificationCodePage({
    super.key,
    required this.email,
  });

  final String email;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // (5) verifyCodeState / requestCodeState を Provider の状態を watch して取得
    final verifyCodeAsyncValue = ref.watch(verifyCodeNotifierProvider);
    final requestCodeAsyncValue = ref.watch(requestCodeNotifierProvider);

    // コード入力用 Controller
    final codeController = useTextEditingController();

    // (6) ページ遷移時に数字キーボードを自動で立ち上げるための FocusNode
    final codeFocusNode = useFocusNode();

    // Resend 成功後アニメーションを切り替えるためのフラグ
    final hasResentCode = useState(false);

    // 「Resend verification code」連打防止用
    final canResend = useState(true);

    // ページ初期表示時に TextField に即フォーカスする（数字キーボードを立ち上げる）
    useEffect(() {
      // build 完了直後にフォーカスを当てる
      Future.microtask(() {
        FocusScope.of(context).requestFocus(codeFocusNode);
      });
      return null;
    }, []);

    // (5) verifyCodeAsyncValue の変更を監視して、成功時に画面遷移・失敗時に SnackBar 表示
    useEffect(() {
      verifyCodeAsyncValue.whenOrNull(
        data: (data) {
          // 成功時に画面遷移
          context.go(Screen.map.path);
        },
        error: (e, stack) {
          // エラー時
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('検証に失敗しました: $e')),
          );
        },
      );
      return null;
    }, [verifyCodeAsyncValue]);

    // (5) requestCodeAsyncValue の変更を監視して、成功時にアニメーション切り替え・失敗時に SnackBar 表示
    useEffect(() {
      requestCodeAsyncValue.whenOrNull(
        data: (_) {
          // リクエスト成功時にアニメーション切り替え
          hasResentCode.value = true;
          // SnackBar の表示
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text(
                'コードを再発行しました。SNPIT アプリを起動してください。',
              ),
            ),
          );
        },
        error: (e, stack) {
          // エラー時
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('リクエストに失敗しました: $e')),
          );
        },
      );
      return null;
    }, [requestCodeAsyncValue]);

    // 別アプリを起動する想定の関数（実際のリンク先などは適宜修正）
    void openOtherApp() {
      // 例：URLスキームで他アプリを開く実装
      // await launchUrlString('snapit://open');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('SNPITアプリを起動します（仮実装）')),
      );
    }

    // 「Resend verification code」押下時の処理
    Future<void> onTapResend() async {
      // 連打防止。false なら SnackBar 表示して return
      if (!canResend.value) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('時間をおいて再度お試しください。')),
        );
        return;
      }
      // 連打防止フラグをオフにしてリクエスト実行
      canResend.value = false;
      // 20 秒後に再度オン
      Timer(const Duration(seconds: 20), () {
        canResend.value = true;
      });
      await ref.read(requestCodeNotifierProvider.notifier).requestCode(email);
    }

    // 「Velify」押下時の処理
    Future<void> onTapVerify() async {
      final codeInt = int.tryParse(codeController.text) ?? 0;
      await ref.read(verifyCodeNotifierProvider.notifier).verifyCode(email, codeInt);
    }

    return Scaffold(
      appBar: AppBar(backgroundColor: Colors.transparent),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            children: [
              const SizedBox(height: 16),

              // (1) Verification code has been sent... をタップ可能にし、Ripple + 別アプリ起動
              Material(
                color: Colors.transparent,
                child: InkWell(
                  onTap: openOtherApp,
                  child: AnimatedSwitcher(
                    duration: const Duration(milliseconds: 500),
                    child: hasResentCode.value
                        ? const Text(
                            'New verification code has been sent to the SNPIT application.',
                            key: ValueKey('resent'),
                            style: TextStyle(fontSize: 16),
                          )
                        : const Text(
                            'Verification code has been sent to the SNPIT application.',
                            key: ValueKey('initial'),
                            style: TextStyle(fontSize: 16),
                          ),
                  ),
                ),
              ),

              const SizedBox(height: 40),

              // (例) コード入力 UI
              const Text(
                'Verification Code',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              SizedBox(
                width: 200,
                child: TextField(
                  focusNode: codeFocusNode,
                  controller: codeController,
                  keyboardType: TextInputType.number,
                  textAlign: TextAlign.center,
                  decoration: const InputDecoration(
                    hintText: 'Enter 4 digits code',
                    border: OutlineInputBorder(),
                  ),
                ),
              ),

              const SizedBox(height: 24),

              // (2) Velify (ElevatedButton) => verifyCode
              ElevatedButton(
                onPressed: onTapVerify,
                child: const Text('Velify'),
              ),

              const SizedBox(height: 16),

              // (3) Resend verification code => requestCode
              TextButton(
                onPressed: onTapResend,
                child: const Text('Resend verification code'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

## 変更点まとめ

1. **(5) の修正**  
   - `verifyCodeState` / `requestCodeState` を `useState` で保持していた部分を削除し、  
   - `ref.watch(verifyCodeNotifierProvider)` / `ref.watch(requestCodeNotifierProvider)` で取得した `AsyncValue` を **`useEffect`** で監視するように変更しました。  
   - 成功/失敗時の SnackBar 表示や画面遷移を、 `useEffect` 内で `AsyncValue.whenOrNull(...)` によってハンドリングしています。

2. **(6) の追加**  
   - `FocusNode` + `useFocusNode()` を使って、画面表示直後に `TextField` に自動フォーカスさせ、数字キーボードが立ち上がるようにしました。  
   - `useEffect` の中で `Future.microtask` を使い、ビルド完了直後に `FocusScope.of(context).requestFocus(codeFocusNode)` を呼び出しています。

---

上記の実装をベースに、UI・アニメーション・SnackBar の文言などをお好みに合わせて調整してみてください。

---

## 👤 User
*2025-01-11 21:20:19*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-17C51nyvSzYWX7BqAEZRLN",
  "size_bytes": 145668,
  "width": 1642,
  "height": 483,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
(1)
この画面に遷移したときに画像のようなエラーになった。

(2)
verifyCodeAsyncValue を verifyCodeState に requestCodeAsyncValue を requestCodeState にrenameしてほしい。

(3)
コメントは日本語でいいが、アプリに表示する文字列は英語にしてほしい

---

## 🤖 Assistant
*2025-01-11 21:20:53*

以下のサンプルコードでは、

- **(1)** 画面遷移直後にエラーが出ないよう、SnackBar を表示する箇所を **`WidgetsBinding.instance.addPostFrameCallback(...)`** で包んでいます。  
  - Hook の `initState` 相当のタイミングではまだ Widget ツリーが確定しておらず、`ScaffoldMessenger.of(context)` が使えないためです。  
- **(2)** `verifyCodeAsyncValue` を `verifyCodeState` に、`requestCodeAsyncValue` を `requestCodeState` にリネームしました。  
- **(3)** アプリに表示する文字列はすべて英語にし、日本語の説明はコメントとして残しています。

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/providers/verify_code.dart';
import 'package:snpit_guild_app/presentation/providers/request_code.dart';

class VerificationCodePage extends HookConsumerWidget {
  const VerificationCodePage({
    super.key,
    required this.email,
  });

  final String email;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // (5) の修正:
    // Provider を watch した結果を useEffect で監視できるようにリネーム
    final verifyCodeState = ref.watch(verifyCodeNotifierProvider);
    final requestCodeState = ref.watch(requestCodeNotifierProvider);

    // コード入力用コントローラ
    final codeController = useTextEditingController();

    // ページ遷移時に数字キーボードを自動で立ち上げるための FocusNode
    final codeFocusNode = useFocusNode();

    // Resend 成功後、文言をアニメーション表示のためのフラグ
    final hasResentCode = useState(false);

    // 「Resend verification code」の連打防止
    final canResend = useState(true);

    // 初期表示時に TextField にフォーカスして数字キーボードを立ち上げる
    useEffect(() {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        FocusScope.of(context).requestFocus(codeFocusNode);
      });
      return null;
    }, []);

    // verifyCodeState の変化を監視し、成功/失敗で画面遷移や SnackBar 表示
    useEffect(() {
      verifyCodeState.whenOrNull(
        data: (_) {
          // 成功時、画面遷移
          WidgetsBinding.instance.addPostFrameCallback((_) {
            context.go(Screen.map.path);
          });
        },
        error: (e, stack) {
          // 失敗時に SnackBar
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Verification failed: $e')),
            );
          });
        },
      );
      return null;
    }, [verifyCodeState]);

    // requestCodeState の変化を監視し、成功/失敗でアニメーション切り替えや SnackBar 表示
    useEffect(() {
      requestCodeState.whenOrNull(
        data: (_) {
          // リクエスト成功時に文言を切り替える
          hasResentCode.value = true;
          // SnackBar 表示
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text(
                  'Code has been resent successfully. Please open the SNPIT app.',
                ),
              ),
            );
          });
        },
        error: (e, stack) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Failed to request code: $e')),
            );
          });
        },
      );
      return null;
    }, [requestCodeState]);

    // 別アプリを起動する想定の関数
    void openOtherApp() {
      // 例: URLスキームで他アプリを開く
      // await launchUrlString('snapit://open');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('SNPIT app launching (mock).')),
      );
    }

    // Resend ボタン押下時の処理
    Future<void> onTapResend() async {
      if (!canResend.value) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please wait for a while and try again.'),
          ),
        );
        return;
      }
      // 連打防止フラグを OFF に
      canResend.value = false;
      // 20秒後に再度 ON
      Timer(const Duration(seconds: 20), () {
        canResend.value = true;
      });
      // requestCode 実行
      await ref.read(requestCodeNotifierProvider.notifier).requestCode(email);
    }

    // Velify ボタン押下時の処理
    Future<void> onTapVerify() async {
      final codeInt = int.tryParse(codeController.text) ?? 0;
      await ref.read(verifyCodeNotifierProvider.notifier)
          .verifyCode(email, codeInt);
    }

    return Scaffold(
      appBar: AppBar(backgroundColor: Colors.transparent),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            children: [
              const SizedBox(height: 16),
              // (1) タップで別アプリ起動 + Ripple
              Material(
                color: Colors.transparent,
                child: InkWell(
                  onTap: openOtherApp,
                  child: AnimatedSwitcher(
                    duration: const Duration(milliseconds: 500),
                    child: hasResentCode.value
                        ? const Text(
                            'New verification code has been sent to the SNPIT application.',
                            key: ValueKey('resent'),
                            style: TextStyle(fontSize: 16),
                          )
                        : const Text(
                            'Verification code has been sent to the SNPIT application.',
                            key: ValueKey('initial'),
                            style: TextStyle(fontSize: 16),
                          ),
                  ),
                ),
              ),
              const SizedBox(height: 40),
              // コード入力UI
              const Text(
                'Verification Code',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              SizedBox(
                width: 200,
                child: TextField(
                  focusNode: codeFocusNode, // 自動フォーカス
                  controller: codeController,
                  keyboardType: TextInputType.number,
                  textAlign: TextAlign.center,
                  decoration: const InputDecoration(
                    hintText: 'Enter 4 digits code',
                    border: OutlineInputBorder(),
                  ),
                ),
              ),
              const SizedBox(height: 24),
              // (2) Velifyボタン
              ElevatedButton(
                onPressed: onTapVerify,
                child: const Text('Velify'),
              ),
              const SizedBox(height: 16),
              // (3) Resendボタン
              TextButton(
                onPressed: onTapResend,
                child: const Text('Resend verification code'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

## 実装のポイント

1. **SnackBar の表示を `build` 以降のフレームに延期**  
   - 「Cannot listen to inherited widgets inside HookState.initState」エラーは、`build` などより早い段階（初期化フックなど）で `ScaffoldMessenger.of(context)` を呼び出すと起こりやすいです。  
   - そこで、`useEffect` の中で `WidgetsBinding.instance.addPostFrameCallback` を使い、初回ビルド完了後に SnackBar を表示するように変更しています。

2. **`verifyCodeAsyncValue` → `verifyCodeState`, `requestCodeAsyncValue` → `requestCodeState` へリネーム**  
   - 上記のように変更しつつ、`useEffect` 内で各 AsyncValue の `whenOrNull` を利用して成功・失敗をハンドリングしています。

3. **アプリに表示する文字列は英語、コメントは日本語**  
   - ボタンラベルやエラーメッセージなど、ユーザーが目にする文言は英語表記に変更しました。  
   - 一方、コード中の解説コメントなどは日本語にしています。

以上の修正により、遷移直後のタイミングでのエラーを避けつつ、要件を満たす構成となります。

---

## 👤 User
*2025-01-11 21:26:38*

これで実装したら、すぐに context.go(Screen.map.path); で遷移してしまった。
dataがnull出ないことは確認したほうがいい
もうひとつのrequestCodeStateについても同じことが言える。
また、URLスキームで他アプリを開く実装もしてほしい。必要であればライブラリも使ってほしい。

---

## 🤖 Assistant
*2025-01-11 21:26:59*

以下のサンプルコードでは、

1. **`verifyCodeState` と `requestCodeState` の `data` が `null` の場合は何もしない** という判定を追加しています。  
   - これにより、API レスポンスに実際のデータが入っていない場合に、即座に `context.go(...)` などが呼ばれないようにしています。  

2. **URL スキームで他アプリを開く実装** を `url_launcher` を用いて実装しています。  
   - 実際に別アプリを開くには、ターゲットアプリ側でカスタム URL スキームの設定をしている必要があります。  
   - ここでは仮で `snapit://open` を使用し、起動できなかった場合には SnackBar を表示するようにしています。  

3. **ユーザーに見える文字列は英語** 、コメントや説明は日本語で書いています。

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

// url_launcher を追加
import 'package:url_launcher/url_launcher.dart';

import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/providers/verify_code.dart';
import 'package:snpit_guild_app/presentation/providers/request_code.dart';

class VerificationCodePage extends HookConsumerWidget {
  const VerificationCodePage({
    super.key,
    required this.email,
  });

  final String email;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Provider を watch して非同期状態を得る。
    // renamed: verifyCodeState, requestCodeState
    final verifyCodeState = ref.watch(verifyCodeNotifierProvider);
    final requestCodeState = ref.watch(requestCodeNotifierProvider);

    // コード入力用
    final codeController = useTextEditingController();

    // ページ遷移時にフォーカスして数字キーボードを出したい
    final codeFocusNode = useFocusNode();

    // Resend 成功後、文言を切り替えるためのフラグ
    final hasResentCode = useState(false);

    // 「Resend verification code」を連打できないようにするフラグ
    final canResend = useState(true);

    // 画面初期表示時にフォーカスするための処理
    useEffect(() {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        FocusScope.of(context).requestFocus(codeFocusNode);
      });
      return null;
    }, []);

    // (1) verifyCodeState の変化を監視し、データがあった場合のみ遷移する
    useEffect(() {
      verifyCodeState.whenOrNull(
        data: (data) {
          // data が null でない場合のみ画面遷移する
          if (data != null) {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              context.go(Screen.map.path);
            });
          }
        },
        error: (e, stack) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Verification failed: $e')),
            );
          });
        },
      );
      return null;
    }, [verifyCodeState]);

    // (2) requestCodeState の変化を監視し、成功時に文言切り替え。data が null じゃなければ OK。
    useEffect(() {
      requestCodeState.whenOrNull(
        data: (data) {
          if (data != null) {
            // Resend 成功時に表示文言を切り替える
            hasResentCode.value = true;
            // SnackBar を表示
            WidgetsBinding.instance.addPostFrameCallback((_) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text(
                    'Code has been resent successfully. Please open the SNPIT app.',
                  ),
                ),
              );
            });
          }
        },
        error: (e, stack) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Failed to request code: $e')),
            );
          });
        },
      );
      return null;
    }, [requestCodeState]);

    // URL スキームで別アプリを開く
    Future<void> openOtherApp() async {
      final schemeUrl = Uri.parse('snapit://open');
      // url_launcher で URL スキームを起動
      if (await canLaunchUrl(schemeUrl)) {
        await launchUrl(schemeUrl);
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to launch SNPIT app. Maybe not installed?'),
          ),
        );
      }
    }

    // Resend ボタン押下処理
    Future<void> onTapResend() async {
      // 連打防止をチェック
      if (!canResend.value) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please wait for a while and try again.'),
          ),
        );
        return;
      }
      canResend.value = false;
      Timer(const Duration(seconds: 20), () {
        canResend.value = true;
      });
      await ref.read(requestCodeNotifierProvider.notifier).requestCode(email);
    }

    // Velify ボタン押下処理
    Future<void> onTapVerify() async {
      final codeInt = int.tryParse(codeController.text) ?? 0;
      await ref.read(verifyCodeNotifierProvider.notifier).verifyCode(email, codeInt);
    }

    return Scaffold(
      appBar: AppBar(backgroundColor: Colors.transparent),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Column(
            children: [
              const SizedBox(height: 16),

              // タップで別アプリ起動 + Ripple
              Material(
                color: Colors.transparent,
                child: InkWell(
                  onTap: openOtherApp,
                  child: AnimatedSwitcher(
                    duration: const Duration(milliseconds: 500),
                    child: hasResentCode.value
                        ? const Text(
                            'New verification code has been sent to the SNPIT application.',
                            key: ValueKey('resent'),
                            style: TextStyle(fontSize: 16),
                          )
                        : const Text(
                            'Verification code has been sent to the SNPIT application.',
                            key: ValueKey('initial'),
                            style: TextStyle(fontSize: 16),
                          ),
                  ),
                ),
              ),

              const SizedBox(height: 40),

              // Verification Code 入力
              const Text(
                'Verification Code',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              SizedBox(
                width: 200,
                child: TextField(
                  focusNode: codeFocusNode,
                  controller: codeController,
                  keyboardType: TextInputType.number,
                  textAlign: TextAlign.center,
                  decoration: const InputDecoration(
                    hintText: 'Enter 4 digits code',
                    border: OutlineInputBorder(),
                  ),
                ),
              ),

              const SizedBox(height: 24),

              ElevatedButton(
                onPressed: onTapVerify,
                child: const Text('Velify'),
              ),

              const SizedBox(height: 16),

              TextButton(
                onPressed: onTapResend,
                child: const Text('Resend verification code'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### 変更点

1. **`data != null` のチェックを追加**  
   - `verifyCodeState.whenOrNull` や `requestCodeState.whenOrNull` で、実際に `data` が返ってきた場合のみ後続の処理を行うようにしています。  
   - これで「`data` が `null` のまま画面遷移してしまう」問題を防ぎます。

2. **URL スキームで他アプリを開く実装**  
   - `url_launcher` パッケージを利用しています（`package:url_launcher/url_launcher.dart` をインポート）。  
   - `canLaunchUrl` / `launchUrl` を使用し、失敗時には `SnackBar` でユーザーに伝えるようにしています。

以上の修正で、  
- `verifyCodeState` と `requestCodeState` の `data` が `null` であるか確認し、不要な画面遷移や SnackBar 表示が行われないようにする。  
- 別アプリ起動を URL スキームで実装する。  

といった要件を満たせるようになります。

---

## 👤 User
*2025-01-11 23:43:55*

一旦修正して以下のコードになった。
useEffectでrequestCodeStateを監視しているコードであるが、なぜかエラーの場合に2回スナックバーが走るようになっていた。boolのフラグではない方法で制御を行いたいもしきはそもそもの記述が間違っているかもしれない。

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/presentation/design_token/color_token.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/auth/request_code.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/auth/verify_code.dart';
import 'package:url_launcher/url_launcher.dart';

class VerificationCodePage extends HookConsumerWidget {
  const VerificationCodePage({
    super.key,
    required this.email,
  });

  final String email;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final verifyCodeState = ref.watch(verifyCodeNotifierProvider);
    final requestCodeState = ref.watch(requestCodeNotifierProvider);
    final codeController = useTextEditingController();
    final focusNode = useFocusNode();
    final canResend = useState(true);

    Future&lt;void&gt; openSnapitApp() async {
      final schemeUrl = Uri.parse('snapit://open');
      if (await canLaunchUrl(schemeUrl)) {
        await launchUrl(schemeUrl);
      } else {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to launch SNPIT app. Maybe not installed.'),
            ),
          );
        });
      }
    }

    Future&lt;void&gt; onTapResend() async {
      if (!canResend.value) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please wait for 180 seconds before trying again.'),
          ),
        );
        return;
      }
      canResend.value = false;
      Timer(const Duration(seconds: 180), () {
        canResend.value = true;
      });
      await ref.read(requestCodeNotifierProvider.notifier).requestCode(email);
    }

    Future&lt;void&gt; onTapVerify() async {
      final codeInt = int.tryParse(codeController.text) ?? 0;
      await ref
          .read(verifyCodeNotifierProvider.notifier)
          .verifyCode(email, codeInt);
    }

    useEffect(
      () {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          FocusScope.of(context).requestFocus(focusNode);
        });
        return null;
      },
      [],
    );

    useEffect(
      () {
        verifyCodeState.whenOrNull(
          data: (data) {
            if (data != null) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                context.go(Screen.map.path);
              });
            }
          },
          error: (e, stack) {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Verification failed: $e')),
              );
            });
          },
        );
        return null;
      },
      [verifyCodeState],
    );

    useEffect(
      () {
        requestCodeState.whenOrNull(
          data: (data) {
            if (data != null) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: const Text(
                      'Verification code sent to SNAPIT app.\n'
                      'Please open the SNAPIT app.',
                    ),
                    action: SnackBarAction(
                      label: 'Open',
                      onPressed: openSnapitApp,
                    ),
                  ),
                );
              });
            }
          },
          error: (e, stack) {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Failed to request code: $e')),
              );
            });
          },
        );
        return null;
      },
      [requestCodeState],
    );

    return Scaffold(
      appBar: AppBar(),
      body: GestureDetector(
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24),
            child: Column(
              children: [
                const SizedBox(height: 16),
                DecoratedBox(
                  decoration: BoxDecoration(
                    color: ColorToken.bg,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: ColorToken.border,
                      width: 0.5,
                    ),
                  ),
                  child: SizedBox(
                    height: 84,
                    width: double.infinity,
                    child: Material(
                      color: Colors.transparent,
                      child: InkWell(
                        onTap: openSnapitApp,
                        child: Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 16),
                          child: Row(
                            children: [
                              Image.asset(
                                Assets.images.snapitAppLogo.path,
                              ),
                              const SizedBox(width: 16),
                              const Text(
                                'Verification code has been\n'
                                'sent to the SNPIT application.',
                                style: TextStyle(fontSize: 16),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 48),
                const Text(
                  'Verification Code',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 30),
                SizedBox(
                  width: 200,
                  child: TextField(
                    focusNode: focusNode,
                    controller: codeController,
                    keyboardType: TextInputType.number,
                    textAlign: TextAlign.center,
                    decoration: const InputDecoration(
                      hintText: 'Enter 4 digits code',
                      border: OutlineInputBorder(),
                    ),
                  ),
                ),
                const SizedBox(height: 80),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 60),
                  child: ElevatedButton(
                    onPressed: onTapVerify,
                    child: const Text('Verify'),
                  ),
                ),
                const SizedBox(height: 30),
                TextButton(
                  onPressed: onTapResend,
                  child: const Text('Resend verification code'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

---

## 🤖 Assistant
*2025-01-11 23:44:37*

以下のように **「前回の状態と今回の状態を比較して、初めてエラーになったタイミングでのみ SnackBar を表示する」** というロジックを入れると、エラー時に複数回 SnackBar が呼ばれる問題を防ぎやすくなります。  

Flutter Hooks には `usePrevious` 相当の仕組みがないため、自分で簡単なカスタム Hook を作るか、あるいは下記のように手動で状態を持って比較するやり方があります。

## やり方の概要

1. **前回ビルド時の `requestCodeState` (または `verifyCodeState`) を保持** し、今回ビルド時の値と比較する。  
2. 新旧の状態を比べて「新たに `AsyncError` になった（かつエラー内容が異なる）」「新たに `AsyncData` になった（かつデータが null ではない）」ときのみ SnackBar を表示する。

これにより、同じエラーが再度反映されても二重に SnackBar を出さずに済みます。  
（※ あるいは「前回が `AsyncLoading` で今回 `AsyncError` に変わった場合だけ SnackBar を出す」など、任意の制御ができます。）

---

## コード例

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:url_launcher/url_launcher.dart';

import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/auth/request_code.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/auth/verify_code.dart';

/// 前回の値を保持して、ビルドごとに更新するカスタムフック
T? usePrevious<T>(T value) {
  final ref = useRef<T?>(null);
  final previousValue = ref.value;
  ref.value = value;
  return previousValue;
}

class VerificationCodePage extends HookConsumerWidget {
  const VerificationCodePage({super.key, required this.email});
  final String email;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // それぞれ AsyncValue を watch
    final verifyCodeState = ref.watch(verifyCodeNotifierProvider);
    final requestCodeState = ref.watch(requestCodeNotifierProvider);

    // “前回の状態” をカスタムフックで取得
    final prevVerifyCodeState = usePrevious(verifyCodeState);
    final prevRequestCodeState = usePrevious(requestCodeState);

    // コード入力用
    final codeController = useTextEditingController();
    // ページ遷移時にフォーカスして数字キーボードを出したい
    final focusNode = useFocusNode();
    // 「Resend verification code」を連打できないようにするフラグ
    final canResend = useState(true);

    // 画面初期表示時にテキストフィールドへフォーカス
    useEffect(
      () {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          FocusScope.of(context).requestFocus(focusNode);
        });
        return null;
      },
      [],
    );

    // 別アプリ（SNPIT アプリ）を URL スキームで開く
    Future<void> openSnapitApp() async {
      final schemeUrl = Uri.parse('snapit://open');
      if (await canLaunchUrl(schemeUrl)) {
        await launchUrl(schemeUrl);
      } else {
        // エラーの場合 SnackBar で通知
        WidgetsBinding.instance.addPostFrameCallback((_) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to launch SNPIT app. Maybe not installed.'),
            ),
          );
        });
      }
    }

    // Resend verification code
    Future<void> onTapResend() async {
      if (!canResend.value) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please wait for 180 seconds before trying again.'),
          ),
        );
        return;
      }
      canResend.value = false;
      Timer(const Duration(seconds: 180), () {
        canResend.value = true;
      });
      await ref.read(requestCodeNotifierProvider.notifier).requestCode(email);
    }

    // Verifyボタン押下
    Future<void> onTapVerify() async {
      final codeInt = int.tryParse(codeController.text) ?? 0;
      await ref.read(verifyCodeNotifierProvider.notifier).verifyCode(email, codeInt);
    }

    // useEffectで verifyCodeState の変化を検知
    useEffect(
      () {
        // 新しい状態
        final newData = verifyCodeState.asData?.value; // data
        final newError = verifyCodeState.asError?.error; // error
        // 前の状態
        final oldData = prevVerifyCodeState?.asData?.value; 
        final oldError = prevVerifyCodeState?.asError?.error;

        // 新たにデータが入った -> 遷移
        if (newData != null && newData != oldData) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            context.go(Screen.map.path);
          });
        }

        // 新たにエラーになった -> SnackBar
        if (newError != null && newError != oldError) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Verification failed: $newError')),
            );
          });
        }

        return null; // dispose 無し
      },
      [verifyCodeState, prevVerifyCodeState],
    );

    // useEffectで requestCodeState の変化を検知
    useEffect(
      () {
        final newData = requestCodeState.asData?.value;
        final newError = requestCodeState.asError?.error;
        final oldData = prevRequestCodeState?.asData?.value;
        final oldError = prevRequestCodeState?.asError?.error;

        // 新たに data が入った -> SnackBar & Open ボタン
        if (newData != null && newData != oldData) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text(
                  'Verification code sent to SNAPIT app.\n'
                  'Please open the SNAPIT app.',
                ),
                action: SnackBarAction(
                  label: 'Open',
                  onPressed: openSnapitApp,
                ),
              ),
            );
          });
        }

        // 新たにエラーになった -> SnackBar
        if (newError != null && newError != oldError) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Failed to request code: $newError')),
            );
          });
        }

        return null;
      },
      [requestCodeState, prevRequestCodeState],
    );

    return Scaffold(
      appBar: AppBar(),
      body: GestureDetector(
        // 画面タップでキーボード隠す
        onTap: () => FocusScope.of(context).unfocus(),
        child: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24),
            child: Column(
              children: [
                const SizedBox(height: 16),
                // SNPITアプリを開くUI
                DecoratedBox(
                  decoration: BoxDecoration(
                    color: Colors.grey.shade200,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.grey, width: 0.5),
                  ),
                  child: SizedBox(
                    height: 84,
                    width: double.infinity,
                    child: Material(
                      color: Colors.transparent,
                      child: InkWell(
                        onTap: openSnapitApp,
                        child: Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 16),
                          child: Row(
                            children: [
                              // 例: SNPITロゴ
                              // Image.asset(Assets.images.snapitAppLogo.path),
                              Container(width: 40, height: 40, color: Colors.green),
                              const SizedBox(width: 16),
                              const Text(
                                'Verification code has been\n'
                                'sent to the SNPIT application.',
                                style: TextStyle(fontSize: 16),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 48),
                const Text(
                  'Verification Code',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 30),
                SizedBox(
                  width: 200,
                  child: TextField(
                    focusNode: focusNode,
                    controller: codeController,
                    keyboardType: TextInputType.number,
                    textAlign: TextAlign.center,
                    decoration: const InputDecoration(
                      hintText: 'Enter 4 digits code',
                      border: OutlineInputBorder(),
                    ),
                  ),
                ),
                const SizedBox(height: 80),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 60),
                  child: ElevatedButton(
                    onPressed: onTapVerify,
                    child: const Text('Verify'),
                  ),
                ),
                const SizedBox(height: 30),
                TextButton(
                  onPressed: onTapResend,
                  child: const Text('Resend verification code'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

### 主なポイント

1. **`usePrevious` フックで前回ビルド時の状態を保持**  
   - `final previousValue = ref.value; ref.value = value; return previousValue;` という簡単な仕組みで「前回の `AsyncValue`」を覚えておきます。

2. **新旧の状態を比べて「初めてエラーになった・データが変わった」ときだけ処理**  
   - 例：  
     ```dart
     final newError = requestCodeState.asError?.error;  
     final oldError = prevRequestCodeState?.asError?.error;  

     if (newError != null && newError != oldError) {
       // SnackBarを表示
     }
     ```
   - これで、同じエラーが繰り返し通知される場合に SnackBar を連発しなくて済みます。

3. **`addPostFrameCallback` を使い、ビルド後に `SnackBar` を表示**  
   - `ScaffoldMessenger.of(context).showSnackBar(...)` をビルド中に呼ぶとエラーが起きる場合があるため、`WidgetsBinding.instance.addPostFrameCallback(...)` 内で呼び出しています。

---

上記のように「前回と比べて変化があったときだけ処理する」というパターンを取り入れると、  
**AsyncValue が更新されるたびに `useEffect` が呼ばれても、同じエラーや同じデータで二重三重に処理すること** が防ぎやすくなります。  

もし「エラーを毎回更新したい場合」「同じエラーでも再度出したい」などの要望があれば、この仕組みを微調整してみてください。

---
