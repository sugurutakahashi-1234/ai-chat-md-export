# Pickerの一般化:オーディオ設定

日付: 2024-05-08

---

## 👤 ユーザー
*2024/05/08 19:13:05*

以下のようなコードがあります。

Picker が @Published の以下の値の数だけ繰り返し記述されるのでうまくまとめたい。
これらの6つのパラメーターはすべてSwiftUIForEachable, SpaceSeparatedTypeNameProvider に対応している。もしかするとSwiftUIForEachable, SpaceSeparatedTypeNameProviderをまとめたプロトコルを定義した方がいいかもしれない。

    @Published var audioSessionCategory: AudioSessionCategory = .record
    @Published var audioSessionMode: AudioSessionMode = .default
    @Published var audioFormat: AudioFormat = .mpeg4aac_acc
    @Published var audioSampleRateQuality: AudioSampleRateQuality = .voiceMemoStandard
    @Published var audioChannel: AudioChannel = .stereo
    @Published var audioEncodeQuality: AudioEncodeQuality = .medium


// MARK: - View

struct RecordingView: View {
    @StateObject private var presenter: RecordingPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        VStack {
            List {
                if #available(iOS 16.0, *) {
                    Picker(selection: $presenter.audioFormat) {
                        ForEach(AudioFormat.allCases, id: \.self) { audioFormat in
                            Text(audioFormat.name)
                        }
                    } label: {
                        Text(AudioFormat.spaceSeparatedTypeName)
                    }
                    .pickerStyle(.navigationLink)
                }
                
                if #available(iOS 16.0, *) {
                    Picker(selection: $presenter.audioSessionCategory) {
                        ForEach(AudioSessionCategory.allCases, id: \.self) { audioSessionCategory in
                            Text(audioSessionCategory.name)
                        }
                    } label: {
                        Text(AudioSessionCategory.spaceSeparatedTypeName)
                    }
                    .pickerStyle(.navigationLink)
                }

            }
            Text("TODO: 録音の検証コード")
            Button {
                presenter.onTapStartRecording()
            } label: {
                Text("録音開始")
            }
            Button {
                presenter.onTapStopRecording()
            } label: {
                Text("録音停止")
            }
            NavigationLink {
                AudioListView()
            } label: {
                Text("録音一覧開始")
            }
        }
        .padding()
        .onAppear {
            presenter.onAppear()
        }
    }
}

// MARK: - Preview

#Preview {
    RecordingView()
}

import AVFoundation

final class RecordingPresenter: ObservableObject {
    @Published var audioSessionCategory: AudioSessionCategory = .record
    @Published var audioSessionMode: AudioSessionMode = .default
    @Published var audioFormat: AudioFormat = .mpeg4aac_acc
    @Published var audioSampleRateQuality: AudioSampleRateQuality = .voiceMemoStandard
    @Published var audioChannel: AudioChannel = .stereo
    @Published var audioEncodeQuality: AudioEncodeQuality = .medium

    private let audioSession: AVAudioSession = AVAudioSession.sharedInstance()
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private var audioRecorder: AVAudioRecorder?
    
    init() {}
    
    func onAppear() {
        Task {
            if #available(iOS 17.0, *) {
                if await AVAudioApplication.requestRecordPermission() {
                    print("granted")
                } else {
                    print("denied")
                }
            } else {
                switch AVAudioSession.sharedInstance().recordPermission {
                case .granted:
                    print("granted")
                case .denied:
                    print("denied")
                case .undetermined:
                    print("undetermined")
                @unknown default:
                    print("unknown")
                }
            }
        }
    }

    func onTapStartRecording() {
        do {
            // Ref: AVAudioSessionの設定で何が変わるのか？ - https://zenn.dev/entaku/articles/e75c4aa914c6cf
            try audioSession.setCategory(audioSessionCategory.toAVAudioSessionCategory, mode: audioSessionMode.toAVAudioSessionMode, options: [])
            try audioSession.setActive(true)
        } catch {
            print("Failed to set audio session category. \(error)")
        }

        let audioFilename = fileManageDriver.getDirectoryURL(directoryType: .tmp)
            .appendingPathComponent("\(Date.ios8601WithFractionalSeconds)")
            .appendingPathExtension(audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(audioFormat.audioFormatID),
            AVSampleRateKey: audioSampleRateQuality.rawValue,
            AVNumberOfChannelsKey: audioChannel.rawValue,
            AVEncoderAudioQualityKey: audioEncodeQuality.toAVAudioQuality.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.record()
        } catch {
            print("Could not start recording: \(error)")
        }
    }

    func onTapStopRecording() {
        audioRecorder?.stop()
        do {
            try AVAudioSession.sharedInstance().setActive(false)
            print("Recording stopped.")
        } catch {
            print("Could not start recording: \(error)")
        }
    }
}  protocol SwiftUIForEachable: Identifiable, CaseIterable {
    var name: String { get }
}

extension SwiftUIForEachable {
    public var id: String {
        "\(self)"
    }
    
    public var name: String {
        "\(self)"
    }
}

public protocol SpaceSeparatedTypeNameProvider {
    static var spaceSeparatedTypeName: String { get }

    var instanceSpaceSeparatedTypeName: String { get }
}

public extension SpaceSeparatedTypeNameProvider {
    static var spaceSeparatedTypeName: String {
        String(describing: Self.self).toSpaceSeparated
    }

    var instanceSpaceSeparatedTypeName: String {
        String(describing: type(of: self)).toSpaceSeparated
    }
}

---

## 🤖 アシスタント
*2024/05/08 19:14:01*

コードの重複を削減し、保守性を高めるために、`SwiftUIForEachable` と `SpaceSeparatedTypeNameProvider` を組み合わせた新しいプロトコルを定義し、それを利用して Picker の設定を一般化することを検討できます。まずは、これらのプロトコルを統合した `AudioSettingType` プロトコルを作成しましょう。

### 新しいプロトコルの定義

```swift
protocol AudioSettingType: SwiftUIForEachable, SpaceSeparatedTypeNameProvider {}

extension AudioSessionCategory: AudioSettingType {}
extension AudioSessionMode: AudioSettingType {}
extension AudioFormat: AudioSettingType {}
extension AudioSampleRateQuality: AudioSettingType {}
extension AudioChannel: AudioSettingType {}
extension AudioEncodeQuality: AudioSettingType {}
```

### Picker の一般化

Picker の設定を一般化するために、次のような `PickerView` を実装できます。このビューは `AudioSettingType` を利用し、動的に適切な選択肢を表示します。

```swift
struct PickerView<T: AudioSettingType>: View {
    @Binding var selection: T
    var body: some View {
        Picker(selection: $selection) {
            ForEach(T.allCases, id: \.self) { value in
                Text(value.name)
            }
        } label: {
            Text(T.spaceSeparatedTypeName)
        }
        .pickerStyle(.navigationLink)
    }
}
```

### `RecordingView` での利用

`RecordingView` 内で、この新しい `PickerView` を利用して、コードの重複を減らすことができます。各パラメーターに対して `PickerView` を適用します。

```swift
struct RecordingView: View {
    @StateObject private var presenter: RecordingPresenter

    init() {
        _presenter = StateObject(wrappedValue: RecordingPresenter())
    }

    var body: some View {
        VStack {
            List {
                if #available(iOS 16.0, *) {
                    PickerView(selection: $presenter.audioFormat)
                    PickerView(selection: $presenter.audioSessionCategory)
                    PickerView(selection: $presenter.audioSampleRateQuality)
                    PickerView(selection: $presenter.audioChannel)
                    PickerView(selection: $presenter.audioEncodeQuality)
                }
            }
            // その他の UI 要素
        }
    }
}
```

これにより、各種オーディオ設定のための Picker を簡潔にかつ効果的に管理できるようになります。また、将来的に新しいオーディオ設定タイプが追加された場合でも、`AudioSettingType` プロトコルに適合させるだけで容易に拡張可能です。

---

## 👤 ユーザー
*2024/05/08 19:30:53*

Generic struct 'ForEach' requires that 'T.AllCases' conform to 'RandomAccessCollectionというエラーになった

---

## 🤖 アシスタント
*2024/05/08 19:31:46*

Swift の `ForEach` 構造体が `CaseIterable` の全ケースを扱う際に `RandomAccessCollection` を要求するというエラーが発生しています。この問題を解決するためには、カスタムプロトコル `AudioSettingType` に対して、その全ケースが `RandomAccessCollection` として扱えるように拡張する必要があります。

`CaseIterable` プロトコルの `allCases` プロパティはデフォルトでは `Array` 型を返しますが、この型は `RandomAccessCollection` プロトコルを満たしているので、直接の型の不一致は原因ではありません。問題は、`T.allCases` の型を Swift が正しく推論できていないことにあります。

### 解決策: 明示的な型注釈の追加

`PickerView` 内の `ForEach` 使用時に、明示的に `T.AllCases` が `RandomAccessCollection` であることを指定します。

```swift
struct PickerView<T: AudioSettingType>: View where T.AllCases: RandomAccessCollection {
    @Binding var selection: T
    var body: some View {
        Picker(selection: $selection) {
            ForEach(T.allCases, id: \.self) { value in
                Text(value.name)
            }
        } label: {
            Text(T.spaceSeparatedTypeName)
        }
        .pickerStyle(.navigationLink)
    }
}
```

このコードでは `where T.AllCases: RandomAccessCollection` を追加して、`T.allCases` が `RandomAccessCollection` に準拠していることを保証しています。これにより、`ForEach` が期待する型の要件を満たすことができます。

### プロトコルの拡張

もし上記の方法で解決しない場合、以下のように `AudioSettingType` に対して具体的に `RandomAccessCollection` を返すように拡張する方法もあります。ただし、この場合は `AudioSettingType` が具体的な型情報を持つ必要があります。

```swift
protocol AudioSettingType: SwiftUIForEachable, SpaceSeparatedTypeNameProvider where AllCases: RandomAccessCollection {}
```

ただし、この拡張は `CaseIterable` の実装がすでに `Array` を返しているため通常は必要ありません。最初の解決策でエラーが解決されるはずです。

---
