# Pickerã®ä¸€èˆ¬åŒ–:ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®š

æ—¥ä»˜: 2024-05-08

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/08 19:13:05*

ä»¥ä¸‹ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚

Picker ãŒ @Published ã®ä»¥ä¸‹ã®å€¤ã®æ•°ã ã‘ç¹°ã‚Šè¿”ã—è¨˜è¿°ã•ã‚Œã‚‹ã®ã§ã†ã¾ãã¾ã¨ã‚ãŸã„ã€‚
ã“ã‚Œã‚‰ã®6ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯ã™ã¹ã¦SwiftUIForEachable, SpaceSeparatedTypeNameProvider ã«å¯¾å¿œã—ã¦ã„ã‚‹ã€‚ã‚‚ã—ã‹ã™ã‚‹ã¨SwiftUIForEachable, SpaceSeparatedTypeNameProviderã‚’ã¾ã¨ã‚ãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®šç¾©ã—ãŸæ–¹ãŒã„ã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚

    @Published var audioSessionCategory: AudioSessionCategory = .record
    @Published var audioSessionMode: AudioSessionMode = .default
    @Published var audioFormat: AudioFormat = .mpeg4aac_acc
    @Published var audioSampleRateQuality: AudioSampleRateQuality = .voiceMemoStandard
    @Published var audioChannel: AudioChannel = .stereo
    @Published var audioEncodeQuality: AudioEncodeQuality = .medium


// MARK: - View

struct RecordingView: View {
    @StateObject private var presenter: RecordingPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        VStack {
            List {
                if #available(iOS 16.0, *) {
                    Picker(selection: $presenter.audioFormat) {
                        ForEach(AudioFormat.allCases, id: \.self) { audioFormat in
                            Text(audioFormat.name)
                        }
                    } label: {
                        Text(AudioFormat.spaceSeparatedTypeName)
                    }
                    .pickerStyle(.navigationLink)
                }
                
                if #available(iOS 16.0, *) {
                    Picker(selection: $presenter.audioSessionCategory) {
                        ForEach(AudioSessionCategory.allCases, id: \.self) { audioSessionCategory in
                            Text(audioSessionCategory.name)
                        }
                    } label: {
                        Text(AudioSessionCategory.spaceSeparatedTypeName)
                    }
                    .pickerStyle(.navigationLink)
                }

            }
            Text("TODO: éŒ²éŸ³ã®æ¤œè¨¼ã‚³ãƒ¼ãƒ‰")
            Button {
                presenter.onTapStartRecording()
            } label: {
                Text("éŒ²éŸ³é–‹å§‹")
            }
            Button {
                presenter.onTapStopRecording()
            } label: {
                Text("éŒ²éŸ³åœæ­¢")
            }
            NavigationLink {
                AudioListView()
            } label: {
                Text("éŒ²éŸ³ä¸€è¦§é–‹å§‹")
            }
        }
        .padding()
        .onAppear {
            presenter.onAppear()
        }
    }
}

// MARK: - Preview

#Preview {
    RecordingView()
}

import AVFoundation

final class RecordingPresenter: ObservableObject {
    @Published var audioSessionCategory: AudioSessionCategory = .record
    @Published var audioSessionMode: AudioSessionMode = .default
    @Published var audioFormat: AudioFormat = .mpeg4aac_acc
    @Published var audioSampleRateQuality: AudioSampleRateQuality = .voiceMemoStandard
    @Published var audioChannel: AudioChannel = .stereo
    @Published var audioEncodeQuality: AudioEncodeQuality = .medium

    private let audioSession: AVAudioSession = AVAudioSession.sharedInstance()
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private var audioRecorder: AVAudioRecorder?
    
    init() {}
    
    func onAppear() {
        Task {
            if #available(iOS 17.0, *) {
                if await AVAudioApplication.requestRecordPermission() {
                    print("granted")
                } else {
                    print("denied")
                }
            } else {
                switch AVAudioSession.sharedInstance().recordPermission {
                case .granted:
                    print("granted")
                case .denied:
                    print("denied")
                case .undetermined:
                    print("undetermined")
                @unknown default:
                    print("unknown")
                }
            }
        }
    }

    func onTapStartRecording() {
        do {
            // Ref: AVAudioSessionã®è¨­å®šã§ä½•ãŒå¤‰ã‚ã‚‹ã®ã‹ï¼Ÿ - https://zenn.dev/entaku/articles/e75c4aa914c6cf
            try audioSession.setCategory(audioSessionCategory.toAVAudioSessionCategory, mode: audioSessionMode.toAVAudioSessionMode, options: [])
            try audioSession.setActive(true)
        } catch {
            print("Failed to set audio session category. \(error)")
        }

        let audioFilename = fileManageDriver.getDirectoryURL(directoryType: .tmp)
            .appendingPathComponent("\(Date.ios8601WithFractionalSeconds)")
            .appendingPathExtension(audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(audioFormat.audioFormatID),
            AVSampleRateKey: audioSampleRateQuality.rawValue,
            AVNumberOfChannelsKey: audioChannel.rawValue,
            AVEncoderAudioQualityKey: audioEncodeQuality.toAVAudioQuality.rawValue
        ]

        do {
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.record()
        } catch {
            print("Could not start recording: \(error)")
        }
    }

    func onTapStopRecording() {
        audioRecorder?.stop()
        do {
            try AVAudioSession.sharedInstance().setActive(false)
            print("Recording stopped.")
        } catch {
            print("Could not start recording: \(error)")
        }
    }
}â€¨â€¨protocol SwiftUIForEachable: Identifiable, CaseIterable {
    var name: String { get }
}

extension SwiftUIForEachable {
    public var id: String {
        "\(self)"
    }
    
    public var name: String {
        "\(self)"
    }
}

public protocol SpaceSeparatedTypeNameProvider {
    static var spaceSeparatedTypeName: String { get }

    var instanceSpaceSeparatedTypeName: String { get }
}

public extension SpaceSeparatedTypeNameProvider {
    static var spaceSeparatedTypeName: String {
        String(describing: Self.self).toSpaceSeparated
    }

    var instanceSpaceSeparatedTypeName: String {
        String(describing: type(of: self)).toSpaceSeparated
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/08 19:14:01*

ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡ã‚’å‰Šæ¸›ã—ã€ä¿å®ˆæ€§ã‚’é«˜ã‚ã‚‹ãŸã‚ã«ã€`SwiftUIForEachable` ã¨ `SpaceSeparatedTypeNameProvider` ã‚’çµ„ã¿åˆã‚ã›ãŸæ–°ã—ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å®šç¾©ã—ã€ãã‚Œã‚’åˆ©ç”¨ã—ã¦ Picker ã®è¨­å®šã‚’ä¸€èˆ¬åŒ–ã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã§ãã¾ã™ã€‚ã¾ãšã¯ã€ã“ã‚Œã‚‰ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’çµ±åˆã—ãŸ `AudioSettingType` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½œæˆã—ã¾ã—ã‚‡ã†ã€‚

### æ–°ã—ã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å®šç¾©

```swift
protocol AudioSettingType: SwiftUIForEachable, SpaceSeparatedTypeNameProvider {}

extension AudioSessionCategory: AudioSettingType {}
extension AudioSessionMode: AudioSettingType {}
extension AudioFormat: AudioSettingType {}
extension AudioSampleRateQuality: AudioSettingType {}
extension AudioChannel: AudioSettingType {}
extension AudioEncodeQuality: AudioSettingType {}
```

### Picker ã®ä¸€èˆ¬åŒ–

Picker ã®è¨­å®šã‚’ä¸€èˆ¬åŒ–ã™ã‚‹ãŸã‚ã«ã€æ¬¡ã®ã‚ˆã†ãª `PickerView` ã‚’å®Ÿè£…ã§ãã¾ã™ã€‚ã“ã®ãƒ“ãƒ¥ãƒ¼ã¯ `AudioSettingType` ã‚’åˆ©ç”¨ã—ã€å‹•çš„ã«é©åˆ‡ãªé¸æŠè‚¢ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚

```swift
struct PickerView<T: AudioSettingType>: View {
    @Binding var selection: T
    var body: some View {
        Picker(selection: $selection) {
            ForEach(T.allCases, id: \.self) { value in
                Text(value.name)
            }
        } label: {
            Text(T.spaceSeparatedTypeName)
        }
        .pickerStyle(.navigationLink)
    }
}
```

### `RecordingView` ã§ã®åˆ©ç”¨

`RecordingView` å†…ã§ã€ã“ã®æ–°ã—ã„ `PickerView` ã‚’åˆ©ç”¨ã—ã¦ã€ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡ã‚’æ¸›ã‚‰ã™ã“ã¨ãŒã§ãã¾ã™ã€‚å„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«å¯¾ã—ã¦ `PickerView` ã‚’é©ç”¨ã—ã¾ã™ã€‚

```swift
struct RecordingView: View {
    @StateObject private var presenter: RecordingPresenter

    init() {
        _presenter = StateObject(wrappedValue: RecordingPresenter())
    }

    var body: some View {
        VStack {
            List {
                if #available(iOS 16.0, *) {
                    PickerView(selection: $presenter.audioFormat)
                    PickerView(selection: $presenter.audioSessionCategory)
                    PickerView(selection: $presenter.audioSampleRateQuality)
                    PickerView(selection: $presenter.audioChannel)
                    PickerView(selection: $presenter.audioEncodeQuality)
                }
            }
            // ãã®ä»–ã® UI è¦ç´ 
        }
    }
}
```

ã“ã‚Œã«ã‚ˆã‚Šã€å„ç¨®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®šã®ãŸã‚ã® Picker ã‚’ç°¡æ½”ã«ã‹ã¤åŠ¹æœçš„ã«ç®¡ç†ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€å°†æ¥çš„ã«æ–°ã—ã„ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®šã‚¿ã‚¤ãƒ—ãŒè¿½åŠ ã•ã‚ŒãŸå ´åˆã§ã‚‚ã€`AudioSettingType` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«é©åˆã•ã›ã‚‹ã ã‘ã§å®¹æ˜“ã«æ‹¡å¼µå¯èƒ½ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/08 19:30:53*

Generic struct 'ForEach' requires that 'T.AllCases' conform to 'RandomAccessCollectionã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã«ãªã£ãŸ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/08 19:31:46*

Swift ã® `ForEach` æ§‹é€ ä½“ãŒ `CaseIterable` ã®å…¨ã‚±ãƒ¼ã‚¹ã‚’æ‰±ã†éš›ã« `RandomAccessCollection` ã‚’è¦æ±‚ã™ã‚‹ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ã¯ã€ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒˆã‚³ãƒ« `AudioSettingType` ã«å¯¾ã—ã¦ã€ãã®å…¨ã‚±ãƒ¼ã‚¹ãŒ `RandomAccessCollection` ã¨ã—ã¦æ‰±ãˆã‚‹ã‚ˆã†ã«æ‹¡å¼µã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

`CaseIterable` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã® `allCases` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ `Array` å‹ã‚’è¿”ã—ã¾ã™ãŒã€ã“ã®å‹ã¯ `RandomAccessCollection` ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’æº€ãŸã—ã¦ã„ã‚‹ã®ã§ã€ç›´æ¥ã®å‹ã®ä¸ä¸€è‡´ã¯åŸå› ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å•é¡Œã¯ã€`T.allCases` ã®å‹ã‚’ Swift ãŒæ­£ã—ãæ¨è«–ã§ãã¦ã„ãªã„ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚

### è§£æ±ºç­–: æ˜ç¤ºçš„ãªå‹æ³¨é‡ˆã®è¿½åŠ 

`PickerView` å†…ã® `ForEach` ä½¿ç”¨æ™‚ã«ã€æ˜ç¤ºçš„ã« `T.AllCases` ãŒ `RandomAccessCollection` ã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡å®šã—ã¾ã™ã€‚

```swift
struct PickerView<T: AudioSettingType>: View where T.AllCases: RandomAccessCollection {
    @Binding var selection: T
    var body: some View {
        Picker(selection: $selection) {
            ForEach(T.allCases, id: \.self) { value in
                Text(value.name)
            }
        } label: {
            Text(T.spaceSeparatedTypeName)
        }
        .pickerStyle(.navigationLink)
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ `where T.AllCases: RandomAccessCollection` ã‚’è¿½åŠ ã—ã¦ã€`T.allCases` ãŒ `RandomAccessCollection` ã«æº–æ‹ ã—ã¦ã„ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€`ForEach` ãŒæœŸå¾…ã™ã‚‹å‹ã®è¦ä»¶ã‚’æº€ãŸã™ã“ã¨ãŒã§ãã¾ã™ã€‚

### ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®æ‹¡å¼µ

ã‚‚ã—ä¸Šè¨˜ã®æ–¹æ³•ã§è§£æ±ºã—ãªã„å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ã« `AudioSettingType` ã«å¯¾ã—ã¦å…·ä½“çš„ã« `RandomAccessCollection` ã‚’è¿”ã™ã‚ˆã†ã«æ‹¡å¼µã™ã‚‹æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚ãŸã ã—ã€ã“ã®å ´åˆã¯ `AudioSettingType` ãŒå…·ä½“çš„ãªå‹æƒ…å ±ã‚’æŒã¤å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```swift
protocol AudioSettingType: SwiftUIForEachable, SpaceSeparatedTypeNameProvider where AllCases: RandomAccessCollection {}
```

ãŸã ã—ã€ã“ã®æ‹¡å¼µã¯ `CaseIterable` ã®å®Ÿè£…ãŒã™ã§ã« `Array` ã‚’è¿”ã—ã¦ã„ã‚‹ãŸã‚é€šå¸¸ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚æœ€åˆã®è§£æ±ºç­–ã§ã‚¨ãƒ©ãƒ¼ãŒè§£æ±ºã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚

---
