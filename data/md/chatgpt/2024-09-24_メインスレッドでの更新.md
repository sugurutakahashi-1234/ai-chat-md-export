# メインスレッドでの更新

Date: 2024-09-24

---

## 👤 User
*2024-09-24 12:37:57*

videoAspect の更新だけメインスレッドでしたお

Task.detached {
                        guard let videoTrack = try await player.currentItem?.asset.loadTracks(withMediaType: .video).first else {
                            print("Video track not found")
                            return
                        }
                        let videoSize = try await videoTrack.load(.naturalSize)
                        videoAspect = videoSize.width / videoSize.height
                    }

---

## 🤖 Assistant
*2024-09-24 12:38:05*

`videoAspect` の更新はメインスレッドで行う必要がありますので、次のようにメインスレッドでの更新を `DispatchQueue.main.async` で行うと良いでしょう：

```swift
Task.detached {
    guard let videoTrack = try await player.currentItem?.asset.loadTracks(withMediaType: .video).first else {
        print("Video track not found")
        return
    }
    let videoSize = try await videoTrack.load(.naturalSize)
    
    // メインスレッドで videoAspect を更新する
    DispatchQueue.main.async {
        videoAspect = videoSize.width / videoSize.height
    }
}
```

このように `DispatchQueue.main.async` を使用することで、非同期処理の中で `videoAspect` をメインスレッドで安全に更新できます。

---

## 👤 User
*2024-09-24 12:38:15*

DispatchQueue.main.async ではなくて、Swift Concurrencyで記述したい

---

## 🤖 Assistant
*2024-09-24 12:38:27*

Swift Concurrency を使ってメインスレッドで `videoAspect` を更新したい場合、`@MainActor` を使うと簡潔に記述できます。以下のように書き直すと、メインスレッドでの更新を自動的に処理してくれます：

```swift
Task.detached {
    guard let videoTrack = try await player.currentItem?.asset.loadTracks(withMediaType: .video).first else {
        print("Video track not found")
        return
    }
    let videoSize = try await videoTrack.load(.naturalSize)
    
    await MainActor.run {
        videoAspect = videoSize.width / videoSize.height
    }
}
```

`MainActor.run` を使うことで、メインスレッド上で処理を行うことが保証されます。この方法で Swift Concurrency に統一した形で記述できますよ。

---
