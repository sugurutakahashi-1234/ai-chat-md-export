# SwiftUI 動画再生方法

日付: 2024-09-24

---

## 👤 ユーザー
*2024/9/24 10:54:59*

SwiftUIで動画の再生をしたい。

---

## 🤖 アシスタント
*2024/9/24 10:55:34*

SwiftUIで動画の再生をするには、`AVKit`フレームワークを利用する方法が便利です。`AVPlayer`を使用して動画の再生を管理し、それをSwiftUIの`VideoPlayer`ビューに組み込むことができます。

以下は、簡単な動画再生の例です。

```swift
import SwiftUI
import AVKit

struct VideoPlayerView: View {
    let player = AVPlayer(url: URL(string: "https://path-to-your-video.com/video.mp4")!)

    var body: some View {
        VideoPlayer(player: player)
            .onAppear {
                player.play() // 動画の自動再生を開始
            }
            .frame(height: 300) // 必要に応じてフレームサイズを調整
            .ignoresSafeArea(edges: .all) // 必要に応じて画面いっぱいに表示
    }
}

struct ContentView: View {
    var body: some View {
        VideoPlayerView()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

このコードでは、次のポイントがあります：

1. **AVPlayerの初期化**: `URL`で動画のパスを指定して`AVPlayer`を作成しています。
2. **VideoPlayer**: SwiftUIのビューとして動画を再生するために使用しています。
3. **自動再生**: `onAppear`でビューが表示されたタイミングで動画の再生を開始します。
4. **フレームサイズの指定**: `frame(height:)`を使って動画の表示サイズを設定できます。

もし、ローカルファイルを再生したい場合は、`Bundle.main.url`を使ってローカル動画のURLを指定することができます。

```swift
let player = AVPlayer(url: Bundle.main.url(forResource: "local-video", withExtension: "mp4")!)
```

必要に応じてカスタマイズできますが、これが基本的な実装です。

---

## 👤 ユーザー
*2024/9/24 10:58:47*

ディサpeerしたときに最初から再生してほしい

---

## 🤖 アシスタント
*2024/9/24 10:59:13*

ディスアピア（`disappear`）したときに動画を最初から再生するには、`onDisappear`モディファイアを使って、ビューが非表示になるタイミングで`AVPlayer`を停止し、再度再生する際に動画を最初から再生するように設定できます。

以下の例では、`onDisappear`内で動画の再生位置をゼロにリセットし、再生を停止しています。

```swift
import SwiftUI
import AVKit

struct VideoPlayerView: View {
    @State private var player = AVPlayer(url: URL(string: "https://path-to-your-video.com/video.mp4")!)

    var body: some View {
        VideoPlayer(player: player)
            .onAppear {
                player.play() // 動画の自動再生を開始
            }
            .onDisappear {
                // 動画の再生位置を最初に戻す
                player.seek(to: .zero)
                player.pause() // 再生を停止する
            }
            .frame(height: 300) // 必要に応じてフレームサイズを調整
            .ignoresSafeArea(edges: .all) // 必要に応じて画面いっぱいに表示
    }
}

struct ContentView: View {
    var body: some View {
        VideoPlayerView()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

### 重要なポイント:
1. **`onAppear`で再生開始**: ビューが表示されたときに動画の再生を開始しています。
2. **`onDisappear`で動画をリセット**: ビューが非表示になるときに、`seek(to:)`を使って再生位置をゼロにリセットし、`pause()`で一時停止します。これにより、次回表示されたときに動画が最初から再生されるようになります。

このアプローチを使うことで、動画がビューが非表示になったタイミングでリセットされ、再表示時に最初から再生されるようになります。

---

## 👤 ユーザー
*2024/9/24 10:59:18*

順番逆だとどうなる

player.seek(to: .zero)
                player.pause() // 再生を停止する

---

## 🤖 アシスタント
*2024/9/24 10:59:39*

`player.seek(to: .zero)`と`player.pause()`の順番を逆にすると、次のような挙動になります。

### 順番を逆にした場合

```swift
player.pause() // 先に再生を停止する
player.seek(to: .zero) // 再生位置をリセットする
```

### 結果
1. **`player.pause()`が先の場合**: 
   - `pause()`メソッドは、動画の再生を現在の位置で一時停止します。
   - その後に`seek(to: .zero)`が呼ばれるため、再生が停止した状態で再生位置をリセットします。

この順番でも動作は問題ありません。`pause()`によって再生が停止した後、`seek(to:)`で再生位置を最初に戻す処理が行われるため、動作自体に大きな違いはないはずです。再生位置をリセットした状態で停止するだけです。

### 元の順番の場合

```swift
player.seek(to: .zero) // 先に再生位置をリセットする
player.pause() // 再生を停止する
```

### 結果
- この順番だと、**まず再生位置をリセット**し、その後で再生を停止します。
- どちらの順番でも、次に再生を開始するときには最初から再生されます。

### 違いについて
**挙動に関しては、どちらの順番でも大きな違いはありません**。ただし、プログラムの流れとしては、再生位置をリセットしてから停止するほうが自然かもしれません。これは、リセットしたあとに他の操作（再生や停止）を行うという論理的な流れに従うためです。

- **おすすめ**: 先に`seek(to: .zero)`を実行してから`pause()`を行うほうが、コードの意図が分かりやすくなります。

---

## 👤 ユーザー
*2024/9/24 12:15:34*

ビデオサイズにフレームを合わせたい

---

## 🤖 アシスタント
*2024/9/24 12:16:05*

SwiftUIの`VideoPlayer`で動画のアスペクト比にフレームサイズを自動的に合わせたい場合、動画のサイズに基づいてフレームを動的に調整することができます。これを行うには、`AVPlayerItem`の`presentationSize`プロパティを使って、動画の幅と高さの比率を取得し、それに基づいてフレームサイズを設定します。

以下は、動画のサイズにフレームを合わせる方法の一例です。

```swift
import SwiftUI
import AVKit

struct VideoPlayerView: View {
    @State private var player = AVPlayer(url: URL(string: "https://path-to-your-video.com/video.mp4")!)
    @State private var videoSize: CGSize = .zero

    var body: some View {
        VStack {
            if videoSize != .zero {
                // 動画サイズに合わせてフレームを調整
                VideoPlayer(player: player)
                    .frame(width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.width * (videoSize.height / videoSize.width))
            } else {
                // 動画サイズが取得されるまでのプレースホルダー
                ProgressView("Loading video...")
                    .frame(width: 100, height: 100)
            }
        }
        .onAppear {
            player.play()

            // 動画サイズを取得するためにリスナーを追加
            if let currentItem = player.currentItem {
                let asset = currentItem.asset
                asset.loadValuesAsynchronously(forKeys: ["tracks"]) {
                    DispatchQueue.main.async {
                        if let track = asset.tracks(withMediaType: .video).first {
                            let size = track.naturalSize.applying(track.preferredTransform)
                            videoSize = CGSize(width: abs(size.width), height: abs(size.height))
                        }
                    }
                }
            }
        }
        .onDisappear {
            player.pause()
            player.seek(to: .zero)
        }
    }
}

struct ContentView: View {
    var body: some View {
        VideoPlayerView()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

### 解説:
1. **`videoSize`を取得**:
   - `AVAsset`を使用して動画のサイズを取得します。動画のトラック（`track`）から、動画のナチュラルサイズ（`naturalSize`）とトランスフォーム情報（回転など）を適用して、実際の表示サイズを計算します。
   
2. **`VideoPlayer`のフレームを調整**:
   - 動画のサイズに基づいて、`frame`を設定します。この場合、デバイスの画面幅（`UIScreen.main.bounds.width`）を基準にして、アスペクト比を維持しつつ高さを調整しています。

3. **`ProgressView`**:
   - 動画のサイズがまだ取得できていないときに表示するためのローディングインジケーターを追加しています。

### 注意:
- 動画のサイズは非同期で取得するため、`loadValuesAsynchronously`を使用して動画のトラック情報を読み込み、表示用のフレームサイズを計算します。
- `naturalSize`に`preferredTransform`を適用することで、回転情報などを考慮した正しいサイズを取得します。

この方法を使えば、動画の実際のサイズにフレームを自動的に合わせることができます。

---

## 👤 ユーザー
*2024/9/24 12:16:19*

もっと簡単に合わせる方法はないの？

---

## 🤖 アシスタント
*2024/9/24 12:16:36*

もっと簡単に動画のサイズにフレームを合わせる方法として、SwiftUIの`VideoPlayer`に`aspectRatio`を適用する方法があります。これにより、元の動画のアスペクト比を保ちながら、指定されたフレーム内に収まるように表示されます。

`aspectRatio(contentMode: .fit)`を使うと、元の動画のアスペクト比を保ちつつ、指定したフレーム内で最適なサイズに自動的に調整できます。

以下は、シンプルに`aspectRatio`を使った例です。

```swift
import SwiftUI
import AVKit

struct VideoPlayerView: View {
    let player = AVPlayer(url: URL(string: "https://path-to-your-video.com/video.mp4")!)

    var body: some View {
        VideoPlayer(player: player)
            .aspectRatio(contentMode: .fit) // アスペクト比を保ってフレームに合わせる
            .onAppear {
                player.play()
            }
            .onDisappear {
                player.pause()
                player.seek(to: .zero)
            }
    }
}

struct ContentView: View {
    var body: some View {
        VideoPlayerView()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

### 重要なポイント：
- **`aspectRatio(contentMode: .fit)`**: 元の動画のアスペクト比（横と縦の比率）を保ちながら、親ビューのサイズに収めます。`contentMode: .fit`を使用することで、元のアスペクト比が維持され、ビュー内に収まるように表示されます。
- **フレームを指定しなくてもOK**: この方法では、`VideoPlayer`にフレームサイズを明示的に指定する必要はなく、デフォルトでアスペクト比を保ちながら自動調整されます。

これが、より簡単でスッキリした実装です。動画のアスペクト比を自動的に合わせつつ、SwiftUIで動画を再生できます。

---

## 👤 ユーザー
*2024/9/24 12:17:54*

.aspectRatio(contentMode: .fill) にしたら上下に暗いものが見える

---

## 🤖 アシスタント
*2024/9/24 12:18:24*

`aspectRatio(contentMode: .fill)` を使用すると、動画が指定されたフレーム全体にフィットするために拡大縮小されますが、動画のアスペクト比がフレームと一致しない場合、左右や上下が切り取られることがあります。その際、動画の外側（黒い部分や透明な部分）が見えてしまうことがあります。

これを解決するために、以下のいくつかの方法を試すことができます。

### 1. フレームを明示的に指定して動画がはみ出さないようにする
`aspectRatio(contentMode: .fill)`はフレーム全体にコンテンツを表示しようとするため、フレームサイズを明示的に指定しておくことで、アスペクト比の違いによって黒い部分が表示されないようにします。例えば、フレームを画面幅に固定して高さをアスペクト比で計算する方法です。

```swift
import SwiftUI
import AVKit

struct VideoPlayerView: View {
    let player = AVPlayer(url: URL(string: "https://path-to-your-video.com/video.mp4")!)

    var body: some View {
        VideoPlayer(player: player)
            .frame(width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.width * 9 / 16) // 16:9のアスペクト比に固定
            .clipped() // フレーム外を表示しないようにクリップ
            .onAppear {
                player.play()
            }
            .onDisappear {
                player.pause()
                player.seek(to: .zero)
            }
    }
}

struct ContentView: View {
    var body: some View {
        VideoPlayerView()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

### 2. `.clipped()`を使ってフレーム外の部分を隠す
動画の一部が拡大されてフレーム外に表示される場合、`clipped()`を使用することで、動画のフレーム外の部分（黒いエリアなど）を表示しないようにできます。

```swift
VideoPlayer(player: player)
    .aspectRatio(contentMode: .fill) // フレーム全体にフィットさせる
    .clipped() // フレーム外の部分を切り取る
```

これにより、`aspectRatio(contentMode: .fill)`での拡大縮小の際に、動画の上下または左右に余計な黒い部分が表示されないようになります。

### 3. 背景色を変更する
もし、上下や左右に黒い部分が表示される場合は、背景色を設定することで見た目を改善できます。例えば、黒ではなく別の色を使うことができます。

```swift
VideoPlayer(player: player)
    .aspectRatio(contentMode: .fill)
    .background(Color.black) // 例えば黒で背景を統一する
```

これにより、動画外の黒い部分が目立たなくなる可能性があります。

---

まとめると、`aspectRatio(contentMode: .fill)`を使用してフレーム全体にフィットさせる場合、フレーム外の部分が気になるときは、`clipped()`を使ってフレーム外を隠すか、フレームサイズを固定して余分なスペースが見えないように調整するのが良いアプローチです。

---

## 👤 ユーザー
*2024/9/24 12:19:01*

.clipped() で切り抜かれなかった

---

## 🤖 アシスタント
*2024/9/24 12:19:33*

`aspectRatio(contentMode: .fill)` と `clipped()` を使用しても期待通りに切り抜かれない場合、原因としては `VideoPlayer` のレイヤーやフレームサイズの扱いに問題がある可能性があります。

別の解決策として、`GeometryReader` を使って動的に動画のフレームサイズを取得し、拡大・縮小をコントロールする方法があります。`GeometryReader` を使うことで、表示されるフレームに対して適切に動画をトリミングすることが可能です。

以下の例では、`GeometryReader` を使ってフレーム全体に動画をフィットさせる方法を紹介します。

```swift
import SwiftUI
import AVKit

struct VideoPlayerView: View {
    let player = AVPlayer(url: URL(string: "https://path-to-your-video.com/video.mp4")!)

    var body: some View {
        GeometryReader { geometry in
            VideoPlayer(player: player)
                .frame(width: geometry.size.width, height: geometry.size.height) // フレームサイズに合わせる
                .aspectRatio(contentMode: .fill) // フレーム全体に動画をフィットさせる
                .clipped() // フレーム外を切り取る
        }
        .onAppear {
            player.play()
        }
        .onDisappear {
            player.pause()
            player.seek(to: .zero)
        }
    }
}

struct ContentView: View {
    var body: some View {
        VideoPlayerView()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
```

### 重要なポイント:
1. **`GeometryReader`**: 親ビューのサイズを取得し、そのサイズに基づいて`VideoPlayer`のフレームサイズを動的に変更します。
2. **`aspectRatio(contentMode: .fill)`**: 動画をフレーム全体に拡大縮小しますが、アスペクト比を維持します。そのため、縦横の比率が異なる場合、余白ができないように拡大されます。
3. **`clipped()`**: フレームの外に出た部分を切り取ります。これにより、黒いバーや不要な余白が見えなくなります。

これにより、`VideoPlayer`のフレームが親ビューのサイズにしっかりとフィットし、黒い余白が表示されずに動画がフレーム全体を埋めるように表示されるはずです。

---
