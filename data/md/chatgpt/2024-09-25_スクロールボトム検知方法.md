# スクロールボトム検知方法

Date: 2024-09-25

---

## 👤 User
*2024-09-25 17:19:36*

スクロールがボトムにあることを検知したい

struct ConversationLogView: View {
    
    @EnvironmentObject var router: FeatureRouter
    @StateObject var viewModel = ConversationLogViewModel()
    
    var body: some View {
        VStack(spacing: 0) {
            NavigationBar()
            Divider().background(Color.gritGray40)
            ScrollView(showsIndicators: false) {
                VStack(spacing: 0) {
                    Spacer().frame(height: 24)
                    Text("会話履歴")
                        .foregroundColor(Color.gritGray90)
                        .font(.bold14)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.leading, 4)
                    Spacer().frame(height: 12)
                    if let studyHistory = viewModel.studyHistory {
                        StudyHistoryView(
                            totalConversationCount: studyHistory.accumulatedDay,
                            totalWordCount: studyHistory.accumulateWordCount
                        )
                    }
                    
                    if viewModel.hasNoMessageThreads {
                        Spacer().frame(height: 60)
                        EmptyStatusView()
                        Spacer().frame(height: 60)
                    } else if let threads = viewModel.threads {
                        Spacer().frame(height: 32)
                        ConversationListView(threads: threads) { messageThread in
                            router.homeFlow(event: .tappedConversationDetail(messageThread: messageThread))
                        }
                        
//                        if let threads = viewModel.threads, threads.isNotEmpty {
//                            if !viewModel.isFetchingMessageThreads {
//                                ProgressView()
//                                    .padding(.vertical, 8)
//                            }
//
//                            GeometryReader { geometry in
//                                Color.clear
//                                    .onAppear {
//                                        if geometry.frame(in: .global).maxY &lt; UIScreen.main.bounds.height {
//                                            viewModel.onScrollToEnd()
//                                        }
//                                    }
//                            }
//                            .frame(height: 1)
//                        }
                    }
                }
                .padding(.horizontal, 12)
            }
            .background(Color.gritBeige40)
        }
        .overlay {
            if viewModel.isLoading {
                ProgressView()
            }
        }
        .overlay {
            if viewModel.showReloadButton {
                ReloadButton {
                    viewModel.onTapReloadButton()
                }
            }
        }
    }
}

---

## 🤖 Assistant
*2024-09-25 17:20:19*

スクロールがボトムに達したことを検知するには、`ScrollView`の中で`GeometryReader`を使用して、スクロール位置を監視する方法がよく使われます。`GeometryReader`を使うことで、画面のボトムに達したときに特定のアクションを実行することができます。

以下のコードでは、`GeometryReader`を使用してスクロールがボトムに達したかを確認し、その場合に`viewModel.onScrollToEnd()`を呼び出すようにしました。

```swift
struct ConversationLogView: View {
    
    @EnvironmentObject var router: FeatureRouter
    @StateObject var viewModel = ConversationLogViewModel()
    
    var body: some View {
        VStack(spacing: 0) {
            NavigationBar()
            Divider().background(Color.gritGray40)
            ScrollView(showsIndicators: false) {
                VStack(spacing: 0) {
                    Spacer().frame(height: 24)
                    Text("会話履歴")
                        .foregroundColor(Color.gritGray90)
                        .font(.bold14)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.leading, 4)
                    Spacer().frame(height: 12)
                    if let studyHistory = viewModel.studyHistory {
                        StudyHistoryView(
                            totalConversationCount: studyHistory.accumulatedDay,
                            totalWordCount: studyHistory.accumulateWordCount
                        )
                    }
                    
                    if viewModel.hasNoMessageThreads {
                        Spacer().frame(height: 60)
                        EmptyStatusView()
                        Spacer().frame(height: 60)
                    } else if let threads = viewModel.threads {
                        Spacer().frame(height: 32)
                        ConversationListView(threads: threads) { messageThread in
                            router.homeFlow(event: .tappedConversationDetail(messageThread: messageThread))
                        }
                        
                        // ボトム到達時の検知
                        GeometryReader { geometry in
                            Color.clear
                                .onAppear {
                                    let scrollPosition = geometry.frame(in: .global).maxY
                                    let screenHeight = UIScreen.main.bounds.height
                                    if scrollPosition < screenHeight {
                                        viewModel.onScrollToEnd()
                                    }
                                }
                        }
                        .frame(height: 1) // ボトム近くに配置
                    }
                }
                .padding(.horizontal, 12)
            }
            .background(Color.gritBeige40)
        }
        .overlay {
            if viewModel.isLoading {
                ProgressView()
            }
        }
        .overlay {
            if viewModel.showReloadButton {
                ReloadButton {
                    viewModel.onTapReloadButton()
                }
            }
        }
    }
}
```

### 追加した部分のポイント
- `GeometryReader` を使ってスクロールのボトム近くに到達したかを検知します。
- `geometry.frame(in: .global).maxY` で現在のスクロール位置を取得し、画面の高さ (`UIScreen.main.bounds.height`) と比較します。
- ボトムに到達した場合は、`viewModel.onScrollToEnd()` を呼び出して、次のデータを取得するなどのアクションを実行できます。

このようにして、ユーザーがスクロールの最後に到達したときに、次の処理を開始することができます。

---

## 👤 User
*2024-09-25 17:20:56*

検知しなかった。

---

## 🤖 Assistant
*2024-09-25 17:21:29*

`GeometryReader`の使用タイミングや判定条件が正確でない場合、スクロールのボトムを検知できないことがあります。`ScrollViewReader`と組み合わせてスクロール位置の変化を監視する方法が有効です。`onChange`を使って`ScrollView`のオフセット位置を追跡する方法を試してみてください。

以下に、`ScrollView`のスクロール位置を追跡するために`onChange`を利用した改善版のコードを示します。

```swift
struct ConversationLogView: View {
    
    @EnvironmentObject var router: FeatureRouter
    @StateObject var viewModel = ConversationLogViewModel()
    
    // ScrollViewのオフセットを追跡するための変数
    @State private var scrollOffset: CGFloat = 0.0
    @State private var contentHeight: CGFloat = 0.0
    @State private var scrollViewHeight: CGFloat = 0.0
    
    var body: some View {
        VStack(spacing: 0) {
            NavigationBar()
            Divider().background(Color.gritGray40)
            ScrollView(showsIndicators: false) {
                VStack(spacing: 0) {
                    Spacer().frame(height: 24)
                    Text("会話履歴")
                        .foregroundColor(Color.gritGray90)
                        .font(.bold14)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.leading, 4)
                    Spacer().frame(height: 12)
                    if let studyHistory = viewModel.studyHistory {
                        StudyHistoryView(
                            totalConversationCount: studyHistory.accumulatedDay,
                            totalWordCount: studyHistory.accumulateWordCount
                        )
                    }
                    
                    if viewModel.hasNoMessageThreads {
                        Spacer().frame(height: 60)
                        EmptyStatusView()
                        Spacer().frame(height: 60)
                    } else if let threads = viewModel.threads {
                        Spacer().frame(height: 32)
                        ConversationListView(threads: threads) { messageThread in
                            router.homeFlow(event: .tappedConversationDetail(messageThread: messageThread))
                        }
                    }
                }
                .background(GeometryReader { geometry -> Color in
                    DispatchQueue.main.async {
                        // ScrollViewのコンテンツ全体の高さを取得
                        self.contentHeight = geometry.size.height
                    }
                    return Color.clear
                })
                .padding(.horizontal, 12)
            }
            .background(Color.gritBeige40)
            .overlay(
                GeometryReader { geometry in
                    Color.clear
                        .onAppear {
                            // ScrollViewの表示可能な高さを取得
                            scrollViewHeight = geometry.size.height
                        }
                        .onChange(of: scrollOffset) { newValue in
                            // スクロールがボトムに到達したか確認
                            if contentHeight - scrollViewHeight - scrollOffset <= 10 {
                                viewModel.onScrollToEnd()
                            }
                        }
                }
            )
            .coordinateSpace(name: "scroll")
            .onPreferenceChange(OffsetPreferenceKey.self) { value in
                // ScrollViewの現在のスクロール位置を取得
                scrollOffset = value
            }
        }
        .overlay {
            if viewModel.isLoading {
                ProgressView()
            }
        }
        .overlay {
            if viewModel.showReloadButton {
                ReloadButton {
                    viewModel.onTapReloadButton()
                }
            }
        }
    }
}

// ScrollViewのオフセットを追跡するためのPreferenceKey
struct OffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0.0
    
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}
```

### 追加のポイント
1. `GeometryReader`を使って、`ScrollView`のコンテンツ全体の高さと表示される範囲の高さ（スクロール可能範囲）を取得します。
2. `onChange(of: scrollOffset)`で、`ScrollView`のスクロール位置が変わるたびにスクロール位置を確認し、ボトムに達したかどうかを判定します。
3. `OffsetPreferenceKey`を使って、スクロールオフセットを追跡します。

この方法では、スクロール位置を正確に追跡し、ボトムに到達したときに`viewModel.onScrollToEnd()`を確実に呼び出せるようになります。

---
