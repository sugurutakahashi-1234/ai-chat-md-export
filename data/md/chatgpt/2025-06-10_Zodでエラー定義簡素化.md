# Zodでエラー定義簡素化

日付: 2025-06-10

---

## 👤 ユーザー
*2025/6/10 10:26:51*

isolatedDeclarations: true によってErrorDefinitionsがこのような重複した定義になってしまっている。
zodを使うと同じような記述isolatedDeclarations: true でもより簡素に書けるか？
簡素といっても、型の記述の重複ぐらいであれば許容できます。
今は"データが見つかりません。"などのリテラルレベルで一致していることを記述しております。

提案するコードの変数宣言や関数の返りについて必ず型を指定してください。
これは必ず行なってください。

export enum ApiErrorType {
  // システムエラー
  Unknown = "Unknown",
  InternalServerError = "InternalServerError",

  // 認証・認可
  Unauthorized = "Unauthorized",
  Forbidden = "Forbidden",

  // バリデーション
  ValidationError = "ValidationError",
  BadRequest = "BadRequest",

  // リソース
  NotFound = "NotFound",
  Conflict = "Conflict",

  // 具体的なビジネスエラー
  UserNotFound = "UserNotFound",
  EmailAlreadyExists = "EmailAlreadyExists",

  // 複数パラメータのテスト用
  InvalidAgeRange = "InvalidAgeRange",
}


/\*\*
 \* エラー定義をas constで定義
 \* 各エラータイプに対して、メッセージ、ステータスコード、必要なパラメータを定義
 \*/
export const ErrorDefinitions: {
  // システムエラー
  readonly Unknown: {
    readonly message: "予期しないエラーが発生しました。";
    readonly statusCode: 500;
    readonly params: Record&lt;string, never&gt;;
  };
  readonly InternalServerError: {
    readonly message: "サーバー内部エラーが発生しました。";
    readonly statusCode: 500;
    readonly params: Record&lt;string, never&gt;;
  };
  // 認証・認可
  readonly Unauthorized: {
    readonly message: "認証が必要です。";
    readonly statusCode: 401;
    readonly params: Record&lt;string, never&gt;;
  };
  readonly Forbidden: {
    readonly message: "アクセス権限がありません。";
    readonly statusCode: 403;
    readonly params: Record&lt;string, never&gt;;
  };
  // バリデーション
  readonly ValidationError: {
    readonly message: "入力値の検証エラーが発生しました。";
    readonly statusCode: 400;
    readonly params: Record&lt;string, never&gt;;
  };
  readonly BadRequest: {
    readonly message: "データの形式が正しくありません。";
    readonly statusCode: 400;
    readonly params: Record&lt;string, never&gt;;
  };
  // リソース
  readonly NotFound: {
    readonly message: "データが見つかりません。";
    readonly statusCode: 404;
    readonly params: Record&lt;string, never&gt;;
  };
  readonly Conflict: {
    readonly message: "既に存在するデータです。";
    readonly statusCode: 409;
    readonly params: Record&lt;string, never&gt;;
  };
  // 具体的なビジネスエラー
  readonly UserNotFound: {
    readonly message: "ユーザーが見つかりません。";
    readonly statusCode: 404;
    readonly params: Record&lt;string, never&gt;;
  };
  readonly EmailAlreadyExists: {
    readonly message: "{email} は既に使用されています。";
    readonly statusCode: 409;
    readonly params: { email: string };
  };
  // 複数パラメータのテスト用
  readonly InvalidAgeRange: {
    readonly message: "年齢は{minAge}歳から{maxAge}歳の間で入力してください。";
    readonly statusCode: 400;
    readonly params: { minAge: string; maxAge: string };
  };
} = {
  // システムエラー
  \[ApiErrorType.Unknown\]: {
    message: "予期しないエラーが発生しました。",
    statusCode: 500,
    params: {} as Record&lt;string, never&gt;,
  },
  \[ApiErrorType.InternalServerError\]: {
    message: "サーバー内部エラーが発生しました。",
    statusCode: 500,
    params: {} as Record&lt;string, never&gt;,
  },

  // 認証・認可
  \[ApiErrorType.Unauthorized\]: {
    message: "認証が必要です。",
    statusCode: 401,
    params: {} as Record&lt;string, never&gt;,
  },
  \[ApiErrorType.Forbidden\]: {
    message: "アクセス権限がありません。",
    statusCode: 403,
    params: {} as Record&lt;string, never&gt;,
  },

  // バリデーション
  \[ApiErrorType.ValidationError\]: {
    message: "入力値の検証エラーが発生しました。",
    statusCode: 400,
    params: {} as Record&lt;string, never&gt;,
  },
  \[ApiErrorType.BadRequest\]: {
    message: "データの形式が正しくありません。",
    statusCode: 400,
    params: {} as Record&lt;string, never&gt;,
  },

  // リソース
  \[ApiErrorType.NotFound\]: {
    message: "データが見つかりません。",
    statusCode: 404,
    params: {} as Record&lt;string, never&gt;,
  },
  \[ApiErrorType.Conflict\]: {
    message: "既に存在するデータです。",
    statusCode: 409,
    params: {} as Record&lt;string, never&gt;,
  },

  // 具体的なビジネスエラー
  \[ApiErrorType.UserNotFound\]: {
    message: "ユーザーが見つかりません。",
    statusCode: 404,
    params: {} as Record&lt;string, never&gt;,
  },
  \[ApiErrorType.EmailAlreadyExists\]: {
    message: "{email} は既に使用されています。",
    statusCode: 409,
    params: {} as { email: string },
  },

  // 複数パラメータのテスト用
  \[ApiErrorType.InvalidAgeRange\]: {
    message: "年齢は{minAge}歳から{maxAge}歳の間で入力してください。",
    statusCode: 400,
    params: {} as { minAge: string; maxAge: string },
  },
} as const satisfies Record&lt;
  ApiErrorType,
  {
    message: string;
    statusCode: number;
    params: Record&lt;string, string&gt;;
  }
&gt;;

---

## 🤖 アシスタント
*2025/6/10 10:26:53*

以下は **`isolatedDeclarations: true`** でも *d.ts 生成時に重複が発生せず*、  
かつ **Zod でパラメータ形を型安全に検証できる** 最小限の実装例です。  
2 つのオブジェクトを分離し、**テンプレート（メッセージ＋HTTP ステータス）** と **パラメータスキーマ** を別々に管理します。

```ts
// errors.ts ---------------------------------------------------------------
import { z, ZodTypeAny } from "zod";

/* ---------- 1. エラー種別 ------------------------------------------------ */
export enum ApiErrorType {
  // システム
  Unknown             = "Unknown",
  InternalServerError = "InternalServerError",

  // 認証・認可
  Unauthorized = "Unauthorized",
  Forbidden    = "Forbidden",

  // バリデーション
  ValidationError = "ValidationError",
  BadRequest      = "BadRequest",

  // リソース
  NotFound = "NotFound",
  Conflict = "Conflict",

  // ビジネス
  UserNotFound        = "UserNotFound",
  EmailAlreadyExists  = "EmailAlreadyExists",
  InvalidAgeRange     = "InvalidAgeRange",
}

/* ---------- 2. メッセージ & HTTP ステータス ----------------------------- */
/** 型注釈を明示して isolatedDeclarations に対応 */
export const errorMetaMap: Readonly<Record<ApiErrorType, { message: string; statusCode: number }>> = {
  // システム
  [ApiErrorType.Unknown]            : { message: "予期しないエラーが発生しました。",              statusCode: 500 },
  [ApiErrorType.InternalServerError]: { message: "サーバー内部エラーが発生しました。",            statusCode: 500 },

  // 認証・認可
  [ApiErrorType.Unauthorized]: { message: "認証が必要です。",             statusCode: 401 },
  [ApiErrorType.Forbidden]   : { message: "アクセス権限がありません。",     statusCode: 403 },

  // バリデーション
  [ApiErrorType.ValidationError]: { message: "入力値の検証エラーが発生しました。", statusCode: 400 },
  [ApiErrorType.BadRequest]      : { message: "データの形式が正しくありません。",   statusCode: 400 },

  // リソース
  [ApiErrorType.NotFound] : { message: "データが見つかりません。",           statusCode: 404 },
  [ApiErrorType.Conflict] : { message: "既に存在するデータです。",           statusCode: 409 },

  // ビジネス
  [ApiErrorType.UserNotFound]       : { message: "ユーザーが見つかりません。",                         statusCode: 404 },
  [ApiErrorType.EmailAlreadyExists] : { message: "{email} は既に使用されています。",                  statusCode: 409 },
  [ApiErrorType.InvalidAgeRange]    : { message: "年齢は{minAge}歳から{maxAge}歳の間で入力してください。", statusCode: 400 },
};

/* ---------- 3. パラメータスキーマ --------------------------------------- */
export const errorParamSchemaMap: Readonly<Record<ApiErrorType, ZodTypeAny>> = {
  // システム
  [ApiErrorType.Unknown]            : z.never(),
  [ApiErrorType.InternalServerError]: z.never(),

  // 認証・認可
  [ApiErrorType.Unauthorized]: z.never(),
  [ApiErrorType.Forbidden]   : z.never(),

  // バリデーション
  [ApiErrorType.ValidationError]: z.never(),
  [ApiErrorType.BadRequest]      : z.never(),

  // リソース
  [ApiErrorType.NotFound] : z.never(),
  [ApiErrorType.Conflict] : z.never(),

  // ビジネス
  [ApiErrorType.UserNotFound]      : z.never(),
  [ApiErrorType.EmailAlreadyExists]: z.object({ email: z.string() }),
  [ApiErrorType.InvalidAgeRange]   : z.object({ minAge: z.string(), maxAge: z.string() }),
} as const;

/* ---------- 4. 型付け済み定義ユーティリティ ----------------------------- */
export type ErrorParams<T extends ApiErrorType> = z.infer<(typeof errorParamSchemaMap)[T]>;

export interface ErrorDefinition<T extends ApiErrorType> {
  readonly type: T;
  readonly message: (typeof errorMetaMap)[T]["message"];
  readonly statusCode: (typeof errorMetaMap)[T]["statusCode"];
  readonly params: ErrorParams<T>;
}

/**
 * 型安全にエラーオブジェクトを生成するファクトリ関数
 * @param type   エラー種別
 * @param params パラメータ (不要な場合は `undefined` を渡す)
 */
export function createError<T extends ApiErrorType>(
  type: T,
  params: ErrorParams<T> extends never ? undefined : ErrorParams<T>,
): ErrorDefinition<T> {
  // 実行時も Zod で検証しておく
  const schema = errorParamSchemaMap[type];
  // @ts-expect-error — `never` の場合はランタイム検証不要
  if (schema !== z.never()) schema.parse(params);

  return {
    type,
    message: errorMetaMap[type].message,
    statusCode: errorMetaMap[type].statusCode,
    // 省略時は {} に整形
    params: (params ?? ({} as ErrorParams<T>)) as ErrorParams<T>,
  };
}
```

---

## 使い方サンプル

```ts
// sample.ts ---------------------------------------------------------------
import { ApiErrorType, createError } from "./errors";

// ✔︎ 必要パラメータあり：コンパイルも実行も OK
const err1 = createError(ApiErrorType.EmailAlreadyExists, { email: "foo@example.com" });

// ✔︎ パラメータ不要のエラー：第二引数は `undefined`
const err2 = createError(ApiErrorType.NotFound, undefined);

// ❌ 型不一致：コンパイルエラー
// const err3 = createError(ApiErrorType.EmailAlreadyExists, { mail: "ng@example.com" });

// ❌ 不要なパラメータ：コンパイルエラー
// const err4 = createError(ApiErrorType.NotFound, { anything: "ng" });
```

---

### この構成のポイント

1. **重複を最小化**  
   - メッセージとステータスは `errorMetaMap` に 1 回だけ記述。  
   - パラメータ形は `errorParamSchemaMap` に 1 回だけ記述。  
   - `isolatedDeclarations` でも各オブジェクトに明示的な型注釈を付けているため、  
     `.d.ts` 生成時に“型が推論できない”という警告が出ません。

2. **Zod でランタイム検証 + 型安全**  
   - `createError` 内で Zod の `parse()` を実行し、開発・テスト環境ではパラメータ不一致を早期発見。  
   - 呼び出し側は `ErrorParams<T>` によりコンパイル時にもチェックされます。

3. **リテラルレベルの厳密一致**  
   - メッセージ文字列は `errorMetaMap` の値として保持しているため、  
     例示いただいた「"データが見つかりません。"」レベルでの一致も担保できます。

4. **拡張も簡単**  
   - 新しいエラー種を追加する場合は  
     1. `ApiErrorType` に列挙子を追加  
     2. `errorMetaMap` と `errorParamSchemaMap` に対応するエントリを 1 行ずつ追加  
     で完了します。  

これで **コードの見通しを損なわずに重複を削減しつつ、`isolatedDeclarations: true` と型安全性を両立** できます。

---

## 👤 ユーザー
*2025/6/10 10:36:58*

この形がダメだった
createError(ApiErrorType.Unknown, undefined); 


createError(ApiErrorType.Unknown); // 2 個の引数が必要ですが、1 個指定されました。ts(2554) api-error-type.ts(350, 3): 'params' の引数が指定されていません。
createError(ApiErrorType.Unknown, undefined); // 型 'undefined' の引数を型 'Record&lt;string, never&gt;' のパラメーターに割り当てることはできません。ts(2345)
createError(ApiErrorType.EmailAlreadyExists, { // OK
  email: "test@example.com",
});
createError(ApiErrorType.InvalidAgeRange, { // OK
  minAge: "18",
  maxAge: "65",
});

---

## 🤖 アシスタント
*2025/6/10 10:37:00*

`Unknown` など **パラメータ不要のエラー** と  
`EmailAlreadyExists` のように **必須パラメータがあるエラー** を  
完全に型レベルで分けて扱えるよう、`createError` を **オーバーロード** で定義し直します。  

> **ポイント**  
> 1. **パラメータ不要／必須を静的に分類**し、各々に別シグネチャを与える  
> 2. 実装シグネチャは共通 (`params?: unknown`) とし、内部で Zod 検証  
> 3. 呼び出し側では「不要なら 2 引数目を省略」「必要なら必ず渡す」ことを TypeScript が強制

---

### 1️⃣ 追加のユーティリティ型

```ts
// errors.ts（前半は前回と同じ。省略） ------------------------------------
type ErrorParams<T extends ApiErrorType> =
  z.infer<(typeof errorParamSchemaMap)[T]>;

// パラメータを要求するエラー種別としない種別を抽出
type ErrorTypeWithParams = {
  [K in ApiErrorType]: ErrorParams<K> extends never ? never : K;
}[ApiErrorType];

type ErrorTypeWithoutParams = Exclude<ApiErrorType, ErrorTypeWithParams>;
```

---

### 2️⃣ `createError` のオーバーロード実装

```ts
/* ---------- 4. エラー生成ファクトリ ------------------------------------ */
/**
 * パラメータ不要のエラー
 */
export function createError<T extends ErrorTypeWithoutParams>(
  type: T,
): ErrorDefinition<T>;

/**
 * パラメータ必須のエラー
 */
export function createError<T extends ErrorTypeWithParams>(
  type: T,
  params: ErrorParams<T>,
): ErrorDefinition<T>;

/* 実装シグネチャ ― 上記 2 つのどちらかにマッチさせる */
export function createError(
  type: ApiErrorType,
  params?: unknown,
): ErrorDefinition<ApiErrorType> {
  const schema = errorParamSchemaMap[type];

  // never 以外はランタイム検証
  if (schema !== z.never()) {
    (schema as z.ZodTypeAny).parse(params);
  } else {
    // パラメータ不要なのに渡された場合は開発時に気づけるようにする
    if (params !== undefined) {
      throw new Error(`Error ${type} does not take parameters`);
    }
  }

  return {
    type,
    message: errorMetaMap[type].message,
    statusCode: errorMetaMap[type].statusCode,
    // params は存在しない場合でも空オブジェクトで統一
    params: (params ?? {}) as never,
  };
}
```

---

## ✅ 動作確認

```ts
// sample.ts ---------------------------------------------------------------
import { ApiErrorType, createError } from "./errors";

// --- パラメータ不要 ----------------------
const e1 = createError(ApiErrorType.Unknown);          // ✔︎ OK
// const e1x = createError(ApiErrorType.Unknown, {});  // ❌ エラー: params を受け付けない

// --- パラメータ必須 ----------------------
const e2 = createError(ApiErrorType.EmailAlreadyExists, {
  email: "foo@example.com",
}); // ✔︎ OK

// const e2x = createError(ApiErrorType.EmailAlreadyExists);          // ❌ エラー: params 必須
// const e2y = createError(ApiErrorType.EmailAlreadyExists, {});      // ❌ エラー: email が不足
// const e2z = createError(ApiErrorType.EmailAlreadyExists, { mail: "ng" }); // ❌ エラー: プロパティ名
```

---

### これで解決できること

| 課題 | 解決ポイント |
|------|--------------|
| **「undefined」を渡すと型不一致** | オーバーロードで “不要なら引数自体を不要” に変更 |
| **`2 個の引数が必要…` エラー** | `ErrorTypeWithoutParams` 用シグネチャで 1 引数を許可 |
| **誤ったパラメータを渡しても通る** | Zod の `parse()` によりランタイム検証も継続 |

---

> **拡張手順**  
> 新しいエラーを追加するときは前回同様 **3 か所**（`enum`／`errorMetaMap`／`errorParamSchemaMap`）を 1 行ずつ追記するだけで、オーバーロードの仕組みは自動的に追従します。

---

## 👤 ユーザー
*2025/6/10 10:44:15*

以下について、minAgeとmaxAgeなどIntにできるか？


/\* ---------- 2. メッセージ & HTTP ステータス ----------------------------- \*/
/\*\* 型注釈を明示して isolatedDeclarations に対応 \*/
export const errorMetaMap: Readonly&lt;
  Record&lt;ApiErrorType, { message: string; statusCode: number }&gt;
&gt; = {
  // システム
  \[ApiErrorType.Unknown\]: {
    message: "予期しないエラーが発生しました。",
    statusCode: 500,
  },
  \[ApiErrorType.InternalServerError\]: {
    message: "サーバー内部エラーが発生しました。",
    statusCode: 500,
  },

  // 認証・認可
  \[ApiErrorType.Unauthorized\]: { message: "認証が必要です。", statusCode: 401 },
  \[ApiErrorType.Forbidden\]: {
    message: "アクセス権限がありません。",
    statusCode: 403,
  },

  // バリデーション
  \[ApiErrorType.ValidationError\]: {
    message: "入力値の検証エラーが発生しました。",
    statusCode: 400,
  },
  \[ApiErrorType.BadRequest\]: {
    message: "データの形式が正しくありません。",
    statusCode: 400,
  },

  // リソース
  \[ApiErrorType.NotFound\]: {
    message: "データが見つかりません。",
    statusCode: 404,
  },
  \[ApiErrorType.Conflict\]: {
    message: "既に存在するデータです。",
    statusCode: 409,
  },

  // ビジネス
  \[ApiErrorType.UserNotFound\]: {
    message: "ユーザーが見つかりません。",
    statusCode: 404,
  },
  \[ApiErrorType.EmailAlreadyExists\]: {
    message: "{email} は既に使用されています。",
    statusCode: 409,
  },
  \[ApiErrorType.InvalidAgeRange\]: {
    message: "年齢は{minAge}歳から{maxAge}歳の間で入力してください。",
    statusCode: 400,
  },
};

/\* ---------- 3. パラメータスキーマ --------------------------------------- \*/
export const errorParamSchemaMap: Readonly&lt;Record&lt;ApiErrorType, ZodTypeAny&gt;&gt; = {
  // システム
  \[ApiErrorType.Unknown\]: z.never(),
  \[ApiErrorType.InternalServerError\]: z.never(),

  // 認証・認可
  \[ApiErrorType.Unauthorized\]: z.never(),
  \[ApiErrorType.Forbidden\]: z.never(),

  // バリデーション
  \[ApiErrorType.ValidationError\]: z.never(),
  \[ApiErrorType.BadRequest\]: z.never(),

  // リソース
  \[ApiErrorType.NotFound\]: z.never(),
  \[ApiErrorType.Conflict\]: z.never(),

  // ビジネス
  \[ApiErrorType.UserNotFound\]: z.never(),
  \[ApiErrorType.EmailAlreadyExists\]: z.object({ email: z.string() }),
  \[ApiErrorType.InvalidAgeRange\]: z.object({
    minAge: z.string(),
    maxAge: z.string(),
  }),
} as const;

/\* ---------- 4. 型付け済み定義ユーティリティ ----------------------------- \*/
// errors.ts（前半は前回と同じ。省略） ------------------------------------
type MessageErrorParams&lt;T extends ApiErrorType&gt; = z.infer&lt;
  (typeof errorParamSchemaMap)\[T\]
&gt;;

// パラメータを要求するエラー種別としない種別を抽出
type ErrorTypeWithParams = {
  \[K in ApiErrorType\]: MessageErrorParams&lt;K&gt; extends never ? never : K;
}\[ApiErrorType\];

type ErrorTypeWithoutParams = Exclude&lt;ApiErrorType, ErrorTypeWithParams&gt;;

export interface ErrorDefinition&lt;T extends ApiErrorType&gt; {
  readonly type: T;
  readonly message: (typeof errorMetaMap)\[T\]\["message"\];
  readonly statusCode: (typeof errorMetaMap)\[T\]\["statusCode"\];
  readonly params: ErrorParams&lt;T&gt;;
}

/\*\*
 \* パラメータ不要のエラー
 \*/
export function createError&lt;T extends ErrorTypeWithoutParams&gt;(
  type: T,
): ErrorDefinition&lt;T&gt;;

/\*\*
 \* パラメータ必須のエラー
 \*/
export function createError&lt;T extends ErrorTypeWithParams&gt;(
  type: T,
  params: ErrorParams&lt;T&gt;,
): ErrorDefinition&lt;T&gt;;

/\* 実装シグネチャ ― 上記 2 つのどちらかにマッチさせる \*/
export function createError(
  type: ApiErrorType,
  params?: unknown,
): ErrorDefinition&lt;ApiErrorType&gt; {
  const schema = errorParamSchemaMap\[type\];

  // never 以外はランタイム検証
  if (schema !== z.never()) {
    (schema as z.ZodTypeAny).parse(params);
  } else {
    // パラメータ不要なのに渡された場合は開発時に気づけるようにする
    if (params !== undefined) {
      throw new Error(`Error ${type} does not take parameters`);
    }
  }

  return {
    type,
    message: errorMetaMap\[type\].message,
    statusCode: errorMetaMap\[type\].statusCode,
    // params は存在しない場合でも空オブジェクトで統一
    params: (params ?? {}) as never,
  };
}

createError(ApiErrorType.Unknown, {}); // 型 'undefined' の引数を型 'Record&lt;string, never&gt;' のパラメーターに割り当てることはできません。ts(2345)
createError(ApiErrorType.EmailAlreadyExists, {
  email: "test@example.com",
});
createError(ApiErrorType.InvalidAgeRange, {
  minAge: "18",
  maxAge: "65",
});

---

## 🤖 アシスタント
*2025/6/10 10:44:16*

はい、`minAge` と `maxAge` を **整数 (int)** 扱いにできます。  
ポイントは **Zod 側を `z.number().int()` に変更**するだけで、  
呼び出し側では `number` 型として扱えます。

---

## 変更点（抜粋）

```ts
/* ---------- 3. パラメータスキーマ --------------------------------------- */
export const errorParamSchemaMap: Readonly<Record<ApiErrorType, ZodTypeAny>> = {
  // …省略…

  // ビジネス
  [ApiErrorType.UserNotFound]: z.never(),
  [ApiErrorType.EmailAlreadyExists]: z.object({
    email: z.string(),
  }),
  [ApiErrorType.InvalidAgeRange]: z.object({
    /** 整数のみ許可 */
    minAge: z.number().int(),
    maxAge: z.number().int(),
  }),
} as const;

/* ---------- 4. 型付けユーティリティ (抜粋) ------------------------------ */
type ErrorParams<T extends ApiErrorType> = z.infer<
  (typeof errorParamSchemaMap)[T]
>;
```

> **補足**  
> - `z.number().int()` で **小数・NaN・Infinity を自動で弾く** ため、  
>   ランタイム検証でも整数しか通りません。  
> - TypeScript の型は `number` ですが、「整数かどうか」の保証は Zod が行います。  

---

## 使い方サンプル（コンパイル確認）

```ts
import { ApiErrorType, createError } from "./errors";

/* -------- パラメータ不要 ------------------------- */
const e0 = createError(ApiErrorType.Unknown); // ✔︎ OK
// createError(ApiErrorType.Unknown, {});     // ❌ コンパイルエラー（params は不要）

/* -------- EmailAlreadyExists -------------------- */
const e1 = createError(ApiErrorType.EmailAlreadyExists, {
  email: "foo@example.com",
}); // ✔︎ OK

/* -------- InvalidAgeRange (整数) ---------------- */
// ✔︎ number 型であれば OK（小数は実行時に Zod が弾く）
const e2 = createError(ApiErrorType.InvalidAgeRange, {
  minAge: 18,
  maxAge: 65,
});

// const e2x = createError(ApiErrorType.InvalidAgeRange, {
//   minAge: "18",            // ❌ コンパイルエラー（string → number）
//   maxAge: "65",
// });
```

---

### まとめ

* `z.number().int()` に変更するだけで **整数必須** を型・ランタイム両面で保証。  
* 既存の `createError` などはそのまま動きます。  
* これ以外の型／実装部分に変更は不要です。

---

## 👤 ユーザー
*2025/6/10 10:52:23*

エラーになった
// 型 'number' を型 'string' に割り当てることはできません。ts(2322)
// api-error-type.ts(101, 24): 予期された型は、型 '{ minAge: string; maxAge: string; }' に対してここで宣言されたプロパティ 'minAge' から取得されています
// api-error-type.ts(373, 17): 呼び出しはこの実装に対して成功した可能性がありますが、オーバーロードの実装シグネチャは外部からは参照できません。
// (property) minAge: string
createError(ApiErrorType.InvalidAgeRange, {
  minAge: 18,
  maxAge: 65,
});

/\* ---------- 2. メッセージ & HTTP ステータス ----------------------------- \*/
/\*\* 型注釈を明示して isolatedDeclarations に対応 \*/
export const errorMetaMap: Readonly&lt;
  Record&lt;ApiErrorType, { message: string; statusCode: number }&gt;
&gt; = {
  // システム
  \[ApiErrorType.Unknown\]: {
    message: "予期しないエラーが発生しました。",
    statusCode: 500,
  },
  \[ApiErrorType.InternalServerError\]: {
    message: "サーバー内部エラーが発生しました。",
    statusCode: 500,
  },

  // 認証・認可
  \[ApiErrorType.Unauthorized\]: { message: "認証が必要です。", statusCode: 401 },
  \[ApiErrorType.Forbidden\]: {
    message: "アクセス権限がありません。",
    statusCode: 403,
  },

  // バリデーション
  \[ApiErrorType.ValidationError\]: {
    message: "入力値の検証エラーが発生しました。",
    statusCode: 400,
  },
  \[ApiErrorType.BadRequest\]: {
    message: "データの形式が正しくありません。",
    statusCode: 400,
  },

  // リソース
  \[ApiErrorType.NotFound\]: {
    message: "データが見つかりません。",
    statusCode: 404,
  },
  \[ApiErrorType.Conflict\]: {
    message: "既に存在するデータです。",
    statusCode: 409,
  },

  // ビジネス
  \[ApiErrorType.UserNotFound\]: {
    message: "ユーザーが見つかりません。",
    statusCode: 404,
  },
  \[ApiErrorType.EmailAlreadyExists\]: {
    message: "{email} は既に使用されています。",
    statusCode: 409,
  },
  \[ApiErrorType.InvalidAgeRange\]: {
    message: "年齢は{minAge}歳から{maxAge}歳の間で入力してください。",
    statusCode: 400,
  },
};

/\* ---------- 3. パラメータスキーマ --------------------------------------- \*/
export const errorParamSchemaMap: Readonly&lt;Record&lt;ApiErrorType, ZodTypeAny&gt;&gt; = {
  // システム
  \[ApiErrorType.Unknown\]: z.never(),
  \[ApiErrorType.InternalServerError\]: z.never(),

  // 認証・認可
  \[ApiErrorType.Unauthorized\]: z.never(),
  \[ApiErrorType.Forbidden\]: z.never(),

  // バリデーション
  \[ApiErrorType.ValidationError\]: z.never(),
  \[ApiErrorType.BadRequest\]: z.never(),

  // リソース
  \[ApiErrorType.NotFound\]: z.never(),
  \[ApiErrorType.Conflict\]: z.never(),

  // ビジネス
  \[ApiErrorType.UserNotFound\]: z.never(),
  \[ApiErrorType.EmailAlreadyExists\]: z.object({ email: z.string() }),
  \[ApiErrorType.InvalidAgeRange\]: z.object({
    minAge: z.number().int(),
    maxAge: z.number().int(),
  }),
} as const;

/\* ---------- 4. 型付け済み定義ユーティリティ ----------------------------- \*/
// errors.ts（前半は前回と同じ。省略） ------------------------------------
type MessageErrorParams&lt;T extends ApiErrorType&gt; = z.infer&lt;
  (typeof errorParamSchemaMap)\[T\]
&gt;;

// パラメータを要求するエラー種別としない種別を抽出
type ErrorTypeWithParams = {
  \[K in ApiErrorType\]: MessageErrorParams&lt;K&gt; extends never ? never : K;
}\[ApiErrorType\];

type ErrorTypeWithoutParams = Exclude&lt;ApiErrorType, ErrorTypeWithParams&gt;;

export interface ErrorDefinition&lt;T extends ApiErrorType&gt; {
  readonly type: T;
  readonly message: (typeof errorMetaMap)\[T\]\["message"\];
  readonly statusCode: (typeof errorMetaMap)\[T\]\["statusCode"\];
  readonly params: ErrorParams&lt;T&gt;;
}

/\*\*
 \* パラメータ不要のエラー
 \*/
export function createError&lt;T extends ErrorTypeWithoutParams&gt;(
  type: T,
): ErrorDefinition&lt;T&gt;;

/\*\*
 \* パラメータ必須のエラー
 \*/
export function createError&lt;T extends ErrorTypeWithParams&gt;(
  type: T,
  params: ErrorParams&lt;T&gt;,
): ErrorDefinition&lt;T&gt;;

/\* 実装シグネチャ ― 上記 2 つのどちらかにマッチさせる \*/
export function createError(
  type: ApiErrorType,
  params?: unknown,
): ErrorDefinition&lt;ApiErrorType&gt; {
  const schema = errorParamSchemaMap\[type\];

  // never 以外はランタイム検証
  if (schema !== z.never()) {
    (schema as z.ZodTypeAny).parse(params);
  } else {
    // パラメータ不要なのに渡された場合は開発時に気づけるようにする
    if (params !== undefined) {
      throw new Error(`Error ${type} does not take parameters`);
    }
  }

  return {
    type,
    message: errorMetaMap\[type\].message,
    statusCode: errorMetaMap\[type\].statusCode,
    // params は存在しない場合でも空オブジェクトで統一
    params: (params ?? {}) as never,
  };
}

---

## 🤖 アシスタント
*2025/6/10 10:52:23*

`minAge` / `maxAge` を `number` にしたのにまだ **“string を期待”** と言われる原因は、  
`errorParamSchemaMap` に **一律 `: Record<… , ZodTypeAny>` という静的型を付けてしまい、  
各プロパティごとの Zod スキーマ型情報が失われている** ためです。

> **解決策** – `as const satisfies …` を使って  
> *「全体として Record<ApiErrorType, ZodTypeAny> を満たす」* ことだけ保証し、  
> 各キーの型は **実際の Zod スキーマ型** を保持させます。

---

## 修正版

```ts
/* ---------- 3. パラメータスキーマ --------------------------------------- */
export const errorParamSchemaMap = {
  // システム
  [ApiErrorType.Unknown]: z.never(),
  [ApiErrorType.InternalServerError]: z.never(),

  // 認証・認可
  [ApiErrorType.Unauthorized]: z.never(),
  [ApiErrorType.Forbidden]: z.never(),

  // バリデーション
  [ApiErrorType.ValidationError]: z.never(),
  [ApiErrorType.BadRequest]: z.never(),

  // リソース
  [ApiErrorType.NotFound]: z.never(),
  [ApiErrorType.Conflict]: z.never(),

  // ビジネス
  [ApiErrorType.UserNotFound]: z.never(),
  [ApiErrorType.EmailAlreadyExists]: z.object({
    email: z.string(),
  }),
  [ApiErrorType.InvalidAgeRange]: z.object({
    /** 整数のみ許可 */
    minAge: z.number().int(),
    maxAge: z.number().int(),
  }),
} as const satisfies Record<ApiErrorType, ZodTypeAny>;
```

### 型エイリアスも 1 行で OK

```ts
type ErrorParams<T extends ApiErrorType> =
  z.infer<(typeof errorParamSchemaMap)[T]>;
```

> これで `InvalidAgeRange` の `ErrorParams` は  
> ```ts
> { minAge: number; maxAge: number }
> ```  
> と推論されます。

---

## 動作確認

```ts
/* ✔︎ 整数を渡せる */
createError(ApiErrorType.InvalidAgeRange, { minAge: 18, maxAge: 65 });

/* ✔︎ 2 引数目は不要エラーなので省略 */
createError(ApiErrorType.Unknown);

/* ❌ パラメータの型違い（string を渡すとエラー） */
// createError(ApiErrorType.InvalidAgeRange, { minAge: "18", maxAge: "65" });

/* ❌ 不要エラーに params を渡すとエラー */
// createError(ApiErrorType.Unknown, {});
```

### 補足

* **`as const satisfies`** TS 4.9+ の構文で  
  * **`as const`** と同じく “各プロパティを読み取り専用・リテラル化”  
  * なおかつ右側型 (`Record<…>`) を **満たすかどうかだけ** をチェック  
  * プロパティ自身の詳しい型は失われず保持されます  
* `isolatedDeclarations: true` でも `.d.ts` に完全な型情報が出力され、  
  **重複定義エラーは発生しません**。  

この修正で `minAge` / `maxAge` を `number` として安全に扱えます。

---

## 👤 ユーザー
*2025/6/10 10:56:55*

isolatedDeclarations: trueがうまく解決しなかった。むしろ全部stringに指定してあげた方がむしろ親切か？

---

## 🤖 アシスタント
*2025/6/10 10:56:56*

### `isolatedDeclarations: true` が噛み合わない理由

`isolatedDeclarations` を有効にすると **「各 `export` に明示的で“ループしない”型注釈が必要」** になります。  
`as const satisfies …` は便利ですが、内部で “自己参照” を含む場合に  
「**型が発散している**」と判断され、`.d.ts` 出力時に警告やエラーが起きがちです。  
（特に **Zod スキーマ** のように巨大な構造体をリテラルで保持する場合）

> *もし型推論をそのまま .d.ts に落とし込みたいなら*  
> - `isolatedDeclarations` を **false** にする  
> - もしくは **各キーを個別の `export const ...`** に分割する  
>   （→ 発散せず、型注釈も短く済む）

---

## 「全部 `string`」に揃える案はアリ？

### ✔️ メリット

| 項目 | `string` で統一した場合 |
|------|------------------------|
| **型注釈の量** | すべて `Record<string, string>` 系で済むのでシンプル |
| **`.d.ts` 生成** | “自己参照のないリテラル” になるため `isolatedDeclarations` と相性がよい |
| **フロント実装** | フォーマット関数などで **`${minAge}`** と埋め込むだけで OK |
| **拡張性** | 新しいエラー追加時に「数値か文字列か」を迷わなくて済む |

### ❌ デメリット

| 項目 | 影響 |
|------|------|
| **バリデーション** | 実行時に “数値っぽい文字列” でもそのまま通る<br>（例: `"18.5"` や `"abc"`） |
| **IDE 補完** | `minAge: string` なので「本当に整数が欲しいのか？」が読み取れない |
| **後工程** | API 層や DB 層で結局 `parseInt()` / `Number()` が必要になる |

---

## 折衷案：**外向きは `string`、Zod で「整数変換＋検証」**

```ts
/* ---------- パラメータスキーマ (抜粋) ---------------------------------- */
[ApiErrorType.InvalidAgeRange]: z.object({
  minAge: z.coerce.number().int(),  // "18" → 18 に変換しつつ整数検証
  maxAge: z.coerce.number().int(),
}),
```

*呼び出し側は「`string` でも `number` でも」渡せる* ので  
IDE 補完はシンプル (`string`)、かつランタイムでは厳密に整数化&検証できます。

```ts
createError(ApiErrorType.InvalidAgeRange, {
  minAge: "18",      // OK
  maxAge: 65,        // OK
});
```

`.d.ts` には **`minAge: string | number`** のように出力されるため  
`isolatedDeclarations` 的にも安全です。

---

## まとめ ― どちらを選ぶ？

| ケース | 推奨型 |
|--------|-------|
| **型の厳密さ < 設定・生成の容易さ**<br>（スキーマ定義を最小化したい、`isolatedDeclarations` を“考えず”に通したい） | **すべて `string`** で揃える |
| **数値である保証が重要**<br>（後段でそのまま計算したい、誤入力を早期検知したい） | `number().int()` を維持し、<br>`isolatedDeclarations` は<br> - 無効化する<br> - もしくはエラー定義を分割 export する |
| **ほどほどの厳密さ＋簡潔さ** | `z.coerce.number().int()` で<br>外部入力は `string`、内部値は `number` |

もし **「エラー定義ファイルは可読性を最優先」** なら  
> *全部 `string` に寄せる → 必要な所だけ `parseInt()`*  

でも十分実践的です。  
逆に **「型安全が売りの SDK を配布したい」** 場合は  
> *Zod で厳密型＋ `isolatedDeclarations` は off*  

が無難です。

---

## 👤 ユーザー
*2025/6/10 10:59:41*

errorParamSchemaMapで、パラメーターは全部 z.string() で固定にできないか？

---

## 🤖 アシスタント
*2025/6/10 10:59:42*

はい、**「エラーパラメータはすべて文字列」** という運用に統一してしまえば  
`errorParamSchemaMap` は次のように簡素化できます。  
（`isolatedDeclarations: true` でも確実に型注釈が付くようにしています）

```ts
/* ---------- 3. パラメータスキーマ（すべて z.string()） ------------------ */
import { z, ZodTypeAny } from "zod";
import { ApiErrorType } from "./api-error-type";

/**
 * 文字列パラメータ 0 個 〜 N 個を許容するユーティリティ
 * - パラメータ不要のエラーは z.never()
 * - 必要なエラーは z.object({ ...string }) に統一
 */
export const errorParamSchemaMap = {
  // ----- パラメータ不要 --------------------------------
  [ApiErrorType.Unknown]: z.never(),
  [ApiErrorType.InternalServerError]: z.never(),

  [ApiErrorType.Unauthorized]: z.never(),
  [ApiErrorType.Forbidden]: z.never(),

  [ApiErrorType.ValidationError]: z.never(),
  [ApiErrorType.BadRequest]: z.never(),

  [ApiErrorType.NotFound]: z.never(),
  [ApiErrorType.Conflict]: z.never(),

  [ApiErrorType.UserNotFound]: z.never(),

  // ----- 文字列パラメータあり ----------------------------
  [ApiErrorType.EmailAlreadyExists]: z.object({
    email: z.string(),
  }),

  [ApiErrorType.InvalidAgeRange]: z.object({
    minAge: z.string(),   // ここも文字列に統一
    maxAge: z.string(),
  }),
} as const satisfies Record<ApiErrorType, ZodTypeAny>;

/* ---------- 型ユーティリティ（変更なしで利用可） ------------------------ */
export type ErrorParams<T extends ApiErrorType> =
  z.infer<(typeof errorParamSchemaMap)[T]>;
```

### 呼び出し例

```ts
// パラメータ不要
createError(ApiErrorType.Unknown);                 // OK

// 文字列パラメータ
createError(ApiErrorType.EmailAlreadyExists, {
  email: "foo@example.com",
});                                                // OK

createError(ApiErrorType.InvalidAgeRange, {
  minAge: "18",    // 数値は呼び出し側で toString() すればよい
  maxAge: "65",
});                                                // OK
```

---

## この方針のメリット / デメリット

| | 文字列に統一 |
|---|---|
| **◎ メリット** | * スキーマ定義がシンプル<br>* `isolatedDeclarations` 下でも型推論が発散しない<br>* 変換・検証ロジックを 1 箇所（使用側）に集約できる |
| **△ デメリット** | * 「整数であるか」の保証は呼び出し側に委ねる<br>* IDE 補完で型ヒントが “string” のみになる |

> **ポイント**  
> - **数値を扱う場面では `Number(minAge)` 等でキャスト** が必要になります。  
> - バリデーションを厳密に行いたい場合は、サービス層やフォーム層など **別レイヤー** で  
>   `z.string().regex(/^\d+$/)` や `z.coerce.number().int()` を追加する方法が現実的です。

---
