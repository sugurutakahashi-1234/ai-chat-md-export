# SwiftUIでプロトコルを使用した配列のレンダリング

日付: 2023-05-24

---

## 👤 ユーザー
*2023/5/24 12:03:52*

SwiftUI で protocol を適応した struct を 配列で持って、それを利用して、ForEach して Viewwo

---

## 🤖 アシスタント
*2023/5/24 12:04:29*

SwiftUIでプロトコルを適用した`struct`を配列で持ち、それを`ForEach`で処理してビューを生成する方法について説明します。以下に簡単な例を示します。

まず、適用するプロトコルを定義します：

```swift
protocol Item {
    var id: Int { get }
    var name: String { get }
}
```

次に、上記のプロトコルを適用した`struct`を作成します：

```swift
struct SampleItem: Item, Identifiable {
    var id: Int
    var name: String
}
```

`Identifiable`プロトコルも適用しています。これは、SwiftUIが`ForEach`を用いて配列をレンダリングする際に、どの要素がどの要素かを識別するために必要です。

次に、この`SampleItem`の配列を持つビューを作成します：

```swift
struct ContentView: View {
    var items: [SampleItem] = [
        SampleItem(id: 1, name: "Item 1"),
        SampleItem(id: 2, name: "Item 2"),
        SampleItem(id: 3, name: "Item 3")
    ]
    
    var body: some View {
        List {
            ForEach(items) { item in
                Text(item.name)
            }
        }
    }
}
```

この`ContentView`ビューでは、`ForEach`を使用して`items`配列内の各`SampleItem`をレンダリングしています。各アイテムは単純なテキストビューとして表示されます。

以上の方法で、プロトコルを適用した`struct`を配列で持ち、それを`ForEach`を利用してレンダリングすることが可能です。

---

## 👤 ユーザー
*2023/5/24 12:07:10*

Item プロトコルを持つ SampleItem であったり、Sample2Item のstruct を同じForEach させたい

---

## 🤖 アシスタント
*2023/5/24 12:08:06*

その場合、各`struct`が特定のプロトコルを満たしている場合、それらを同じ配列で保持し、同じ`ForEach`に対して処理することが可能です。

ただし、Swiftでは、異なる型の要素を持つ配列は作成できません。それぞれが`Item`プロトコルを満たしていても、`SampleItem`と`Sample2Item`は異なる型なので、同じ配列に保持することはできません。これを解決するためには、型消去（type erasure）を利用することができます。

以下に、これを実現するためのコードスニペットを示します。

```swift
protocol Item: Identifiable {
    var id: Int { get }
    var name: String { get }
}

struct AnyItem: Item {
    var id: Int
    var name: String
    private let box: Any

    init<I: Item>(_ item: I) {
        self.id = item.id
        self.name = item.name
        self.box = item
    }
}

struct SampleItem: Item {
    var id: Int
    var name: String
}

struct Sample2Item: Item {
    var id: Int
    var name: String
}

struct ContentView: View {
    var items: [AnyItem] = [
        AnyItem(SampleItem(id: 1, name: "SampleItem 1")),
        AnyItem(Sample2Item(id: 2, name: "Sample2Item 1")),
        AnyItem(SampleItem(id: 3, name: "SampleItem 2")),
        AnyItem(Sample2Item(id: 4, name: "Sample2Item 2"))
    ]
    
    var body: some View {
        List {
            ForEach(items) { item in
                Text(item.name)
            }
        }
    }
}
```

このコードでは、`AnyItem`という新しい`struct`を定義しています。これは`Item`プロトコルを満たす任意のオブジェクトを包装する役割を果たします。そして`items`配列は`AnyItem`の配列として定義され、`SampleItem`オブジェクトと`Sample2Item`オブジェクトの両方を含むことができます。これにより、`ForEach`は`Item`プロトコルを満たす`struct`の配列を処理することが可能になります。

この方法を用いることで、異なる型の要素を同じ配列に含め、その配列を`ForEach`で処理することができます。ただし、各`struct`が共有するプロパティとメソッドのみが利用可能であることに注意してください。

---

## 👤 ユーザー
*2023/5/24 12:08:07*

some を使えば型消去しなくても済むのでは？

---

## 🤖 アシスタント
*2023/5/24 12:08:47*

Swiftの`some`キーワードを使うと、確かに型を具体的に指定しなくても特定のプロトコルに適合するタイプを返すことができます。`some`は、Swiftのopaque result typeと呼ばれる機能を表現します。

しかしながら、SwiftUIの`View`のコンテキストで`some View`を使っても、それは返すビュータイプを非具体的にするだけで、異なるタイプの配列を同時に扱うことができるわけではありません。つまり、`some`キーワードは異なる型の配列を同時に扱う問題を解決するものではないため、ここでは適していないと思われます。

`ForEach`で異なる型の`struct`を扱いたい場合、基本的にはそれらの`struct`が適合する共通のプロトコルを作成し、そのプロトコルに適合するラッパー型（type erasure）を使用することで実現するのが一般的なアプローチです。

---

## 👤 ユーザー
*2023/5/24 12:09:27*

\[AnyItem\] ではなくて \[some Item\] とはできないの？

---

## 🤖 アシスタント
*2023/5/24 12:09:55*

SwiftUIで `some` キーワードを使うと、返すビューの型を非具体的にできますが、`some` を使った配列を作成することは現在のSwiftのバージョンではサポートされていません。つまり、 `\[some Item\]` のような配列は作成できません。

`some` キーワードは主に関数の戻り値として使用され、関数が特定のプロトコルに準拠する型を返すことを保証しますが、その具体的な型は関数の使用者には非公開となります。これはオペーク型（Opaque Types）と呼ばれる概念で、返される型が一貫性を保つことを保証します。

しかし、配列や他のコレクションの要素に `some` を使用することはできません。これは配列や他のコレクションがその要素について具体的な型情報を必要とするからです。したがって、 `\[some Item\]` のような表現は Swift の型システムには存在しないため、使用することはできません。

そのため、異なる型を含む配列を作成するには、先程説明したように型消去（type erasure）を使用する必要があります。

---
