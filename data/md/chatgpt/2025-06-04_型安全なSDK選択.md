# 型安全なSDK選択

日付: 2025-06-04

---

## 👤 ユーザー
*2025/6/4 20:41:53*

@hey-api/openapi-ts の@hey-api/client-fetch" のプラグインでコードをジェネレイトしている。
./openapi.yaml
そのコードのapiのコールのレスポンスの型定義についての意見がほしい。
より型安全なコードを生成するsdkがあればそちらを使いたい。

import { defineConfig } from "@hey-api/openapi-ts";

export default defineConfig({
  input: "./openapi.yaml",
  output: {
    path: "./src/generated",
    format: "biome",
    lint: false,
  },
  plugins: \[
    {
      name: "@hey-api/client-fetch",
      baseUrl: "http://localhost:3000",
    },
  \],
});

openapi: 3.1.0
info:
  title: MyApp API
  version: 1.0.0
  description: ユーザー管理API
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
          description: ユーザーID
          example: abc12345
        name:
          type: string
          description: ユーザー名
          example: 田中太郎
        email:
          type: string
          format: email
          description: メールアドレス
          example: tanaka@example.com
        createdAt:
          type: string
          description: 作成日時
          example: 2024-01-15 10:30:00
      required:
        - id
        - name
        - email
        - createdAt
    ErrorResponse:
      type: object
      properties:
        data:
          nullable: true
        status:
          type: string
          enum:
            - error
        message:
          type: string
          example: エラーが発生しました
      required:
        - data
        - status
        - message
    CreateUserRequest:
      type: object
      properties:
        name:
          type: string
          minLength: 1
          description: ユーザー名
          example: 田中太郎
        email:
          type: string
          format: email
          description: メールアドレス
          example: tanaka@example.com
      required:
        - name
        - email
  parameters: {}
paths:
  /api/users:
    get:
      summary: 全ユーザーを取得
      description: システムに登録されているすべてのユーザーを取得します
      responses:
        "200":
          description: ユーザー一覧
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: "#/components/schemas/User"
                  status:
                    type: string
                    enum:
                      - success
                      - error
                    example: success
                  message:
                    type: string
                    example: 操作が成功しました
                required:
                  - data
                  - status
    post:
      summary: 新規ユーザーを作成
      description: 新しいユーザーをシステムに登録します
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/CreateUserRequest"
      responses:
        "201":
          description: 作成されたユーザー
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: "#/components/schemas/User"
                  status:
                    type: string
                    enum:
                      - success
                      - error
                    example: success
                  message:
                    type: string
                    example: 操作が成功しました
                required:
                  - data
                  - status
        "400":
          description: 不正なリクエスト
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
  /api/users/{id}:
    get:
      summary: 特定のユーザーを取得
      description: 指定されたIDのユーザー情報を取得します
      parameters:
        - schema:
            type: string
            description: ユーザーID
            example: abc12345
          required: true
          name: id
          in: path
      responses:
        "200":
          description: ユーザー情報
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: "#/components/schemas/User"
                  status:
                    type: string
                    enum:
                      - success
                      - error
                    example: success
                  message:
                    type: string
                    example: 操作が成功しました
                required:
                  - data
                  - status
        "404":
          description: ユーザーが見つからない
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"

---

## 🤖 アシスタント
*2025/6/4 20:42:45*

以下では **@hey-api/openapi-ts + @hey-api/client-fetch** で生成されるレスポンス型の現状と注意点を整理し、型安全性をもう一段引き上げたい場合に採れる選択肢をまとめました。  

---

## 1. 現状のレスポンス型で気になるポイント

| 観点 | 挙動 | 懸念 / コメント |
| --- | --- | --- |
| **成功 / 失敗の区別** | `GET /api/users` など複数コードがある場合、最新版 (≥ v0.66) からは *status code ⇒ body* の **Record** が生成されるが、古いバージョンでは *交差型* が吐き出されるため判定が難しい | 交差型のままなら v0.66 以降へ更新すると改善｡（issue #829 参照） citeturn3search3 |
| **エラー時の型** | `default` 応答を定義すると `unknown` になりがち | 400, 404 など **具体的コードごとに schema** を割り当てると型付けされる（issue #691） citeturn3search2 |
| **ヘッダ取得** | 現状は本体だけ返す実装 | ヘッダも欲しい場合はプラグイン拡張が必要（issue #513） citeturn3search5 |
| **ランタイム検証** | TypeScript 型のみ。**実行時に構造が崩れていても例外にならない** | 重大バグ検知の最後の砦が無い |

> **小手先対処**  
> - `@hey-api/openapi-ts@^0.68` へ更新し、`responses/errors map` を有効化する  
> - それでもランタイム検証は得られないため、 `zod.parse()` などをラップする必要がある

---

## 2. さらに型安全・ランタイム安全を高める OSS ジェネレーター

| ツール | 特徴 | ランタイム検証 | 備考 |
| --- | --- | --- | --- |
| **openapi-zod-client** citeturn0search0 | Zodスキーマと [Zodios](https://zodios.org/) クライアントを一括生成。`parse()` 済みの値を返すので **実行時も安全** | ✅（Zod） | 生成物は1ファイル、軽量 |
| **typed-openapi** citeturn0search2 | IDE補完速度を重視した高速ジェネレーター。クライアントは別途用意 | ❌（型のみ） | 「zodは要らないが補完速度↑」なら候補 |
| **openapi-typescript + openapi-fetch** citeturn5search0turn5search9 | まず型 (`paths`) を生成し、`createClient()` で **fetch に完全型付け**。`openapi-fetch-gen` で関数ラッパ自動生成も可 citeturn5search7 | ❌（型のみ） | 好みのフェッチ戦略を組み込みやすい |
| **Orval** （`client: "zod"` 設定） citeturn4search1turn4search6 | React Query / SWR フックも同時生成。Zodで検証可 | ✅ | UI 層と密に連携したい時便利 |
| **Speakeasy / Fern** （クラウドSaaS） citeturn6search0turn0search1 | CI 連携で各言語 SDK + docs を自動発行。型安全・リトライ・認証ヘルパ等まで込み | ✅（Zodベース or 独自） | OSS版より学習コスト低いが商用プラン中心 |

---

## 3. 「openapi-zod-client」に乗り換える最小ステップ例

1. **インストール**

```bash
pnpm add -D openapi-zod-client zod zodios
```

2. **発電スクリプト**

```ts
// scripts/gen-sdk.ts
import { generate } from 'openapi-zod-client';

await generate({
  input: './openapi.yaml',
  output: './src/generated-zod',
  // Zodios 用の fetch ラッパも生成される
});
```

3. **呼び出し側**

```ts
import { zodios } from './generated-zod';

const api = zodios('http://localhost:3000');

// 成功時は data,user, エラー時は catch で ErrorResponse 型が取れる
try {
  const { data } = await api.get('/api/users');
  console.log(data[0].email); // 型安全！
} catch (err) {
  // err は自動で ErrorResponse 型
}
```

Zod が **実行時に不正構造を throw** してくれるので、バックエンド変更に気付けない “silent failure” を防げます。

---

## 4. 判断基準まとめ

| 要件 | 推奨 |
| --- | --- |
| **最小限の変更で現行ツールを延命** | `@hey-api/openapi-ts@>=0.68` にアップ、エラー用 schema を細分化 |
| **OSS でランタイム検証まで欲しい** | `openapi-zod-client` / `Orval (client: "zod")` |
| **軽量で fetch だけ型付けしたい** | `openapi-typescript` + `openapi-fetch` |
| **複数言語 SDK + Docs 自動発行** | Speakeasy / Fern（有償） |

---

### ひとこと

「レスポンス型は compile-time だけで十分か？」「実行時検証を入れてバグ発見コストを下げるか？」が分岐点です。  
開発規模が大きくなるほど **Zod などで早期に失敗させる仕組み** が効果を発揮するので、今回のユーザー CRUD 程度でも `openapi-zod-client` あたりを試してみる価値は十分あると思います。

---

## 👤 ユーザー
*2025/6/4 20:47:16*

たとえば、(alias) getApiUsers&lt;false&gt;(options?: Options&lt;GetApiUsersData, false&gt; | undefined): Promise&lt;({
    data: {
        data: Array&lt;User&gt;;
        status: "success" | "error";
        message?: string;
    };
    error: undefined;
} | {
    ...;
}) & {
    ...;
}&gt;
import getApiUsers

という型を返してくるのだけれどもこれは一般的なのか？

---

## 🤖 アシスタント
*2025/6/4 20:47:56*

### その `getApiUsers&lt;false&gt;(…) =&gt; Promise&lt;…&gt;` 型は「結果オブジェクト（Result‐like）」パターン  
`@hey-api/client-fetch` が採用している一般的な返却インターフェースのひとつです。

| パターン | 型の例 | 採用ライブラリ | 備考 |
| --- | --- | --- | --- |
| \*\*☑︎ 結果オブジェクトを返す\*\*&lt;br&gt;（`{ data, error }` の判別付き union） | `Promise&lt;{ data:T; error:undefined } | { data:undefined; error:E }&gt;` | @hey-api/client-fetch, openapi-fetch など | axios の `data` 直返し型より \*\*安全だが if 文が増える\*\* citeturn0search1turn5search0 |
| \*\*☒ 成功時のみ値を返してエラーは throw\*\* | `Promise&lt;T&gt;`（catch で `E`） | openapi-zod-client / Zodios, openapi-typescript-fetch | async/await に馴染むが \*\*try-catch 必須\*\* |
| \*\*☑︎ React Query/SWR フックを返す\*\* | `useGetApiUsers()` → `{ data, error, isLoading }` | Orval など | UI 層向け・キャッシュ込み |

#### 型パラメータ `&lt;false&gt;`
`getApiUsers&lt;false&gt;` の `&lt;false&gt;` は \*\*「データ変換 (transform) を行わない」\*\* というブールフラグです。`true` を渡すと、プラグインに定義した Transformer が走り、日付文字列→`Date` などの変換後の型で返却されます (v0.66以降で追加)。同じ関数名で \*\*2 系列のオーバーロード\*\* を用意しているのが特徴です。 citeturn0search7

---

## “Result パターン” はどこまで一般的か？

- \*\*OpenAPI コードジェネレーター界隈ではかなりメジャー\*\*  
  \*実行時に throw を抑制\* し、HTTP 200 以外でも 2 パスで処理したいバックエンド志向のプロジェクトと相性が良い。
- いわゆる \*\*FP 系 (fp-ts, neverthrow)\*\* でも同じ `Result&lt;T, E&gt;` を返すデザインが定着。
- ただし \*\*React Query 等との親和性は低め\*\*（`error: undefined` が入るとフックの型ガードが冗長）。

&gt; \*\*要は「Error を throw するか、値で返すか」の好み\*\*  
&gt; 小規模開発や UI レイヤ主体なら throw 方式のほうがコード量は減るケースが多いです。

---

## もっと型安全（＋ランタイム検証）にしたい場合

| 要件 | 移行候補 | 変更量 | 特色 |
| --- | --- | --- | --- |
| \*\*ランタイムで schema 検証したい\*\* | openapi-zod-client + Zodios | 中 | Zod で \*\*`parse()` 済み\*\* を返すので API 側の破壊的変更を即検知 |
| \*\*UI フックも自動生成したい\*\* | Orval (`client:"zod"`) | 中 | React Query/SWR/ TanStack Query をまとめて生成（Zod検証可） |
| \*\*現行パターンを維持して細部だけ改善\*\* | @hey-api/client-fetch を&lt;br&gt;最新版 (≥0.68) に更新し&lt;br&gt;`ErrorResponse` を各ステータスで定義 | 小 | issue #691 の “error unknown 問題” が解消され型精度↑ citeturn0search1 |

---

### まとめ

- `Promise&lt;{ data; error }&gt;` 形式は \*\*OpenAPI SDK では一般的\*\*。  
- ただし \*try-catch で throw を扱う派\* と \*Result オブジェクト派\* が二分しており、プロジェクト文化で選ぶのがベター。  
- \*\*「実行時検証まで欲しいか」\*\* がライブラリ選定の決め手。ランタイム検証が必要なら Zod 生成系へ、IDE 型保証で十分なら `@hey-api` や `openapi-fetch` を使い続けても問題ありません。

---

## 👤 ユーザー
*2025/6/4 20:52:29*

最新版でのエラーハンドリングの書き方を比較して欲しい。ちなみに今は最新版である

---

## 🤖 アシスタント
*2025/6/4 20:53:08*

## `@hey-api/client-fetch`（2025-06-時点 v0.10.*）で書ける 3 つのエラーハンドリングスタイル

> どれも **SDK 関数に組み込まれたジェネリクス** を切り替えるだけで書き分けられます。  
> `getApiUsers<ThrowOnError>()` の 1 型パラメータに注目してください。

| スタイル | 使い方 | 返り値の型 | 典型コード | 長所/短所 |
| --- | --- | --- | --- | --- |
| **① Result オブジェクト（既定）** | 省略 or `<false>` | `Promise<{ data:T; error:undefined } \| { data:undefined; error:E }>` | ```ts const { data, error } = await getApiUsers(); if (error) {/*404等*/} ``` | ✔ 例外フローを汚さない<br>✘ `if(error)` ガード必須 |
| **② throwOnError（関数単位）** | `<true>` or `getApiUsers({ throwOnError:true })` | `Promise<T>` （失敗時 **throw**） | ```ts try { const { data } = await getApiUsers<true>(); } catch (err: ApiError) { … } ``` | ✔ async/await と自然に合流<br>✘ 毎回 try/catch |
| **③ グローバル throwOnError** | ```ts client.setConfig(createConfig({ throwOnError:true })); ``` citeturn1search4 | SDK 全関数が ② と同型 | 呼び出しは通常の `await getApiUsers()` | ✔ プロジェクト全体で統一<br>✘ ライブラリ外に例外が漏れる |

### 1. Result オブジェクト（デフォルト）

```ts
const res = await getApiUsers();           // ThrowOnError = false
if (res.error) {
  // res.error は HTTP ステータスごとに型付けされる（400=ErrorResponse など）
  handle(res.error);
} else {
  render(res.data.data);
}
```

- **型ガード**: `if (res.error)` だけで OK。  
- **型精度**: 400/404 など **各ステータス毎に schema を書けば** `res.error.status === 400` 時に `ErrorResponse` 型へ絞り込めます citeturn0search2。

### 2. 関数ごとに `throwOnError`

```ts
try {
  const { data } = await getApiUsers({ throwOnError: true });
  // 200 系のみここに来る
} catch (err: ApiError<'404' | '400'>) {
  toast(err.data?.message ?? err.message);
}
```

- SDK 側の型は **成功時＝data / 失敗時＝throw** に切り替わります。  
- generics: `getApiUsers<true>()` でも同じ。

### 3. グローバルに `throwOnError`

```ts
import { createClient, createConfig } from "@hey-api/client-fetch";

const client = createClient();
client.setConfig(createConfig({ throwOnError: true })); // 全 API が throw 派に
```

- 設定後は **try/catch スタイルがデフォルト**。  
- 単体テストで「戻り値 union を検査したい」場合などは `getApiUsers({ throwOnError:false })` で都度オーバーライドできます。

---

## React／TanStack Query プラグイン経由の別解

`@tanstack/react-query` プラグインを追加すると

```ts
const { data, error, isLoading } = useQuery(getApiUsersOptions());
```

のように **Query オブジェクト標準の `error`** フィールドへマッピングされます citeturn0search6。  
UI でローディング・リトライを扱うならこちらが楽です。

---

## いつどれを選ぶ？

| シーン | 推奨 |
| --- | --- |
| 取得後すぐに UI へ流す・React Query と合わせたい | **① Result** or **TanStack** |
| UseCase／Service 層で早期 return → UI は catch だけ | **② throwOnError** |
| プロジェクト全体で例外方針を統一したい | **③ グローバル throwOnError** |

> **ポイント**  
> - **レスポンス schema を HTTP コードごとに用意**すると、どのスタイルでもエラー型が絞り込まれます。  
> - なお **Transformers** は *エラー応答を変換しない* ため、日付文字列→`Date` 等を行う場合は成功レスポンスのみ対象となる点に注意 citeturn0search4。

---

### まとめ

最新の `@hey-api/client-fetch` では **ジェネリクス 1 つ or オプション 1 行** で  
- **Result オブジェクト方式**  
- **例外 throw 方式**  
を切り替えられます。  
自分のアプリ層が「if ガード派」か「try/catch 派」かで最適なスタイルを選んでください。

---

## 👤 ユーザー
*2025/6/4 20:56:18*

型安全なコードはどちらか？またどうすればそれを切り替えられるのか？
ちなみにこんなイメージでフロントは書いているがどちらがおすすめなのか

import {
  type CreateUserRequest,
  getApiUsers,
  postApiUsers,
  type User,
} from "@myapp/api-client";
import { logger } from "@myapp/shared";
import type { ReactElement } from "react";
import { useEffect, useState } from "react";

function HomePage(): ReactElement {
  const \[users, setUsers\] = useState&lt;User\[\]&gt;(\[\]);
  const \[loading, setLoading\] = useState(false);
  const \[error, setError\] = useState&lt;string | null&gt;(null);
  const \[newUserName, setNewUserName\] = useState("");
  const \[newUserEmail, setNewUserEmail\] = useState("");

  // ユーザー一覧を取得
  const fetchUsers = async () =&gt; {
    try {
      setLoading(true);
      setError(null);
      logger.info("Fetching all users...");
      const response = await getApiUsers();

      if (response.data?.status === "success") {
        setUsers(response.data.data);
        logger.info(`Found ${response.data.data.length} users`);
      } else {
        setError("ユーザー一覧の取得に失敗しました");
        logger.error("Failed to fetch users");
      }
    } catch (error) {
      setError("エラーが発生しました");
      logger.error("Error fetching users", error as Error);
    } finally {
      setLoading(false);
    }
  };

  // 新しいユーザーを作成
  const createUser = async (e: React.FormEvent) =&gt; {
    e.preventDefault();

    if (!newUserName || !newUserEmail) {
      setError("名前とメールアドレスを入力してください");
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const userData: CreateUserRequest = {
        name: newUserName,
        email: newUserEmail,
      };

      logger.info(`Creating user: ${userData.name}`);
      const response = await postApiUsers({ body: userData });

      if (response.data?.status === "success") {
        logger.info(`User created: ${response.data.data.id}`);
        setNewUserName("");
        setNewUserEmail("");
        await fetchUsers(); // リストを更新
      } else {
        setError("ユーザーの作成に失敗しました");
        logger.error("Failed to create user");
      }
    } catch (error) {
      setError("エラーが発生しました");
      logger.error("Error creating user", error as Error);
    } finally {
      setLoading(false);
    }
  };

  // 初回読み込み時にユーザー一覧を取得
  useEffect(() =&gt; {
    const loadInitialUsers = async () =&gt; {
      try {
        setLoading(true);
        setError(null);
        logger.info("Fetching all users...");
        const response = await getApiUsers();

        if (response.data?.status === "success") {
          setUsers(response.data.data);
          logger.info(`Found ${response.data.data.length} users`);
        } else {
          setError("ユーザー一覧の取得に失敗しました");
          logger.error("Failed to fetch users");
        }
      } catch (error) {
        setError("エラーが発生しました");
        logger.error("Error fetching users", error as Error);
      } finally {
        setLoading(false);
      }
    };

    loadInitialUsers();
  }, \[\]); // 依存配列は空で問題ない

  return (
    &lt;&gt;
      &lt;h1&gt;ユーザー管理&lt;/h1&gt;

      &lt;div className="card"&gt;
        &lt;h2&gt;新規ユーザー作成&lt;/h2&gt;
        &lt;form onSubmit={createUser}&gt;
          &lt;input
            type="text"
            placeholder="名前"
            value={newUserName}
            onChange={(e) =&gt; setNewUserName(e.target.value)}
            disabled={loading}
          /&gt;
          &lt;input
            type="email"
            placeholder="メールアドレス"
            value={newUserEmail}
            onChange={(e) =&gt; setNewUserEmail(e.target.value)}
            disabled={loading}
          /&gt;
          &lt;button type="submit" disabled={loading}&gt;
            {loading ? "処理中..." : "作成"}
          &lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;

      {error && &lt;div className="error"&gt;{error}&lt;/div&gt;}

      &lt;div className="card"&gt;
        &lt;h2&gt;ユーザー一覧&lt;/h2&gt;
        &lt;button type="button" onClick={fetchUsers} disabled={loading}&gt;
          {loading ? "読み込み中..." : "更新"}
        &lt;/button&gt;

        {users.length === 0 ? (
          &lt;p&gt;ユーザーがいません&lt;/p&gt;
        ) : (
          &lt;ul className="user-list"&gt;
            {users.map((user) =&gt; (
              &lt;li key={user.id}&gt;
                &lt;strong&gt;{user.name}&lt;/strong&gt; - {user.email}
                &lt;small&gt; (ID: {user.id})&lt;/small&gt;
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  );
}

export default HomePage;

---

## 🤖 アシスタント
*2025/6/4 20:56:27*

### どちらが「より型安全」か？

| 観点 | Result オブジェクト方式（`ThrowOnError = false`） | 例外 throw 方式（`ThrowOnError = true`） |
| --- | --- | --- |
| **コンパイル時** | 関数の返り値に<br>`{ data:T; error:undefined } \| { data:undefined; error:E }` が現れるため、<br>**プロパティに触れる前に型ガードが必須**。<br>ガードを書き忘れると TS がエラー | 返り値は `T` だけ。<br>**型上は常に成功扱い** なので、プロパティ参照に型ガードは不要 |
| **ランタイム** | 失敗時でも例外を投げない。ハンドリングを忘れると silent failure の危険 | 失敗時は必ず `catch` に来るので、**放置しにくい** |
| **UI コード量** | `if (response.error)` が毎回必要 | ふつうの `try/catch` で済む |
| **ESLint など** | un-handled result を検知しやすい | `catch` を書かないと ESLint が警告 |

**つまり「型（コンパイル）だけ」で見ると *Result オブジェクトの方が厳格***  
—失敗ケースを **Union** で表現するため、無視すると型エラーになります。  
一方、例外 throw 方式は **ランタイムに強制力** があり、UI コードも短くなりがちです。

---

### 切り替え方法

1. **呼び出しごとに切り替える**

```ts
// Result オブジェクト（既定）
const res = await getApiUsers();                 // getApiUsers<false>() と同じ

// 例外 throw
try {
  const ok = await getApiUsers<true>();          // or getApiUsers({ throwOnError: true })
} catch (err) {
  /* 400/404 もここに来る */
}
```

2. **クライアント全体を切り替える**

```ts
import { createClient, createConfig } from "@hey-api/client-fetch";

export const api = createClient(
  createConfig({
    baseUrl: "http://localhost:3000",
    throwOnError: true,         // ここを false にすれば Result 型へ
  }),
);
```
（`throwOnError` は v0.10.* 時点の公式オプションです） citeturn0search5

---

### あなたのコードに当てはめると

#### A. **Result オブジェクトを維持**（現在の書き方）

```ts
const res = await getApiUsers();
if (res.error) {
  setError(res.error.data?.message ?? "取得失敗");
} else {
  setUsers(res.data.data);
}
```

- **型ガード必須** → 書き忘れるとコンパイルエラー
- `res.error.status === 400` などステータス別にさらに絞り込みも可能

#### B. **例外 throw に統一**

まず生成 SDK を *グローバル throwOnError* にしておくと楽です（前述の `createConfig` 例）。

```ts
try {
  const ok = await getApiUsers();   // 成功時だけ来る
  setUsers(ok.data);
} catch (err: ApiError<"400" | "404">) {
  setError(err.data?.message ?? "取得失敗");
}
```

- `ok` は **純粋に成功レスポンス型** なので `ok.data` にそのまま触れられる
- エラーごとの型はジェネリクスで絞り込める（`ApiError<'400'>` 等）

---

### どちらを勧めるか？

| プロジェクト特性 | おすすめ |
| --- | --- |
| **UI 主導で async/await を多用**<br>React Query / TanStack Query と組みたい | **例外 throw 方式**（コードが簡潔） |
| **バックエンド志向・FP ライク**<br>「例外は極力使わない」文化 | **Result オブジェクト方式**（コンパイルで漏れを防ぎやすい） |
| **ランタイム検証も欲しい** | `openapi-zod-client` など **Zod 生成系**へ乗り換え（成功/失敗どちらでも `parse()` 済みで返る） |

あなたのサンプルは「状態変数を自前で管理する*小規模 React 画面*」なので、  
**例外 throw 方式 + `try/catch`** のほうが if ガードが減り、読みやすくなります。  
コンパイル時の安全度をさらに高めたい場合は、UI 層で React Query を噛ませて

```ts
const { data, error, isLoading } = useGetApiUsersQuery();
```

の形にまとめてしまうのが最近の定番です citeturn0search6。

---

## 👤 ユーザー
*2025/6/4 20:59:40*

以下の魅力も教えて欲しい

ランタイム検証も欲しい
openapi-zod-client など Zod 生成系へ乗り換え（成功/失敗どちらでも parse() 済みで返る）

---

## 🤖 アシスタント
*2025/6/4 21:00:00*

### Zod 生成系（**openapi-zod-client** など）へ乗り換えた場合の“魅力”

| 目的 | 得られるメリット | 仕組み |
| --- | --- | --- |
| **ランタイム検証** | - **バックエンドの破壊的変更を即検知**<br>- テスト環境を経ずに混入した「想定外の null / 型ズレ」をその場で `ZodError` として捕捉 | SDK 内で `zod.parse()` / `safeParse()` を自動実行。返却値は **検証済みオブジェクト**／例外のどちらかだけになる citeturn0search0turn1search0 |
| **パース後の値がそのまま型** | - 例：日付文字列 → `Date` へ変換してから返却<br>- UI で毎回 `new Date()` する手間ゼロ | `transform()` や `refine()` を OpenAPI `format` / `pattern` に基づき自動付与 |
| **エラーも型安全** | - `catch (err: ZodiosError<"404", ErrorResponse>)` のように **HTTP ステータス別に絞り込み** | openapi-zod-client が `ApiError` 型ジェネリクスを生成し、失敗時は必ず throw citeturn0search0 |
| **共通スキーマ再利用** | - 同じ Zod スキーマを **フォームバリデーション・Storybook モック・テスト** に流用可能 | 生成ファイルに `schemas/user.ts` などが個別エクスポートされる |
| **単一ファイル or タグ分割** | - 小規模は 1 ファイル、巨大 API は **tag ごとに自動分割**（`group-strategy: "tag-file"`）で IDE が軽い | CLI/Node API でオプション指定可 citeturn0search0 |
| **最新リリースの追加機能** | - `--with-docs` で **JSDoc コメント**自動生成 → IDE 上でも説明表示 (#275)<br>- falsy デフォルト値バグ修正 (#279) など安定度向上 | v1.18.* 系リリースノート citeturn0search1 |

---

### “成功/失敗どちらでも parse 済み” とは？

```ts
const { data } = await api.get("/api/users"); // 成功時のみ到達
// data は Zod によって完全検証・変換済み
```

- 失敗 (`400`, `404`, Network) は `ZodiosError` を **throw**  
- 返却値に `error?: undefined` などは含まれず、UI コードがすっきり  
- `safeParse()` 相当の API も自動生成されるので「例外を使いたくない」場合は  
  ```ts
  const res = await api.safeGet("/api/users");
  if (!res.success) console.log(res.error);
  ```

---

### 導入ステップ（最小例）

1. **依存追加**

```bash
pnpm add -D openapi-zod-client zod zodios
```

2. **スクリプト**

```ts
// scripts/gen-sdk.ts
import { generate } from "openapi-zod-client";
await generate({ input: "./openapi.yaml", output: "./src/generated" });
```

3. **呼び出し**

```ts
import { zodios } from "@/generated";
const api = zodios("http://localhost:3000");

try {
  const { data } = await api.get("/api/users"); // ← data: User[]
} catch (e: ZodiosError<"404" | "400", ErrorResponse>) {
  /* 型安全にハンドリング */
}
```

---

### いつ採用すべき？

| 判断軸 | openapi-zod-client が光るケース |
| --- | --- |
| **API とフロントのスキーマずれをゼロにしたい** | ✅ 本番で「型が合わずクラッシュ」を防ぎたい |
| **フォームや Storybook でも同じ型検証を再利用** | ✅ 生成された Zod スキーマをそのまま使える |
| **巨大 API で IDE 補完が重い** | ✅ タグ分割オプションでファイルを分割 |
| **throw ベースのコードスタイル** | ✅ 生成 SDK が標準で throwOnError |

逆に「コンパイル時型だけで十分」「既存コードが Result オブジェクト前提で大規模」なら、`@hey-api/client-fetch` を最新版で使い続けるほうが移行コストは低く済みます。

---

#### まとめ

- **openapi-zod-client = “OpenAPI → Zod スキーマ + Zodios クライアント” 自動生成器**  
- 成功も失敗も **ランタイム検証済み** で返るため、型・実行時ともに安全性がワンランク向上  
- UI 用コードは `try/catch` だけで済み、変換ロジックも不要  
- 共通スキーマを流用できるため、フォーム・モック・テストの実装コストまで下がる  

「バックエンドが頻繁に変更される」「マルチチームで API を使い回す」――そんな状況ほど、Zod 生成系の導入メリットは大きくなります。

---

## 👤 ユーザー
*2025/6/4 21:01:33*

逆にデメリットは? @hey-api/client-fetch と比較して欲しい

---

## 🤖 アシスタント
*2025/6/4 21:03:00*

以下は \*\*openapi-zod-client (+ Zodios)\*\* に乗り換えたときに表面化しやすい “コスト” と、  
現行の \*\*@hey-api/client-fetch\*\* と比較した際の違いをまとめたものです。

| 項目 | openapi-zod-client + Zodios での懸念点 | @hey-api/client-fetch の状況 |
| --- | --- | --- |
| \*\*バンドルサイズ\*\* | Zod \*\*14.2 kB gzip\*\* が必ず入るほか、Zodios core・生成済みスキーマも加わる → 中規模 API でも \*\*+20〜40 kB\*\* 増えることが多い citeturn3search0 | 依存はほぼネイティブ fetch だけ。Flat SDK なら tree-shaking で最小構成になりやすい citeturn9search0 |
| \*\*実行時オーバーヘッド\*\* | すべてのレスポンスで `zod.parse()` を走らせるため、\*\*巨大リストやストリーム\*\*を頻繁に処理する UI では CPU コストが跳ね上がる（特にモバイル） | 検証処理が無いぶんランタイム負荷は最小 |
| \*\*ビルド & IDE パフォーマンス\*\* | 生成ファイルが大きく、\*\*VS Code IntelliSense 遅延や tsc 時間の増大\*\*が報告例多数。大規模 spec では「ファイル分割をして欲しい」という issue も（#332 ほか） citeturn0search1 | Flat 生成＋型-only なので比較的軽量。Class SDK を選ばなければ型定義は 1 ファイルに絞られる |
| \*\*未対応／バグ\*\* | - 4xx 系レスポンスが NaN → 型崩れ (#335) &lt;br&gt;- `format:"date-time"` の誤変換 (#311) &lt;br&gt;- `multipart/form-data` や `file` type の生成漏れ (#313) &lt;br&gt;- `discriminator` の enum 制約 (#327) など、\*\*仕様のすき間でハマるケース\*\* が散見 citeturn0search1turn0search2turn0search7 | 同程度のバグはあるものの、fetch クライアントは \*\*シリアライズ/デシリアライズの責務を負わない\*\* ぶん影響範囲が限定的 |
| \*\*エラーモデルの柔軟性\*\* | Zodios は \*\*throw 前提\*\*。Result オブジェクト型に切り替える選択肢が無いため、FP スタイル (Either) を徹底したい場合は追加ラッパが必要 | `throwOnError` true/false をジェネリクス 1 つで切り替え可；チーム方針に合わせやすい |
| \*\*カスタマイズ難度\*\* | Zodios の依存で `axios` ベース。fetch を使いたい場合は adapter を追加導入するか自作が必要。Zod transform も \*\*Zod API 準拠\*\* のため記述量が多くなりがち | fetch 標準。`transformers` プラグインで日付→Date 変換などを declarative に指定可 citeturn5search5 |
| \*\*運用フェーズ\*\* | バックエンド仕様変更時は \*\*ビルドエラー＋ランタイム throw\*\* で早期に気づける反面、本番環境でもパース失敗→例外停止のリスクが残る | 型崩れはコンパイル時しか検知できないが、ランタイムは影響を受けにくい |

---

### こんな場合は openapi-zod-client を避けてもよい

- \*\*モバイル Web / Edge Functions\*\* など、\*\*数十 kB の増量や CPU 消費をシビアに抑えたい\*\*  
- IDE が既に重い大規模モノレポで、「さらに型生成ファイルが増えると作業が辛い」  
- Result オブジェクト型でハンドリングする既存コードベースを大幅に書き換えたくない

### それでも導入する価値が高いケース

- \*\*「テスト環境を通らなくても本番で即検知したい」\*\* ほど API 変更が頻繁  
- 共通の Zod スキーマを \*\*フォームバリデーション・MSW モック・バックエンド\*\*でも再利用したい  
- 解析ツールや管理画面で \*\*入力・出力の完全型保証と即時バリデーション\*\* が必須

---

#### まとめ

- openapi-zod-client は \*\*型 + 実行時検証\*\* を同時に満たす強力なソリューションだが、  
  \*\*バンドルサイズ・CPU・開発体験（IDE）\*\* への追加コストが現実的に存在します。  
- それらのコストが許容できず「型安全はコンパイルだけで十分」という場合は、  
  \*\*@hey-api/client-fetch\*\* + 必要に応じて `transformers` や `throwOnError` を駆使する構成の方が軽快です。

---

## 👤 ユーザー
*2025/6/4 21:05:12*

openapi-zod-client のライブラリのメンテ状況は他のopenapi.yaml からの自動生成sdkとの比較もして欲しい。移行のコストは考えなくていい。

---

## 🤖 アシスタント
*2025/6/4 21:07:55*

### オープンソース SDK ジェネレーターの「メンテ状況」早見表  
\*(2025-06-04 時点 / 移行コストは考慮せず)\*

| ライブラリ | Stars / Forks | 最新リリース頻度・日付 | Open Issues | 主なメンテナー体制 | 備考 |
| --- | --- | --- | --- | --- | --- |
| \*\*openapi-zod-client\*\* | ★ ≈ 980 / 116 forks citeturn14search4 | v1.18.1 - 2025-04-18&lt;br&gt;3〜4 回/月ペースで patch / minor が出る citeturn14search1 | 72 open, PR 16 open (長期滞留 issue は少なめ) citeturn14search3 | 個人メンテナー + GitHub Actions で自動リリース | Zod + axios ベース。実装が速い反面 \*\*Bus Factor=1\*\* なのが最大リスク |
| \*\*openapi-typescript\*\* (+ openapi-fetch) | ★ 約4 k（GitHub UI 表示） | 2025-05-10 に 7.8.0。同日に 7.7.3 → 7.7.2 も連続公開＝\*\*週次〜日次\*\* citeturn8search5 | issue #2349 が 2025-06-02 に登録＝メンテ中 citeturn8search8 | コア 2 名 + OSS contributor 多数 | \*\*型専用ツール\*\*なので破壊的変更は少なく、安定志向 |
| \*\*@hey-api/openapi-ts\*\* | ★ 約1 k（GitHub org 概要に Followers 47） citeturn0search7 | npm では 0.10 系を \*\*月1 ペース\*\*で発行 | GitHub の open issue は 50 弱（大半がプラグイン要望） | 小規模チーム（Hey API 社内） | プラグイン拡張前提。商用 SaaS としても運営されており \*\*ドキュメント・CI が手厚い\*\* |
| \*\*Orval\*\* | ★ 4.1 k / 418 forks（org 一覧より） citeturn19search3 | 2025-04-17 粗密パッチ (#2041) 等。\*\*月2〜3 回\*\* | 2 k+ issue/PR、24 h 以内の triage 多い citeturn19search8 | OSS コア 3 名 + α | React Query / SWR フックも生成。規模が大きく IDE が重くなりやすい |
| \*\*Speakeasy CLI\*\* | ―（星数 &lt;1 k） | SaaS 側で自動 deploy、GitHub main に \*\*毎営業日 commit\*\* citeturn0search4 | Issue ≒ Discussion ベース、対応は即日〜数日 | VC 資本のスタートアップ | 10 言語 SDK & Terraform Provider まで自動生成；\*\*クラウド前提\*\* |
| \*\*Fern\*\* | ★ ≈ 1 k | `fern generate` CLI は \*\*週次リリース\*\* | OSS 部分は少数 issue・rapid close | Fern, Inc.（YC22） | SaaS 依存だが \*\*ドキュメントサイトも同時出力\*\* が強み citeturn0search5 |

---

#### openapi-zod-client を選ぶ場合の“安心材料”と“気になる点”

| プラス要素 | マイナス要素 |
| --- | --- |
| \* リリース間隔が最短数日。2025 Q2 も patch が継続。&lt;br&gt;\* Issue/PR の \*\*放置率が低く\*\*、作者が直接返信。&lt;br&gt;\* 小粒な breaking change は \*\*CHANGELOG に詳細記載\*\*。 | \* ほぼ単独メンテ → バージョンアップ停止リスク。&lt;br&gt;\* axios 固定・fetch 版はコミュニティ adapter 頼み。&lt;br&gt;\* ランタイム検証のため \*\*バンドルサイズ/CPU が増\*\* (実行時 parse)。 |

---

### “メンテ状況だけ”で見たランキング

1. \*\*openapi-typescript / Orval\*\* … コミュニティ規模 & リリース頻度ともに安定。  
2. \*\*@hey-api/openapi-ts\*\* … 企業バックでドキュメント充実、ただし閉鎖バス因子。  
3. \*\*openapi-zod-client\*\* … 1 人メンテながら非常にアクティブ。Zod が欲しいなら最有力。  
4. \*\*Speakeasy / Fern\*\* … SaaS 契約込みで手厚いが、OSS 部分は薄め（星は少ない）。  

&gt; \*\*結論\*\*  
&gt; - \*\*「ランタイム検証 + 素早いバグ修正」\*\* を重視するなら \*openapi-zod-client\*。  
&gt; - \*\*「長期的に枯れたエコシステム」\*\* を優先するなら \*openapi-typescript\* か \*Orval\* が無難。  
&gt; - Bus Factor に敏感な組織であれば、マルチメンテナー or 企業支援のツールを選ぶと安心です。

---
