# テストコード作成

Date: 2024-02-28

---

## 👤 User
*2024-02-28 13:12:18*

以下のテストコードを書いてほしい。

final class LicenseListPresenter: ObservableObject {
    @Published private(set) var licenseList: [License]
    @Published var selectedLicense: License?

    init(dependency: some LicenseListPresenterDependency) {
        LoggerContainer.initLog()

        licenseList = dependency.libraryLicenseDriver.licenseList
    }

    deinit {
        LoggerContainer.deinitLog()
    }

    func onAppear() {
        LoggerContainer.logOnAppear()
    }

    func onDisappear() {
        LoggerContainer.logOnDisappear()
    }

    func onTapLicense(license: License) {
        selectedLicense = license
    }
}

---

## 🤖 Assistant
*2024-02-28 13:14:10*

テストコードを書く際には、`LicenseListPresenter` の振る舞いを検証することが目的です。これには、依存関係のモック化、状態の検証、および期待されるメソッド呼び出しの確認が含まれます。以下のステップに従ってテストケースを作成します。

1. **依存関係のモック化**: `LicenseListPresenterDependency` と `LoggerContainer` のモックを作成します。
2. **初期化テスト**: `LicenseListPresenter` が正しく初期化されることを検証します。
3. **`onAppear` と `onDisappear` メソッドのテスト**: これらのメソッドが呼ばれた時に、`LoggerContainer` の対応するメソッドが呼ばれることを検証します。
4. **`onTapLicense` メソッドのテスト**: 選択されたライセンスが正しく更新されることを検証します。

以下は、上記のステップに基づいたテストコードの例です。この例では、SwiftのXCTestフレームワークを使用しています。

```swift
import XCTest
@testable import YourApp // YourAppは適切なアプリケーション名に置き換えてください

// モック依存関係
class MockLicenseListPresenterDependency: LicenseListPresenterDependency {
    var libraryLicenseDriver: LibraryLicenseDriver

    init(libraryLicenseDriver: LibraryLicenseDriver) {
        self.libraryLicenseDriver = libraryLicenseDriver
    }
}

// モックLibraryLicenseDriver
class MockLibraryLicenseDriver: LibraryLicenseDriver {
    var licenseList: [License] = []

    init(licenses: [License]) {
        self.licenseList = licenses
    }
}

// モックLoggerContainer
class MockLoggerContainer: LoggerContainer {
    static var initLogCalled = false
    static var deinitLogCalled = false
    static var logOnAppearCalled = false
    static var logOnDisappearCalled = false

    override class func initLog() {
        initLogCalled = true
    }

    override class func deinitLog() {
        deinitLogCalled = true
    }

    override class func logOnAppear() {
        logOnAppearCalled = true
    }

    override class func logOnDisappear() {
        logOnDisappearCalled = true
    }

    class func reset() {
        initLogCalled = false
        deinitLogCalled = false
        logOnAppearCalled = false
        logOnDisappearCalled = false
    }
}

class LicenseListPresenterTests: XCTestCase {

    func testInitialization() {
        let licenses = [License(name: "Test License", details: "Some details")]
        let driver = MockLibraryLicenseDriver(licenses: licenses)
        let dependency = MockLicenseListPresenterDependency(libraryLicenseDriver: driver)
        let presenter = LicenseListPresenter(dependency: dependency)

        XCTAssertTrue(MockLoggerContainer.initLogCalled, "initLog was not called")
        XCTAssertEqual(presenter.licenseList, licenses, "License list was not initialized correctly")
    }

    func testOnAppear() {
        let presenter = makePresenter()
        presenter.onAppear()

        XCTAssertTrue(MockLoggerContainer.logOnAppearCalled, "logOnAppear was not called")
    }

    func testOnDisappear() {
        let presenter = makePresenter()
        presenter.onDisappear()

        XCTAssertTrue(MockLoggerContainer.logOnDisappearCalled, "logOnDisappear was not called")
    }

    func testOnTapLicense() {
        let licenses = [License(name: "Test License", details: "Some details")]
        let presenter = makePresenter(licenses: licenses)
        let expectedLicense = licenses.first!

        presenter.onTapLicense(license: expectedLicense)

        XCTAssertEqual(presenter.selectedLicense, expectedLicense, "Selected license was not updated correctly")
    }

    private func makePresenter(licenses: [License] = []) -> LicenseListPresenter {
        MockLoggerContainer.reset()
        let driver = MockLibraryLicenseDriver(licenses: licenses)
        let dependency = MockLicenseListPresenterDependency(libraryLicenseDriver: driver)
        return LicenseListPresenter(dependency: dependency)
    }
}
```

このテストコードは、`LicenseListPresenter` の基本的な機能をカバーしています。しかし、実際のプロジェクトでは、`License` や `LoggerContainer`、`LicenseListPresenterDependency` などの具体的な実装に応じて、テストケースをさらに追加または調整する必要があるかもしれません。また、`MockLoggerContainer` の実装は、`LoggerContainer` の実際の実装に依存します。この例では、`LoggerContainer` のメソッドをオーバーライドするために、`LoggerContainer` がクラスであることを前提としています。もし `LoggerContainer` が静的メソッドのみを持つ構造体や列挙型である場合は、このアプローチを適用できませんので、適宜調整が必要です。

---

## 👤 User
*2024-02-29 07:01:49*

XCTestCase 専用のbeforeEach処理みたいなものやsetupはなかったっけ？

---

## 🤖 Assistant
*2024-02-29 07:02:35*

はい、`XCTestCase` にはテストの実行前に毎回実行されるセットアップ処理を記述するための `setUp` メソッドがあります。また、テストの実行後に毎回実行されるクリーンアップ処理を記述するための `tearDown` メソッドもあります。これらのメソッドは、テストケース内で共通の初期化や後処理が必要な場合に非常に便利です。

`setUp` はテストメソッドが実行される直前に毎回呼び出され、`tearDown` はテストメソッドが実行された直後に毎回呼び出されます。これにより、テスト間でデータが共有されることを防ぎ、各テストが独立して実行されることを保証します。

以下に、`setUp` と `tearDown` メソッドを使用したテストクラスの例を示します。

```swift
class LicenseListPresenterTests: XCTestCase {

    var presenter: LicenseListPresenter!
    var mockDependency: MockLicenseListPresenterDependency!

    override func setUp() {
        super.setUp()
        // モック依存関係とプレゼンターの初期化
        let licenses = [License(name: "Test License", details: "Some details")]
        let driver = MockLibraryLicenseDriver(licenses: licenses)
        mockDependency = MockLicenseListPresenterDependency(libraryLicenseDriver: driver)
        presenter = LicenseListPresenter(dependency: mockDependency)
        MockLoggerContainer.reset()
    }

    override func tearDown() {
        // オブジェクトの解放や後処理
        presenter = nil
        mockDependency = nil
        super.tearDown()
    }

    func testInitialization() {
        XCTAssertTrue(MockLoggerContainer.initLogCalled, "initLog was not called")
        XCTAssertEqual(presenter.licenseList, mockDependency.libraryLicenseDriver.licenseList, "License list was not initialized correctly")
    }

    // 他のテストメソッド...
}
```

この例では、`setUp` メソッド内でテスト用のプレゼンターとその依存関係を初期化し、`tearDown` メソッドで後処理を行っています。これにより、各テストメソッドが実行される前に常に同じ状態から開始することが保証されます。

---

## 👤 User
*2024-02-29 07:03:55*

tearDown を使わずに setUp に最初の処理に初期化をするのはどうだろうか？

---

## 🤖 Assistant
*2024-02-29 07:04:52*

`setUp` メソッド内での初期化だけに頼り、`tearDown` を使用しないアプローチは、一部のシナリオでは問題なく機能するかもしれません。特に、テストが比較的単純で、後処理がほとんどまたは全く必要ない場合や、作成したオブジェクトがテスト間での副作用を引き起こさない場合に該当します。しかし、このアプローチにはいくつかの潜在的な問題があります。

### リソースのリーク
`tearDown` を使用しないと、テストが生成したリソースが適切に解放されない可能性があります。これは、特にリソースが限られている環境や、外部リソース（ファイルハンドル、データベース接続など）を多用するテストで問題になります。

### テスト間の独立性
`setUp` でのみ初期化を行う場合、テストの実行順序やテスト間での副作用によってテスト結果が影響を受ける可能性があります。`tearDown` で適切に後処理を行うことで、各テストがクリーンな状態から開始され、他のテストの実行結果に影響されないようにすることが重要です。

### 再利用性とメンテナンス性
テストコードもソフトウェアの一部であり、再利用性とメンテナンス性を考慮する必要があります。`tearDown` を適切に使用することで、テストコードの構造を明確にし、後処理のロジックを一箇所に集約できます。これにより、テストコードの読みやすさと保守性が向上します。

### 実践的なアプローチ
実際には、`setUp` と `tearDown` を組み合わせて使用することが一般的です。`setUp` でテストの前提条件を設定し、`tearDown` でテストによって変更された状態をクリーンアップします。これにより、各テストが独立して実行されることが保証され、テストの信頼性が向上します。

### 結論
`setUp` のみで全てを処理するアプローチは、簡単なテストスイートであれば機能するかもしれませんが、より複雑なテストや、リソースのクリーンアップ、テスト間の独立性を保証する必要がある場合には適していません。`tearDown` を適切に使用することで、テストの信頼性、再利用性、およびメンテナンス性を向上させることができます。

---
