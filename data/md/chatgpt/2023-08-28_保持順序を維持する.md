# 保持順序を維持する

日付: 2023-08-28

---

## 👤 ユーザー
*2023/8/29 1:50:06*

この処理について、配列の順番を維持するようにして欲しい

func convertToDomainEntity(amplifyResearchs: \[Research\]) async throws -&gt; \[EmomilCore.Research\] {
        try await withThrowingTaskGroup(of: EmomilCore.Research.self) { group in
            for amplifyResearch in amplifyResearchs {
                group.addTask {
                    try await self.convertToDomainEntity(amplifyResearch: amplifyResearch)
                }
            }
            var domainResearches: \[EmomilCore.Research\] = \[\]
            for try await domainResearch in group {
                domainResearches.append(domainResearch)
            }
            
            // 【デグレ】【お願いリスト】お願い一覧のサムネイルを非同期処理で取得する影響で順番が保持されなくなってしまっている #638
            // https://github.com/Viagate/emomil-app-ios/issues/638
            
            // TODO: orderを送って欲しい（現状、順番が入れ替わっております。。。）
            return domainResearches
        }
    }

---

## 🤖 アシスタント
*2023/8/29 1:50:43*

非同期タスクは、タスクが終了するタイミングが異なるため、元の順序が保持されないことがよくあります。この問題を解決するためには、`TaskGroup`のタスクを追加した順序と同じ順序で結果を取得する必要があります。

以下の方法で配列の順序を維持しながら、各タスクの結果を格納することができます:

1. `domainResearches`のサイズを元の`amplifyResearchs`と同じサイズに初期化します。
2. 各タスクでのインデックスを記録し、そのインデックスに対応する`domainResearches`の位置に結果を格納します。

以下が改善されたコードです：

```swift
func convertToDomainEntity(amplifyResearchs: [Research]) async throws -> [EmomilCore.Research] {
    try await withThrowingTaskGroup(of: (Int, EmomilCore.Research).self) { group in
        for (index, amplifyResearch) in amplifyResearchs.enumerated() {
            group.addTask {
                let domainResearch = try await self.convertToDomainEntity(amplifyResearch: amplifyResearch)
                return (index, domainResearch)
            }
        }
        var domainResearches: [EmomilCore.Research?] = Array(repeating: nil, count: amplifyResearchs.count)
        for try await (index, domainResearch) in group {
            domainResearches[index] = domainResearch
        }
        
        // 結果としてOptionalを取り除き、確実に全てのデータが格納されていることを保証する
        return domainResearches.compactMap { $0 }
    }
}
```

この変更により、各タスクの結果が正確な順序で`domainResearches`に格納され、順序が維持されます。

---

## 👤 ユーザー
*2023/8/29 10:29:07*

var domainResearches: \[EmomilCore.Research?\] = Array(repeating: nil, count: amplifyResearchs.count) これはどういう意味？

---

## 🤖 アシスタント
*2023/8/29 10:29:40*

このコードの行は、Swiftの配列を初期化しています。特に、次のことを行っています：

```swift
var domainResearches: [EmomilCore.Research?] = Array(repeating: nil, count: amplifyResearchs.count)
```

1. `domainResearches`という変数を宣言しています。
2. 型は`[EmomilCore.Research?]`で、これは`EmomilCore.Research`のオプショナル型の配列を意味します。オプショナル型は、値が存在する場合や存在しない場合(nil)の2つの状態を持つことができます。
3. `Array(repeating: nil, count: amplifyResearchs.count)`は、特定の値を繰り返して配列を初期化する方法です。この場合、`nil`を`amplifyResearchs.count`回繰り返して、その大きさの配列を作成しています。

このコードの目的は、`domainResearches`配列を`amplifyResearchs`と同じ大きさに初期化し、すべての要素を`nil`で埋めることです。その後、非同期タスクが完了するたびに、`domainResearches`の特定のインデックスに結果を格納します。この方法で、タスクが終了する順番に関係なく、元の`amplifyResearchs`の順序を維持して`domainResearches`に結果を格納することができます。

---

## 👤 ユーザー
*2023/8/29 10:30:34*

オプショナルを使わない方法ってないのかな？

---

## 🤖 アシスタント
*2023/8/29 10:31:05*

オプショナルを使用せずに順序を維持する方法はいくつか考えられます。一つの方法として、`domainResearches`を事前に領域を確保するのではなく、後から結果を挿入するのに適した方法を使用することが考えられます。

具体的には、インデックスと結果を組にしたデータを保存する一時的な配列を使用します。非同期タスクが完了するたびにこの配列に結果を追加し、全てのタスクが完了した後にこの一時的な配列をソートして、正しい順序で結果を取得します。

以下はその実装例です：

```swift
func convertToDomainEntity(amplifyResearchs: [Research]) async throws -> [EmomilCore.Research] {
    try await withThrowingTaskGroup(of: (Int, EmomilCore.Research).self) { group in
        for (index, amplifyResearch) in amplifyResearchs.enumerated() {
            group.addTask {
                let domainResearch = try await self.convertToDomainEntity(amplifyResearch: amplifyResearch)
                return (index, domainResearch)
            }
        }
        
        var tempResults: [(Int, EmomilCore.Research)] = []
        for try await result in group {
            tempResults.append(result)
        }
        
        // 一時的な配列をインデックスでソート
        tempResults.sort(by: { $0.0 < $1.0 })
        
        // ソートされた配列からEmomilCore.Researchの値のみを抽出
        return tempResults.map { $0.1 }
    }
}
```

この方法では、オプショナルを使用せずに非同期タスクの結果を正しい順序で取得することができます。

---

## 👤 ユーザー
*2023/8/29 10:31:48*

tempResults のタプルに変数名をつけて処理をわかりやすくして欲しい

---

## 🤖 アシスタント
*2023/8/29 10:32:13*

了解しました。タプルの各要素に変数名をつけることで、コードの可読性を向上させることができます。以下のように改善します：

```swift
func convertToDomainEntity(amplifyResearchs: [Research]) async throws -> [EmomilCore.Research] {
    try await withThrowingTaskGroup(of: (index: Int, domainResearch: EmomilCore.Research).self) { group in
        for (index, amplifyResearch) in amplifyResearchs.enumerated() {
            group.addTask {
                let domainResearch = try await self.convertToDomainEntity(amplifyResearch: amplifyResearch)
                return (index: index, domainResearch: domainResearch)
            }
        }
        
        var tempResults: [(index: Int, domainResearch: EmomilCore.Research)] = []
        for try await result in group {
            tempResults.append(result)
        }
        
        // 一時的な配列をインデックスでソート
        tempResults.sort(by: { $0.index < $1.index })
        
        // ソートされた配列からEmomilCore.Researchの値のみを抽出
        return tempResults.map { $0.domainResearch }
    }
}
```

このようにタプルの各要素に名前をつけることで、どの要素が何を意味するのかが明確になり、コードの可読性が向上します。

---
