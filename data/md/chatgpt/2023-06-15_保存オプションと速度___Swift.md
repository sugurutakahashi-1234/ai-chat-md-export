# 保存オプションと速度 - Swift

日付: 2023-06-15

---

## 👤 ユーザー
*2023/6/15 15:39:05*

swiftで以下のようなファイルの保存処理をしているのだけれどもよく使うようなオプションとかあったりする？速度を求めたいんだ

func saveDataToLocal(data: Data, fileName: String, serializeMethod: SerializeMethod) throws {
        let filePath = FileManager.default.directoryURL(directory: .document).appendingPathComponent(fileName).appendingPathExtension(serializeMethod.fileExtension)

        do {
            try data.write(to: filePath, options: .atomic)
        } catch {
            AppLogger.debugLog("Failed to save data to \(fileName)\(serializeMethod.fileExtension): \(error)", level: .error)
            throw error
        }
    }

---

## 🤖 アシスタント
*2023/6/15 15:39:55*

SwiftのDataの`write(to:options:)`メソッドには2つのオプションがあります。

1. `.atomic`: これはデータが完全に書き込まれるまで、一時的な補助ファイルに書き込まれ、それが成功したら、その補助ファイルが最終的な目的地に置き換えられます。もし書き込み途中で何らかの問題が発生した場合でも、以前のデータは保持されます。つまり、完全性と安全性を保つために使用されますが、パフォーマンスには若干の影響を及ぼします。

2. `.withoutOverwriting`: これは、指定されたURLにすでにファイルが存在する場合、そのファイルを上書きしないようにします。すでにファイルが存在する場合、エラーが発生します。

あなたがパフォーマンス（書き込み速度）を最優先するなら、`.atomic`オプションを取り除くことを検討してみてください。ただし、これはデータの完全性や書き込みの安全性に影響を及ぼす可能性があるため、注意が必要です。

また、書き込み速度を改善するための他の方法としては、ファイルの書き込みをバックグラウンドスレッドで行うことが考えられます。これにより、UIがブロックされることなく、重いファイル書き込みタスクを行うことができます。

また、大きなデータを扱っている場合、データを分割して一部ずつ書き込むことを検討することも可能です。これは特に大きなデータを扱っている場合に有用で、データの一部を失うリスクを減らします。

ただし、これらのすべてのアプローチにはそれぞれトレードオフが存在するため、要件と使用状況によって適切な選択をすることが重要です。

---

## 👤 ユーザー
*2023/6/15 15:41:08*

どうやったらバックグラウンドで処理してくるようになる Swiftコンカレンシーをつかってほしい

今はこんな感じ。治せそうなところは直して欲しい

public func serializeAndUpload(target: SerializableUploadTarget) async throws {
        let serializeMethod: SerializeMethod = userDefaultsManager.isEnableJSONEncode ? .json : .binaryDelimited
        let key: DataKey
        let serializedData: Data

        switch target {
        case .anchor(let anchorKey, let data):
            key = anchorKey
            let convertedData = try data.map { try AnchorConverter.convertToData($0) }
            serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

        case .emotion(let emotionKey, let data):
            key = emotionKey
            let convertedData = try data.map { try EmotionConverter.convertToData($0) }
            serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

        case .interaction(let interactionKey, let data):
            key = interactionKey
            let convertedData = try data.map { try InteractionConverter.convertToData($0) }
            serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)
        }

        if userDefaultsManager.isEnableLocalBackup {
            try saveDataToLocal(data: serializedData, fileName: key.localFileName, serializeMethod: serializeMethod)
        }

        guard serializeMethod == .binaryDelimited else {
            AppLogger.debugLog("Skip upload data because serialize method is not BinaryDelimited")
            return
        }
        try await cloudStorageManager.upload(key: key.path, data: serializedData)
    }

// 以下の private extension で実行している関数は SerializeManager という class を新規に作成して、そこで定義してもよさそうであるが、他で使わなそうな処理なので一旦ここに置いている（今後、検討する）
private extension SerializeAndUploadInteractor {
    func serializeToData(messages: [some Message], serializeMethod: SerializeMethod) throws -&gt; Data {
        let data: Data
        switch serializeMethod {
        case .binaryDelimited:
            data = try serializeToBinaryData(messages: messages)
        case .json:
            data = try serializeToJSONData(messages: messages)
        }
        return data
    }

    func saveDataToLocal(data: Data, fileName: String, serializeMethod: SerializeMethod) throws {
        let filePath = FileManager.default.directoryURL(directory: .document).appendingPathComponent(fileName).appendingPathExtension(serializeMethod.fileExtension)

        do {
            try data.write(to: filePath, options: .atomic)
        } catch {
            AppLogger.debugLog("Failed to save data to \(fileName)\(serializeMethod.fileExtension): \(error)", level: .error)
            throw error
        }
    }

    func serializeToBinaryData(messages: [some Message]) throws -&gt; Data {
        let outputStream = OutputStream.toMemory()
        outputStream.open()

        // エラーを throw するため forEach などは使えない
        for message in messages {
            do {
                try BinaryDelimited.serialize(message: message, to: outputStream)
            } catch {
                AppLogger.debugLog("Failed to BinaryDelimited serialize: \(error)", level: .error)
                throw error
            }
        }

        outputStream.close()

        guard let data = outputStream.property(forKey: .dataWrittenToMemoryStreamKey) as? Data else {
            AppLogger.debugLog("Failed to retrieve data from OutputStream", level: .error)
            throw NSError(domain: "EncodingError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to retrieve data from OutputStream"])
        }

        return data
    }

    func serializeToJSONData(messages: [some Message]) throws -&gt; Data {
        var jsonData = Data()

        // エラーを throw するため forEach などは使えない
        for message in messages {
            do {
                let stringData = try message.jsonUTF8Data()
                jsonData.append(stringData)
            } catch {
                AppLogger.debugLog("Failed to serialize to JSON: \(error)", level: .error)
                throw error
            }
        }

        return jsonData
    }
}

---

## 🤖 アシスタント
*2023/6/15 15:42:09*

Swift 5.5から非同期/同期（async/await）パターンをサポートしているので、その機能を利用してバックグラウンドでデータの保存とアップロードを行うことができます。

以下にその一例を示します。`Task`という新しいAPIを使って非同期タスクを作成し、`detach`メソッドを使って新しい非同期タスクをバックグラウンドで実行します。`saveDataToLocal`メソッドと`cloudStorageManager.upload`メソッドを非同期に呼び出すために、`async`キーワードを使ってこれらのメソッドを非同期メソッドに変換します。

```swift
public func serializeAndUpload(target: SerializableUploadTarget) async throws {
    let serializeMethod: SerializeMethod = userDefaultsManager.isEnableJSONEncode ? .json : .binaryDelimited
    let key: DataKey
    let serializedData: Data

    switch target {
    case .anchor(let anchorKey, let data):
        key = anchorKey
        let convertedData = try data.map { try AnchorConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

    case .emotion(let emotionKey, let data):
        key = emotionKey
        let convertedData = try data.map { try EmotionConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

    case .interaction(let interactionKey, let data):
        key = interactionKey
        let convertedData = try data.map { try InteractionConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)
    }

    if userDefaultsManager.isEnableLocalBackup {
        Task {
            do {
                try await saveDataToLocal(data: serializedData, fileName: key.localFileName, serializeMethod: serializeMethod)
            } catch {
                AppLogger.debugLog("Failed to save data to \(key.localFileName)\(serializeMethod.fileExtension): \(error)", level: .error)
                // throw error // If you want to throw the error to the caller, remove this comment
            }
        }
    }

    guard serializeMethod == .binaryDelimited else {
        AppLogger.debugLog("Skip upload data because serialize method is not BinaryDelimited")
        return
    }

    Task {
        do {
            try await cloudStorageManager.upload(key: key.path, data: serializedData)
        } catch {
            AppLogger.debugLog("Failed to upload data: \(error)", level: .error)
            // throw error // If you want to throw the error to the caller, remove this comment
        }
    }
}

// Your other methods remain the same...

func saveDataToLocal(data: Data, fileName: String, serializeMethod: SerializeMethod) async throws {
    let filePath = FileManager.default.directoryURL(directory: .document).appendingPathComponent(fileName).appendingPathExtension(serializeMethod.fileExtension)
    do {
        try data.write(to: filePath, options: .atomic)
    } catch {
        AppLogger.debugLog("Failed to save data to \(fileName)\(serializeMethod.fileExtension): \(error)", level: .error)
        throw error
    }
}
```

このコードは、データの保存とアップロードを

---

## 🤖 アシスタント
*2023/6/15 15:42:39*

同時に非同期で行います。そのため、これらの操作が同時に行われ、全体としてのパフォーマンスが向上します。

ただし、注意点として非同期タスクがエラーをスローすると、そのエラーは`Task`の中でキャッチされます。そのため、呼び出し元にエラーを伝えるためには、別の方法を考える必要があります。

---

## 👤 ユーザー
*2023/6/15 15:43:14*

saveDataToLocalだけバックグランドが良くて、この処理に失敗しても何もしなくていいよ

---

## 🤖 アシスタント
*2023/6/15 15:44:04*

了解しました。`saveDataToLocal`メソッドを非同期タスクとしてバックグラウンドで実行し、その処理が失敗した場合は何も行わないようにすることができます。以下にその方法を示します。

```swift
public func serializeAndUpload(target: SerializableUploadTarget) async throws {
    let serializeMethod: SerializeMethod = userDefaultsManager.isEnableJSONEncode ? .json : .binaryDelimited
    let key: DataKey
    let serializedData: Data

    switch target {
    case .anchor(let anchorKey, let data):
        key = anchorKey
        let convertedData = try data.map { try AnchorConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

    case .emotion(let emotionKey, let data):
        key = emotionKey
        let convertedData = try data.map { try EmotionConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

    case .interaction(let interactionKey, let data):
        key = interactionKey
        let convertedData = try data.map { try InteractionConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)
    }

    if userDefaultsManager.isEnableLocalBackup {
        Task {
            do {
                try await saveDataToLocal(data: serializedData, fileName: key.localFileName, serializeMethod: serializeMethod)
            } catch {
                AppLogger.debugLog("Failed to save data to \(key.localFileName)\(serializeMethod.fileExtension): \(error)", level: .error)
                // Do nothing if saveDataToLocal fails
            }
        }
    }

    guard serializeMethod == .binaryDelimited else {
        AppLogger.debugLog("Skip upload data because serialize method is not BinaryDelimited")
        return
    }
    
    try await cloudStorageManager.upload(key: key.path, data: serializedData)
}

func saveDataToLocal(data: Data, fileName: String, serializeMethod: SerializeMethod) async throws {
    let filePath = FileManager.default.directoryURL(directory: .document).appendingPathComponent(fileName).appendingPathExtension(serializeMethod.fileExtension)
    do {
        try data.write(to: filePath, options: .atomic)
    } catch {
        AppLogger.debugLog("Failed to save data to \(fileName)\(serializeMethod.fileExtension): \(error)", level: .error)
        throw error
    }
}
```
このようにすることで、`saveDataToLocal`メソッドは非同期に実行され、失敗した場合でもそのエラーは無視されます。これにより、UIのブロックなどのパフォーマンス問題を避けることができます。

---
