# ä¿å­˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨é€Ÿåº¦ - Swift

æ—¥ä»˜: 2023-06-15

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2023/6/15 15:39:05*

swiftã§ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜å‡¦ç†ã‚’ã—ã¦ã„ã‚‹ã®ã ã‘ã‚Œã©ã‚‚ã‚ˆãä½¿ã†ã‚ˆã†ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã‹ã‚ã£ãŸã‚Šã™ã‚‹ï¼Ÿé€Ÿåº¦ã‚’æ±‚ã‚ãŸã„ã‚“ã 

func saveDataToLocal(data: Data, fileName: String, serializeMethod: SerializeMethod) throws {
        let filePath = FileManager.default.directoryURL(directory: .document).appendingPathComponent(fileName).appendingPathExtension(serializeMethod.fileExtension)

        do {
            try data.write(to: filePath, options: .atomic)
        } catch {
            AppLogger.debugLog("Failed to save data to \(fileName)\(serializeMethod.fileExtension): \(error)", level: .error)
            throw error
        }
    }

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2023/6/15 15:39:55*

Swiftã®Dataã®`write(to:options:)`ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯2ã¤ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã™ã€‚

1. `.atomic`: ã“ã‚Œã¯ãƒ‡ãƒ¼ã‚¿ãŒå®Œå…¨ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹ã¾ã§ã€ä¸€æ™‚çš„ãªè£œåŠ©ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¾ã‚Œã€ãã‚ŒãŒæˆåŠŸã—ãŸã‚‰ã€ãã®è£œåŠ©ãƒ•ã‚¡ã‚¤ãƒ«ãŒæœ€çµ‚çš„ãªç›®çš„åœ°ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚ã‚‚ã—æ›¸ãè¾¼ã¿é€”ä¸­ã§ä½•ã‚‰ã‹ã®å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã§ã‚‚ã€ä»¥å‰ã®ãƒ‡ãƒ¼ã‚¿ã¯ä¿æŒã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€å®Œå…¨æ€§ã¨å®‰å…¨æ€§ã‚’ä¿ã¤ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ãŒã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«ã¯è‹¥å¹²ã®å½±éŸ¿ã‚’åŠã¼ã—ã¾ã™ã€‚

2. `.withoutOverwriting`: ã“ã‚Œã¯ã€æŒ‡å®šã•ã‚ŒãŸURLã«ã™ã§ã«ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ã™ã§ã«ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚

ã‚ãªãŸãŒãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼ˆæ›¸ãè¾¼ã¿é€Ÿåº¦ï¼‰ã‚’æœ€å„ªå…ˆã™ã‚‹ãªã‚‰ã€`.atomic`ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’å–ã‚Šé™¤ãã“ã¨ã‚’æ¤œè¨ã—ã¦ã¿ã¦ãã ã•ã„ã€‚ãŸã ã—ã€ã“ã‚Œã¯ãƒ‡ãƒ¼ã‚¿ã®å®Œå…¨æ€§ã‚„æ›¸ãè¾¼ã¿ã®å®‰å…¨æ€§ã«å½±éŸ¿ã‚’åŠã¼ã™å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚

ã¾ãŸã€æ›¸ãè¾¼ã¿é€Ÿåº¦ã‚’æ”¹å–„ã™ã‚‹ãŸã‚ã®ä»–ã®æ–¹æ³•ã¨ã—ã¦ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ›¸ãè¾¼ã¿ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã§è¡Œã†ã“ã¨ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€UIãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ãªãã€é‡ã„ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿ã‚¿ã‚¹ã‚¯ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

ã¾ãŸã€å¤§ããªãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã£ã¦ã„ã‚‹å ´åˆã€ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†å‰²ã—ã¦ä¸€éƒ¨ãšã¤æ›¸ãè¾¼ã‚€ã“ã¨ã‚’æ¤œè¨ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚ã“ã‚Œã¯ç‰¹ã«å¤§ããªãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã£ã¦ã„ã‚‹å ´åˆã«æœ‰ç”¨ã§ã€ãƒ‡ãƒ¼ã‚¿ã®ä¸€éƒ¨ã‚’å¤±ã†ãƒªã‚¹ã‚¯ã‚’æ¸›ã‚‰ã—ã¾ã™ã€‚

ãŸã ã—ã€ã“ã‚Œã‚‰ã®ã™ã¹ã¦ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã¯ãã‚Œãã‚Œãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ãŒå­˜åœ¨ã™ã‚‹ãŸã‚ã€è¦ä»¶ã¨ä½¿ç”¨çŠ¶æ³ã«ã‚ˆã£ã¦é©åˆ‡ãªé¸æŠã‚’ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2023/6/15 15:41:08*

ã©ã†ã‚„ã£ãŸã‚‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å‡¦ç†ã—ã¦ãã‚‹ã‚ˆã†ã«ãªã‚‹ Swiftã‚³ãƒ³ã‚«ãƒ¬ãƒ³ã‚·ãƒ¼ã‚’ã¤ã‹ã£ã¦ã»ã—ã„

ä»Šã¯ã“ã‚“ãªæ„Ÿã˜ã€‚æ²»ã›ãã†ãªã¨ã“ã‚ã¯ç›´ã—ã¦æ¬²ã—ã„

public func serializeAndUpload(target: SerializableUploadTarget) async throws {
        let serializeMethod: SerializeMethod = userDefaultsManager.isEnableJSONEncode ? .json : .binaryDelimited
        let key: DataKey
        let serializedData: Data

        switch target {
        case .anchor(let anchorKey, let data):
            key = anchorKey
            let convertedData = try data.map { try AnchorConverter.convertToData($0) }
            serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

        case .emotion(let emotionKey, let data):
            key = emotionKey
            let convertedData = try data.map { try EmotionConverter.convertToData($0) }
            serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

        case .interaction(let interactionKey, let data):
            key = interactionKey
            let convertedData = try data.map { try InteractionConverter.convertToData($0) }
            serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)
        }

        if userDefaultsManager.isEnableLocalBackup {
            try saveDataToLocal(data: serializedData, fileName: key.localFileName, serializeMethod: serializeMethod)
        }

        guard serializeMethod == .binaryDelimited else {
            AppLogger.debugLog("Skip upload data because serialize method is not BinaryDelimited")
            return
        }
        try await cloudStorageManager.upload(key: key.path, data: serializedData)
    }

// ä»¥ä¸‹ã® private extension ã§å®Ÿè¡Œã—ã¦ã„ã‚‹é–¢æ•°ã¯ SerializeManager ã¨ã„ã† class ã‚’æ–°è¦ã«ä½œæˆã—ã¦ã€ãã“ã§å®šç¾©ã—ã¦ã‚‚ã‚ˆã•ãã†ã§ã‚ã‚‹ãŒã€ä»–ã§ä½¿ã‚ãªãã†ãªå‡¦ç†ãªã®ã§ä¸€æ—¦ã“ã“ã«ç½®ã„ã¦ã„ã‚‹ï¼ˆä»Šå¾Œã€æ¤œè¨ã™ã‚‹ï¼‰
private extension SerializeAndUploadInteractor {
    func serializeToData(messages: [some Message], serializeMethod: SerializeMethod) throws -&gt; Data {
        let data: Data
        switch serializeMethod {
        case .binaryDelimited:
            data = try serializeToBinaryData(messages: messages)
        case .json:
            data = try serializeToJSONData(messages: messages)
        }
        return data
    }

    func saveDataToLocal(data: Data, fileName: String, serializeMethod: SerializeMethod) throws {
        let filePath = FileManager.default.directoryURL(directory: .document).appendingPathComponent(fileName).appendingPathExtension(serializeMethod.fileExtension)

        do {
            try data.write(to: filePath, options: .atomic)
        } catch {
            AppLogger.debugLog("Failed to save data to \(fileName)\(serializeMethod.fileExtension): \(error)", level: .error)
            throw error
        }
    }

    func serializeToBinaryData(messages: [some Message]) throws -&gt; Data {
        let outputStream = OutputStream.toMemory()
        outputStream.open()

        // ã‚¨ãƒ©ãƒ¼ã‚’ throw ã™ã‚‹ãŸã‚ forEach ãªã©ã¯ä½¿ãˆãªã„
        for message in messages {
            do {
                try BinaryDelimited.serialize(message: message, to: outputStream)
            } catch {
                AppLogger.debugLog("Failed to BinaryDelimited serialize: \(error)", level: .error)
                throw error
            }
        }

        outputStream.close()

        guard let data = outputStream.property(forKey: .dataWrittenToMemoryStreamKey) as? Data else {
            AppLogger.debugLog("Failed to retrieve data from OutputStream", level: .error)
            throw NSError(domain: "EncodingError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to retrieve data from OutputStream"])
        }

        return data
    }

    func serializeToJSONData(messages: [some Message]) throws -&gt; Data {
        var jsonData = Data()

        // ã‚¨ãƒ©ãƒ¼ã‚’ throw ã™ã‚‹ãŸã‚ forEach ãªã©ã¯ä½¿ãˆãªã„
        for message in messages {
            do {
                let stringData = try message.jsonUTF8Data()
                jsonData.append(stringData)
            } catch {
                AppLogger.debugLog("Failed to serialize to JSON: \(error)", level: .error)
                throw error
            }
        }

        return jsonData
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2023/6/15 15:42:09*

Swift 5.5ã‹ã‚‰éåŒæœŸ/åŒæœŸï¼ˆasync/awaitï¼‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã§ã€ãã®æ©Ÿèƒ½ã‚’åˆ©ç”¨ã—ã¦ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã¨ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸‹ã«ãã®ä¸€ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚`Task`ã¨ã„ã†æ–°ã—ã„APIã‚’ä½¿ã£ã¦éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã—ã€`detach`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦æ–°ã—ã„éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œã—ã¾ã™ã€‚`saveDataToLocal`ãƒ¡ã‚½ãƒƒãƒ‰ã¨`cloudStorageManager.upload`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’éåŒæœŸã«å‘¼ã³å‡ºã™ãŸã‚ã«ã€`async`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’éåŒæœŸãƒ¡ã‚½ãƒƒãƒ‰ã«å¤‰æ›ã—ã¾ã™ã€‚

```swift
public func serializeAndUpload(target: SerializableUploadTarget) async throws {
    let serializeMethod: SerializeMethod = userDefaultsManager.isEnableJSONEncode ? .json : .binaryDelimited
    let key: DataKey
    let serializedData: Data

    switch target {
    case .anchor(let anchorKey, let data):
        key = anchorKey
        let convertedData = try data.map { try AnchorConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

    case .emotion(let emotionKey, let data):
        key = emotionKey
        let convertedData = try data.map { try EmotionConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

    case .interaction(let interactionKey, let data):
        key = interactionKey
        let convertedData = try data.map { try InteractionConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)
    }

    if userDefaultsManager.isEnableLocalBackup {
        Task {
            do {
                try await saveDataToLocal(data: serializedData, fileName: key.localFileName, serializeMethod: serializeMethod)
            } catch {
                AppLogger.debugLog("Failed to save data to \(key.localFileName)\(serializeMethod.fileExtension): \(error)", level: .error)
                // throw error // If you want to throw the error to the caller, remove this comment
            }
        }
    }

    guard serializeMethod == .binaryDelimited else {
        AppLogger.debugLog("Skip upload data because serialize method is not BinaryDelimited")
        return
    }

    Task {
        do {
            try await cloudStorageManager.upload(key: key.path, data: serializedData)
        } catch {
            AppLogger.debugLog("Failed to upload data: \(error)", level: .error)
            // throw error // If you want to throw the error to the caller, remove this comment
        }
    }
}

// Your other methods remain the same...

func saveDataToLocal(data: Data, fileName: String, serializeMethod: SerializeMethod) async throws {
    let filePath = FileManager.default.directoryURL(directory: .document).appendingPathComponent(fileName).appendingPathExtension(serializeMethod.fileExtension)
    do {
        try data.write(to: filePath, options: .atomic)
    } catch {
        AppLogger.debugLog("Failed to save data to \(fileName)\(serializeMethod.fileExtension): \(error)", level: .error)
        throw error
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã¨ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2023/6/15 15:42:39*

åŒæ™‚ã«éåŒæœŸã§è¡Œã„ã¾ã™ã€‚ãã®ãŸã‚ã€ã“ã‚Œã‚‰ã®æ“ä½œãŒåŒæ™‚ã«è¡Œã‚ã‚Œã€å…¨ä½“ã¨ã—ã¦ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå‘ä¸Šã—ã¾ã™ã€‚

ãŸã ã—ã€æ³¨æ„ç‚¹ã¨ã—ã¦éåŒæœŸã‚¿ã‚¹ã‚¯ãŒã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼ã™ã‚‹ã¨ã€ãã®ã‚¨ãƒ©ãƒ¼ã¯`Task`ã®ä¸­ã§ã‚­ãƒ£ãƒƒãƒã•ã‚Œã¾ã™ã€‚ãã®ãŸã‚ã€å‘¼ã³å‡ºã—å…ƒã«ã‚¨ãƒ©ãƒ¼ã‚’ä¼ãˆã‚‹ãŸã‚ã«ã¯ã€åˆ¥ã®æ–¹æ³•ã‚’è€ƒãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2023/6/15 15:43:14*

saveDataToLocalã ã‘ãƒãƒƒã‚¯ã‚°ãƒ©ãƒ³ãƒ‰ãŒè‰¯ãã¦ã€ã“ã®å‡¦ç†ã«å¤±æ•—ã—ã¦ã‚‚ä½•ã‚‚ã—ãªãã¦ã„ã„ã‚ˆ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2023/6/15 15:44:04*

äº†è§£ã—ã¾ã—ãŸã€‚`saveDataToLocal`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’éåŒæœŸã‚¿ã‚¹ã‚¯ã¨ã—ã¦ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œã—ã€ãã®å‡¦ç†ãŒå¤±æ•—ã—ãŸå ´åˆã¯ä½•ã‚‚è¡Œã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã«ãã®æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
public func serializeAndUpload(target: SerializableUploadTarget) async throws {
    let serializeMethod: SerializeMethod = userDefaultsManager.isEnableJSONEncode ? .json : .binaryDelimited
    let key: DataKey
    let serializedData: Data

    switch target {
    case .anchor(let anchorKey, let data):
        key = anchorKey
        let convertedData = try data.map { try AnchorConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

    case .emotion(let emotionKey, let data):
        key = emotionKey
        let convertedData = try data.map { try EmotionConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)

    case .interaction(let interactionKey, let data):
        key = interactionKey
        let convertedData = try data.map { try InteractionConverter.convertToData($0) }
        serializedData = try serializeToData(messages: convertedData, serializeMethod: serializeMethod)
    }

    if userDefaultsManager.isEnableLocalBackup {
        Task {
            do {
                try await saveDataToLocal(data: serializedData, fileName: key.localFileName, serializeMethod: serializeMethod)
            } catch {
                AppLogger.debugLog("Failed to save data to \(key.localFileName)\(serializeMethod.fileExtension): \(error)", level: .error)
                // Do nothing if saveDataToLocal fails
            }
        }
    }

    guard serializeMethod == .binaryDelimited else {
        AppLogger.debugLog("Skip upload data because serialize method is not BinaryDelimited")
        return
    }
    
    try await cloudStorageManager.upload(key: key.path, data: serializedData)
}

func saveDataToLocal(data: Data, fileName: String, serializeMethod: SerializeMethod) async throws {
    let filePath = FileManager.default.directoryURL(directory: .document).appendingPathComponent(fileName).appendingPathExtension(serializeMethod.fileExtension)
    do {
        try data.write(to: filePath, options: .atomic)
    } catch {
        AppLogger.debugLog("Failed to save data to \(fileName)\(serializeMethod.fileExtension): \(error)", level: .error)
        throw error
    }
}
```
ã“ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã€`saveDataToLocal`ãƒ¡ã‚½ãƒƒãƒ‰ã¯éåŒæœŸã«å®Ÿè¡Œã•ã‚Œã€å¤±æ•—ã—ãŸå ´åˆã§ã‚‚ãã®ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€UIã®ãƒ–ãƒ­ãƒƒã‚¯ãªã©ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œã‚’é¿ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---
