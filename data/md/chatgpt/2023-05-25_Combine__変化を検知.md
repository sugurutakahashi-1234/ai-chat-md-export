# Combine: 変化を検知

日付: 2023-05-25

---

## 👤 ユーザー
*2023/5/26 3:53:58*

SwiftのCombineで前回の値と比較して変化があったら流れるストリームを実装して欲しい

---

## 🤖 アシスタント
*2023/5/26 3:54:45*

SwiftのCombineフレームワークを使用して、前回の値と比較した際に変化があった場合にのみ値を発行するストリームを実装するには、`removeDuplicates`メソッドを使用します。これはストリーム上の連続した重複値を除去します。

以下に簡単な例を示します：

```swift
import Combine

let publisher = PassthroughSubject<Int, Never>()

let subscription = publisher
    .removeDuplicates()
    .sink { value in
        print("Received value: \(value)")
    }

publisher.send(1)
publisher.send(1) // 重複値は無視されます
publisher.send(2)
publisher.send(2) // 重複値は無視されます
publisher.send(3)

// 出力：
// Received value: 1
// Received value: 2
// Received value: 3
```

この例では、`PassthroughSubject`という特定の`Publisher`を作成し、それに`removeDuplicates`オペレータを適用しています。そして、その結果を`sink`メソッドを使用して購読し、値が流れるたびにコンソールに表示するようにしています。これにより、同じ値が連続して流れると、2回目以降の値は無視され、変化した値のみが出力されます。

`removeDuplicates`はデフォルトで`==`演算子を使用して比較しますが、独自の比較方法を提供することも可能です。例えば：

```swift
publisher
    .removeDuplicates(by: { (oldValue, newValue) in
        // 独自の比較ロジックを記述します
    })
    .sink { value in
        print("Received value: \(value)")
    }
```

上記のコードでは、`removeDuplicates(by:)`を使用して、前回の値と新しい値を比較する独自の方法を提供しています。

---

## 👤 ユーザー
*2023/5/26 3:58:25*

Equatable を適応させなくてはいけないのが大変なんだが、、、

---

## 🤖 アシスタント
*2023/5/26 3:59:07*

`Equatable`を適用するのが困難な場合でも、`removeDuplicates(by:)` を使用してカスタム比較ロジックを実装することが可能です。

次の例は、単に前回の値と新しい値が異なる場合のみ値を発行するストリームを実装します。この場合、`Equatable`は必要ありません：

```swift
import Combine

let publisher = PassthroughSubject<String, Never>()

let subscription = publisher
    .tryRemoveDuplicates(by: { (oldValue, newValue) in
        return oldValue != newValue
    })
    .sink { completion in
        switch completion {
        case .failure(let error):
            print("Received error: \(error)")
        case .finished:
            print("Publisher is finished")
        }
    } receiveValue: { value in
        print("Received value: \(value)")
    }

publisher.send("A")
publisher.send("A") // 重複値は無視されます
publisher.send("B")
publisher.send("B") // 重複値は無視されます
publisher.send("A")

// 出力：
// Received value: A
// Received value: B
// Received value: A
```

この例では、新しい値と前回の値を比較するロジックは、新旧の値が等しくない場合に `true` を返す単純なものです。しかし、このロジックは任意の複雑さを持つことができます。

`tryRemoveDuplicates(by:)`を使用しているので、エラーが発生した場合には `Failure`を受け取ることができます。この例では、そのようなエラーが発生したときにそれを単にプリントしています。

上記のコードでは`String`を使用しましたが、どのような型にも対応可能です。適切な比較ロジックを提供すればいいのです。

---

## 👤 ユーザー
*2023/5/26 4:00:30*

こんな型なのでできなかった。

struct InputtedUserAttributes {
    // TODO: 仮実装
    var nickName: String?
    var gender: SampleUserAttribute?
    var birthday: Date?
    var location: SampleUserAttribute?
    var residenceType: SampleUserAttribute?
    var householdSize: SampleUserAttribute?
    var houseAnnualIncome: SampleUserAttribute?
    var occupation: SampleUserAttribute?
    var industry: SampleUserAttribute?
    var annualIncome: SampleUserAttribute?
    var education: SampleUserAttribute?
}

---

## 🤖 アシスタント
*2023/5/26 4:01:22*

なるほど、構造体 `InputtedUserAttributes` が含む全てのフィールドを比較することはかなり複雑になる可能性がありますね。

しかし、`tryRemoveDuplicates(by:)` を使えば `Equatable` プロトコルを適用せずにこれを実現することが可能です。以下にサンプルのコードを示します：

```swift
import Combine

struct InputtedUserAttributes {
    var nickName: String?
    var gender: String? // 仮にStringとする
    var birthday: Date?
    var location: String? // 仮にStringとする
    // ...他のフィールド...
}

let publisher = PassthroughSubject<InputtedUserAttributes, Never>()

let subscription = publisher
    .tryRemoveDuplicates(by: { (oldValue, newValue) in
        return oldValue.nickName != newValue.nickName ||
               oldValue.gender != newValue.gender ||
               oldValue.birthday != newValue.birthday ||
               oldValue.location != newValue.location
               // 他のフィールドについても同様に比較します...
    })
    .sink { completion in
        switch completion {
        case .failure(let error):
            print("Received error: \(error)")
        case .finished:
            print("Publisher is finished")
        }
    } receiveValue: { value in
        print("Received value: \(value)")
    }
```

ここでは、新旧の値が等しいかどうかをチェックするために、全てのフィールドを個別に比較しています。フィールドの一つでも違いがあれば、その値は新しいものとして扱われます。

ただし、この実装はそれぞれのフィールドを明示的に比較する必要があるため、新たなフィールドが追加された場合にはその比較ロジックも追加する必要があります。また、フィールドの数が多くなるとこの方法は手間がかかる可能性があります。

なお、SampleUserAttribute型の詳細な実装内容によっては、その比較方法も適宜調整する必要があります。上記の例では仮にStringとして扱っています。

---

## 👤 ユーザー
*2023/5/26 4:01:51*

ちなみにこんな型

struct SampleUserAttribute: Equatable, PickerProtocol {
    let id: String
    let name: String
}

---

## 🤖 アシスタント
*2023/5/26 4:02:33*

了解しました。`SampleUserAttribute`型が`Equatable`プロトコルを準拠しているのであれば、`SampleUserAttribute`のインスタンス間の比較はデフォルトの`==`演算子を使用することができます。ですので、`InputtedUserAttributes`の各フィールドを比較する際に、`SampleUserAttribute`型のフィールドはそのまま比較可能です。

以下の例では、`InputtedUserAttributes`が`SampleUserAttribute`の各フィールドを含むように修正しました：

```swift
import Combine

struct SampleUserAttribute: Equatable {
    let id: String
    let name: String
}

struct InputtedUserAttributes {
    var nickName: String?
    var gender: SampleUserAttribute?
    var birthday: Date?
    var location: SampleUserAttribute?
    // ...他のフィールド...
}

let publisher = PassthroughSubject<InputtedUserAttributes, Never>()

let subscription = publisher
    .tryRemoveDuplicates(by: { (oldValue, newValue) in
        return oldValue.nickName != newValue.nickName ||
               oldValue.gender != newValue.gender ||
               oldValue.birthday != newValue.birthday ||
               oldValue.location != newValue.location
               // 他のフィールドについても同様に比較します...
    })
    .sink { completion in
        switch completion {
        case .failure(let error):
            print("Received error: \(error)")
        case .finished:
            print("Publisher is finished")
        }
    } receiveValue: { value in
        print("Received value: \(value)")
    }
```

ここでは、`SampleUserAttribute`型のフィールド（この例では`gender`と`location`）は、`==`演算子を使用して直接比較しています。これは`SampleUserAttribute`が`Equatable`プロトコルに準拠しているためです。

---
