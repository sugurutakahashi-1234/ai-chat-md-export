# å•ã„åˆã‚ã›ç”»é¢ã®ä½œæˆ

æ—¥ä»˜: 2024-08-16

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/8/16 18:29:56*

å•ã„åˆã‚ã›ç”»é¢ã‚’ä½œã‚ŠãŸã„ã€‚
ä»¥ä¸‹ã®2ã¤ã®é …ç›®ã«ãªã‚‹

- å•ã„åˆã‚ã›ç¨®åˆ¥
- å•ã„åˆã‚ã›è©³ç´°


å•ã„åˆã‚ã›ç¨®åˆ¥ã¯ä»¥ä¸‹ã®enum ã§å®šç¾©ã—ã¦ã€displayName: String ã‚’å®šç¾©ã—ã¦ã»ã—ã„ã€‚ã¾ãŸã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæœªé¸æŠã§Pickerã§å®šç¾©ã—ã¦ã»ã—ã„ã€‚â€¨
ä¸å…·åˆã®å ±å‘Š
è¿·æƒ‘è¡Œç‚ºã®å ±å‘Š
æ¨©åˆ©ä¾µå®³ã®å ±å‘Š
ã‚¢ã‚¤ãƒ‡ã‚¢ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
ãã®ä»–ã®ãŠå•ã„åˆã‚ã›
æœªé¸æŠ

å•ã„åˆã‚ã›è©³ç´°ã¯SwiftUIã®TextEditorã‚’ä½¿ã£ã¦æ¬²ã—ã„â€¨
Viewã«ã¯@Stateã‚’æŒãŸãšã«presenterã«@Publishedã‚’æŒãŸã›ã¦æ¬²ã—ã„â€¨
ã¾ãŸã€ã€Œå†…å®¹ã‚’ç¢ºèªã™ã‚‹ã€ã¨ã„ã†ãƒœã‚¿ãƒ³ã‚’ä¸‹éƒ¨ã«é…ç½®ã—ã¦ã€ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨å†…å®¹ç¢ºèªç”»é¢ã«ãªã£ã¦ã€ãã“ã®ä¸‹éƒ¨ã«ã¯ã€Œé€ä¿¡ã™ã‚‹ã€ãƒœã‚¿ãƒ³ã‚’ã¤ã‘ã¦æ¬²ã—ã„
â€¨public struct InquiryView: View {
    @StateObject private var presenter: InquiryPresenter

    public init() {
        \_presenter = .init(wrappedValue: InquiryPresenter())
    }

    public var body: some View {
        VStack {
            Text("TODO: å•ã„åˆã‚ã›")
        }
        .navigationTitle("å•ã„åˆã‚ã›")
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}

@MainActor
final class InquiryPresenter: ObservableObject {
    private let logDriver: any LogDriverProtocol

    init(logDriver: any LogDriverProtocol = LogDriver()) {
        self.logDriver = logDriver

        logDriver.initLog()
    }

    deinit {
        logDriver.deinitLog()
    }

    func onAppear() async {
        logDriver.onAppearLog()
    }

    func onDisappear() {
        logDriver.onDisappearLog()
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/8/16 18:30:05*

User wants to create an inquiry screen with the following items:
- Inquiry Type (using an enum with display names and a default unselected state in a Picker)
- Inquiry Details (using SwiftUI's TextEditor)

The view should have a "Review Content" button at the bottom that navigates to a review screen, which includes a "Send" button at the bottom. The view should use `@StateObject` for the presenter, and the presenter should use `@Published` for state management. The presenter should handle logging with a `LogDriverProtocol`.

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2024/8/16 18:30:05*

Model set context updated.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/8/16 18:30:05*

Here's how you can define the inquiry screen with the requirements you mentioned:

### InquiryType Enum

Define the `InquiryType` enum with `displayName`:

```swift
enum InquiryType: String, CaseIterable, Identifiable {
    case bugReport = "ä¸å…·åˆã®å ±å‘Š"
    case harassmentReport = "è¿·æƒ‘è¡Œç‚ºã®å ±å‘Š"
    case rightsViolationReport = "æ¨©åˆ©ä¾µå®³ã®å ±å‘Š"
    case feedback = "ã‚¢ã‚¤ãƒ‡ã‚¢ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯"
    case other = "ãã®ä»–ã®ãŠå•ã„åˆã‚ã›"
    case none = "æœªé¸æŠ"

    var id: String { rawValue }

    var displayName: String {
        rawValue
    }
}
```

### InquiryPresenter

Update `InquiryPresenter` to include properties for the inquiry type and details:

```swift
@MainActor
final class InquiryPresenter: ObservableObject {
    @Published var selectedInquiryType: InquiryType = .none
    @Published var inquiryDetails: String = ""

    private let logDriver: any LogDriverProtocol

    init(logDriver: any LogDriverProtocol = LogDriver()) {
        self.logDriver = logDriver
        logDriver.initLog()
    }

    deinit {
        logDriver.deinitLog()
    }

    func onAppear() async {
        logDriver.onAppearLog()
    }

    func onDisappear() {
        logDriver.onDisappearLog()
    }
}
```

### InquiryView

Here's how you can set up `InquiryView` with `Picker`, `TextEditor`, and navigation:

```swift
public struct InquiryView: View {
    @StateObject private var presenter: InquiryPresenter

    public init() {
        _presenter = .init(wrappedValue: InquiryPresenter())
    }

    public var body: some View {
        VStack {
            Picker("å•ã„åˆã‚ã›ç¨®åˆ¥", selection: $presenter.selectedInquiryType) {
                ForEach(InquiryType.allCases) { type in
                    Text(type.displayName).tag(type)
                }
            }
            .pickerStyle(MenuPickerStyle()) // Use a different style if preferred

            TextEditor(text: $presenter.inquiryDetails)
                .frame(height: 150) // Adjust the height as needed
                .border(Color.gray, width: 1)
                .padding()

            Spacer()

            NavigationLink(destination: ReviewContentView(presenter: presenter)) {
                Text("å†…å®¹ã‚’ç¢ºèªã™ã‚‹")
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
        }
        .navigationTitle("å•ã„åˆã‚ã›")
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}
```

### ReviewContentView

Define `ReviewContentView` to show the details and include a "Send" button:

```swift
struct ReviewContentView: View {
    @ObservedObject var presenter: InquiryPresenter

    var body: some View {
        VStack {
            Text("å•ã„åˆã‚ã›ç¨®åˆ¥: \(presenter.selectedInquiryType.displayName)")
                .padding()

            Text("å•ã„åˆã‚ã›è©³ç´°:")
                .padding(.top)

            ScrollView {
                Text(presenter.inquiryDetails)
                    .padding()
            }

            Spacer()

            Button("é€ä¿¡ã™ã‚‹") {
                // Handle sending the inquiry
            }
            .padding()
            .background(Color.green)
            .foregroundColor(.white)
            .cornerRadius(8)
        }
        .navigationTitle("å†…å®¹ç¢ºèª")
    }
}
```

This setup uses `@StateObject` for `InquiryPresenter`, displays a `Picker` for selecting the inquiry type, and a `TextEditor` for entering details. The "Review Content" button navigates to a screen where the user can review the content and submit it. Adjust the styles and layout as needed for your design.

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/8/16 18:31:19*

rawValueã¯ã‚„ã‚ã¦æ¬²ã—ã„
enum InquiryType: String, CaseIterable, Identifiable {
    case bugReport = "ä¸å…·åˆã®å ±å‘Š"
    case harassmentReport = "è¿·æƒ‘è¡Œç‚ºã®å ±å‘Š"
    case rightsViolationReport = "æ¨©åˆ©ä¾µå®³ã®å ±å‘Š"
    case feedback = "ã‚¢ã‚¤ãƒ‡ã‚¢ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯"
    case other = "ãã®ä»–ã®ãŠå•ã„åˆã‚ã›"
    case none = "æœªé¸æŠ"

    var id: String { rawValue }

    var displayName: String {
        rawValue
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/8/16 18:31:21*

Understood! If you want to avoid using `rawValue` for the `displayName`, you can directly associate the display names with the enum cases. Here's how you can modify the `InquiryType` enum:

### InquiryType Enum Without rawValue

```swift
enum InquiryType: CaseIterable, Identifiable {
    case bugReport
    case harassmentReport
    case rightsViolationReport
    case feedback
    case other
    case none

    var id: String {
        displayName
    }

    var displayName: String {
        switch self {
        case .bugReport: return "ä¸å…·åˆã®å ±å‘Š"
        case .harassmentReport: return "è¿·æƒ‘è¡Œç‚ºã®å ±å‘Š"
        case .rightsViolationReport: return "æ¨©åˆ©ä¾µå®³ã®å ±å‘Š"
        case .feedback: return "ã‚¢ã‚¤ãƒ‡ã‚¢ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯"
        case .other: return "ãã®ä»–ã®ãŠå•ã„åˆã‚ã›"
        case .none: return "æœªé¸æŠ"
        }
    }
}
```

This version uses a `switch` statement in the `displayName` property to provide the display names for each enum case. It avoids relying on `rawValue` and directly maps each case to its display name.

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/8/16 19:12:49*

presenterã‚’å¼•æ•°ã«ã›ãšã«ã€åˆ†é›¢ã—ãŸã„

struct InquirySendView: View {
    @Environment(\\.dismiss) private var dismiss

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text("å•ã„åˆã‚ã›ç¨®åˆ¥")
                    .font(.headline)
                Spacer()
                Text("\\(presenter.selectedInquiryType.displayName)")
            }
            .padding(.horizontal, 20)
            .padding(.vertical)
            
            HStack {
                Text("å•ã„åˆã‚ã›è©³ç´°")
                    .font(.headline)
                Spacer()
            }
            .padding(.horizontal, 20)
            .padding(.vertical)
            
            ScrollView(.vertical) {
                Text(presenter.inquiryDetailText)
            }
            .padding(.horizontal, 20)
            .padding(.bottom)
            
            Spacer()
            
            Button {
                presenter.onTapSend()
            } label: {
                Text("é€ä¿¡ã™ã‚‹")
                    .font(.title2)
                    .frame(height: 54)
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            .clipShape(.rect(cornerRadius: 50))
            .padding(.bottom, 32)
            .padding(.horizontal, 32)
        }
        .navigationTitle("å•ã„åˆã‚ã›")
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/8/16 19:12:57*

User wants to separate the presenter from the `InquirySendView` by not passing it as an argument. Instead, the view should use environment or other mechanisms to access the necessary data.

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2024/8/16 19:12:57*

Model set context updated.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/8/16 19:12:57*

To separate the presenter from `InquirySendView` and avoid passing it directly as an argument, you can use the `@EnvironmentObject` property wrapper or other mechanisms to access the necessary data. Hereâ€™s how you can do it using `@EnvironmentObject`:

### Update InquiryPresenter

Make sure `InquiryPresenter` conforms to `ObservableObject` and is injected into the environment:

```swift
@MainActor
final class InquiryPresenter: ObservableObject {
    @Published var selectedInquiryType: InquiryType = .none
    @Published var inquiryDetails: String = ""

    private let logDriver: any LogDriverProtocol

    init(logDriver: any LogDriverProtocol = LogDriver()) {
        self.logDriver = logDriver
        logDriver.initLog()
    }

    deinit {
        logDriver.deinitLog()
    }

    func onAppear() async {
        logDriver.onAppearLog()
    }

    func onDisappear() {
        logDriver.onDisappearLog()
    }

    func onTapSend() {
        // Handle sending inquiry
    }

    var inquiryDetailText: String {
        return inquiryDetails
    }
}
```

### Inject Presenter into the Environment

In your app or main view, inject the presenter into the environment:

```swift
@main
struct MyApp: App {
    @StateObject private var inquiryPresenter = InquiryPresenter()

    var body: some Scene {
        WindowGroup {
            NavigationView {
                InquiryView()
                    .environmentObject(inquiryPresenter)
            }
        }
    }
}
```

### InquirySendView Using @EnvironmentObject

Update `InquirySendView` to use `@EnvironmentObject`:

```swift
struct InquirySendView: View {
    @EnvironmentObject private var presenter: InquiryPresenter
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text("å•ã„åˆã‚ã›ç¨®åˆ¥")
                    .font(.headline)
                Spacer()
                Text(presenter.selectedInquiryType.displayName)
            }
            .padding(.horizontal, 20)
            .padding(.vertical)
            
            HStack {
                Text("å•ã„åˆã‚ã›è©³ç´°")
                    .font(.headline)
                Spacer()
            }
            .padding(.horizontal, 20)
            .padding(.vertical)
            
            ScrollView(.vertical) {
                Text(presenter.inquiryDetailText)
            }
            .padding(.horizontal, 20)
            .padding(.bottom)
            
            Spacer()
            
            Button {
                presenter.onTapSend()
                dismiss()
            } label: {
                Text("é€ä¿¡ã™ã‚‹")
                    .font(.title2)
                    .frame(height: 54)
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            .clipShape(.rect(cornerRadius: 50))
            .padding(.bottom, 32)
            .padding(.horizontal, 32)
        }
        .navigationTitle("å•ã„åˆã‚ã›")
    }
}
```

### InquiryView Setup

Ensure `InquiryView` navigates to `InquirySendView` correctly:

```swift
public struct InquiryView: View {
    @StateObject private var presenter: InquiryPresenter

    public init() {
        _presenter = .init(wrappedValue: InquiryPresenter())
    }

    public var body: some View {
        NavigationView {
            VStack {
                Picker("å•ã„åˆã‚ã›ç¨®åˆ¥", selection: $presenter.selectedInquiryType) {
                    ForEach(InquiryType.allCases) { type in
                        Text(type.displayName).tag(type)
                    }
                }
                .pickerStyle(MenuPickerStyle())

                TextEditor(text: $presenter.inquiryDetails)
                    .frame(height: 150)
                    .border(Color.gray, width: 1)
                    .padding()

                Spacer()

                NavigationLink(destination: InquirySendView().environmentObject(presenter)) {
                    Text("å†…å®¹ã‚’ç¢ºèªã™ã‚‹")
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(8)
                }
            }
            .navigationTitle("å•ã„åˆã‚ã›")
        }
    }
}
```

In this setup, `InquirySendView` accesses the `InquiryPresenter` instance through the environment, ensuring it remains decoupled from the presenter initialization and management.

---
