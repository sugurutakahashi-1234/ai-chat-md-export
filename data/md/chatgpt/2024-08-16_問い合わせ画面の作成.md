# 問い合わせ画面の作成

日付: 2024-08-16

---

## 👤 ユーザー
*2024/8/16 18:29:56*

問い合わせ画面を作りたい。
以下の2つの項目になる

- 問い合わせ種別
- 問い合わせ詳細


問い合わせ種別は以下のenum で定義して、displayName: String を定義してほしい。また、デフォルト未選択でPickerで定義してほしい。 
不具合の報告
迷惑行為の報告
権利侵害の報告
アイデアのフィードバック
その他のお問い合わせ
未選択

問い合わせ詳細はSwiftUIのTextEditorを使って欲しい 
Viewには@Stateを持たずにpresenterに@Publishedを持たせて欲しい 
また、「内容を確認する」というボタンを下部に配置して、タップすると内容確認画面になって、そこの下部には「送信する」ボタンをつけて欲しい
 public struct InquiryView: View {
    @StateObject private var presenter: InquiryPresenter

    public init() {
        \_presenter = .init(wrappedValue: InquiryPresenter())
    }

    public var body: some View {
        VStack {
            Text("TODO: 問い合わせ")
        }
        .navigationTitle("問い合わせ")
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}

@MainActor
final class InquiryPresenter: ObservableObject {
    private let logDriver: any LogDriverProtocol

    init(logDriver: any LogDriverProtocol = LogDriver()) {
        self.logDriver = logDriver

        logDriver.initLog()
    }

    deinit {
        logDriver.deinitLog()
    }

    func onAppear() async {
        logDriver.onAppearLog()
    }

    func onDisappear() {
        logDriver.onDisappearLog()
    }
}

---

## 🤖 アシスタント
*2024/8/16 18:30:05*

User wants to create an inquiry screen with the following items:
- Inquiry Type (using an enum with display names and a default unselected state in a Picker)
- Inquiry Details (using SwiftUI's TextEditor)

The view should have a "Review Content" button at the bottom that navigates to a review screen, which includes a "Send" button at the bottom. The view should use `@StateObject` for the presenter, and the presenter should use `@Published` for state management. The presenter should handle logging with a `LogDriverProtocol`.

---

## 🔧 ツール
*2024/8/16 18:30:05*

Model set context updated.

---

## 🤖 アシスタント
*2024/8/16 18:30:05*

Here's how you can define the inquiry screen with the requirements you mentioned:

### InquiryType Enum

Define the `InquiryType` enum with `displayName`:

```swift
enum InquiryType: String, CaseIterable, Identifiable {
    case bugReport = "不具合の報告"
    case harassmentReport = "迷惑行為の報告"
    case rightsViolationReport = "権利侵害の報告"
    case feedback = "アイデアのフィードバック"
    case other = "その他のお問い合わせ"
    case none = "未選択"

    var id: String { rawValue }

    var displayName: String {
        rawValue
    }
}
```

### InquiryPresenter

Update `InquiryPresenter` to include properties for the inquiry type and details:

```swift
@MainActor
final class InquiryPresenter: ObservableObject {
    @Published var selectedInquiryType: InquiryType = .none
    @Published var inquiryDetails: String = ""

    private let logDriver: any LogDriverProtocol

    init(logDriver: any LogDriverProtocol = LogDriver()) {
        self.logDriver = logDriver
        logDriver.initLog()
    }

    deinit {
        logDriver.deinitLog()
    }

    func onAppear() async {
        logDriver.onAppearLog()
    }

    func onDisappear() {
        logDriver.onDisappearLog()
    }
}
```

### InquiryView

Here's how you can set up `InquiryView` with `Picker`, `TextEditor`, and navigation:

```swift
public struct InquiryView: View {
    @StateObject private var presenter: InquiryPresenter

    public init() {
        _presenter = .init(wrappedValue: InquiryPresenter())
    }

    public var body: some View {
        VStack {
            Picker("問い合わせ種別", selection: $presenter.selectedInquiryType) {
                ForEach(InquiryType.allCases) { type in
                    Text(type.displayName).tag(type)
                }
            }
            .pickerStyle(MenuPickerStyle()) // Use a different style if preferred

            TextEditor(text: $presenter.inquiryDetails)
                .frame(height: 150) // Adjust the height as needed
                .border(Color.gray, width: 1)
                .padding()

            Spacer()

            NavigationLink(destination: ReviewContentView(presenter: presenter)) {
                Text("内容を確認する")
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
        }
        .navigationTitle("問い合わせ")
        .task {
            await presenter.onAppear()
        }
        .onDisappear {
            presenter.onDisappear()
        }
    }
}
```

### ReviewContentView

Define `ReviewContentView` to show the details and include a "Send" button:

```swift
struct ReviewContentView: View {
    @ObservedObject var presenter: InquiryPresenter

    var body: some View {
        VStack {
            Text("問い合わせ種別: \(presenter.selectedInquiryType.displayName)")
                .padding()

            Text("問い合わせ詳細:")
                .padding(.top)

            ScrollView {
                Text(presenter.inquiryDetails)
                    .padding()
            }

            Spacer()

            Button("送信する") {
                // Handle sending the inquiry
            }
            .padding()
            .background(Color.green)
            .foregroundColor(.white)
            .cornerRadius(8)
        }
        .navigationTitle("内容確認")
    }
}
```

This setup uses `@StateObject` for `InquiryPresenter`, displays a `Picker` for selecting the inquiry type, and a `TextEditor` for entering details. The "Review Content" button navigates to a screen where the user can review the content and submit it. Adjust the styles and layout as needed for your design.

---

## 👤 ユーザー
*2024/8/16 18:31:19*

rawValueはやめて欲しい
enum InquiryType: String, CaseIterable, Identifiable {
    case bugReport = "不具合の報告"
    case harassmentReport = "迷惑行為の報告"
    case rightsViolationReport = "権利侵害の報告"
    case feedback = "アイデアのフィードバック"
    case other = "その他のお問い合わせ"
    case none = "未選択"

    var id: String { rawValue }

    var displayName: String {
        rawValue
    }
}

---

## 🤖 アシスタント
*2024/8/16 18:31:21*

Understood! If you want to avoid using `rawValue` for the `displayName`, you can directly associate the display names with the enum cases. Here's how you can modify the `InquiryType` enum:

### InquiryType Enum Without rawValue

```swift
enum InquiryType: CaseIterable, Identifiable {
    case bugReport
    case harassmentReport
    case rightsViolationReport
    case feedback
    case other
    case none

    var id: String {
        displayName
    }

    var displayName: String {
        switch self {
        case .bugReport: return "不具合の報告"
        case .harassmentReport: return "迷惑行為の報告"
        case .rightsViolationReport: return "権利侵害の報告"
        case .feedback: return "アイデアのフィードバック"
        case .other: return "その他のお問い合わせ"
        case .none: return "未選択"
        }
    }
}
```

This version uses a `switch` statement in the `displayName` property to provide the display names for each enum case. It avoids relying on `rawValue` and directly maps each case to its display name.

---

## 👤 ユーザー
*2024/8/16 19:12:49*

presenterを引数にせずに、分離したい

struct InquirySendView: View {
    @Environment(\\.dismiss) private var dismiss

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text("問い合わせ種別")
                    .font(.headline)
                Spacer()
                Text("\\(presenter.selectedInquiryType.displayName)")
            }
            .padding(.horizontal, 20)
            .padding(.vertical)
            
            HStack {
                Text("問い合わせ詳細")
                    .font(.headline)
                Spacer()
            }
            .padding(.horizontal, 20)
            .padding(.vertical)
            
            ScrollView(.vertical) {
                Text(presenter.inquiryDetailText)
            }
            .padding(.horizontal, 20)
            .padding(.bottom)
            
            Spacer()
            
            Button {
                presenter.onTapSend()
            } label: {
                Text("送信する")
                    .font(.title2)
                    .frame(height: 54)
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            .clipShape(.rect(cornerRadius: 50))
            .padding(.bottom, 32)
            .padding(.horizontal, 32)
        }
        .navigationTitle("問い合わせ")
    }
}

---

## 🤖 アシスタント
*2024/8/16 19:12:57*

User wants to separate the presenter from the `InquirySendView` by not passing it as an argument. Instead, the view should use environment or other mechanisms to access the necessary data.

---

## 🔧 ツール
*2024/8/16 19:12:57*

Model set context updated.

---

## 🤖 アシスタント
*2024/8/16 19:12:57*

To separate the presenter from `InquirySendView` and avoid passing it directly as an argument, you can use the `@EnvironmentObject` property wrapper or other mechanisms to access the necessary data. Here’s how you can do it using `@EnvironmentObject`:

### Update InquiryPresenter

Make sure `InquiryPresenter` conforms to `ObservableObject` and is injected into the environment:

```swift
@MainActor
final class InquiryPresenter: ObservableObject {
    @Published var selectedInquiryType: InquiryType = .none
    @Published var inquiryDetails: String = ""

    private let logDriver: any LogDriverProtocol

    init(logDriver: any LogDriverProtocol = LogDriver()) {
        self.logDriver = logDriver
        logDriver.initLog()
    }

    deinit {
        logDriver.deinitLog()
    }

    func onAppear() async {
        logDriver.onAppearLog()
    }

    func onDisappear() {
        logDriver.onDisappearLog()
    }

    func onTapSend() {
        // Handle sending inquiry
    }

    var inquiryDetailText: String {
        return inquiryDetails
    }
}
```

### Inject Presenter into the Environment

In your app or main view, inject the presenter into the environment:

```swift
@main
struct MyApp: App {
    @StateObject private var inquiryPresenter = InquiryPresenter()

    var body: some Scene {
        WindowGroup {
            NavigationView {
                InquiryView()
                    .environmentObject(inquiryPresenter)
            }
        }
    }
}
```

### InquirySendView Using @EnvironmentObject

Update `InquirySendView` to use `@EnvironmentObject`:

```swift
struct InquirySendView: View {
    @EnvironmentObject private var presenter: InquiryPresenter
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text("問い合わせ種別")
                    .font(.headline)
                Spacer()
                Text(presenter.selectedInquiryType.displayName)
            }
            .padding(.horizontal, 20)
            .padding(.vertical)
            
            HStack {
                Text("問い合わせ詳細")
                    .font(.headline)
                Spacer()
            }
            .padding(.horizontal, 20)
            .padding(.vertical)
            
            ScrollView(.vertical) {
                Text(presenter.inquiryDetailText)
            }
            .padding(.horizontal, 20)
            .padding(.bottom)
            
            Spacer()
            
            Button {
                presenter.onTapSend()
                dismiss()
            } label: {
                Text("送信する")
                    .font(.title2)
                    .frame(height: 54)
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            .clipShape(.rect(cornerRadius: 50))
            .padding(.bottom, 32)
            .padding(.horizontal, 32)
        }
        .navigationTitle("問い合わせ")
    }
}
```

### InquiryView Setup

Ensure `InquiryView` navigates to `InquirySendView` correctly:

```swift
public struct InquiryView: View {
    @StateObject private var presenter: InquiryPresenter

    public init() {
        _presenter = .init(wrappedValue: InquiryPresenter())
    }

    public var body: some View {
        NavigationView {
            VStack {
                Picker("問い合わせ種別", selection: $presenter.selectedInquiryType) {
                    ForEach(InquiryType.allCases) { type in
                        Text(type.displayName).tag(type)
                    }
                }
                .pickerStyle(MenuPickerStyle())

                TextEditor(text: $presenter.inquiryDetails)
                    .frame(height: 150)
                    .border(Color.gray, width: 1)
                    .padding()

                Spacer()

                NavigationLink(destination: InquirySendView().environmentObject(presenter)) {
                    Text("内容を確認する")
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(8)
                }
            }
            .navigationTitle("問い合わせ")
        }
    }
}
```

In this setup, `InquirySendView` accesses the `InquiryPresenter` instance through the environment, ensuring it remains decoupled from the presenter initialization and management.

---
