# リップル表示修正方法

Date: 2025-01-25

---

## 👤 User
*2025-01-25 22:46:01*

タップ時のリップルが反映されないんだ

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/infrastructure/entities/extensions/camera_dto_x.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_account.dart';
import 'package:snpit_guild_app/presentation/providers/editing_camera_list.dart';
import 'package:snpit_guild_app/presentation/widgets/camera_row.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';

class CameraListPage extends HookConsumerWidget {
  const CameraListPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // TODO: [カメラ] 本来はカメラAPIから取得する
    final myAccountAsyncValue = ref.read(getMyAccountNotifierProvider);
    final editingCameraListStateValue =
        ref.watch(editingCameraListNotifierProvider);
    final selectedCameraIndexState = useState&lt;int?&gt;(null);
    final selectedCamera = useState&lt;CameraDTO?&gt;(null);

    Future&lt;void&gt; onTapPutCamera() async {
      final camera = selectedCamera.value;
      if (camera != null) {
        ref.read(editingCameraListNotifierProvider.notifier).addCamera(camera);
      }

      context.pop();
    }

    Future&lt;void&gt; onTapCamera(int index, CameraDTO camera) async {
      selectedCameraIndexState.value = index;
      selectedCamera.value = camera;
    }

    useEffect(
      () {
        Future.microtask(() async {
          try {
            await ref
                .read(getMyAccountNotifierProvider.notifier)
                .getMyAccount();
          } on Exception catch (error) {
            if (context.mounted) {
              showErrorSnackBar(context, error);
            }
          }
        });
        return null;
      },
      [],
    );

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: false,
        title: const Text(
          'Camera list',
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: () {
              context.pop();
            },
          ),
        ],
      ),
      body: myAccountAsyncValue.when(
        data: (account) {
          // final cameraList = account?.decks?.first.deckCameras ?? [];
          final cameraList = [
            account!.decks!.first.deckCameras!.first,
            account.decks!.first.deckCameras!.first,
          ]
              .where(
                (camera) =&gt; !editingCameraListStateValue.any(
                  (editingCamera) =&gt; editingCamera.cameraId == camera.cameraId,
                ),
              )
              .toList()
              .sorted();

          if (cameraList.isEmpty) {
            return const Center(
              child: Text('No camera'),
            );
          }

          return Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: cameraList.asMap().entries.map((entry) {
                final index = entry.key;
                final camera = entry.value;

                return Padding(
                  padding: const EdgeInsets.only(bottom: 8),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: () async {
                        await onTapCamera(index, camera);
                      },
                      borderRadius: BorderRadius.circular(8),
                      child: DecoratedBox(
                        decoration: BoxDecoration(
                          color: ColorToken.bg,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: selectedCameraIndexState.value == index
                                ? ColorToken.primary
                                : ColorToken.border,
                          ),
                        ),
                        child: CameraRow(camera: camera),
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
          );
        },
        loading: () =&gt; const Center(child: CircularProgressIndicator()),
        error: (error, stack) =&gt; Center(child: Text('Error: $error')),
      ),
      bottomNavigationBar: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: ElevatedButton(
            onPressed: () async {
              await onTapPutCamera();
            },
            child: const Text('Put Camera'),
          ),
        ),
      ),
    );
  }
}

---

## 🔧 Tool
*2025-01-25 22:46:23*

**Examining Flutter code**

I’m looking into a Flutter code snippet where the user is noticing a missing ripple effect on tap. This is likely due to not using a Material widget or lacking a Theme for the InkWell.

**Ensuring clarity**

To guarantee the ripple effect visibility, avoiding a fully transparent color in the Material widget is crucial. Consider using an Ink widget behind the child or removing the transparent setting.

**Wondering about visibility**

The ripple effect might be hidden by a `DecoratedBox` with `BoxDecoration`, which doesn’t allow ink to diffuse. Using an `Ink` widget or removing transparency might help.

**Refining the ripple effect**

To ensure the ripple effect, using an `Ink` widget around `InkWell` or removing decoration from `InkWell`'s child is recommended, especially for custom shapes or backgrounds.

**Ensuring ripple visibility**

To enhance the ripple effect, it’s crucial to add a background color to the Material widget and remove the DecoratedBox. Also, confirm the presence of a MaterialApp or Scaffold.

**Pinpointing the root**

The absence of the ripple effect is likely due to the transparent Material color and the internal DecoratedBox, which blocks the ink from being painted.

**Making a material selection**

To ensure the ripple effect in Flutter, the use of a `Material` widget with a defined color, or the inclusion of an `Ink` widget, or the removal of a `DecoratedBox` is essential.

---

## 🤖 Assistant
*2025-01-25 22:46:23*

Flutterの「リップル」(Inkエフェクト)は、**InkWell とそれを描画するための Material (あるいは Ink) がセット**になっている必要があります。現状のコードだと、`Material(color: Colors.transparent)` の上にさらに `DecoratedBox` を置いているため、リップルが描画されず見えなくなっている可能性が高いです。

よく使われるパターンとしては、以下のように **`Ink` + `InkWell` の組み合わせ**でデコレーション込みの領域に対してリップルを表示するやり方です。`Material` ウィジェットを透明で包んでしまう場合は、Inkの描画領域が隠れてしまうケースがあるため、`DecoratedBox` の代わりに `Ink` を使うのがポイントです。

例えば以下のように書き換えることでリップルが表示されるようになります。

```dart
return Padding(
  padding: const EdgeInsets.only(bottom: 8),
  child: Material(
    // あるいは MaterialType.card 等、お好みで
    color: Colors.transparent,
    child: Ink(
      decoration: BoxDecoration(
        color: ColorToken.bg,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: selectedCameraIndexState.value == index
              ? ColorToken.primary
              : ColorToken.border,
        ),
      ),
      child: InkWell(
        onTap: () async {
          await onTapCamera(index, camera);
        },
        borderRadius: BorderRadius.circular(8),
        child: CameraRow(camera: camera),
      ),
    ),
  ),
);
```

### よくあるパターン

1. **Material + InkWell のみで完結する場合**  
   親の `Material` に色を指定し、`InkWell` の `child` に配置したウィジェット全体をタップ領域としてリップルさせる。

   ```dart
   Material(
     color: Colors.white, // 透過にしない
     child: InkWell(
       onTap: onTap,
       child: Padding(
         padding: const EdgeInsets.all(16.0),
         child: Text('タップ領域'),
       ),
     ),
   );
   ```

2. **デコレーション付きの領域にリップルを出したい場合**  
   `Ink` ウィジェットを使ってデコレーションを指定し、その中に `InkWell` を置く。

   ```dart
   Material(
     color: Colors.transparent,
     child: Ink(
       decoration: BoxDecoration(
         color: Colors.white,
         borderRadius: BorderRadius.circular(8),
       ),
       child: InkWell(
         onTap: onTap,
         borderRadius: BorderRadius.circular(8),
         child: Padding(
           padding: const EdgeInsets.all(16.0),
           child: Text('タップ領域'),
         ),
       ),
     ),
   );
   ```

多くの場合、後者の方が装飾を保ったままリップルを実現できるので便利です。  
したがって、上記のように `DecoratedBox` の代わりに `Ink` を使う (もしくはリップルを描画可能な `Material` ウィジェットに直接色を指定してしまう) ことで、タップ時のリップルがきちんと表示されるようになります。

---
