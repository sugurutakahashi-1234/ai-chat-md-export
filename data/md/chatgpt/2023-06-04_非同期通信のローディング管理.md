# 非同期通信のローディング管理

Date: 2023-06-04

---

## 👤 User
*2023-06-05 02:51:34*

swiftでの通信を行うasync/awaitの関数で、実行の前処理でローディング状態をtrueにして、通信後にfalseにしたい。ただ、この処理は失敗するかのせいがあったり、funcを定義しているclassが削除される可能性があるので、その辺のことが起きてもローディング状態をfalseにしたい場合はどうすればいいのかおしえてほしい。

---

## 🤖 Assistant
*2023-06-05 02:52:10*

`Swift 5.5`以降では、`async/await`を利用して非同期の通信を行うことができます。ローディング状態を管理するためには、非同期タスクが成功、失敗、あるいはキャンセルされた場合でも安全に後処理を行う必要があります。

そのため、以下のように`defer`ステートメントを使うと良いでしょう。`defer`は、現在のスコープから退出するときに必ず実行されるコードブロックを提供します。これにより、非同期タスクがどのような結果で終了しても、`isLoading`が`false`に設定されることが保証されます。

```swift
class MyNetworkingClass {
    var isLoading: Bool = false
    
    func fetchData() async throws {
        isLoading = true
        defer {
            isLoading = false
        }

        // Do the network task
        let url = URL(string: "https://example.com")!
        let (data, response) = try await URLSession.shared.data(from: url)
        // ... handle data and response
    }
}
```

ただし、これは`MyNetworkingClass`インスタンスが存在し続ける限り有効です。もし`fetchData`メソッドが実行中に`MyNetworkingClass`インスタンスが解放された場合、`isLoading`は解放され、アクセスすることはできません。そういった場合には、`isLoading`を管理するためのシングルトンクラスやグローバル変数を使用することで解決できる可能性がありますが、この解決策はアプリケーション全体の設計やアーキテクチャに依存します。

また、Swiftの非同期タスクは終了時に`Task`オブジェクトを返すので、そのオブジェクトを用いてタスクの状態を追跡することも可能です。ただし、これも同じく`MyNetworkingClass`インスタンスが存在する限り有効です。

---
