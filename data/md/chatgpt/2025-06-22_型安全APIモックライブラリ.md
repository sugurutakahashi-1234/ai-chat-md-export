# 型安全APIモックライブラリ

Date: 2025-06-22

---

## 👤 User
*2025-06-22 15:50:07*

今、TypeScript で APIのmockするライブラリを検討しているが、どんな選択肢があるだろうか？
型安全なものでいくつか紹介して欲しい。vitestや開発時に使いやすいものがよくgitのスター数や伸びや最近の流行りも知りたい。

---

## 🤖 Assistant
*2025-06-22 15:50:44*

## 主要な型安全 API モックライブラリ（2025-06-22 時点）

### 1. **Mock Service Worker (MSW)**
* **スター数** 16.8 k citeturn1view0  
* **特徴**  
  * ブラウザ／Node 双方で `fetch` / XHR を透過的にインターセプト。  
  * ルーティングは Express ライクで型定義付き。  
  * `@mswjs/msw/node` + `setupServer()` を使うと **Vitest** に即組み込み可。  
  * OpenAPI→MSW 用ハンドラを自動生成するツール（*orval* など）とも相性が良く、スター数も毎年 3〜4 k ずつ伸びており “デファクト” の位置を固めています。  
* **こんな時に**  
  * UI テストとE2Eを同じモックで回したい  
  * ブラウザで本番さながらに動作確認したい

---

### 2. **Orval**
* **スター数** 4.1 k citeturn3view0  
* **特徴**  
  * OpenAPI から **型安全なクライアント**と **MSW モック** を同時生成。  
  * `tanstack/react-query`・`zod`・`faker` 連携オプションあり。  
  * “定義駆動” 開発に強く、コード量を極力減らしたいときに便利。  
* **こんな時に**  
  * すでに OpenAPI がある、または Contract-First で進めたい  
  * モックと実クライアントを 1 コマンドで揃えたい

---

### 3. **Zodios**
* **スター数** 1.8 k citeturn2view0  
* **特徴**  
  * **Zod スキーマ**で API を宣言し、同時にクライアント・モックを生成。  
  * 軽量／ゼロコードジェネレーションで “手触り” が良い。  
  * `@tanstack/query` 用フックや Express アダプタも同梱。  
* **こんな時に**  
  * OpenAPI ほど重い仕様は不要だが **厳密な型安全** が欲しい  
  * Zod をプロジェクトの中心バリデータに据えている

---

### 4. **Mockoon**
* **スター数** 7.3 k citeturn5view0  
* **特徴**  
  * GUI でモック API を作成 → CLI や Docker で共有／CI 実行も可。  
  * OpenAPI インポート／エクスポート対応。  
  * “手動でレスポンスをいじりながら動作確認” する UX が強み。  
* **留意点** : コードベースから直接型を得られるわけではなく、**型安全性は OpenAPI に依存**。

---

### 5. **Nock**
* **スター数** 13 k citeturn9view0  
* **特徴**  
  * Node 専用の老舗 HTTP モック。シンタックスはシンプルで学習コスト低め。  
  * 近年は **型定義が整備** されており、基本的な型安全は確保。  
* **留意点** : Service Worker ベースの MSW と違い **ブラウザ側では動作しない**。フロントエンドの統合テストよりは、バックエンド/SDK 単体テスト向き。

---

### 6. **vi-fetch**（参考）
* **スター数** 56・**2024-05 でアーカイブ済み** citeturn4view0  
* Vitest に特化した軽量モックですが、作者が **「MSW を使ってほしい」** と明言して開発終了。新規導入は推奨されません。

---

## 選定のヒント

| 目的 | 最適候補 | 補足 |
|------|----------|------|
| UI/E2E とユニットテストを同じ DSL で共通化 | **MSW** | 公式の Vitest/Playwright セットアップガイドあり |
| OpenAPI 契約を中心に “フル自動生成” したい | **Orval** | MSW ハンドラ + React Query フックを一括生成 |
| Zod に統一したスキーマ管理をしたい | **Zodios** | API 宣言・バリデーション・モックが 1 つの DSL |
| ノーコード/GUI で手早くモックを共有 | **Mockoon** | デザイナーや QA と非エンジニア連携しやすい |
| Node のみで外部 HTTP を切り分けたい | **Nock** | レガシー資産が多い場合にまだ利用価値あり |

---

### 個人的なおすすめフロー

1. **Contract-First**                : OpenAPI ⇒ *Orval* でクライアント＋MSW モック生成  
2. **UI テスト・ローカル開発**      : 生成された **MSW** だけを使い回す  
3. **エッジケース手動テストが必要** : Mockoon で GUI 追加モックを作り MSW の上にプロキシ

こうしておくと **Vitest／Playwright／Storybook** すべてで同一のモックを扱え、型安全性と DX を両立できます。

---

## 👤 User
*2025-06-22 15:56:20*

https://fakerjs.dev/やhttps://github.com/ladjs/supertestはどうだろうか？
他の選択肢と比べてopenapi形式と相性がいいものはどれか？

---

## 🤖 Assistant
*2025-06-22 15:56:44*

### Faker.js と Supertest の位置づけ

| ライブラリ | 主目的 | 型安全 | OpenAPI との相性 | GitHub ⭐ (2025-06-22) |
|-----------|--------|--------|-----------------|-------------------------|
| **Faker.js** | ダミーデータ生成 | ✅ (完全 TS 対応) | *単体では仕様連携なし*&lt;br&gt;→ Prism の `x-faker` や Orval のモック生成に採用されるケース多い | 14 k citeturn2view0 |
| **Supertest** | Node サーバーの **実動 API** を叩いてアサーション | ✅ 型定義あり | 公式連携は無し。&lt;br&gt;ただし community 製の **supertest-openapi-validator** でレスポンスを OpenAPI と突き合わせ可 citeturn0search3 | 14.1 k citeturn0search2 |

&gt; **要点**  
&gt; *Faker.js* は「モック *レスポンス中の値* をリアリスティックにする補助ツール」  
&gt; *Supertest* は「サーバー実装が **契約どおり** か検証するユニット／統合テスト用クライアント」  
&gt; どちらも **“モックサーバーを用意する” ライブラリではない** ため、OpenAPI を丸ごと読み込んで自動モックを作る用途には別のツールを組み合わせます。

---

### OpenAPI 契約と “親和性” の比較

| 親和性ランク | ライブラリ | 仕組み |
|--------------|-----------|-------|
| 🥇 **Orval + MSW** | OpenAPI → **型安全クライアント**と **MSW ハンドラ**を一括生成。faker でダミーデータも注入可。Stars: 4.1 k (Orval) / 16.8 k (MSW) citeturn3view0turn4view0 |
| 🥈 **Stoplight Prism** | OpenAPI ファイルをそのまま読み込み、`x-faker` 拡張で Faker.js によるリアルなレスポンスを自動生成 citeturn0search9 |
| 🥉 **Zodios (＋zodios-openapi)** | Zod で書いた宣言からクライアント／サーバーを生成し、必要なら OpenAPI v3 へエクスポート citeturn5view0turn1search4 |
| 参考 | **Supertest ＋ supertest-openapi-validator** | 既存 API 実装が OpenAPI と一致するかを **テスト時** に検証するアプローチ。モックは作らない。 |
| 参考 | **Faker.js 単体** | OpenAPI → モック レスポンスを生成するツール（例: *openapi-mock-generator*）の“データ工場”として採用される citeturn0search5 |

---

### どう選ぶか？

| 目的 | ベストチョイス | 補足 |
|------|---------------|------|
| **フロントエンド開発／Vitest** で “同じハンドラ” をローカル・E2E・Storybook まで共有したい | **Orval + MSW** | 生成時に `mock: true` を指定するだけ。faker で自動ダミーも注入可能。 |
| **OpenAPI だけ渡されて**「今すぐ動くモックサーバー」が欲しい | **Prism** | コード不要。CLI 一発で起動。`x-faker` を書くとレスポンスがリアルになる。 |
| **Zod を中心**に型＆バリデーション管理したい | **Zodios** | Zod スキーマ＝API 定義。必要なら `zodios-openapi` で後から OpenAPI を生成。 |
| **既存の Node REST** が OpenAPI どおりに返しているか **CI で保証**したい | **Supertest + supertest-openapi-validator** | サーバーを立ち上げずに **in-process** で実装検証が可能。 |
| **ダミーデータだけ** もっとリアルにしたい | Faker.js を **上記ツールのプラグイン**として使う | 例: Orval の `faker: true`, Prism の `x-faker` など。 |

---

## まとめ

- **Faker.js** と **Supertest** は “OpenAPI 仕様からモックを作る” というより、  
  - **Faker.js** ➜ モックに **現実味ある値** を流し込むツール。  
  - **Supertest** ➜ **実装⇔仕様** のズレをテストで検出するツール。  
- **OpenAPI への親和性** を重視するなら **Orval + MSW** が最も DX が高く、  
  - 自動生成された MSW ハンドラに Faker データを組み込める  
  - クライアント型・React Query フック・モックを **1 コマンド** で揃えられる  
- GUI で触りたい場合は **Prism**、Zod ベースなら **Zodios** も選択肢。  

現行のフロント／バック両方の開発フローを鑑みて、**「OpenAPI → 自動コード & モック生成」**のレイヤをまず固め、その上で Faker.js や Supertest を “補完ツール” として組み込むのが最も無駄のない組み合わせです。

---

## 👤 User
*2025-06-22 16:01:52*

Faker.js と Prism の相性がいいのか？

---

## 🤖 Assistant
*2025-06-22 16:02:12*

### 結論 ― **相性は “良いが、癖がある”**

- **Prism は内部で Faker.js（+ JSON Schema Faker）を標準採用**しており、`prism mock -d` で **スキーマ準拠のランダム値**を自動生成します。citeturn5view0turn8search0  
- OpenAPI に `x-faker` ベンダー拡張を付けると **Faker API を直接呼び出して**フィールド単位で「名前」「メール」などを細かく指定できます。citeturn5view0turn4view0  
- つまり **「OpenAPI ⇒ Prism ⇒ Faker」** という流れが公式想定のワークフローで、ツールを追加せずに *契約駆動 × ライフライクなダミーデータ* が実現できます。

---

## 実用面のメリット

| 目的 | Prism × Faker で得られるもの |
|------|---------------------------|
| **Contract First 開発** | OpenAPI さえあれば即 `prism mock` でモック稼働。&lt;br&gt;Faker により **例が無いプロパティも動的値** が入るので、クライアント側が「固定サンプル依存」になりにくい。citeturn5view0 |
| **テスト・デバッグ** | スキーマバリデーション + ランダム値で境界値や欠損値テストが容易。|
| **コード量削減** | Faker を直接 import する必要がなく、OpenAPI の `x-faker` だけで制御できる。|

### `x-faker` の最小例

```yaml
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
          x-faker: person.fullName     # Faker.person.fullName()
        email:
          type: string
          format: email
          x-faker: internet.email
```

`prism mock -d openapi.yaml` を起動すると、`/users` エンドポイントのレスポンスには
```json
{
  "id": "3f94e280-fd4e-4c37-a4f0-28ed7190a5b3",
  "name": "岡田 明美",
  "email": "akemi.okada73@example.com"
}
```
のような Faker 生成値が自動注入されます。

---

## 注意点・制限

| 項目 | 説明 |
|------|------|
| **Faker バージョン固定** | Prism 5.x 系は `@faker-js/faker` **v6 系**に固定（`^6.0.0`）。v8 以降の新 API は使えません。citeturn1search0 |
| **パラメータ渡し不可** | `address.cardinalDirection(useAbbr: true)` のような *メソッド引数* は `x-faker` からは指定できません (Issue #2087 など)。citeturn0search1 |
| **複雑制約** | `min/max` など Schema 側の制約は **JSON Schema Faker が優先**されるため、Faker の値が範囲外になるケースがある。必要なら `minimum`/`maximum` キーワードを併用。|
| **多言語ロケール** | Prism は Faker のロケール設定を表向き公開していないため、特定言語のダミーデータが欲しければ自前で例を追加する方が確実。|

---

## どう使い分ける？

1. **手軽さ優先**  
   - OpenAPI に `x-faker` を書いて **Prism だけで完結**。  
2. **生成パターンをもっと細かく制御**したい  
   - `json-schema-faker` を単体で使い、生成した例を `example` に貼る。  
3. **最新 Faker API を使いたい / Zod で統一したい**  
   - Orval + MSW で `faker: true` オプションを使う（Faker v9 互換）。  
4. **CI で契約との整合性も検証**  
   - Prism を **proxy モード**で起動し、Supertest などで実装ロジックを叩く。

---

### まとめ

- **Faker.js と Prism は“公式に結びついている”ため相性は良好**。  
- ただし **バージョン固定と引数未対応**など細かい制約があるので、  
  - OpenAPI に軽く `x-faker` を添えるレベルなら十分  
  - **高度なダミーデータ生成**が必要なら *Orval + MSW* や *json-schema-faker* との併用を検討  
- いずれも **OpenAPI を中心に据えたワークフロー**を維持できる点が最大の利点です。

---

## 👤 User
*2025-06-22 16:06:54*

以下について詳しく

Orval + MSW で faker: true オプションを使う（Faker v9 互換）。

---

## 🤖 Assistant
*2025-06-22 16:07:44*

### Orval + MSW + Faker の全体像  
Orval で `output.mock: true` を指定すると **MSW ハンドラ**と**Faker で作られたダミーデータ**を同時に生成します。Orval 7.x 系は `@faker-js/faker` v9 系 API でテンプレートが書かれているため、そのまま **Faker v9 互換**で動きます。citeturn7view0  

---

## 1. セットアップ手順

```bash
pnpm add -D \
  orval @faker-js/faker msw \
  @tanstack/react-query @tanstack/react-query-devtools
```

&gt; Node ≥ 18 / TypeScript ≥ 5 を前提とした構成です。  

---

## 2. `orval.config.ts` の最小例

```ts
import { defineConfig } from 'orval';
import { faker } from '@faker-js/faker';

export default defineConfig({
  petstore: {
    /* --- OpenAPI 入力 --- */
    input: './openapi/petstore.yaml',

    /* --- 出力設定 --- */
    output: {
      mode: 'split',                 // *.ts / *.schemas.ts / *.msw.ts に分割
      target: 'src/api/petstore.ts',
      schemas: 'src/api/model',
      client: 'react-query',
      /**
       * ★ ここがポイント
       * mock: true だけで
       *   - faker で型に沿ったダミー値
       *   - MSW ハンドラ
       * を生成
       */
      mock: {
        type: 'msw',
        delay: 500,    // 500 ms レイテンシ
        locale: 'ja',  // Faker のロケール
      },

      /** 個別エンドポイントの上書きも可能 */
      override: {
        operations: {
          listPets: {
            mock: {
              // data でレスポンス全体を、properties で部分的に上書き
              data: () => ({
                id: faker.number.int({ min: 1, max: 999 }),
                name: faker.person.fullName(),      // Faker v9 API
              }),
            },
          },
        },
      },
    },
  },
});
```

上記は公式 “Full example” を簡略化したものです。詳細なオーバーライド例はドキュメントにも載っています。citeturn12view0  

生成コマンド:

```bash
npx orval --config orval.config.ts
```

---

## 3. 生成されるファイル構成

```
src/api/
  ├─ petstore.ts          // 型安全クライアント + React-Query フック
  ├─ petstore.schemas.ts  // 各モデル
  └─ petstore.msw.ts      // MSW ハンドラ（faker 付き）
```

`petstore.msw.ts` では各ハンドラが `faker` を直接呼び出し、OpenAPI の型情報に合わせて値を合成します。例:

```ts
export const listPetsHandler = http.get('*/pets', () =>
  HttpResponse.json({
    id: faker.number.int({ min: 1, max: 999 }),
    name: faker.person.fullName(),
  })
);
```

---

## 4. 開発・テストへの組み込み例

### 4-1. ブラウザ／Storybook

```ts
// src/mocks/browser.ts
import { setupWorker } from 'msw/browser';
import * as handlers from '@/api/petstore.msw';

export const worker = setupWorker(...Object.values(handlers));
```

```ts
// src/main.ts (Vite)
if (import.meta.env.DEV) {
  const { worker } = await import('./mocks/browser');
  worker.start({ onUnhandledRequest: 'bypass' });
}
```

Storybook なら `msw-storybook-addon` を使い `initialize()`＋`mswDecorator` を追加するだけです。

### 4-2. Vitest

```ts
// vitest.setup.ts
import { setupServer } from 'msw/node';
import * as handlers from '@/api/petstore.msw';

const server = setupServer(...Object.values(handlers));

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

Vitest 側のテストコードではネットワークを意識せず `fetch*()` フックや React Query をそのまま呼び出せます。

---

## 5. Faker カスタマイズのコツ

| 方法 | どこに書くか | 例 |
|------|--------------|----|
| **全レスポンス共通のポリシー** | `override.mock.properties` | `/id$/`: `() => faker.string.uuid()` |
| **エンドポイント単位** | `override.operations.<opId>.mock` | 上の `listPets` の例 |
| **OpenAPI 側に例を書きたい** | `examples:` or `example:` を使い、`output.mock.useExamples: true` に設定 | — |

---

## 6. よくある疑問

| FAQ | 回答 |
|-----|------|
| **Faker のシードを固定したい** | ハンドラ内で `faker.seed(123)` を呼ぶか、`setupServer` 開始前に一度だけ設定します。 |
| **日付／enum の扱いは？** | Orval がスキーマを解析し `faker.date.anytime()` や `faker.helpers.arrayElement()` を自動選択します。 |
| **複雑な `allOf` / `oneOf`** | 一部バグ報告もあるため（Issue #1895 など）、必要に応じて `override` で手動修正が推奨されます。citeturn13search6 |

---

## 7. なぜ Orval + MSW + Faker が強力か？

| 指標 | Orval | MSW | Faker |
|------|-------|-----|-------|
| GitHub ⭐ | 4.1 k starsciteturn6search0 | 16.8 k starsciteturn15search3 | 14 k starsciteturn16search2 |
| 生成物 | 型安全クライアント / モデル / ハンドラ | リクエストインターセプト | 実在感あるダミーデータ |
| 役割 | **OpenAPI ⇒ コード** 一括生成 | **ランタイム** で HTTP を横取り | **値の質感** を付与 |

この 3 点を組み合わせることで **「契約定義 → コード生成 → 実行時モック」** が完全に自動化され、GUI 開発・ユニットテスト・E2E まで **同一ソース** を共有できます。

---

### まとめ

- **`mock: true` で Faker×MSW を自動生成** ― 追加コードはほぼ不要。  
- **Faker v9 API** に合わせてテンプレートが更新済みなので、`faker.number.int` など新シグネチャにそのまま対応。  
- `override` と `locale` で柔軟にカスタマイズでき、Vitest・Storybook・Playwright へ簡単に組み込める。  

実装コストを最小に抑えて **“型安全なフェイク API”** を用意したいなら、現状もっとも DX の高い選択肢です。

---

## 👤 User
*2025-06-22 16:16:30*

OrvalがFakerをサポートしているのか？
MSWがFakerをサポートしているのか？
Orvalを使っていなくてもopenapi-typescriptでhttps://www.npmjs.com/package/openapi-mswをつかってMSW対応しようと思っているのだけれども、自動的に Fakerをつかったりできるのか？

---

## 🤖 Assistant
*2025-06-22 16:17:00*

### ① Orval は Faker を **公式サポート**

* `orval.config.ts` で `output.mock: true` を指定すると  
  - **MSW ハンドラ**  
  - **Faker で生成されたダミー値**  
  を同時に吐き出します。実装例でも `const { faker } = require('@faker-js/faker')` が前提になっており、生成コード内でも `faker.person.fullName()` など v9 API が直接呼ばれますciteturn10view0turn11view0。  
* したがって **Orval ＝ “Faker 内蔵の MSW ジェネレーター”** と覚えると早いです。追加の設定は不要で、`locale` や `override` で細部を調整できます。

---

### ② MSW（本体）は Faker を **内蔵していない**

* **MSW は単なるリクエストインターセプタ**。値生成までは担当せず、ハンドラ内で自由に Faker を呼ぶのが基本パターンです。  
* ただし公式拡張の **`@mswjs/source`** で `fromOpenApi()` を使うと、OpenAPI の JSON-Schema から **自動で Faker を呼んで値を合成**してくれますciteturn5view0。  
  * 例：`type: "string", format: "email"` → ランダムなメールアドレスを返す。

---

### ③ `openapi-msw` は **型ラッパーのみ** で Faker 自動生成なし

* `openapi-msw` は **MSW の `http` API を OpenAPI-TS の型で包む**ことが目的で、データ生成ロジックは一切含みませんciteturn6view0。  
* したがって **モック値は自分で書くか、別ツールで生成して渡す**必要があります。

---

### ④ Faker を自動で噛ませる代替ツール

| ツール | 位置づけ | Faker連携 | 備考 |
|--------|---------|-----------|------|
| **Orval** | クライアント & MSW モック自動生成 | ◎ 内蔵 | `mock: true` だけで完結 |
| **@mswjs/source** | OpenAPI → MSW ハンドラ | ◎ 内蔵 | CLI ではなく JS API |
| **openapi-to-msw / msw-auto-mock** | CLI で MSW ハンドラ生成 | ◎ 外部依存だが README に `faker-js/faker` を併記 | OpenAPI→TS 型は不要citeturn13view0 |
| **openapi-msw** | 型安全ラッパー | ✖ | 値は手動または上記ツールで作る |

---

## 実践パターン別のおすすめ

| シナリオ | 推奨構成 |
|----------|----------|
| **OpenAPI をソースに、型付きクライアントとモックを一括生成したい** | **Orval (`mock: true`)** |
| **既存 MSW プロジェクトに “自動 Faker 値” だけ追加したい** | `@mswjs/source` の `fromOpenApi()` |
| **openapi-typescript で型は持っているが、モック生成は別でやる** | ① `openapi-msw` で型安全ハンドラを作る&lt;br&gt;② `openapi-to-msw` や `msw-auto-mock` で Faker 付きハンドラを生成し、`server.use(...)` で束ねる |
| **とにかく手軽にタイプセーフだけ確保したい** | `openapi-msw` ＋ 自前で Faker を呼ぶ |

---

### まとめ

* **Orval** ＝ Faker 搭載・フル自動生成  
* **MSW 本体** ＝ データ生成は別途  
* **`@mswjs/source`/openapi-to-msw** ＝ “MSW＋Faker” を OpenAPI から直生成  
* **openapi-msw** ＝ **型** 強化だけ。Faker 連携は自動では動かない  

要件に合わせて “型安全性” と “ダミーデータ自動化” のどちらを重視するかを軸に選ぶと失敗しません。

---
