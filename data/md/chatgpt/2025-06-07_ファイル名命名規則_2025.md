# ファイル名命名規則 2025

日付: 2025-06-07

---

## 👤 ユーザー
*2025/06/07 23:38:56*

TypeScitpのファイル名の命名規則について2025年現在一番無難なものはどれか？またどういう思想に分かれるのか？

---

## 🤖 アシスタント
*2025/06/07 23:39:40*

### 結論 ― 2025 年時点で **「とりあえず迷ったら `kebab-case`（すべて小文字＋ハイフン区切り）」** が最も無難  
* クロスプラットフォーム（Windows ⇔ Linux）の大文字小文字⾮互換や Git での衝突を避けやすい  
* Next.js／Vite／Angular など主要 Web フレームワークの新規プロジェクトは kebab-case 前提の CLI や ESLint プリセットが増加  
* ESLint `unicorn/filename-case` ルールもデフォルトは kebabCase citeturn9search3  
* Google 開発者ドキュメントは「ファイルは基本 lowercase」方針を推奨citeturn6search2  
* 2025 年の実践記事でも「PascalCase → kebab-case への乗り換え」が紹介されているciteturn8view0  

&gt; **実務 tip**  
&gt; *React/Preact など**コンポーネントを 1 ファイル 1 エクスポート**で書く場合だけは、  
&gt; `UserCard.tsx` のように **PascalCase に揃える**チームも依然多い（理由は後述）。  
&gt; それでも pages/ や hooks/、utils/ など「ルーティングやユーティリティ層」は kebab-case に統一しておくと事故が少ない。

---

## 主要 4 スタイルと「思想」の分かれ⽅

| スタイル | 採用例/ツール | 選ばれる理由 (= 思想) | 代表的な欠点 |
| --- | --- | --- | --- |
| **kebab-case**&lt;br&gt;`user-service.ts` | Next.js 13+ 公式例、Angular、shadcn/ui、Unicorn 既定 citeturn9search3 | *OS 非依存・URL に近い・視認性◎*&lt;br&gt;新人でも読みやすく長い名前を無理なく分節化 | React のコンポーネント名と形がズレる（`UserCard` ⇔ `user-card.tsx`） |
| **camelCase**&lt;br&gt;`userService.ts` | AWS CDK ガイド citeturn6search5、Basarat SG citeturn7search1 | *変数/関数と揃う ― JS 的感覚の延長* | Windows で問題なくても Linux で `UserService.ts` と衝突しやすい |
| **PascalCase**&lt;br&gt;`UserService.ts` | 旧来の React/CRA、Airbnb React SG citeturn0search1 | *「ファイル = クラス/コンポーネント」という OO 的対応*&lt;br&gt;IDE のシンボル検索と一致 | URL 生成系(Next.js pages など)と相性が悪い |
| **snake_case**&lt;br&gt;`user_service.ts` | 一部の Google 派・Python 混在モノレポ | *大小区別を完全に排除* citeturn6search10 | JS エコシステムでは少数派・ESLint 設定を追加で要調整 |

---

## 選択基準をどう決めるか？

1. **プラットフォーム／CI の制約**  
   *Linux サーバーにデプロイ → ローカルは macOS/Windows* という典型的構成なら大小問題を避けられる kebab-case が楽。
2. **フレームワーク⾃体の慣例**  
   - Next.js ＝ kebab-case が URLと一致  
   - React SPA（pages なし）＝ PascalCase でも破綻しない
3. **⼈間の視認性と grep・IDE 検索効率**  
   ハイフン・アンダースコアは「単語境界」を明示でき、長いファイル名の可読性が高い。
4. **導入済みの Linter / Formatter**  
   既に Unicorn や eslint-plugin-filename でルールが走っているなら、それに合わせてチーム全体を auto-fix で統一するのが最短コスト。

---

## 実務でよく落ち着く落としどころ

```text
src/
├─ components/
│   └─ UserCard.tsx          ← React コンポーネントだけ PascalCase
├─ pages/
│   └─ user-profile.tsx      ← ルーティング層は kebab-case
├─ hooks/
│   └─ use-auth.ts
├─ utils/
│   └─ string-format.ts
└─ types/
    └─ user.ts
```

* **ESLint**  
  ```jsonc
  // .eslintrc.cjs
  "unicorn/filename-case": [
    "error",
    {
      "cases": {
        "kebabCase": true,
        "pascalCase": true   // JSX/TSX は override
      }
    }
  ]
  ```
* **Prettier** にはファイル名自動変換機能がないため、`rename-regex` などのスクリプトで一括変換するか、IDE のリファクタリングを利用。

---

## まとめ

* **新規プロジェクトで迷ったら**：**kebab-case をベース**にする  
  *React/Storybook の UI コンポーネントだけは PascalCase に例外を設ける*  
* 既存コードが別規則なら **「ESLint + --fix で自動整形」か「既存を尊重」**のどちらかに早めに決断  
* 重要なのは **チーム全員が守れるルールを 1 つに固定し、CI で破られないよう自動チェック**を入れること――思想（美学）の違いより一貫性が正義、です。

---
