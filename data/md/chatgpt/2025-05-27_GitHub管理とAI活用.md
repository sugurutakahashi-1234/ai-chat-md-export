# GitHub管理とAI活用

日付: 2025-05-27

---

## 👤 ユーザー
*2025/5/27 18:39:39*

Claude Codeで開発するときに、GitHubのissueを見ながら開発してほしいと思って、Claude.md にissueに管理などの方法について記述をしたが、CLIベースでラベルなどはつけられたが、GitHub Projects でボード上で管理するのは難しいみたいであった。

すぐにコンテキストが多くなって、limitになってしまう。

ある程度、手動で管理するところと、AIがいい感じに自動で管理するところと、GitHub Actions で行った方がいいこと。

そもそもどんなことを管理していったらいいのか整理したい。

また、Claude.md にどんなことを明記したらいいのかアドバイスが欲しい。

---

## 🤖 アシスタント
*2025/5/27 18:39:41*

### ① 「人がやる」「Claude など AI に任せる」「GitHub Actions に任せる」のざっくり仕分け

|フェーズ|典型的に“手動”|AI が得意|Actions で自動|
|---|---|---|---|
|課題の発見・背景整理|✍️ チーム内対話 / 仕様決定 / プライオリティ判断|–|–|
|Issue 作成|本文の骨子（目的・再現手順・期待結果）|文体校正、箇条書き→標準テンプレ変換、タグ候補抽出|`ISSUE_TEMPLATE` 自動挿入|
|ラベル付け・分類|ラベル設計方針の決定|「この Issue は bug/システム/API…」を推定、下書きコメントで提案|`github/labeler` で PR に自動ラベル|
|Project Board への配置|ロードマップ視点で優先度調整|Issue/PR を所定カラムに“提案”|`projects_v2` API でカラム移動（merge 時 Done に）|
|実装・レビュー|複雑な設計判断、ロジック実装|部分コード生成、テストスケルトン生成、PR 説明文要約|CI、lint、ビルド、テスト実行|
|追跡・メンテ|技術的負債の棚卸し|古い Issue の要約＋次アクション案|`stale` Action で放置 Issue に ping|

> **ポイント**  
> - **AI は「分類・要約・下書き」に強い**。最終決定・優先度付けは人間が行う。  
> - **Actions は「一定条件で機械的に動かす」だけに絞る**とトラブルが少ない。

---

### ② コンテキスト爆発を防ぐ運用 Tips

1. **ID 指定で都度取得**  
   - `gh issue view 123 --json title,body` → Claude に貼る。  
   - ファイルを丸ごと渡さず「今は概要だけ」「コードは関係箇所だけ」と分割。

2. **Issue 定型セクションを短く**  
   - 「背景」「やること」「受け入れ条件」を最大 *n* 行に制限。  
   - 詳細議論はスレッドで；AI に渡すのは最新コメントだけ。

3. **Claude.md に “要約ルール” を明記**  
   - 「3 行以内で要約し、それ以上はリンクを示す」など制限を書いておくと、毎回 prompt に書かなくても済む。

---

### ③ Claude.md に書くと便利な項目例

```markdown
# Claude.md（例）

## 目的
このリポジトリで LLM（Claude）に支援してもらう方法と制約をまとめる。

## リポジトリ概要
- **バックエンド**: Hono（Node 18）
- **フロントエンド**: Vite + React
- **共通**: PNPM ワークスペース構成  
  → 詳細は docs/architecture.md

## Issue / Project 運用ガイド
### ラベル一覧
|カテゴリ|説明|
|---|---|
|`type:bug`|バグ修正|
|`type:feature`|新機能|
|`scope:api`|API 層|
|`scope:ui`|UI 層|

### Project カラム
1. **Todo** – 起票直後 / ラベル付け済み  
2. **In Progress** – 担当者決定  
3. **Review** – PR オープンで自動移動  
4. **Done** – PR merge 時に自動移動

> **Automation** — `.github/workflows/project-auto.yml` が PR merge をトリガーに「Review → Done」へ移動。

## Claude への依頼パターン
|ケース|プロンプト例|
|---|---|
|Issue 要約|`issue:123 を 3 行で要約して`|
|ラベル提案|`次の issue 本文から適切なラベルを 3 つまで提案して`|
|PR 説明文生成|`diff.txt を基に Conventional Commits 準拠の PR 説明を書いて`|

### コンテキスト制約
- 同時に渡す Issue は最大 **3 件**。  
- コードは関連関数のみ抜粋すること。  
- Claude がテキストを返す際は **800 tokens** 以内。  

## GitHub Actions 一覧
|Workflow|役割|トリガー|
|---|---|---|
|`ci.yml`|lint / test|`push`, `pull_request`|
|`labeler.yml`|ファイルパスに応じて自動ラベル|`pull_request`|
|`project-auto.yml`|Project カラム移動|`pull_request` closed|
|`stale.yml`|60 日無反応 Issue に `stale` ラベル|`schedule (daily)`|

## よくある Q&A
- **Q:** コンテキスト上限に達したら？  
  **A:** Claude に「要約してから再送して」と依頼。
```

---

### ④ GitHub Actions（抜粋サンプル）

```yaml
# .github/workflows/project-auto.yml
name: Move cards on PR merge
on:
  pull_request:
    types: [closed]
jobs:
  project:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Move project card to Done
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            // Issue → Project Item を探し Done に移動 …
```

---

### ⑤ まとめ

1. **ラベル設計と Project カラム設計** は手動で最初に決める。  
2. **機械的な移動・通知** は GitHub Actions に任せる。  
3. **文章生成・分類・要約** は Claude に下書きを作らせ、最終確認は人が行う。  
4. **Claude.md** には「ラベル／カラム表」「Automation 一覧」「Prompt 例」「トークン制約」を書くと **毎回の指示が激減**。  

これで *人* × *AI* × *Automation* をほどよく分担し、コンテキスト爆発も抑えつつスムーズに開発を進められるはずです。

---

## 👤 ユーザー
*2025/5/27 18:44:24*

ルールファイルを分割するのはアンチパターンなのか？リンクを飛ばしてもあまり読んでくれない気がしている

---

## 🤖 アシスタント
*2025/5/27 18:44:25*

### 「ルールを 1 ファイルにまとめる vs. 分割する」――判断の軸

|判断軸|1 ファイル派が有利|分割派が有利|
|---|---|---|
|**ファイルサイズ**|数 KB 〜 1 つの画面で収まる|5 KB 超えたあたりから見通し急降下|
|**読まれるタイミング**|初回セットアップ時に一気読み|必要な瞬間にチラ見される|
|**更新頻度/責任者**|全体を同じ人・同じ頻度で更新|部分ごとに担当や頻度が違う|
|**検索性**|ブラウザ検索（Cmd/Ctrl-F）1 発|GitHub 検索＋見出しジャンプ|
|**CI/自動チェック**|1 ファイルにルールが凝縮→CI で抜粋しやすい|スクリプトで対象フォルダを再帰的に読む方が楽|

> **結論**  
> - **サイズと更新責任が「１チーム同質」なら 1 ファイルで良い。**  
> - **規模が膨らみ始めたら “分割” 自体はアンチパターンではない**——*読まれない* のは構造・導線の設計ミスが原因。  

---

## 「リンクを飛ばしても読まれない」問題への 5 つの対策

|対策|ポイント|
|---|---|
|### 1. エントリポイントは必ず “サマリ＋目次” だけに|README 先頭で **TL;DR** と “次に何を読めばよいか” を 6 行以内で示す。|
|### 2. **Relative link + 見出しアンカー** を使う|`docs/branching.md#release` のように <br>クリック 1 回で目的地 & 見出しまで着地。|
|### 3. “仕事の流れ” に文書への **自動リマインド** を埋める|PR テンプレに「この変更が X に影響する場合は docs/X.md も更新」チェックボックス。|
|### 4. 必読ルールは **CI で強制**|`dangerfile.js` や `actionlint` で、「未更新なら CI Fail / Warn」。読む動機を自動注入。|
|### 5. **Doc-as-Code** で **箇所ごとに reviewer 自動割当**|`CODEOWNERS` を docs/ 以下にも設定 → 該当ルール変更時に担当者に Review 要請。|

---

## 分割したいときの「最小構成」ひな形

```
docs/
├── index.md          # 目次兼 TL;DR → “ここだけ読めば開始できる”
├── conventions/
│   ├── naming.md     # 命名規約
│   └── branching.md  # git-flow / trunk based 等
└── processes/
    ├── issue.md      # Issue 作成〜Project 配置ルール
    └── release.md    # リリース手順
```

- **命名**は *カテゴリ/トピック* の 2 階層まで。深い階層は読者ロスト率↑。  
- どのファイルにも **冒頭 3 行で目的・読者・更新責任者** を書く。  
- `docs/index.md` は **“人力ポータル”**：各トピックを 1 行で要約＋リンク。

---

## 併用テクニック

|テクニック|効果|
|---|---|
|**Mermaid の Site-Map** を index.md に埋め込む|全体像が視覚的に一目でわかる|
|**mkdocs / Docusaurus** で GitHub Pages 自動ホスト|サイドバー目次が常時表示 → 読み飛ばし防止|
|**`docs/` 直下に `README-short.md` を自動生成**|CI でサマリ抽出 → AI への prompt もそこを読ませるだけ|

---

## まとめ — 分割＝アンチパターンではなく「導線設計」が鍵

1. **1 ファイルで済むうちは単一ファイルが最強**。  
2. 5 KB 超・複数担当・更新頻度バラバラなら **迷わず分割**。  
3. 「読まれない」はリンクの深さではなく **入口・検索性・ワークフロー統合** が原因。  
4. **目次・アンカー・CI リマインド** を徹底すれば分割しても読まれる。  

> 🧩 **実装ヒント**  
> 既に分割したいルールがあるなら、まず `docs/index.md` を作って **TL;DR＋1 行リンク集** を書くだけで “読まれない問題” の 7 割は解消します。

---

## 👤 ユーザー
*2025/5/27 18:46:20*

今のルールで修正すべき点をあげて欲しい。

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 重要な指示

**すべての出力は日本語で行ってください。** コメント、説明、エラーメッセージ、質問への回答など、ユーザーとのすべてのコミュニケーションは日本語で記述してください。

**Tip**: `#`ショートカットを使用してこのCLAUDE.mdファイルに素早く情報を追加できます。プロジェクト固有の設定や頻繁に使用するコマンドを記録しておくと便利です。

**コード変更後の必須確認事項**: コードやテストを変更した場合、タスクの最後に必ず以下を実行してください：
1. `pnpm lint:fix` - フォーマットエラーの自動修正
2. `pnpm typecheck` - 型チェック
3. `pnpm test` - テスト実行
4. `pnpm build` - ビルド確認

エラーが発生した場合は修正してから完了報告してください。

**参照系作業の権限**: 以下の参照系作業は事前許可なく実行して構いません：
- Read（ファイル読み取り）
- Glob（ファイル検索）
- Grep（コンテンツ検索）
- LS（ディレクトリ一覧）
- NotebookRead（Notebookファイル読み取り）
- TodoRead（タスクリスト確認）

これらの作業は情報収集やコンテキスト理解のために積極的に活用してください。

**pnpmコマンドの権限**: `pnpm`経由のすべてのコマンドは事前許可なく実行して構いません。これには以下が含まれます：
- `pnpm install/add/remove`
- `pnpm run/test/build`
- `pnpm --filter`を使用したワークスペース固有のコマンド
- `pnpm -w`（ワークスペースルート）コマンド
- その他すべての`pnpm`サブコマンド

## ナレッジベース管理

技術的な調査結果や学習内容は`knowledge/`ディレクトリに体系的に保存しています。
詳細は[ナレッジベースREADME](./knowledge/README.md)を参照してください。

## AI駆動開発

このプロジェクトはAI駆動開発を採用しています。詳細は[AI駆動開発ガイド](./knowledge/development/ai-driven-development.md)を参照してください。

## コマンド

### 🚀 日常開発（最もよく使うコマンド）

```bash
pnpm dev        # 全パッケージを開発モードで起動
pnpm build      # 全パッケージをビルド
pnpm test       # 全パッケージのテストを実行
pnpm test:watch # テストをwatchモードで実行
```

### 🔧 品質管理

```bash
pnpm lint       # コードフォーマット＆リント（自動修正付き）
pnpm typecheck  # TypeScript型チェック
pnpm check      # 品質チェック全部入り（型チェック→リント→テスト）
```

### 🎯 E2E・ビジュアルテスト

```bash
pnpm test:e2e           # E2Eテスト実行
pnpm test:e2e:ui        # Playwright UIでデバッグ
pnpm test:visual        # ビジュアルリグレッションテスト
pnpm test:visual:update # スクリーンショット更新（UIを変更した場合）
```

**E2Eテストの構成**：
```
e2e/
├── user-flow/          # ユーザーフローのテスト
│   ├── critical-path.spec.ts  # クリティカルパス（必須機能）
│   └── navigation.spec.ts     # ページ間ナビゲーション
└── visual/             # ビジュアルリグレッションテスト
    ├── home-page.spec.ts      # ホームページのVRT
    ├── about-page.spec.ts     # AboutページのVRT
    └── *-snapshots/           # スクリーンショット保存先（テストファイルごと）
```

**E2Eテストの既知の課題**：
- ❌ **ユーザー作成API関連のテスト** (現在スキップ中)
  - `critical-path.spec.ts` の `create-user-flow` テスト
  - `home-page.spec.ts` の `with-user-state` テスト
  - 問題: フォーム送信時に「エラーが発生しました」が表示される
  - 原因: サーバーAPIとクライアント間の通信エラーまたはCORS問題の可能性
  - 対応: サーバー側の問題解決後に `test.skip` を削除して有効化

### 🔄 API開発フロー

```bash
# 1. サーバーでAPIを実装
# 2. OpenAPI仕様とクライアントコードを生成
pnpm codegen

# 3. 必要に応じて手動でapi-clientのOpenAPIを更新
cp packages/server/openapi.yaml packages/api-client/openapi.yaml
```

### 🏃 アプリケーション実行

```bash
pnpm start:server  # ビルド済みサーバーを起動
pnpm start:web     # ビルド済みWebクライアントを起動
```

### 🧹 保守・メンテナンス

```bash
pnpm clean         # ビルド成果物を削除
pnpm clean:test    # VRTのテスト結果を削除（test-results/, playwright-report/）
pnpm update        # 依存関係を最新版に更新
pnpm update:check  # 更新可能なパッケージを確認
```

### 🚦 Git Hooks（自動実行）

```bash
# コミット時（自動）
pnpm precommit  # lint → typecheck

# プッシュ時（自動）
pnpm prepush    # typecheck → lint → test
```

### 📦 パッケージ個別操作

```bash
# 特定パッケージでコマンド実行
pnpm --filter @myapp/server dev
pnpm --filter @myapp/web-client test

# 依存関係の追加
pnpm add <package> --filter @myapp/server
pnpm add -D <package> --filter @myapp/web-client
```

### 💡 Tips

1. **開発の始め方**
   ```bash
   pnpm dev  # これだけでサーバーとクライアントが起動
   ```

2. **コード変更後の確認**
   ```bash
   pnpm check  # 型・フォーマット・テストを一括確認
   ```

3. **ビジュアルテストでUIの変更を確認**
   ```bash
   pnpm test:visual  # 差分があれば失敗する
   # UIを意図的に変更した場合は
   pnpm test:visual:update  # スクリーンショットを更新
   ```

## アーキテクチャ

このプロジェクトは、Honoフレームワークの学習用として構築されたpnpm workspaceのモノレポです。厳密なTypeScript設定を使用しています。

### パッケージ構成と依存関係

```
@myapp/shared (共通ライブラリ - Logger等のユーティリティ)
    ↑
    ├── @myapp/server (HonoAPIサーバー)
    └── @myapp/web-client (フロントエンドアプリ)
           ↑
    @myapp/api-client (自動生成されたAPIクライアント)
```

**重要**: 
- `api-client`は自動生成されたコードのみを含み、`shared`に依存しません
- `server`は`api-client`を参照しません
- `api-client`を知っているのは`web-client`のみです

### 各パッケージの役割
- `@myapp/server` - HonoベースのAPIサーバー、OpenAPI/Swagger統合
- `@myapp/web-client` - フロントエンドクライアントアプリケーション
- `@myapp/api-client` - OpenAPI仕様から自動生成されるAPIクライアント（依存関係なし）
- `@myapp/shared` - serverとweb-clientで使用される共通のユーティリティ（Logger等）

### 主要パターン
- **OpenAPI駆動**: サーバーでAPI仕様定義、クライアントコード自動生成
- **共通ユーティリティ**: `@myapp/shared`のLogger等をserver/web-clientが利用
- **厳密なTypeScript**: レベル4の型安全設定を使用
- **パスエイリアス**: `@myapp/shared`は`./packages/shared/src`を指す
- **React Router v7**: 最新のルーティングライブラリでSPA構築

### ビルド依存関係
パッケージは以下の順序でビルドする必要があります：
1. `@myapp/shared` (依存なし)
2. `@myapp/api-client` (依存なし - 自動生成)
3. `@myapp/server` (sharedに依存)
4. `@myapp/web-client` (shared、api-clientに依存)

### パッケージごとの開発コマンド

#### @myapp/server
- `pnpm --filter @myapp/server dev` - 開発サーバー起動（tsx watch）
- `pnpm --filter @myapp/server build` - ビルド (ESM + 型定義)
- `pnpm --filter @myapp/server start` - ビルド済みサーバー起動
- `pnpm --filter @myapp/server openapi:generate` - OpenAPI仕様を`openapi.yaml`に生成

#### @myapp/web-client  
- `pnpm --filter @myapp/web-client dev` - 開発モード起動
- `pnpm --filter @myapp/web-client build` - TypeScriptコンパイル
- `pnpm --filter @myapp/web-client start` - ビルド済みアプリ起動

#### @myapp/api-client
- `pnpm --filter @myapp/api-client codegen` - OpenAPI仕様からクライアントコード生成
- `pnpm --filter @myapp/api-client build` - ビルド（生成コードを含む）

#### @myapp/shared
- `pnpm --filter @myapp/shared build` - 共通ライブラリのビルド

### 技術仕様

#### TypeScript設定
- **strictモード**: `tsconfig.base.json`で厳密な型チェックを有効化
- **モジュールシステム**: ESM only (`"type": "module"`)
- **パスエイリアス**: `@myapp/*`は各パッケージの`src`ディレクトリを指す
- **Node.js**: v24+ 必須
- **pnpm**: v10.11.0+ 必須

#### Biome設定
- **フォーマット**: ダブルクォート、スペース2つでインデント
- **リンティング**: 推奨ルールセットを使用
- **VS Code統合**: 保存時自動フォーマット設定済み

#### Hono仕様
- **ポート**: 3000（開発・本番）
- **Swagger UI**: `/swagger`でアクセス可能
- **バリデーション**: Zod + @hono/zod-openapi
- **エントリーポイント**: `src/app.ts`（index.tsではない）

### コーディング規約
- **命名**: ファイル/ディレクトリはkebab-case、コンポーネントはPascalCase
- **型定義**: `interface`より`type`を優先、default exportより named export
- **APIレスポンス**: sharedパッケージの`ApiResponse<T>`型を使用
- **インポート順序**: Node.js標準ライブラリ → 外部パッケージ → @myapp/* → 相対パス
- **JSDoc**: 関数・型には積極的にJSDocコメントを記述
- **ライブラリ使用時**: 新しいライブラリを使用する際は、context7のMCPサーバーと疎通して最新の使い方を確認すること

### 開発フロー
1. **API設計**: サーバーでOpenAPI仕様を定義
2. **コード生成**: `pnpm codegen`でAPIクライアントを生成
3. **実装**: 型安全にクライアント・サーバーを実装
4. **品質チェック**: `pnpm typecheck`と`pnpm lint`でコード品質確認

### OpenAPI仕様の運用ルール

**重要**: OpenAPIファイルはYAML形式のみを使用（JSONは使用しない）

1. **サーバー側の仕様生成**
   - `pnpm --filter @myapp/server openapi:generate`を実行
   - `packages/server/openapi.yaml`にのみ生成される
   - OpenAPIバージョンは3.1.0を使用

2. **APIクライアント側の仕様更新**
   - `packages/api-client/openapi.yaml`は**手動で更新**する
   - サーバー側で先行してAPIをリリースする場合があるため、自動同期しない
   - クライアント側の更新タイミングは開発者が判断

3. **更新フロー**
   ```bash
   # 1. サーバー側でAPI変更を実装
   # 2. OpenAPI仕様を生成
   pnpm --filter @myapp/server openapi:generate
   
   # 3. 必要に応じてapi-client側のopenapi.yamlを手動更新
   cp packages/server/openapi.yaml packages/api-client/openapi.yaml
   
   # 4. APIクライアントコードを再生成
   pnpm --filter @myapp/api-client codegen
   ```

## 新しいIssueに着手する前の必須確認事項

新しいissueやタスクに取り掛かる前に、以下を必ず確認してください：

### 1. Git状態の確認
```bash
# 現在のブランチとコミット状況を確認
git status
git log --oneline -5

# リモートの最新状態を取得
git fetch origin

# 未pushのコミットを確認
git log origin/$(git branch --show-current)..HEAD --oneline

# mainブランチとの差分を確認
git log origin/main..HEAD --oneline
```

### 2. 確認チェックリスト
- [ ] **作業中の変更**: `git status`でクリーンな状態か確認
- [ ] **未pushのコミット**: ローカルにのみ存在するコミットがないか
- [ ] **PR状況**: 現在のブランチのPRがマージ待ちでないか
- [ ] **リモートの更新**: `git fetch`で最新状態を取得済みか
- [ ] **ブランチの整理**: 不要なブランチが残っていないか

### 3. 状態に応じた対応
```bash
# 未pushのコミットがある場合
git push origin $(git branch --show-current)

# 作業中の変更がある場合
git add -A
git commit -m "適切なコミットメッセージ"
git push

# mainが更新されている場合（必要に応じて）
git checkout main
git pull origin main
git checkout -
git rebase main  # または merge
```

### 4. 新しいissueの開始手順（重要なルール）

**重要**: 新しいissueに着手する際は、必ずmainブランチを最新に更新してから開発を開始すること。これにより、最新のコードベースで作業し、マージコンフリクトを最小限に抑えることができます。

```bash
# 1. 現在の作業を完了させる（作業中の場合はコミット＆プッシュ）
git add -A
git commit -m "現在の作業を保存"
git push origin $(git branch --show-current)

# 2. mainブランチに切り替えて最新を取得（重要！）
git checkout main
git pull origin main

# 3. 新しいfeatureブランチを作成（mainから分岐）
git checkout -b feature/<issue番号>

# 4. issueの詳細を確認
gh issue view <issue番号>
```

**注意点**:
- mainブランチからの分岐を必ず行う（他のfeatureブランチからは分岐しない）
- pullする前にローカルの変更がないことを確認
- コンフリクトが発生した場合は慎重に解決する

## Claude Code と GitHub Issues の効率的な管理方法

### 🎯 基本方針
Claude Codeを活用したissue管理により、コーディング作業とプロジェクト管理を統合し、開発効率を最大化する。

### 📋 Issue管理のワークフロー

#### 0. Issue着手前の準備（重要）
```bash
# 1. 現時点でのベストプラクティスを調査
"<技術名> ベストプラクティス 2025"で調査依頼

# 2. 調査結果をドキュメント化
docs/<TECHNOLOGY>_BEST_PRACTICES_2025.md として保存

# 3. CLAUDE.mdにサマリー追加
重要なルールや設定をCLAUDE.mdに反映

# 4. issueをブラウザで開く
open https://github.com/<owner>/<repo>/issues/<number>
```

#### 1. Issue作成フェーズ
```bash
# 課題を発見したら即座にissue起票
gh issue create --title "🚨 [カテゴリ] 問題の概要" \
  --body "詳細な説明・再現手順・完了条件" \
  --label "priority-high,bug"

# テンプレートを活用した一貫性のあるissue作成
# 🚨 = 緊急度高, 🔒 = セキュリティ, 🤖 = 自動化, 📊 = 品質改善
```

#### 2. 作業開始フェーズ
```bash
# issueの詳細確認
gh issue view <issue_number>

# 作業ブランチ作成（issueと連携）
git checkout -b feature/<issue番号>

# 例：
# git checkout -b feature/3  # CORS設定修正用
# git checkout -b feature/5  # データ永続化層実装用

# Claude Codeでの作業指示例：
# "issue #5 のデータ永続化層を実装してください"
# "issue #3 のCORS設定を修正してください"
```

#### 3. 実装フェーズ
```bash
# 進捗をコミットメッセージで記録
git commit -m "#5 feat: implement SQLite database layer

- Add Drizzle ORM configuration
- Create user table schema
- Update user service to use database"

# 課題に対するコメント追加
gh issue comment <issue_number> --body "実装中: データベーススキーマ完了"
```

#### 4. Push前チェックリスト
```bash
# 自動チェック（pre-commitフック）
- ✅ Biomeによるリント・フォーマット
- ✅ TypeScript型チェック

# 手動チェック（推奨）
- [ ] git statusで確認し、問題なさそうな変更はaddしてcommit
- [ ] コミットメッセージは日本語/英語両方記載
- [ ] テストがすべて通る（pnpm test）
- [ ] E2Eテストが通る（pnpm test:e2e）
- [ ] ビルドが成功する（pnpm build）
- [ ] 不要なconsole.logやデバッグコードを削除
- [ ] .env.exampleを更新（環境変数追加時）
- [ ] CLAUDE.mdを更新（新しいパターンや設定追加時）

# Push前の最終確認
git status  # すべての変更が意図的か確認
# 例：設定ファイルの変更など、問題ないものは含める

# push実行
git push -u origin feature/<issue番号>
```

#### 5. PR作成フェーズ
```bash
# PR作成時にissueと自動連携
gh pr create --title "Fix: CORS configuration security issue #3" \
  --body "Closes #3

## 変更内容
- CORS設定を環境別に分離
- 本番環境での許可ドメイン制限
- 開発環境での利便性維持

## テスト
- [ ] 開発環境でのCORS動作確認
- [ ] 本番想定でのCORS制限確認"

# issueクローズ（マージ後）
gh issue close <issue_number> --comment "修正完了・マージ済み"
```

## GitHub Copilot PRレビュー

詳細は[GitHub Copilot PRレビューガイド](./knowledge/development/github-copilot-pr-review.md)を参照してください。

### PRレビュー対応の重要ルール

**重要**: GitHub CopilotからのPRレビューコメントには**すべて返信が必須**です。

#### 対応方法
1. **修正実装**: 指摘に従って修正し、コミットハッシュを含めて返信
2. **説明対応**: 設計上の理由がある場合は、その意図を説明
3. **次回対応**: 今回のPRでは対応しない場合は、**必ずissueを作成**してから返信

#### 返信例
```bash
# 修正した場合
"ご指摘ありがとうございます。○○を修正しました（コミット: abc123）"

# 説明する場合
"この実装は○○の理由により意図的なものです。詳細は..."

# 次回対応の場合（issue作成必須）
"良い提案をありがとうございます。この改善は次のPRで対応させていただきます。
issue #14 として起票しました: https://github.com/owner/repo/issues/14"
```

#### 次回対応時のissue作成フロー
```bash
# 1. issueを作成
gh issue create --title "📚 [改善] Copilotレビュー指摘: <改善内容>" \
  --body "## 背景
PR #<PR番号> でCopilotから以下の指摘を受けました：
<指摘内容の引用>

## 対応内容
- <具体的な改善内容>

## 参考
- 元のPR: #<PR番号>
- Copilotのコメント: <コメントURL>" \
  --label "enhancement,priority-low"

# 2. PRコメントに返信（issue番号を含める）
```

## GitHub Projects 活用による効率的なIssue管理

**現在のProject**: [Hono Learning Development (Project #16)](https://github.com/users/suguruTakahashi-1234/projects/16)

詳細は以下のナレッジベースを参照してください：
- [GitHub Issue管理ガイド](./knowledge/development/github-issue-management.md)
- [移行ガイド](./knowledge/guides/issue-management-migration.md)
- [**GitHub Projects セットアップガイド（実践版）**](./knowledge/development/github-projects-setup.md) ← 実際の作成手順

### 🎯 新しい管理システムの特徴

1. **5軸ラベル体系**: 優先度、カテゴリ、工数、ステータス、タイプの体系的分類
2. **自動化ワークフロー**: issue作成時の自動ラベル付与とProject追加
3. **視覚的管理**: カンバンボード、ロードマップ、スプリントビューの活用
4. **段階的移行**: 従来のメタissue管理からの無理のない移行

### 🏷️ 新しいラベリング戦略

#### GitHubラベル（自動付与）
```bash
priority-critical  # 🚨 即座に対応が必要（セキュリティ・障害）
priority-high      # 🔴 優先的に対応（機能不良）
priority-medium    # 🟡 計画的に対応（改善・新機能）
priority-low       # 🟢 余裕があるときに対応（最適化）

category-security     # 🔒 セキュリティ関連
category-performance  # ⚡ パフォーマンス改善
category-dx          # 🛠️ 開発体験向上

effort-xs  # ⏱️ 1時間以内（ドキュメント更新等）
effort-s   # 🕐 半日程度（設定変更、小さなバグ修正）
effort-m   # 📅 1-2日（機能追加、中規模な実装）
effort-l   # 📆 3-5日（大きな機能実装、アーキテクチャ変更）
```

#### Projectカスタムフィールド（手動設定）
```bash
Priority: 🚨 Critical | 🔴 High | 🟡 Medium | 🟢 Low
Effort:   ⏱️ XS (薄青) | 🕐 S (青) | 📅 M (濃青) | 📆 L (紺)
Category: 🔒 Security | ⚡ Performance | 🛠️ DX | 📊 Quality | ✨ Feature
```

### 🤖 自動化機能

#### 自動ラベル付与
新しく作成されたissueは、タイトルに基づいて自動的にラベルが付与されます：
- `🚨` `critical` `security` → `priority-critical`
- `🔒` `urgent` → `priority-high`
- `📋` `enhancement` → `priority-medium`
- その他 → `priority-low`

#### 自動Project追加
GitHub Actionsにより、新しいissueとPRは自動的にProjectに追加されます。

### 📊 移行戦略

1. **並行運用期間**: メタissue（#8）とGitHub Projectsを1-2週間並行運用
2. **段階的移行**: 新規issueから順次新システムを適用
3. **完全移行**: メタissueを静的なロードマップに変更

### 💡 使用方法

#### 新規issue作成時
```bash
# 従来通りのissue作成（自動ラベル付与される）
gh issue create --title "🚨 [Security] CORS設定の脆弱性修正" \
  --body "..." --label "bug"

# 手動でのラベル追加（必要に応じて）
gh issue edit <number> --add-label "effort-m,category-security"
```

#### ProjectへのIssue追加
```bash
# 新しいissueをProjectに追加
gh project item-add 16 --owner @me --url "https://github.com/suguruTakahashi-1234/hono-learning/issues/<number>"

# Project内のアイテム確認
gh project item-list 16 --owner @me --format json | jq '.items[] | {number: .content.number, title: .content.title}'
```

#### GitHubラベル vs Projectカスタムフィールド使い分け戦略

**📋 二重管理ではなく、用途別使い分けで効率化**

| 用途         | GitHubラベル           | Projectカスタムフィールド  |
| ------------ | ---------------------- | -------------------------- |
| **自動化**   | ✅ ワークフロー条件分岐 | ❌ API制限あり              |
| **検索**     | ✅ GitHub全体検索       | ❌ Project内のみ            |
| **視覚管理** | ❌ 色のみ、絵文字なし   | ✅ 絵文字+色+説明           |
| **フィルタ** | ❌ 単純な条件のみ       | ✅ 複数軸での柔軟なフィルタ |
| **ソート**   | ❌ アルファベット順のみ | ✅ 優先度・工数順           |

**🔄 推奨運用フロー**:
1. issue作成 → 自動でGitHubラベル付与
2. Project追加 → 手動でカスタムフィールド設定
3. 日常管理 → Projectのカスタムフィールドを主軸
4. 検索・自動化 → GitHubラベルを活用

#### 進捗管理
- **日次**: [Project #16 Board View](https://github.com/users/suguruTakahashi-1234/projects/16)で進捗確認
- **週次**: Priority別ビューでスプリント計画
- **月次**: Category別ビューで長期計画見直し

### 📊 プロジェクト全体管理

#### 動的メタissue管理
プロジェクト全体の進捗を追跡するため、**動的メタissue** を活用します。

- **#8 プロジェクト全体管理** - 全issueを動的に分類・管理
- 新しいissue作成時は必ずメタissueに分類追加
- 継続的な優先度調整とロードマップ更新

#### スケーラブルな分類システム
```bash
🚨 Critical      # セキュリティ・機能不良（即座に対応）
🏗️ Foundation    # アプリ基盤・アーキテクチャ（計画的対応）
📊 Quality       # 品質向上・最適化（余裕のあるときに対応）
💡 Enhancement   # 新機能・改善（将来的に対応）
```

#### 新issue作成時のフロー
```bash
# 1. 通常のissue作成
gh issue create --title "🔍 新しい課題" --body "..." --label "bug"

# 2. メタissue更新（手動 or Claude Code依頼）
gh issue comment 8 --body "📝 新issue #9 を Critical カテゴリに追加
📊 更新後進捗: Critical 0/3, Foundation 0/3, Quality 0/2"

# 3. Claude Codeでの自動分類（推奨）
"新しく作成されたissue #9 を確認して、メタissue #8 に適切なカテゴリで追加してください"
```

#### 継続的管理プロセス
- **issue作成時**: カテゴリ分類と優先度付け
- **issue完了時**: 進捗反映と次の優先課題確認
- **週次**: 新規issue分類と依存関係見直し
- **月次**: カテゴリ体系の見直しとロードマップ更新

### 🔄 Claude Code活用パターン

#### パターン1: Issue -> 実装
```bash
# 1. issueから直接作業依頼
"issue #4 のGitHub Actions設定を実装してください。
pnpm check コマンドを使ったCI設定をお願いします。"

# 2. Claude Codeが実装 + 関連ファイル更新
# 3. 実装完了時にissueステータス更新を依頼
"issue #4 の実装が完了したので、進捗を更新してください"
```

#### パターン2: コードレビュー -> Issue化
```bash
# 1. コード調査依頼
"セキュリティの観点でコードを確認し、問題があればissue化してください"

# 2. Claude Codeが分析・issue作成
# 3. 優先度付けと対応方針の相談
```

#### パターン3: 定期メンテナンス
```bash
# 月次での一括確認
"依存関係の更新確認とセキュリティチェックを行い、
必要に応じてissueを作成してください"
```

#### パターン4: 動的プロジェクト管理
```bash
# 新issue作成時の自動分類
"新しく作成されたissue #X を分析して、
メタissue #8 に適切なカテゴリで追加してください"

# 全体状況の定期確認
"現在のオープンissueを確認し、メタissue #8 を更新してください。
優先度の変更が必要な課題があれば提案してください"

# プロジェクト方向性の相談
"メタissue #8 の現在の状況を見て、
次の2週間で取り組むべき優先課題を3つ提案してください"
```

##### メタissue更新時のフォーマット（重要）
```bash
# GitHubでissue番号を展開させるためにリスト形式を使用
# ❌ 悪い例（展開されない）
✅ #3 [Critical] CORS設定修正完了
📊 更新後進捗: Critical 1/2, Foundation 0/3, Quality 0/2

# ⭕ 良い例（issue番号が展開される）
- ✅ #3 [Critical] CORS設定修正完了
- 📊 更新後進捗: Critical 1/2, Foundation 0/3, Quality 0/2

# 完了時の更新例
gh issue comment 8 --body "- ✅ #3 [Critical] CORS設定の修正完了（PR #10）
- 📊 更新後進捗: Critical 1/2, Foundation 0/3, Quality 0/2

## 次の優先事項
- #4 GitHub Actionsワークフローの設定を開始します

## 新規issue追加
- #9 環境変数の型安全管理システム（Quality カテゴリ）"
```

### 📊 プロジェクト状況の把握

#### 定期確認コマンド
```bash
# アクティブなissue一覧
gh issue list --state open

# 高優先度issue確認
gh issue list --label "priority-high" --state open

# 自分にアサインされたissue
gh issue list --assignee @me

# 最近の活動
gh issue list --limit 10
```

#### Claude Codeでの状況確認
```bash
# プロジェクト全体の健康状態チェック
"現在のオープンissueを確認し、優先度の高いものから
3つ選んで対応方針を提案してください"

# 技術的負債の特定
"コードベース全体を確認し、リファクタリングが必要な箇所を
issueとして起票してください"
```

### 🎯 成功指標
- **Issue解決率**: 月間でクローズしたissue数
- **レスポンス時間**: issue起票から着手までの時間
- **品質向上**: バグissueの減少傾向
- **自動化率**: 手動作業のissue化・自動化実装

### 💡 Tips

#### 効率的なissue作成
```markdown
## Issueテンプレート
**問題**: 何が問題か
**影響**: だれ・何に影響するか  
**再現**: どうやって確認するか
**期待**: どうなればよいか
**完了条件**: 何をもって完了とするか
```

#### Claude Code連携のコツ
- issue番号を必ず参照する
- 関連ファイルのパスを具体的に指定
- 完了条件を明確にする
- 実装後の確認方法を含める

#### ブランチ命名規則
```bash
# 基本形式
feature/<issue番号>

# 例
feature/1   # issue #1 対応
feature/10  # issue #10 対応

# NGパターン（冗長すぎる）
feature/issue-1-fix-cors-settings
feature/1-cors-fix

# 理由：シンプルで一意性が保たれ、issue番号で容易に追跡可能
```

#### コミットメッセージ規則
```bash
# 基本形式（先頭にissue番号、日本語と英語の両方記載）
#<issue番号> <type>: <日本語タイトル> / <English title>

日本語:
- 変更内容1
- 変更内容2

English:
- Change 1
- Change 2

# 実例
#3 fix: CORS設定のセキュリティ修正 / Update CORS configuration for security

日本語:
- 環境別のCORS設定を実装
- ワイルドカード（*）を明示的な許可オリジンに置き換え

English:
- Implement environment-based CORS configuration
- Replace wildcard (*) with explicit allowed origins

# コミットタイプ
feat:     # 新機能
fix:      # バグ修正
docs:     # ドキュメント更新
style:    # コードスタイル修正
refactor: # リファクタリング
test:     # テスト追加・修正
chore:    # ビルド・設定等

# 理由：
# - 日本語/英語両方で国際的なコラボレーションに対応
# - GitHub上でissue番号クリックで簡単に参照可能
# - コミット履歴でissueとの関連が一目瞭然
```

#### PRタイトル規則
```bash
# 基本形式（末尾にissue番号）
<type>: <description> #<issue番号>

# 例
Fix: CORS configuration security issue #3
Feat: implement SQLite database layer #5
Test: fix E2E user creation tests #1

# 理由：
# - タイトルの内容が先に読める（可読性重視）
# - GitHubのPR一覧で内容とissue番号が両方見える
# - issue番号が末尾にあることで統一感がある
```

## TODO・既知の課題

### 🎯 プロジェクト全体管理
- **プロジェクト進捗追跡** [#8](https://github.com/suguruTakahashi-1234/hono-learning/issues/8)
  - 全issueのロードマップと進捗管理
  - フェーズ別の優先度付け
  - 工数見積もりと成功基準

### 🚨 緊急度：高
- **E2Eテストのユーザー作成API修正** [#1](https://github.com/suguruTakahashi-1234/hono-learning/issues/1)
  - ファイル: `e2e/user-flow/critical-path.spec.ts:32`、`e2e/visual/home-page.spec.ts:43`
  - 現象: フォーム送信時に「エラーが発生しました」表示
  - 調査: サーバーAPIとクライアント間の通信、CORS設定、APIエンドポイント

- **CORS設定の見直し** [#3](https://github.com/suguruTakahashi-1234/hono-learning/issues/3)
  - ファイル: `packages/server/src/app.ts`
  - 問題: 全ドメイン許可のセキュリティリスク
  - 対応: 環境別CORS設定の実装

- **GitHub Actionsワークフロー設定** [#4](https://github.com/suguruTakahashi-1234/hono-learning/issues/4)
  - 問題: CI/CDパイプライン未設定
  - 対応: 自動テスト・品質チェック・デプロイの実装

- **データ永続化層の実装** [#5](https://github.com/suguruTakahashi-1234/hono-learning/issues/5)
  - 問題: メモリベースでデータが永続化されない
  - 対応: SQLite + Drizzle ORMの導入

- **認証・認可システムの実装** [#6](https://github.com/suguruTakahashi-1234/hono-learning/issues/6)
  - 問題: APIが無認証でアクセス可能
  - 対応: JWT認証とミドルウェアの実装

### 📋 緊急度：中
- **Schemathesis導入** [#2](https://github.com/suguruTakahashi-1234/hono-learning/issues/2)
  - OpenAPI仕様からの自動APIテスト生成
  - 効果: APIのエッジケーステストの自動化

- **テストカバレッジの向上** [#7](https://github.com/suguruTakahashi-1234/hono-learning/issues/7)
  - 問題: カバレッジレポート未設定、単体テスト不足
  - 対応: Vitestカバレッジ設定とテスト拡充

### 💡 緊急度：低
- **テスト結果レポートの改善**
  - Playwright HTMLレポートのカスタマイズ
  - CIでのテスト結果可視化

## セキュリティベストプラクティス

詳細は[CORSベストプラクティス](./knowledge/security/cors-best-practices.md)を参照してください。

## 導入を見送ったツール

このプロジェクトでは、以下のツールの導入を検討しましたが、現時点では見送っています：

### ビルドツール
- **❌ Turborepo** - 4パッケージ程度の規模では速度向上がほぼない。10パッケージ以上になったら再検討
- **❌ tsup** - TypeScriptのcomposite/incrementalと競合し、設定が複雑化。tscで十分高速
- **❌ esbuild** - 型定義ファイル生成ができない。フロントエンドはViteが既に使用

### バージョン管理
- **❌ Changeset** - NPMパッケージとして公開予定がないため不要
- **❌ syncpack** - pnpmの`update`コマンドで十分。依存関係の厳密な同期は小規模では過剰

### その他のツール
- **❌ Lefthook** - Huskyで十分機能している。v10移行時に再検討
- **❌ nx** - エンタープライズ向けで学習プロジェクトには過剰
- **❌ Lerna** - pnpmワークスペースで十分。追加の抽象化層は不要

### 導入基準
新しいツールを導入する前に、以下を確認してください：
1. 現在の課題を明確に解決するか
2. 設定・学習コストに見合う価値があるか
3. 既存ツールと競合しないか
4. プロジェクト規模に適しているか

## TypeScript設定の注意点

### module と moduleResolution の設定戦略

#### ベース設定（tsconfig.base.json）
- **module**: `"ESNext"` - 最新のESM仕様に準拠
- **moduleResolution**: `"Bundler"` - モダンなツールチェイン向けの柔軟な解決

#### パッケージごとの設定
1. **@myapp/server**
   - **module**: `"NodeNext"` - Node.jsのESMに完全準拠（拡張子必須）
   - **moduleResolution**: `"NodeNext"` - package.json の exports フィールドを認識
   - 理由: Node.jsランタイムで直接実行されるため

2. **@myapp/web-client**
   - ベース設定を継承（ESNext/Bundler）
   - 理由: Viteがバンドル時に解決

3. **@myapp/api-client**
   - ベース設定を継承（ESNext/Bundler）
   - 理由: 自動生成コードで拡張子省略がある

4. **@myapp/shared**
   - ベース設定を継承（ESNext/Bundler）
   - 理由: 複数環境で使用される共通ライブラリ

### NodeNext vs ESNext/Bundler の使い分け
- **NodeNext**: Node.jsで直接実行されるコード（サーバー）
  - 拡張子の明示が必須（`.js`）
  - package.jsonのexportsフィールドを厳密に解釈
  - CommonJSとの相互運用性を保証
  
- **ESNext/Bundler**: バンドラーやツールチェインで処理されるコード
  - 拡張子の省略が可能
  - より柔軟なモジュール解決
  - 最新のESM機能をフル活用

### exports フィールド
全パッケージで`exports`フィールドを設定し、ESMに完全対応：
```json
"exports": {
  ".": {
    "types": "./dist/index.d.ts",
    "import": "./dist/index.js"
  }
}
```

## テスト

### テストコマンド

#### 単体テスト・統合テスト（Vitest）
- `pnpm test` - 全パッケージでテスト実行（一度だけ実行）
- `pnpm test:watch` - テスト実行（watch mode）
- `pnpm test:ui` - Vitest UIでテスト実行
- `pnpm test:coverage` - カバレッジレポート生成

#### パッケージ個別のテスト実行
- `pnpm --filter @myapp/shared test` - sharedパッケージのテスト
- `pnpm --filter @myapp/server test` - serverパッケージのテスト
- `pnpm --filter @myapp/web-client test` - web-clientパッケージのテスト

#### E2Eテスト（Playwright）
- `pnpm test:e2e` - 基本的な動作確認テストを実行
- `pnpm test:e2e:ui` - Playwright UIでテスト実行
- 初回実行時: `pnpm playwright install` でブラウザをインストール

#### ビジュアルリグレッションテスト（無料・画像差分）
- `pnpm test:e2e:visual` - 画像スクリーンショット比較テスト実行
- `pnpm test:e2e:visual:update` - スクリーンショットを更新（UIを変更した場合）
- `pnpm test:e2e:visual:ui` - Playwright UIで画像差分を確認

**特徴**:
- 追加ライブラリ不要（Playwright標準機能）
- 初回実行時に自動でベースライン画像生成
- 差分がある場合は差分画像を自動生成
- `e2e/**/*.png` にスクリーンショット保存

#### テスト命名規約（ファイル名を簡潔に）

```typescript
// ❌ 悪い例：日本語を含むと冗長なディレクトリ名になる
test.describe("ビジュアルテスト @visual", () => {
  test("ホームページ全体のスクリーンショット", async ({ page }) => {
// → test-results/visual-ビジュアルテスト-visual-ホームページ全体のスクリーンショット-chromium/

// ✅ 良い例：意味のある英語名で管理、日本語はコメントで記載
test.describe("visual @visual", () => {
  test("home-page-full", async ({ page }) => {
    // ホームページ全体のスクリーンショット
// → test-results/visual-home-page-full-chromium/
```

**命名ルール**:
- `test.describe`: 機能カテゴリを短い英語で（例: `visual`, `auth`, `api`）
- `test`: 「何を-どうする」形式の英語（例: `user-login-success`, `form-validation-error`）
- 日本語の説明はテスト内のコメントで記載
- 番号管理は避ける（メンテナンスが困難）

**推奨パターン**:
```typescript
// 視覚的テスト
test.describe("visual @visual", () => {
  test("home-page-full", async ({ page }) => { // ページ全体
  test("form-section", async ({ page }) => {    // 特定セクション
  test("error-state", async ({ page }) => {     // 特定の状態

// 機能テスト
test.describe("user-management", () => {
  test("create-user-success", async ({ page }) => { // 成功ケース
  test("create-user-validation", async ({ page }) => { // バリデーション
  test("delete-user-confirm", async ({ page }) => { // 削除確認

// 複数ページのテスト
test.describe("multi-page @visual", () => {
  test("about-page-full", async ({ page }) => { // 別ページ
  test("navigation-flow", async ({ page }) => {  // ページ遷移
```

**複数ページのテスト構成**:
- 各ページごとに`describe`ブロックを分ける
- 共通のナビゲーションテストは別ブロックに
- ページ固有のビジュアルテストとフローテストを分離
- test-resultsのディレクトリが整理される

#### テスト結果の確認方法

**1. コンソール出力**
```bash
pnpm test:e2e
# 簡潔なリスト形式で結果表示
```

**2. HTMLレポート**
```bash
# テスト実行後に生成されるレポートを手動で開く
open playwright-report/index.html  # macOS
start playwright-report/index.html  # Windows
```

**3. テスト失敗時の確認**
```
test-results/
├── <test-describe>-<test-name>-<browser>/
│   ├── test-failed-1.png      # 失敗時のスクリーンショット
│   ├── *-actual.png           # 実際の画像（ビジュアルテスト）
│   ├── *-expected.png         # 期待される画像（ビジュアルテスト）
│   ├── *-diff.png             # 差分画像（ビジュアルテスト）
│   └── error-context.md       # エラーの詳細情報
```

**4. ビジュアルテストのスナップショット**
```
e2e/visual.spec.ts-snapshots/
├── home-page-full-chromium-darwin.png
├── form-section-chromium-darwin.png
└── ... (各ブラウザ・OS別に保存)
```

#### APIテスト自動生成（Schemathesis）
- `pnpm test:api:auto` - OpenAPIからAPIテストを自動実行（実装予定）
- `pnpm test:api:fuzzing` - ファジングテストも自動実行（実装予定）

### テストファイルの構成

テストファイルは各パッケージの`src/__tests__/`ディレクトリに配置されています：

```
packages/
├── shared/src/
│   ├── __tests__/
│   │   └── index.test.ts
│   └── index.ts
├── server/src/
│   ├── __tests__/
│   │   └── app.test.ts
│   └── app.ts
└── web-client/src/
    ├── __tests__/
    │   ├── App.test.tsx
    │   └── setup.ts
    └── App.tsx
```

### テスト戦略

詳細は[テスト戦略 2025年ベストプラクティス](./knowledge/testing/testing-strategy-2025.md)を参照してください。

### 各パッケージのテスト設定

各パッケージには独自の`vitest.config.ts`があります：

- **server/shared**: `environment: "node"`
- **web-client**: `environment: "jsdom"` + React Testing Library

### テストカバレッジ

カバレッジレポートは以下のファイルを除外：
- `**/*.config.*`
- `**/dist/**`
- `**/node_modules/**`
- `**/src/generated/**` (自動生成コード)

## 環境変数の管理

現在は`CI`環境変数のみを使用しています。将来的に環境変数が増えた場合：

### 推奨アプローチ
1. **開発環境**: `.env.local`ファイル（gitignore済み）
2. **型定義**: 各パッケージで必要に応じて`env.d.ts`を作成
3. **バリデーション**: `@t3-oss/env-core`の導入を検討

### 現在の対応
- Playwright設定では`process.env.CI === "true"`で判定
- CI環境（GitHub Actions等）は自動的に`CI=true`を設定
- workersは`undefined`にして自動設定を利用（型エラー回避）
```

## メモリ（to memorize）
```

---

## 🤖 アシスタント
*2025/5/27 18:46:21*

以下では、**内容の重複・曖昧さ・最新運用との不整合**という観点で「今の CLAUDE.md を読む人 / AI / CI」の三者が迷わず使えるようにするために、**直しておくと効果が高いポイント**を優先順にまとめました。  
（🛠 = すぐ直せる小修正、🚧 = 構成レベルの見直し、🔐 = セキュリティ観点）

---

## 1️⃣ 最上部の “必須指示” ブロックをもっと短く 🚧
|問題|修正案|
|---|---|
|**重要指示が 5 行目以降に分散**しており、初見で埋もれる|「日本語出力」「pnpm check」など **“絶対守る 3 ルール”** だけ先頭に箱囲いで記載し、詳細コマンドは下位節へ移動|
|“参照系作業の権限”と“pnpm権限”が長く、読む負荷↑|**✅/❌ マトリクス表**（←yes/no 区別だけ）に縮約し 5 行以内に|

---

## 2️⃣ **「AI へのプロンプト指針」** が散在している → 独立節に 🛠
- **「issue 番号を必ず参照する」等が末尾 Tips に埋もれ**ており、Claude を初利用の人が気づきにくい  
  → `## Claude への依頼ガイドライン` に **✔︎ 5 箇条**（例: *必ず #123 の形式で issue を指定*）をまとめ、末尾の重複 Tip は削除。

---

## 3️⃣ コマンド表の **重複・陳腐化リスク** を低減 🚧
|観点|現状|修正案|
|---|---|---|
|**`pnpm check`** が 3 ヶ所に出現|1 ヵ所へ統合し、他は「→ `pnpm check` を参照」とリンク|
|似た説明が “日常開発”“品質管理”“開発フロー” に重複|`docs/commands.md` に **1 行説明付き早見表**を分離し、CLAUDE.md は「よく使う 5 コマンド」だけ残す|

---

## 4️⃣ **Git フロー節** が実運用とズレる恐れ 🛠
- チェックリストに **`git rebase main`** を推奨とあるが、CI が *merge コミット前提* なら衝突。  
  → **プロジェクトの事実（merge or rebase）を明記**し、不要な手順は削除。

---

## 5️⃣ **権限制御を明示的に** 🔐
|問題|修正案|
|---|---|
|“参照系は無制限OK”と書いているが、**書き込み系の可否が抜けている**|`## ファイル操作ポリシー` を追加し、&lt;br&gt;**Write / Delete / Shell exec** など **禁止 or 要レビュー** をテーブルで列挙|
|`pnpm install` 系をフル許可すると **supply-chain attack** リスク|「本番依存は要 PR / devDependency は OK」など **ワークスペース別ルール** を補足|

---

## 6️⃣ **トークン／ファイルサイズ制限** が未記載 🛠
- “コンテキスト limit” の悩みが動機なら、**`## コンテキスト圧縮ルール`** を新設し、  
  - *最大 800 tokens*  
  - *添付は 200 行以下*  
  を明文化。（→ AI が自動要約を提案しやすい）

---

## 7️⃣ **セキュリティ & CI の最新状態をリンクで** 🛠
- 「CORS ベストプラクティス」等は **knowledge/ 側の単独ドキュメント** を一次情報にして、CLAUDE.md では **更新日時とリンクだけ**。  
  → 長期でメンテ負荷を減らせる。

---

## 8️⃣ **TODO / 既知課題** は Project へ移管 🚧
- CLAUDE.md 自体に #1 #3 … を列挙すると **二重管理**。  
  → `TODO:` 節は「**→ Project #16 ‘Backlog’ に集約**」の 1 行だけ残して削除。

---

## 9️⃣ **英語混在のコミット規約** は “必須 or 推奨” を分離 🛠
- 現状「日本語/英語両方書く」が **強制なのか任意なのか曖昧**。  
  → `必須: 先頭の #issue と type` / `任意: Bilingual body` のように区分。

---

## 🔟 ファイル肥大化対策 🚧
- 🎯 9,000 行超→ **5 分で読み切れない**  
  1. `00_CLAUDE_PRIMER.md` – 必須 100 行  
  2. `docs/ops/branching.md` – Git フロー詳説  
  3. `docs/ops/commands.md` – コマンド表  
  … のように **3~4 ファイル** へ分割し、トップの `README` だけに “目次 + TL;DR” を置く。

---

### ✨ まとめ – 最低限やるなら
1. **先頭に「絶対守る 3 行」だけ残す**  
2. **AI プロンプト指針とコンテキスト制限を 1 章で整理**  
3. **長大コマンド表・TODO リストは外部 docs/ に移動**  

これで *読む人が迷わず*・*AI が過不足なく理解でき*・*メンテが軽く* なります。

---

## 👤 ユーザー
*2025/5/27 19:14:18*

WindsurfやCursorやCopilotやDevinなど、ルールを設定する記述がClaude Code 同様にあると思うが、この手のAIがルール通りに開発するために行うべきTipsなどがあれば教えて欲しい。

---

## 🤖 アシスタント
*2025/5/27 19:14:19*

## AI コーディング‐アシスタント共通の「ルール厳守」テクニック集

| フェーズ | ❶ プロジェクト側で用意 | ❷ プロンプト／チャットで徹底 | ❸ “機械チェック”で担保 |
|---|---|---|---|
| **仕様・規約提示** | - **AI 専用ガイド**をルートに置く <br>  `CLAUDE.md` / `COPILOT.md` / `CURSOR.md` … <br>  → *必須ルールは 100 行以内* <br>- `.editorconfig` / `biome.json` / `eslint.config.*` など **機械可読設定** | - セッション開始時に **ガイドファイルを貼るかパスを明示** <br>- 「**出力は常に日本語**」など *1 行ルール* を毎回添える | - CI で **設定ファイル存在チェック** (actionlint / script) |
| **コード生成** | - **スキャフォルド用テンプレ**を用意し、 <br>  AI には “内容を埋めるだけ” にさせる | - 「★ 触れて良いのは `src/**/*.ts` だけ」 <br>- 「⚠️ ファイル追加は必ず `pnpm lint:fix` 実行後」 | - **fail-fast lint**（pnpm check） <br>- **Danger.js** で「変更加えたファイルは X だけか？」 |
| **コミット** | - `commitlint` & `husky` でメッセージ強制 | - プロンプト例：<br>  「`#3 fix: ...` の形式で 50 文字以内」 | - PR に **コミットメッセージ CI** |
| **テスト** | - 生成しやすい **空のテストスケルトン** を置く | - 「実装後 `pnpm test` → グリーンを確認して返答」 | - CI / ReviewBot で失敗ブロック |
| **ドキュメント更新** | - `docs/TEMPLATE.md` を用意 <br>- `gh` alias で自動タイトル生成 | - 「コード変更に伴う **docs 更新タスクも一緒に**」 | - **Markdown link checker** で壊れたリンク検知 |

---

### 1. AI 専用ガイドファイルを“1 ファイルにつき 1 役割”で分ける
| ガイド | 主な内容 | サイズのめやす |
|---|---|---|
| `xxx.md` (各 AI) | **入出力言語・禁止事項・必須コマンド 3 つ** | 〜100 行 |
| `docs/commands.md` | すべての pnpm/gh コマンドの辞書 | 必要に応じて |
| `docs/branching.md` | Git フロー詳細 | 必要に応じて |

> **Tip**: 巨大 1 ファイルは “読まずに実行→失敗” の元凶。**入口は TL;DR に絞る→深掘りドキュメントへリンク**が鉄則。

---

### 2. チャットプロンプトに組み込む「ミニ定型文」

```text
# いつでも貼る 3 行
• 出力は日本語のみ
• 触れてよいのは src/**/*.ts, test/**/*.ts
• 実装後 `pnpm check` が通ることを必ず確認
```

- Copilot Chat → `/system` か **最初のメッセージ**で固定
- Cursor → 「Pin Prompt」に保存
- Windsurf / Devin → セッションプリセットに登録

---

### 3. 各ツール固有の小ワザ

| ツール | 実行中に効くテクニック |
|---|---|
| **Copilot Chat** | - 先頭に `@sys` ブロック → ルールを“システム指示”扱い <br>- `.copilot/ignore` に **生成対象外**パスを列挙 |
| **Cursor** | - `// cursor: no-edit` コメントで **行単位ロック** <br>- `Cursor.json` に **preset prompt** を保存（共有可） |
| **Windsurf** | - **Prompt Stack** で「会社標準ルール」を最上位に固定 <br>- `windsurf/projects.toml` で **ツール毎コマンド**を宣言 |
| **Devin** | - “タスク分割→サブタスク実行”が特徴。**各サブタスクの Done 条件**を明記すると精度↑ |

---

### 4. 「AI が破ったら自動で落ちる」仕組みを最後の盾に

1. **lint / typecheck / test を 1 つでも落ちたら PR に赤バッジ**  
2. **CI で diff size や TODO コメント検査**  
   ```yaml
   - uses: reviewdog/action-actionlint@v1
   - run: grep -R --line-number 'TODO' src/ && exit 1 || true
   ```
3. **Danger.js** で *規約違反コミット* を強制ブロック  
   ```js
   if (!pr.title.match(/^#[0-9]+ (feat|fix|docs):/))  fail("PR タイトルが規約違反です")
   ```

---

### 5. まとめ – 人･AI･CI の三層で“抜け”を塞ぐ

| 層 | 役割 |
|---|---|
| **人** | 最初に *短い* ガイドを整える／例外判断 |
| **AI** | ガイドに従い生成・修正を自動化 |
| **CI** | ガイド違反を**情け容赦なく失敗**させる |

この三層で回しておくと、どの AI を使っても **「ルールを守ったコミットだけが main に入る」** 開発サイクルを維持できます。

---

## 👤 ユーザー
*2025/5/27 19:16:29*

たとえばdocs/commands.mdやdocs/branching.mdはプロジェクト内部におくべきなのか？それとも、gistとかでURL形式の方が読みやすいのか？

---

## 🤖 アシスタント
*2025/5/27 19:16:30*

### “リポジトリ内 docs” と “外部 URL（Gist・社内 Wiki など）”――目的別の置き場所ガイド

| 判断軸 | **リポジトリ `docs/` 内** が向く | **外部 URL**（Gist／Wiki／Notion…）が向く |
|---|---|---|
| **バージョンとコードの同期** | - コード変更と同じ PR で更新できる<br>- “そのコミット時点で正しい手順” を保証 | - 複数リポで共有する共通手順<br>- リンク 1 本で参照するだけで OK |
| **CI／自動チェック** | - `markdownlint`, link-checker で壊れた手順を **ビルド落とし** | - CI 対象外なので壊れたまま残りやすい |
| **検索性 (⌘/Ctrl-F, GitHub Search)** | - `repo:myapp docs/branching.md` で即ヒット | - GitHub 全文検索の対象外 |
| **オフライン閲覧 (IDE 内 README Preview)** | - VS Code などでコードと並べて読める | - ブラウザ起動 → ログインが必要な場合も |
| **リンクの耐久性** | - 相対パスなので **リネームに強い** | - Gist 削除、Workspace 移行で 404 リスク |
| **社外公開／社内秘** | - OSS なら公開しやすい<br>- クローズドなら権限設定が集中 | - 同じ手順をクローズド／オープンで“差分だけ”変えたい |
| **長大ドキュメント (>数百行)** | - GitHub UI だと読みにくい → **Docs サイト化**を検討 | - Gatsby / MkDocs などで**読み物として整形**できる |

#### TL;DR – 迷ったらこう置く
| ファイル | 推奨置き場 | 理由 |
|---|---|---|
| **`docs/commands.md`**<br>(pnpm や gh の “このリポジトリ専用” コマンド辞書) | **リポジトリ内** | コマンド更新はソース変更と 1 セット。CI でリンク切れ検知も可能 |
| **`docs/branching.md`**<br>(このリポジトリだけの Git フロー詳細) | **リポジトリ内** | コンフリクトの手順など “コード基盤に依存” するため |
| **会社共通ハンドブック / ESLint 汎用ルール** | **外部 URL** | 複数リポで共通化。更新を一箇所に集約 |
| **長文チュートリアルや設計思想エッセイ** | 外部 (Notion / GitHub Pages) **＋**<br>README からリンク | 可読性重視。Markdown 単独だと UI がつらい |

---

## 実務 Tips – 併用すると読みやすさが大幅向上

### 1. **“リポジトリ内 → サイト化” で両取り**

1. `docs/` をそのまま **MkDocs / Docusaurus** で GitHub Pages にデプロイ  
2. **相対リンクは維持**されるので、  
   - AI はリポジトリパスで読める  
   - 人は https://foo.github.io/docs/commands/ で快適閲覧  
3. CLAUDE.md や README のリンクは **「相対パス ＋ 外部 URL」両方**を書き、どちらでも辿れるように。

```md
### コマンド早見表
- [docs/commands.md](./docs/commands.md) – ソースツリー内
- <https://myapp.github.io/docs/commands/> – サイト表示（読みやすい）
```

### 2. **“共通ルール” は Git Submodule / npm-package 化も可**

- 会社全体で使う **`coding-guidelines.md`** を「docs-guidelines」リポジトリに置き、必要な各社内 repo に **submodule** で取り込む → コードレビューと同じプロセスで変更可。  
- もっと機械可読にしたい場合は **`@myorg/dev-guides`** という npm package にし、`node_modules/.bin/open-guide` で PDF/HTML 展開する方式も。

### 3. **“外部 URL” にする場合の落とし穴を回避**

| リスク | ガード方法 |
|---|---|
| URL 404 | - **リンクチェッカー CI** をリポジトリ側に走らせる<br>- Gist の削除権限を限定 |
| 変更履歴が埋もれる | - Gist でも **commit comment** を必ず書く<br>- 変更時はリポジトリの CHANGELOG に “外部 doc 更新” を記載 |
| AI が読めない | - プロンプトで **必要部分だけコピペ** or<br>  “fetch `https://…raw.githubusercontent.com/.../branching.md`” を依頼 |

### 4. **AI のコンテキスト効率を上げる配置**

- **大項目ごと小分けファイル**：AI に「`docs/commands/md#lint` だけ読んで」と指示できる  
- **冒頭 5 行で要約 + 更新日**：AI がインデックス作りやすい  
- **コード例は最小に**：長文コードは別 `.example.ts` にし、必要時だけ読み込む

---

## 結論

1. **プロジェクトに直結し、コードと一緒に進化させたい文書**（コマンド一覧・ブランチ手順）は **リポジトリ内 `docs/`** が原則。  
2. **横展開したい共通知識や長文ハンドブック**は **外部 URL** に集約し、README/CLAUDE.md からリンク。  
3. 読みやすさを高めるなら **リポジトリ内 docs を自動でサイト化**し、“相対リンク + 公開 URL” の二重リンク方式で人も AI も迷わない構成にする。

---
