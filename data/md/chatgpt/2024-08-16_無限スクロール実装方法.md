# ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Ÿè£…æ–¹æ³•

Date: 2024-08-16

---

## ðŸ‘¤ User
*2024-08-16 12:07:13*

ä»¥ä¸‹ã‚’ç„¡é™ã«ãƒ«ãƒ¼ãƒ—ã—ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹æ–¹æ³•ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ

@available(iOS 17.0, *)
public struct TransitionScrollDesignView: View {
    let items: [ScrollDesignViewItem]
    let spacing: CGFloat
    let padding: CGFloat

    public var body: some View {
        GeometryReader { geometry in
            ScrollView(.horizontal) {
                LazyHStack(spacing: spacing) {
                    ForEach(items, id: \.id) { item in
                        RoundedRectangle(cornerRadius: 15)
                            .fill(item.color.gradient)
                            .frame(width: max(geometry.size.width - padding * 2, 0), height: 100)
                            .scrollTransition(.interactive, axis: .horizontal) { view, phase in
                                view
                                    .scaleEffect(phase.isIdentity ? 1 : 0.95)
                                    .offset(y: phase.isIdentity ? -15 : 0)
                            }
                            .offset(y: 15)
                    }
                }
                .padding(.horizontal, padding)
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned) // paging ã ã¨ä¸Šæ‰‹ãã„ã‹ãªã„
            .scrollIndicators(.hidden)
        }
        .frame(height: 150)
    }
}

---

## ðŸ¤– Assistant
*2024-08-16 12:07:37*

ã“ã®ã‚ˆã†ãªæ°´å¹³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ“ãƒ¥ãƒ¼ã‚’ç„¡é™ã«ãƒ«ãƒ¼ãƒ—ã•ã›ã‚‹ãŸã‚ã«ã¯ã€è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹è¦ç´ ã®æœ€å¾Œã¨æœ€åˆã‚’æŽ¥ç¶šã™ã‚‹å·¥å¤«ãŒå¿…è¦ã§ã™ã€‚ã“ã‚Œã¯é€šå¸¸ã€ã€Œãƒ‡ãƒ¼ã‚¿ã®è¤‡è£½ã€ãŠã‚ˆã³ã€Œä½ç½®ãƒªã‚»ãƒƒãƒˆã€ã‚’ä½¿ç”¨ã—ã¦å®Ÿç¾ã—ã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€é…åˆ—ã®å‰å¾Œã«ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¦ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ãŒæœ€åˆã¾ãŸã¯æœ€å¾Œã«åˆ°é”ã—ãŸã¨ãã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æ°—ã¥ã‹ã‚Œãªã„ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚

ä»¥ä¸‹ã«ãã®å®Ÿè£…ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
@available(iOS 17.0, *)
public struct TransitionScrollDesignView: View {
    let items: [ScrollDesignViewItem]
    let spacing: CGFloat
    let padding: CGFloat
    
    // Add duplicated items at the start and end for infinite scroll
    private var loopedItems: [ScrollDesignViewItem] {
        let loopItems = items
        return [items.last!] + loopItems + [items.first!]
    }

    @State private var scrollOffset: CGFloat = 0
    @State private var isScrolling = false
    
    public var body: some View {
        GeometryReader { geometry in
            ScrollView(.horizontal) {
                LazyHStack(spacing: spacing) {
                    ForEach(loopedItems, id: \.id) { item in
                        RoundedRectangle(cornerRadius: 15)
                            .fill(item.color.gradient)
                            .frame(width: max(geometry.size.width - padding * 2, 0), height: 100)
                            .scrollTransition(.interactive, axis: .horizontal) { view, phase in
                                view
                                    .scaleEffect(phase.isIdentity ? 1 : 0.95)
                                    .offset(y: phase.isIdentity ? -15 : 0)
                            }
                            .offset(y: 15)
                    }
                }
                .padding(.horizontal, padding)
                .scrollTargetLayout()
                .content.offset(x: scrollOffset)
                .onAppear {
                    // Set the initial scroll position to the second item
                    scrollOffset = -geometry.size.width + padding * 2 + spacing
                }
                .gesture(
                    DragGesture()
                        .onChanged { value in
                            isScrolling = true
                            scrollOffset = value.translation.width + (scrollOffset)
                        }
                        .onEnded { _ in
                            isScrolling = false
                            let scrollThreshold = geometry.size.width - padding * 2 + spacing
                            // Check if the scroll position is close to the start or end
                            if scrollOffset > 0 {
                                // Snap to the last item (loop)
                                withAnimation {
                                    scrollOffset = -(scrollThreshold * CGFloat(items.count))
                                }
                            } else if scrollOffset < -scrollThreshold * CGFloat(items.count + 1) {
                                // Snap to the first item (loop)
                                withAnimation {
                                    scrollOffset = -scrollThreshold
                                }
                            }
                        }
                )
            }
            .scrollTargetBehavior(.viewAligned)
            .scrollIndicators(.hidden)
        }
        .frame(height: 150)
    }
}
```

### èª¬æ˜Žï¼š
1. **Duplicated Items**: `loopedItems` å¤‰æ•°ã«ã‚ˆã‚Šã€æœ€åˆã¨æœ€å¾Œã®é …ç›®ã‚’è¤‡è£½ã—ã€ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ„Ÿã‚’ä½œã‚Šå‡ºã—ã¾ã™ã€‚
2. **Scroll Position Reset**: `DragGesture` ã‚’ä½¿ç”¨ã—ã¦ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæœ€å¾Œã®é …ç›®ã«åˆ°é”ã—ãŸå ´åˆã€æ¬¡ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒæœ€åˆã®é …ç›®ã«æˆ»ã‚‹ã‚ˆã†ã«ã€`scrollOffset` ã‚’èª¿æ•´ã—ã¾ã™ã€‚
3. **Initial Position**: `onAppear` ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ“ãƒ¥ãƒ¼ãŒæœ€åˆã«è¡¨ç¤ºã•ã‚Œã‚‹ä½ç½®ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ°—ã¥ã‹ãªã„å½¢ã§ç„¡é™ã«ãƒ«ãƒ¼ãƒ—ã™ã‚‹æ°´å¹³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚

---
