# Dio基本使い方

Date: 2024-12-18

---

## 👤 User
*2024-12-18 17:34:53*

flutterのdioについて色々教えてほしい

---

## 🤖 Assistant
*2024-12-18 17:35:37*

**Dio** は、Flutterで人気のあるHTTPクライアントライブラリで、REST APIとの通信を簡単に行うために使用されます。機能が豊富でカスタマイズ性が高いのが特徴です。

以下にDioの基本的な使い方や特徴、応用方法について解説します。

---

## **Dioの特徴**
1. **シンプルなAPI**  
   HTTPリクエスト（GET、POST、PUT、DELETEなど）を簡単に記述可能。
   
2. **リクエストとレスポンスのインターセプター**  
   リクエストやレスポンスに対して前処理・後処理を挟むことが可能。

3. **リクエストキャンセル**  
   特定のリクエストをキャンセルできる機能を提供。

4. **タイムアウト設定**  
   接続、読み取り、書き込みのタイムアウトを個別に設定可能。

5. **Base URLの設定**  
   ベースとなるURLを設定し、リクエストごとに記述を省略可能。

6. **ファイルアップロード/ダウンロード**  
   簡単にファイルのアップロードやダウンロードが可能。

7. **デバッグやログの出力**  
   プラグイン（`dio_logger`や`pretty_dio_logger`など）を利用して、デバッグ用ログを出力可能。

8. **JSON自動パース**  
   JSONレスポンスを簡単に解析する機能を持つ。

---

## **Dioのインストール**
```yaml
dependencies:
  dio: ^5.0.0
```

`pubspec.yaml`に追加後、以下を実行してインストールします。
```bash
flutter pub get
```

---

## **基本的な使い方**

### **1. シンプルなGETリクエスト**
```dart
import 'package:dio/dio.dart';

void main() async {
  final dio = Dio();
  final response = await dio.get('https://jsonplaceholder.typicode.com/posts');
  print(response.data); // レスポンスデータを出力
}
```

### **2. POSTリクエスト**
```dart
final response = await dio.post(
  'https://jsonplaceholder.typicode.com/posts',
  data: {
    'title': 'Flutter',
    'body': 'Dio is amazing!',
    'userId': 1,
  },
);
print(response.data);
```

### **3. タイムアウト設定**
```dart
final dio = Dio(
  BaseOptions(
    connectTimeout: Duration(seconds: 5),
    receiveTimeout: Duration(seconds: 3),
  ),
);
```

---

## **インターセプターの活用**

### **リクエスト前に処理を挟む**
```dart
dio.interceptors.add(
  InterceptorsWrapper(
    onRequest: (options, handler) {
      print('リクエスト送信: ${options.uri}');
      return handler.next(options); // リクエストを続行
    },
    onResponse: (response, handler) {
      print('レスポンス受信: ${response.statusCode}');
      return handler.next(response); // レスポンスを続行
    },
    onError: (DioError e, handler) {
      print('エラー発生: ${e.message}');
      return handler.next(e); // エラーを続行
    },
  ),
);
```

---

## **ファイルアップロード**
```dart
final file = MultipartFile.fromFileSync('path/to/file');
final formData = FormData.fromMap({'file': file});

final response = await dio.post(
  'https://example.com/upload',
  data: formData,
);
print(response.data);
```

---

## **ファイルダウンロード**
```dart
await dio.download(
  'https://example.com/file.zip',
  '/path/to/save/file.zip',
  onReceiveProgress: (received, total) {
    if (total != -1) {
      print('${(received / total * 100).toStringAsFixed(0)}% 完了');
    }
  },
);
```

---

## **リクエストのキャンセル**
```dart
final cancelToken = CancelToken();

dio.get(
  'https://example.com/api',
  cancelToken: cancelToken,
);

// 後でリクエストをキャンセル
cancelToken.cancel('リクエストキャンセル!');
```

---

## **デバッグ用のログ出力**
`pretty_dio_logger`を利用することで、リクエストやレスポンスを見やすく出力可能です。

### インストール
```yaml
dependencies:
  pretty_dio_logger: ^1.3.0
```

### 使用方法
```dart
import 'package:pretty_dio_logger/pretty_dio_logger.dart';

dio.interceptors.add(PrettyDioLogger());
```

---

## **応用例: 認証付きリクエスト**
Bearerトークンをヘッダーに追加して認証リクエストを送信する例です。

```dart
dio.options.headers['Authorization'] = 'Bearer your_token_here';

final response = await dio.get('https://example.com/protected');
print(response.data);
```

---

Dioは柔軟で使いやすいライブラリです。認証、ファイル操作、カスタマイズなどの場面で力を発揮します。もし特定のユースケースや課題があれば、さらに詳しくお手伝いできます！

---

## 👤 User
*2024-12-18 17:36:31*

openapi genで作ったコードでヘッダーにオーソライズトークンを埋め込んだりしたい
dioを使うとどうなるのか？

---

## 🤖 Assistant
*2024-12-18 17:37:22*

OpenAPI Generatorで生成したコードを使って、Dioを利用してHTTP通信を行う場合、ヘッダーに認証トークンを埋め込む方法について説明します。

### **前提**
OpenAPI Generatorでコードを生成する際、`dart-dio`テンプレートを指定しているものとします。このテンプレートはDioを利用したクライアントコードを生成します。

---

## **ヘッダーに認証トークンを埋め込む方法**

### **1. OpenAPI GeneratorでDioテンプレートを使用してコードを生成**
```bash
openapi-generator-cli generate \
  -i api-spec.yaml \
  -g dart-dio \
  -o generated_code
```

これにより、Dioを利用したクライアントが生成されます。例えば、以下のような構造のコードが出力されます：
- `lib/api/api.dart`
- `lib/api/api_client.dart`
- `lib/api/apis/`

---

### **2. 認証トークンをヘッダーに追加**

生成されたコードの中で、HTTPリクエストをカスタマイズするには`ApiClient`を利用します。

#### **2.1 ヘッダーをカスタマイズ**
`ApiClient`の`addDefaultHeader`を使用すると、すべてのリクエストに共通のヘッダーを追加できます。

```dart
import 'package:generated_code/api/api.dart';

void main() async {
  // ApiClientのインスタンスを取得
  final apiClient = ApiClient();

  // 認証トークンをデフォルトのヘッダーに追加
  apiClient.addDefaultHeader('Authorization', 'Bearer your_token_here');

  // 使用するAPIのインスタンスを作成
  final exampleApi = ExampleApi(apiClient);

  // APIリクエストを実行
  final response = await exampleApi.getExample();
  print(response);
}
```

#### **2.2 インターセプターを利用**
生成されたコードでは、Dioのインスタンスを直接操作できます。インターセプターを設定して認証トークンを動的に追加することも可能です。

```dart
void main() async {
  final apiClient = ApiClient();

  // Dioインスタンスを取得
  final dio = apiClient.dio;

  // インターセプターを追加して認証トークンをヘッダーに埋め込む
  dio.interceptors.add(
    InterceptorsWrapper(
      onRequest: (options, handler) {
        options.headers['Authorization'] = 'Bearer your_token_here';
        return handler.next(options); // 次の処理へ
      },
    ),
  );

  final exampleApi = ExampleApi(apiClient);
  final response = await exampleApi.getExample();
  print(response);
}
```

---

### **3. トークンの動的管理**

#### **トークンの更新に対応**
トークンが定期的に更新される場合、Dioのインターセプター内でトークン取得ロジックを追加することで対応可能です。

```dart
dio.interceptors.add(
  InterceptorsWrapper(
    onRequest: (options, handler) async {
      // トークンを動的に取得
      final token = await getToken(); // トークン取得ロジックを実装
      options.headers['Authorization'] = 'Bearer $token';
      return handler.next(options);
    },
  ),
);
```

#### **トークンの有効期限をチェック**
トークンの有効期限をチェックし、有効でない場合にリフレッシュする処理も追加できます。

```dart
dio.interceptors.add(
  InterceptorsWrapper(
    onRequest: (options, handler) async {
      if (isTokenExpired()) {
        await refreshToken(); // トークン更新処理を実装
      }
      options.headers['Authorization'] = 'Bearer ${getToken()}';
      return handler.next(options);
    },
  ),
);
```

---

### **4. カスタムHTTPクライアントの使用**
生成されたクライアントコードを拡張して、認証ヘッダーを含むカスタムDioインスタンスを使用することもできます。

#### **カスタムApiClient**
```dart
class CustomApiClient extends ApiClient {
  CustomApiClient() {
    dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) async {
          final token = await getToken();
          options.headers['Authorization'] = 'Bearer $token';
          return handler.next(options);
        },
      ),
    );
  }
}
```

使用例：
```dart
void main() async {
  final apiClient = CustomApiClient();
  final exampleApi = ExampleApi(apiClient);
  final response = await exampleApi.getExample();
  print(response);
}
```

---

### **5. 環境変数や設定ファイルからトークンを取得**
トークンをハードコーディングせず、セキュアに管理するため、環境変数や設定ファイルからトークンを取得する方法を推奨します。

```dart
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

Future<String> getToken() async {
  final storage = FlutterSecureStorage();
  return await storage.read(key: 'auth_token') ?? '';
}
```

---

## **まとめ**
Dioを使用してOpenAPI Generatorで生成したコードに認証トークンを埋め込むには、以下の手法が便利です：
1. `addDefaultHeader`を使用する。
2. Dioのインターセプターを活用してトークンを動的に追加する。
3. カスタム`ApiClient`を作成して再利用性を高める。

これにより、認証処理を効率化し、セキュアなリクエストを実現できます。

---

## 👤 User
*2024-12-18 17:38:43*

リクエストトークンが変わるたびにAPIリクエストクラスの初期化を行うのは難しくないか？

どうにか差し込みたい

---

## 🤖 Assistant
*2024-12-18 17:39:24*

リクエストトークンが変わるたびにAPIリクエストクラスの初期化を繰り返すのは確かに非効率です。このような場合、Dioの **インターセプター** を活用することで、トークンを動的に差し込む方法が有効です。

---

## **インターセプターで動的にトークンを差し込む方法**

### **解決のポイント**
1. **トークンの一元管理**
   - トークンをシングルトンまたは状態管理ライブラリで一元管理。
   - リクエストごとに動的に取得して適用。

2. **Dioインターセプターの利用**
   - リクエストが実行されるたびに、最新のトークンをヘッダーに差し込む。

---

### **実装例：トークンを動的に差し込む**

以下のように、Dioのインターセプターを利用して、認証トークンをリクエストに差し込むことができます。

```dart
import 'package:dio/dio.dart';

// トークンを一元管理するクラス
class AuthTokenManager {
  String? _token;

  // トークンを取得
  String? get token => _token;

  // トークンを更新
  void updateToken(String newToken) {
    _token = newToken;
  }
}

// グローバルでトークンを管理
final authTokenManager = AuthTokenManager();

void main() async {
  // Dioインスタンスを作成
  final dio = Dio();

  // インターセプターを追加して、リクエストごとにトークンを適用
  dio.interceptors.add(
    InterceptorsWrapper(
      onRequest: (options, handler) {
        // 最新のトークンを取得してヘッダーに差し込む
        final token = authTokenManager.token;
        if (token != null) {
          options.headers['Authorization'] = 'Bearer $token';
        }
        return handler.next(options); // 次の処理へ
      },
    ),
  );

  // リクエストの送信例
  authTokenManager.updateToken("newToken123"); // トークンを更新
  final response = await dio.get('https://example.com/api/data');
  print(response.data);
}
```

---

### **このアプローチのメリット**
1. **トークンの変更に対応**
   - トークンが変更された場合でも、`AuthTokenManager`を更新するだけで、すべてのリクエストに反映される。

2. **コードの簡潔化**
   - 各APIリクエストクラスを再初期化する必要がなくなる。

3. **再利用性**
   - Dioインスタンスを再利用でき、リクエストごとに新しいインスタンスを作成する必要がない。

---

### **応用：トークンのリフレッシュ対応**
トークンが期限切れの場合に自動でリフレッシュするロジックを追加できます。

```dart
dio.interceptors.add(
  InterceptorsWrapper(
    onRequest: (options, handler) async {
      // 最新のトークンを取得
      var token = authTokenManager.token;

      // トークンが期限切れの場合にリフレッシュ
      if (isTokenExpired(token)) {
        token = await refreshAuthToken(); // リフレッシュロジックを実装
        authTokenManager.updateToken(token!); // 新しいトークンを保存
      }

      if (token != null) {
        options.headers['Authorization'] = 'Bearer $token';
      }

      return handler.next(options); // 次の処理へ
    },
  ),
);
```

---

### **トークンの一元管理の代替案**
以下のような方法でもトークンを一元管理できます：

1. **プロバイダ（ProviderやRiverpod）**
   - 状態管理ライブラリを使ってトークンを管理。

2. **Flutter Secure Storage**
   - 永続的なトークン管理が必要な場合。

---

### **まとめ**
- APIリクエストクラスの初期化を繰り返さないために、Dioのインターセプターを利用してトークンを動的に差し込む方法が最適です。
- 状態管理とDioインターセプターを組み合わせることで、トークンの管理と適用を効率化できます。
- トークンの更新やリフレッシュロジックも容易に追加可能です。

この方法を採用すれば、トークンの管理やAPIリクエストが簡単かつ柔軟に行えます！

---

## 👤 User
*2024-12-18 17:40:29*

リバーポッドを使いたい
認証APiがあってそれを使って最初のオーソライズヘッダーをセットしたい

---

## 🤖 Assistant
*2024-12-18 17:41:27*

Riverpod を使用して認証 API を使い、最初のオーソライズヘッダーをセットする方法について説明します。以下に、Riverpod のプロバイダーを活用して認証トークンを管理し、Dio のリクエストに動的にヘッダーを追加する方法を解説します。

---

## **実装ステップ**

### **1. 認証トークンの管理**
認証トークンを `StateNotifierProvider` または `AsyncNotifierProvider` を使用して管理します。

---

### **コード例**

#### **1. トークン管理クラス**
トークンを管理する `AuthNotifier` を作成します。

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AuthNotifier extends StateNotifier<String?> {
  AuthNotifier() : super(null);

  // 認証トークンを取得して保存
  Future<void> fetchAuthToken() async {
    // 認証APIを呼び出してトークンを取得
    final token = await _authenticateUser();
    state = token;
  }

  // トークンをクリア（ログアウトなどで使用）
  void clearToken() {
    state = null;
  }

  // 仮の認証API呼び出し
  Future<String> _authenticateUser() async {
    await Future.delayed(Duration(seconds: 1)); // ダミーの遅延
    return "example_auth_token";
  }
}

// トークンを管理するプロバイダー
final authProvider = StateNotifierProvider<AuthNotifier, String?>((ref) {
  return AuthNotifier();
});
```

---

#### **2. Dioインスタンスの設定**
Dio を使って API クライアントを構築します。

```dart
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Dioクライアントを提供するプロバイダー
final dioProvider = Provider<Dio>((ref) {
  final dio = Dio();

  // インターセプターを追加
  dio.interceptors.add(
    InterceptorsWrapper(
      onRequest: (options, handler) {
        // トークンを取得
        final token = ref.read(authProvider);

        if (token != null) {
          // Authorizationヘッダーをセット
          options.headers['Authorization'] = 'Bearer $token';
        }

        return handler.next(options);
      },
    ),
  );

  return dio;
});
```

---

#### **3. 認証処理を呼び出すUI**
トークンを取得し、Dio を設定する処理を UI に統合します。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AuthScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);

    return Scaffold(
      appBar: AppBar(title: Text('認証画面')),
      body: Center(
        child: authState == null
            ? ElevatedButton(
                onPressed: () async {
                  // 認証トークンを取得
                  await ref.read(authProvider.notifier).fetchAuthToken();
                },
                child: Text('ログイン'),
              )
            : Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text('トークン取得済み: $authState'),
                  ElevatedButton(
                    onPressed: () async {
                      // 認証トークンを利用してAPIリクエスト
                      final dio = ref.read(dioProvider);
                      final response = await dio.get('https://example.com/api/data');
                      print(response.data);
                    },
                    child: Text('APIリクエスト'),
                  ),
                  ElevatedButton(
                    onPressed: () {
                      // トークンをクリア
                      ref.read(authProvider.notifier).clearToken();
                    },
                    child: Text('ログアウト'),
                  ),
                ],
              ),
      ),
    );
  }
}
```

---

### **説明**

1. **`AuthNotifier`**
   - 認証トークンを管理するクラスです。
   - 初回ログイン時に API を呼び出してトークンを取得し、状態 (`state`) に保存します。
   - ログアウト時にトークンをクリアします。

2. **`authProvider`**
   - Riverpod の `StateNotifierProvider` を利用して `AuthNotifier` の状態を提供します。

3. **`dioProvider`**
   - Dio のインスタンスを提供するプロバイダーです。
   - インターセプターを利用して、すべてのリクエストに動的にトークンを追加します。

4. **`AuthScreen`**
   - トークンの取得、APIリクエスト、ログアウト機能を実装した画面です。

---

### **動作フロー**
1. ユーザーが「ログイン」ボタンを押すと、`fetchAuthToken` が呼び出され、トークンが取得されます。
2. トークンは `authProvider` を通じて状態に保存され、Dio のインターセプターがトークンを自動的にヘッダーに追加します。
3. ユーザーが「APIリクエスト」ボタンを押すと、Dio を利用した認証付きリクエストが実行されます。
4. 「ログアウト」ボタンを押すとトークンが削除されます。

---

### **この方法のメリット**
- **トークン管理が一元化**：`AuthProvider`でトークンを集中管理。
- **動的ヘッダー適用**：Dioのインターセプターでリクエスト時に動的にトークンを適用。
- **状態管理との統合**：Riverpodを利用して、認証状態を簡単に監視・操作可能。

---

この実装で、認証トークンを効率よく管理し、ヘッダーに自動で差し込む仕組みを構築できます！

---

## 👤 User
*2024-12-18 17:41:51*

ノティファイアを使うならリバーポッドアノテーションで自動生成したい

---

## 🤖 Assistant
*2024-12-18 17:42:41*

Riverpod アノテーションを使用して `StateNotifier` を自動生成する方法を説明します。これにより、コードの記述が簡潔になり、よりモダンな開発体験を得られます。

以下は、認証トークンを管理し、APIリクエストで動的にオーソライズヘッダーを設定するコード例です。

---

## **準備**

1. **必要な依存関係を追加**
   `pubspec.yaml` に以下を追加します。

   ```yaml
   dependencies:
     flutter:
       sdk: flutter
     flutter_riverpod: ^2.0.0

   dev_dependencies:
     build_runner: ^2.0.0
     riverpod_generator: ^2.0.0
   ```

2. **自動生成コマンドを実行**
   次のコマンドを実行して生成されたコードを作成します。

   ```bash
   flutter pub run build_runner build
   ```

---

## **認証トークン管理の実装**

以下は Riverpod アノテーションを使用したコード例です。

### **1. AuthNotifier の定義**
認証トークンの管理を自動生成対応にするコードです。

```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'auth_provider.g.dart';

@riverpod
class AuthNotifier extends _$AuthNotifier {
  @override
  String? build() {
    // 初期状態ではトークンはnull
    return null;
  }

  // 認証トークンを取得して保存
  Future<void> fetchAuthToken() async {
    final token = await _authenticateUser();
    state = token; // トークンを更新
  }

  // トークンをクリア
  void clearToken() {
    state = null;
  }

  // ダミーの認証API呼び出し
  Future<String> _authenticateUser() async {
    await Future.delayed(Duration(seconds: 1)); // ダミーの遅延
    return "example_auth_token";
  }
}
```

---

### **2. Dio クライアントの設定**

Dio を利用して、トークンをヘッダーに動的に追加するインターセプターを設定します。

```dart
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'auth_provider.dart';

final dioProvider = Provider<Dio>((ref) {
  final dio = Dio();

  // インターセプターを追加
  dio.interceptors.add(
    InterceptorsWrapper(
      onRequest: (options, handler) {
        // トークンを取得
        final token = ref.read(authNotifierProvider);
        if (token != null) {
          // Authorizationヘッダーをセット
          options.headers['Authorization'] = 'Bearer $token';
        }
        return handler.next(options);
      },
    ),
  );

  return dio;
});
```

---

### **3. UIでの利用**

認証状態を反映する UI を作成します。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'auth_provider.dart';
import 'dio_provider.dart';

class AuthScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authNotifierProvider);

    return Scaffold(
      appBar: AppBar(title: Text('認証画面')),
      body: Center(
        child: authState == null
            ? ElevatedButton(
                onPressed: () async {
                  // トークンを取得
                  await ref.read(authNotifierProvider.notifier).fetchAuthToken();
                },
                child: Text('ログイン'),
              )
            : Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text('トークン取得済み: $authState'),
                  ElevatedButton(
                    onPressed: () async {
                      // APIリクエスト
                      final dio = ref.read(dioProvider);
                      final response = await dio.get('https://example.com/api/data');
                      print(response.data);
                    },
                    child: Text('APIリクエスト'),
                  ),
                  ElevatedButton(
                    onPressed: () {
                      // トークンをクリア
                      ref.read(authNotifierProvider.notifier).clearToken();
                    },
                    child: Text('ログアウト'),
                  ),
                ],
              ),
      ),
    );
  }
}
```

---

## **説明**

1. **`AuthNotifier`**
   - Riverpod アノテーションを使用して `AuthNotifier` クラスを作成。
   - トークンの取得 (`fetchAuthToken`) とクリア (`clearToken`) を管理。

2. **自動生成されたプロバイダー**
   - `@riverpod` アノテーションを使うことで、`authNotifierProvider` が自動生成されます。
   - プロバイダー名は、クラス名に基づいて生成されます。

3. **Dio クライアント**
   - トークンをヘッダーに追加するために `dioProvider` を設定。
   - トークンは `authNotifierProvider` から動的に取得されます。

4. **UI**
   - トークンの有無によって表示内容を切り替え。
   - ボタンで認証トークンの取得、APIリクエスト、ログアウトが可能。

---

## **動作フロー**

1. **「ログイン」ボタンを押す**  
   → 認証APIからトークンを取得し、`AuthNotifier` の `state` を更新。
   
2. **APIリクエストを送信**  
   → Dio のインターセプターがトークンをヘッダーに追加してリクエストを実行。

3. **「ログアウト」ボタンを押す**  
   → `state` を `null` にしてトークンをクリア。

---

## **利点**
- **コードの簡潔化**: `@riverpod` アノテーションでプロバイダーを自動生成。
- **状態管理の一元化**: トークン管理と API 呼び出しを分離。
- **拡張性**: 他の状態や依存関係を簡単に追加可能。

この実装により、Riverpod アノテーションの強力な自動生成機能を活かして、認証処理を効率よく実現できます！

---
