# SFSymbol再生とリセット

Date: 2024-05-10

---

## 👤 User
*2024-05-10 14:22:02*

全体的に以下になった

再生と停止のボタンを文字ではなくてSFSymbolにしてほしい。
あともうすこし再生中のスライダーの流れをよくしたい。

最後まで再生したら、再生ボタンを表示して、再生ボタンを押したら最初から再生してほしい。

import Foundation
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    private var timeObserverToken: Any?

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.audioUrl = audioUrl
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        let interval = CMTime(seconds: 0.5, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}

import SwiftUI

@MainActor
struct AudioPlayerView: View {
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $presenter.currentTime, in: 0...presenter.duration) { editing in
                if editing {
                    presenter.seek(to: presenter.currentTime)
                }
            }
            HStack {
                Text(presenter.currentTime.mmss)
                Spacer()
                Text(presenter.duration.mmss)
            }
            Button(presenter.isPlaying ? "Pause" : "Play") {
                presenter.playPauseAction()
            }
        }
        .padding()
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
    }
}

#Preview {
    AudioPlayerView(audioUrl: URL(string: "https://amachamusic.chagasi.com/mp3/ukiukilalala.mp3")!)
        .navigationStacked()
}

---

## 🤖 Assistant
*2024-05-10 14:22:36*

Here's how you can modify your SwiftUI `AudioPlayerView` to use SF Symbols for play and pause buttons, improve the slider's responsiveness, and reset the playback when it reaches the end:

1. **Using SF Symbols for Play and Pause Buttons**: Replace the textual representation with SF Symbols.
2. **Improving Slider Performance**: Ensure that the slider updates smoothly and interacts properly when dragged.
3. **Resetting Playback**: Automatically reset the playback to the start once it finishes.

I've adjusted the relevant sections in your SwiftUI view and also made some enhancements in your presenter to handle the end of the playback.

### Modified Code
Here is your updated `AudioPlayerPresenter` and `AudioPlayerView`:

```swift
import Foundation
import Combine
import AVFoundation
import SwiftUI

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []
    private var timeObserverToken: Any?

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.audioUrl = audioUrl
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        let interval = CMTime(seconds: 0.5, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            guard let self = self else { return }
            self.currentTime = time.seconds
            if time == self.player?.currentItem?.duration {
                self.isPlaying = false
                self.player?.pause()
                self.player?.seek(to: .zero)
            }
        }

        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}

@MainActor
struct AudioPlayerView: View {
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $presenter.currentTime, in: 0...presenter.duration, step: 0.1) { editing in
                if editing {
                    presenter.seek(to: presenter.currentTime)
                }
            }
            HStack {
                Text(presenter.currentTime.mmss)
                Spacer()
                Text(presenter.duration.mmss)
            }
            Button(action: {
                presenter.playPauseAction()
            }) {
                Image(systemName: presenter.isPlaying ? "pause.circle.fill" : "play.circle.fill")
                    .font(.largeTitle)
            }
        }
        .padding()
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
    }
}

#Preview {
    AudioPlayerView(audioUrl: URL(string: "https://amachamusic.chagasi.com/mp3/ukiukilalala.mp3")!)
        .navigationStacked()
}
```

### Key Changes
- **SF Symbols**: Replaced the button text with SF Symbols for play and pause.
- **Slider**: Adjusted the `Slider` to be more responsive and added a small `step` value to make the updates smoother.
- **Playback Reset**: Added logic to reset the playback when it finishes.

These changes should align the functionality closer to your requirements. If you need further adjustments, feel free to ask!

---

## 👤 User
*2024-05-10 16:23:29*

あんまりaddPeriodicTimeObserver を使いたくない。これを使わずに現在の再生時刻を取得する方法はないのか？

let interval = CMTime(seconds: 0.1, preferredTimescale: 600)
        timeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = time.seconds
        }

---

## 🤖 Assistant
*2024-05-10 16:24:10*

`addPeriodicTimeObserver`を使用せずにAVPlayerの現在の再生時刻を更新する方法として、タイマーやCombineのPublisherを活用する方法があります。こちらは`addPeriodicTimeObserver`の代わりとしても動作しますし、よりコントロールしやすいかもしれません。

### タイマーを使用する方法

`Timer.publish`を使用して定期的に現在の再生時間を更新します。この方法はSwiftUIのViewと連動しやすく、特にUIの更新が必要な場合に便利です。

```swift
import SwiftUI
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.audioUrl = audioUrl
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
        setupTimeUpdater()
    }

    private func setupPlayerObservers() {
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    private func setupTimeUpdater() {
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.currentTime = self?.player?.currentTime().seconds ?? 0
                if self?.currentTime == self?.duration {
                    self?.isPlaying = false
                    self?.player?.pause()
                    self?.player?.seek(to: .zero)
                }
            }
            .store(in: &cancellables)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}
```

このコードでは、`Timer.publish`を使って0.1秒ごとにプレーヤーの現在時間を更新しています。この方法は特にUIの更新が求められる場合に適しており、`addPeriodicTimeObserver`と似た挙動をしますが、より細かく制御可能です。

また、この方法はAVPlayerのイベントに依存せずに動作するため、特定の条件下でのプレーヤーの挙動をカスタマイズしたい場合にも有効です。プレーヤーが終了時に自動的に停止し、再生位置をリセットするように設定しています。

---

## 👤 User
*2024-05-10 16:25:12*

Timerを使う懸念点を教えてほしい

---

## 🤖 Assistant
*2024-05-10 16:25:58*

`Timer`を使用してAVPlayerの現在の再生時刻を更新する際には、いくつかの懸念点があります。これらはアプリケーションのパフォーマンスや正確性に影響を与える可能性があります。

1. **リソース消費とパフォーマンス**: `Timer`は定期的に発火されるため、メインスレッドで実行されるとUIのレスポンシブネスに影響を及ぼす可能性があります。これは特にタイマーの間隔を非常に短く設定した場合（例えば0.1秒ごとなど）に顕著です。メインスレッドが忙しいと、タイマーの発火が期待通りに行われないこともあります。

2. **タイマーの精度**: タイマーはシステムのクロックに基づいていますが、100%の精度を保証するものではありません。バックグラウンドプロセスやシステムの負荷、スリープ状態などによってタイマーの精度が影響を受けることがあります。これにより、実際の再生時間とUI上で表示される時間にズレが生じる可能性があります。

3. **エネルギー使用量**: `Timer`が頻繁に更新を行う設定の場合、デバイスのバッテリー消耗が早まる可能性があります。特にバックグラウンドで音楽再生アプリケーションを実行している場合、この影響は無視できません。

4. **バックグラウンド実行時の問題**: iOSではバックグラウンドで実行されるアプリの処理能力が制限されています。`Timer`がバックグラウンドで正確に実行されない場合があり、これによりアプリがフォアグラウンドに戻った際に不整合が生じることがあります。

5. **メモリ管理**: `Timer`は強参照を持っているため、不適切に管理されるとメモリリークを引き起こす可能性があります。特に`Timer`を破棄しないで再び生成するといった操作を繰り返すと、リソースの浪費が生じることがあります。

これらの点を考慮し、特にパフォーマンスやエネルギー効率が重要なアプリケーションでは、`addPeriodicTimeObserver`のような専用のAPIを使用することが一般的に推奨されます。これは、これらのAPIが特定のハードウェアやOSの機能とより密接に統合されているため、より効率的かつ正確に動作するためです。

---

## 👤 User
*2024-05-10 16:26:00*

これってポーズした場合はどうするの？

---

## 🤖 Assistant
*2024-05-10 16:26:44*

`Timer`を使用している場合、再生がポーズされた時の挙動を適切に管理することが重要です。`Timer`が継続的に動作していると、ポーズ中も無駄にリソースを消費することになりますし、再生位置の更新も誤って行われる可能性があります。以下のように対応する方法が考えられます：

### タイマーの停止と再開
ポーズ時には`Timer`を無効にし、再生を再開したときに`Timer`を再度有効にするという方法が一般的です。これにより、無駄なリソース消費を防ぎ、再生がポーズされている間は時刻の更新を停止できます。

### 実装方法
以下は`Timer`を使用している`AudioPlayerPresenter`クラスにおいて、再生とポーズの操作を行う際にタイマーの停止と再開を行う方法を示したコードです：

```swift
import SwiftUI
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []
    private var timeUpdater: AnyCancellable?

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.audioUrl = audioUrl
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
    }

    private func setupPlayerObservers() {
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    private func setupTimeUpdater() {
        timeUpdater = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                guard let self = self, self.isPlaying else { return }
                self.currentTime = self.player?.currentTime().seconds ?? 0
                if self.currentTime >= self.duration {
                    self.isPlaying = false
                    self.player?.pause()
                    self.player?.seek(to: .zero)
                }
            }
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
            setupTimeUpdater()  // タイマーを再開
        } else {
            player.pause()
            isPlaying = false
            timeUpdater?.cancel()  // タイマーを停止
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}
```

このコードでは、`playPauseAction()` 関数内で再生が開始された際にタイマーをセットアップし、再生がポーズされた際にはタイマーをキャンセルしています。この方法により、アプリケーションのパフォーマンスとリソースの効率的な利用を保つことができます。

---

## 👤 User
*2024-05-10 16:27:50*

TimerにisPlayingをcombineLatestでつけて制御すればいいのでは？

---

## 🤖 Assistant
*2024-05-10 16:28:36*

はい、`isPlaying`と`Timer`を`combineLatest`で組み合わせるというのは、SwiftUIとCombineを活用して、より反応的で効率的な実装を行うための良い方法です。このアプローチにより、`isPlaying`の状態が変わるたびにタイマーの購読を自動的に管理できます。

以下に、`isPlaying`と`Timer`を`combineLatest`で結合して、プレーヤーの現在時刻を更新する方法の実装例を示します。

### 実装例

```swift
import SwiftUI
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.audioUrl = audioUrl
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
        setupTimeUpdater()
    }

    private func setupPlayerObservers() {
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    private func setupTimeUpdater() {
        $isPlaying
            .filter { $0 }  // 再生中のときのみタイマーを動作させる
            .flatMap { _ in
                Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            }
            .combineLatest($isPlaying) { (time, isPlaying) -> TimeInterval? in
                isPlaying ? self.player?.currentTime().seconds : nil
            }
            .compactMap { $0 }
            .receive(on: RunLoop.main)
            .assign(to: &$currentTime)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}
```

### 説明

このコードでは、`$isPlaying`を使って再生状態の変更を監視しています。再生が開始されると、`Timer.publish`が開始され、現在の再生時刻を更新します。`combineLatest`を使用してタイマーの出力と再生状態を組み合わせ、再生が止まっている時は時刻更新を無視します。

この方法では、再生の開始と停止に応じてタイマーが動作するか停止するかが自動で制御され、不要なリソースの消費を防ぎながら、UIの更新もスムーズに行えるようになります。また、`filter`と`flatMap`を用いて再生中のみタイマーが動作するよう制御していますが、これにより不要なタイマーイベントの発生を抑制し、パフォーマンスの向上が期待できます。

---

## 👤 User
*2024-05-10 16:29:21*

見ずらいので Timer.publish(every: 0.1, on: .main, in: .common).autoconnect().combineLatest($isPlaying) みたいな形で実装してほしい。そしてfilterすると言った流れかな

---

## 🤖 Assistant
*2024-05-10 16:30:06*

了解しました。`Timer.publish`と`$isPlaying`を`combineLatest`で組み合わせ、その後で`filter`を使って再生中のみタイムアップデートを行うように調整します。これによりコードがより読みやすく、目的の動作が明確になります。

### 実装例

```swift
import SwiftUI
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isPlaying: Bool = false

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set<AnyCancellable> = []

    init(audioUrl: URL) {
        let item = AVPlayerItem(url: audioUrl)
        self.audioUrl = audioUrl
        self.player = AVPlayer(playerItem: item)
        self.duration = item.asset.duration.seconds

        setupPlayerObservers()
        setupTimeUpdater()
    }

    private func setupPlayerObservers() {
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                if status == .readyToPlay {
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                }
            }
            .store(in: &cancellables)
    }

    private func setupTimeUpdater() {
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest($isPlaying)
            .filter { _, isPlaying in isPlaying }  // 再生中のみ更新
            .map { time, _ in self.player?.currentTime().seconds ?? 0 }
            .assign(to: &$currentTime)
    }

    func playPauseAction() {
        guard let player = player else { return }
        if player.timeControlStatus == .paused {
            player.play()
            isPlaying = true
        } else {
            player.pause()
            isPlaying = false
        }
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime)
    }
}
```

### 解説

1. **タイマーのセットアップ**: `Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()`で0.1秒ごとに現在時刻を更新するタイマーを設定しています。

2. **combineLatestの使用**: タイマーの出力と`$isPlaying`の最新値を組み合わせています。これにより、タイマーの各ティックごとに再生状態が考慮されます。

3. **フィルタリングとマッピング**: `filter`を使用して再生中(`isPlaying == true`)のみタイムアップデートを行います。その後、`map`を使ってプレイヤーの現在の秒数を取得し、`currentTime`に割り当てます。

この方式では、プレーヤーがポーズされた場合にはタイマーの更新が停止し、リソースの無駄遣いを防ぎます。また、タイマーが再生中のみ動作するため、再生が再開された時に自動的に再開します。これにより、パフォーマンスが最適化され、アプリの反応も向上します。

---

## 👤 User
*2024-05-10 16:43:16*

うまくseekが機能していない改善してほしい。

import Foundation
import Combine
import AVFoundation

@MainActor
class AudioPlayerPresenter: ObservableObject {
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isSeeking: Bool = false
    @Published var isLoading: Bool = false
    @Published var isPlaying: Bool = false
    private var isEnded: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
    

    let audioUrl: URL
    private var player: AVPlayer?
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    private var timeObserverToken: Any?

    init(audioUrl: URL) {
        self.audioUrl = audioUrl
    }
    
    func onApper() {
        isLoading = true
        defer {
            isLoading = false
        }

        let item = AVPlayerItem(url: audioUrl)
        player = AVPlayer(playerItem: item)

        // 0.1 秒ごとに再生時刻と seek bar を同期させる
        Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()
            .combineLatest($isPlaying, $isSeeking)
            .filter { _, isPlaying, isSeeking in
                isPlaying && !isSeeking // 再生中かつseekしていないときのみ更新
            }
            .map { [weak self] time, _, _ in
                self?.player?.currentTime().seconds ?? 0
            }
            .assign(to: &$currentTime)

        // 動画を最後まで見終わったら再生開始状態にリセットする
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                guard let self else {
                    return
                }
                self.isPlaying = false
                self.isEnded = true
                self.currentTime = self.duration
            }
            .store(in: &cancellables)

        // 再生準備が完了したら再生時間をセットする
        player?.currentItem?.publisher(for: \.status)
            .receive(on: RunLoop.main)
            .sink { [weak self] status in
                switch status {
                case .readyToPlay:
                    self?.duration = self?.player?.currentItem?.duration.seconds ?? 0
                case .unknown, .failed:
                    break
                @unknown default:
                    break
                }
            }
            .store(in: &cancellables)

        do {            
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            OSLogger.errorLog("Audio playback failed: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapPlay() {
        if isEnded {
            player?.seek(to: .zero)
        }
        player?.play()
        isPlaying = true
    }
    
    func onTapPause() {
        player?.pause()
        isPlaying = false
    }

    func seek(to time: TimeInterval) {
        let cmTime = CMTime(seconds: time, preferredTimescale: 600)
        player?.seek(to: cmTime) { [weak self] completed in
            if completed {
                self?.currentTime = time
            }
        }
    }
}

import SwiftUI

@MainActor
struct AudioPlayerView: View {
    @StateObject private var presenter: AudioPlayerPresenter

    init(audioUrl: URL) {
        _presenter = .init(wrappedValue: .init(audioUrl: audioUrl))
    }

    var body: some View {
        VStack {
            Slider(value: $presenter.currentTime, in: 0...presenter.duration) { editing in
                presenter.isSeeking = editing
                if !editing {  // 編集が終了したときにのみシークを実行
                    presenter.seek(to: presenter.currentTime)
                }
            }
            
            HStack {
                Text(presenter.currentTime.mmss)
                Spacer()
                Text(presenter.duration.mmss)
            }
            
            Spacer()

            if presenter.isPlaying {
                Button {
                    presenter.onTapPause()
                } label: {
                    SFSymbols.pauseFill.image
                        .font(.largeTitle)
                }
            } else {
                Button {
                    presenter.onTapPlay()
                } label: {
                    SFSymbols.playFill.image
                        .font(.largeTitle)
                }
                .disabled(presenter.isLoading)
            }
        }
        .padding()
        .navigationBarTitleDisplayMode(.inline)
        .navigationTitle(presenter.audioUrl.lastPathComponent)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError)
        .onAppear {
            presenter.onApper()
        }
    }
}

---

## 🤖 Assistant
*2024-05-10 16:44:04*

`seek(to:)` メソッドの機能が十分でない場合は、いくつかの改善点を考慮することができます。シーク操作における一般的な問題は、ユーザーのインタラクションとプレーヤーの状態同期のタイミングの問題です。これを解決するために、以下の改善を提案します。

### 1. シーク操作の安定性の向上

シーク操作を行う際に、プレーヤーが正確に求められた位置に移動することを保証するために、シーク完了のコールバックを活用し、UIの更新もそのタイミングで行うことが重要です。また、`isSeeking` フラグを使ってシーク中にタイマーによる位置更新を停止し、シーク完了後に正しい位置に更新されるようにします。

### 2. プレシジョンの向上

`CMTime` の `preferredTimescale` をより高い値に設定することで、シークの精度を向上させることができます。例えば、`timescale` を `600` から `1000` に変更してみるのはどうでしょうか。

### 3. シーク中のユーザーインタラクションの改善

シークバーの動きがスムーズでない場合は、シーク中には`currentTime`の更新を一時停止し、シークが完了した際にのみ更新するようにします。これにより、シーク操作中にスライダーが跳ね返る問題を避けることができます。

### 改善されたコード例

```swift
func seek(to time: TimeInterval) {
    isSeeking = true // シーク開始時にフラグを立てる
    let cmTime = CMTime(seconds: time, preferredTimescale: 1000) // 精度を上げる
    player?.seek(to: cmTime, toleranceBefore: .zero, toleranceAfter: .zero) { [weak self] completed in
        guard let self = self else { return }
        if completed {
            DispatchQueue.main.async {
                self.currentTime = time
                self.isSeeking = false // シーク終了時にフラグを下ろす
            }
        }
    }
}
```

### SwiftUI Viewの調整

シーク操作が完了した際にのみ`currentTime`を更新するように、Sliderのコンポーネントのハンドリングを調整します。

```swift
Slider(value: $presenter.currentTime, in: 0...presenter.duration) { editing in
    presenter.isSeeking = editing
    if !editing { // シーク終了時のみ
        presenter.seek(to: presenter.currentTime)
    }
}
```

この変更により、シーク操作がより安定し、ユーザー体験も向上します。`seek(to:)` メソッドでの`toleranceBefore`と`toleranceAfter`を `.zero` に設定することで、より正確な位置にシークするように指示しています。これにより、特に長いオーディオファイルや動画ファイルでの精度が向上します。

---
