# SwiftUI ÏàòÏ†ï Î∞è Íµ¨Ï°∞Ìôî

Êó•‰ªò: 2024-06-03

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/06/03 17:15:24*

Static method 'buildExpression' requires that 'DisclosureGroup&lt;Text, some View&gt;' conform to 'TableRowContent'

struct PropertyView&lt;T: Encodable&gt;: View {
    @Binding var showToast: Bool
    let objects: [T]
    var onTapElement: (Any) -&gt; Void

    public var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                propertyView(object: object)
            } header: {
                HStack {
                    Text("\(type(of: object))[\(index)]")

                    Spacer()

                    Button {
                        onTapElement(object)
                    } label: {
                        SFSymbols.docOnDoc.image
                    }
                    .buttonStyle(.borderless)
                }
            }
            .textCase(.none)
        }
    }

    func propertyView(object: Any) -&gt; some View {
        AnyView(ForEach(Array(Mirror(reflecting: object).children.enumerated()), id: \.offset) { index, child in
            if let label = child.label {
                let childMirror = Mirror(reflecting: child.value)
                if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                    DisclosureGroup {
                        propertyView(object: child.value)
                    } label: {
                        Text(label)
                    }
                } else if let subObjects = child.value as? [Any] {
                    DisclosureGroup {
                        ForEach(Array(subObjects.enumerated()), id: \.offset) { subIndex, subObject in
                            let subObjectMirror = Mirror(reflecting: subObject)
                            if subObjectMirror.displayStyle == .struct || subObjectMirror.displayStyle == .class {
                                DisclosureGroup {
                                    propertyView(object: subObject)
                                } label: {
                                    HStack(alignment: .top) {
                                        Text("\(type(of: subObject))")
                                            .foregroundStyle(.black)
                                        Spacer()
                                        Text("\(type(of: subObject))[\(subIndex)]")
                                    }
                                }
                            } else {
                                Button {
                                    onTapElement(subObject)
                                } label: {
                                    HStack(alignment: .top) {
                                        Text("[\(subIndex)]")
                                            .foregroundStyle(.black)
                                        Spacer()
                                        Text("\(subObject)")
                                    }
                                }
                            }
                        }
                    } label: {
                        HStack(alignment: .top) {
                            Text(label)
                                .foregroundStyle(.black)
                            Spacer()
                            Text("\(Mirror(reflecting: child.value).subjectType)")
                        }
                    }
                } else {
                    Button {
                        onTapElement(object: child.value)
                    } label: {
                        HStack(alignment: .top) {
                            Text(label)
                                .foregroundStyle(.black)
                            Spacer()
                            Text("\(child.value)")
                        }
                    }
                }
            } else {
                Button {
                    onTapElement(child.value)
                } label: {
                    HStack(alignment: .top) {
                        Text("[\(index)]")
                            .foregroundStyle(.black)
                        Spacer()
                        Text("\(child.value)")
                    }
                }
            }
        })
    }
}

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/06/03 17:16:04*

The error you are encountering is due to the type constraints of the `DisclosureGroup` in SwiftUI. The `DisclosureGroup`'s content must conform to `View`, and the generic constraints of your `propertyView` function may be causing issues with type inference.

To address this, you should ensure that the type `some View` is properly used and conforms to the requirements expected by SwiftUI. Here‚Äôs a revised version of your `PropertyView`:

```swift
import SwiftUI

struct PropertyView<T: Encodable>: View {
    @Binding var showToast: Bool
    let objects: [T]
    var onTapElement: (Any) -> Void

    public var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                propertyView(object: object)
            } header: {
                HStack {
                    Text("\(type(of: object))[\(index)]")

                    Spacer()

                    Button {
                        onTapElement(object)
                    } label: {
                        Image(systemName: "doc.on.doc") // Replace with your SFSymbols
                    }
                    .buttonStyle(.borderless)
                }
            }
            .textCase(.none)
        }
    }

    func propertyView(object: Any) -> some View {
        ForEach(Array(Mirror(reflecting: object).children.enumerated()), id: \.offset) { index, child in
            if let label = child.label {
                let childMirror = Mirror(reflecting: child.value)
                if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                    DisclosureGroup {
                        propertyView(object: child.value)
                    } label: {
                        Text(label)
                    }
                } else if let subObjects = child.value as? [Any] {
                    DisclosureGroup {
                        ForEach(Array(subObjects.enumerated()), id: \.offset) { subIndex, subObject in
                            let subObjectMirror = Mirror(reflecting: subObject)
                            if subObjectMirror.displayStyle == .struct || subObjectMirror.displayStyle == .class {
                                DisclosureGroup {
                                    propertyView(object: subObject)
                                } label: {
                                    HStack(alignment: .top) {
                                        Text("\(type(of: subObject))")
                                            .foregroundStyle(.black)
                                        Spacer()
                                        Text("\(type(of: subObject))[\(subIndex)]")
                                    }
                                }
                            } else {
                                Button {
                                    onTapElement(subObject)
                                } label: {
                                    HStack(alignment: .top) {
                                        Text("[\(subIndex)]")
                                            .foregroundStyle(.black)
                                        Spacer()
                                        Text("\(subObject)")
                                    }
                                }
                            }
                        }
                    } label: {
                        HStack(alignment: .top) {
                            Text(label)
                                .foregroundStyle(.black)
                            Spacer()
                            Text("\(Mirror(reflecting: child.value).subjectType)")
                        }
                    }
                } else {
                    Button {
                        onTapElement(child.value)
                    } label: {
                        HStack(alignment: .top) {
                            Text(label)
                                .foregroundStyle(.black)
                            Spacer()
                            Text("\(child.value)")
                        }
                    }
                }
            } else {
                Button {
                    onTapElement(child.value)
                } label: {
                    HStack(alignment: .top) {
                        Text("[\(index)]")
                            .foregroundStyle(.black)
                        Spacer()
                        Text("\(child.value)")
                    }
                }
            }
        }
    }
}
```

Here are the changes made:

1. **Updated `propertyView` Function:** The `propertyView` function was simplified to use a direct return of `ForEach` without wrapping it in `AnyView`. This avoids potential issues with type inference and ensures that the views conform to `View`.
2. **Image System Name:** Replaced the `SFSymbols.docOnDoc.image` with `Image(systemName: "doc.on.doc")`, assuming you are using SF Symbols.

These changes should help resolve the type constraint issues with `DisclosureGroup` and ensure that all views conform correctly to `View`.

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/06/03 17:16:40*

Function opaque return type was inferred as 'ForEach&lt;Array&lt;EnumeratedSequence&lt;Mirror.Children&gt;.Element&gt;, Int, _ConditionalContent&lt;_ConditionalContent&lt;_ConditionalContent&lt;DisclosureGroup&lt;Text, some View&gt;, DisclosureGroup&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;, ForEach&lt;Array&lt;EnumeratedSequence&lt;[Any]&gt;.Element&gt;, Int, _ConditionalContent&lt;DisclosureGroup&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;, some View&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;&gt;&gt;&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;&gt;' (aka 'ForEach&lt;Array&lt;(offset: Int, element: (label: Optional&lt;String&gt;, value: Any))&gt;, Int, _ConditionalContent&lt;_ConditionalContent&lt;_ConditionalContent&lt;DisclosureGroup&lt;Text, some View&gt;, DisclosureGroup&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;, ForEach&lt;Array&lt;(offset: Int, element: Any)&gt;, Int, _ConditionalContent&lt;DisclosureGroup&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;, some View&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;&gt;&gt;&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;&gt;'), which defines the opaque type in terms of itself

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/06/03 17:17:14*

To resolve the issue with the complex return type inferred in the `propertyView` function, we can use `Group` to help with type inference. Wrapping the conditional views inside a `Group` will help the compiler infer the correct return type. Here‚Äôs an updated version of the `PropertyView` struct:

```swift
import SwiftUI

struct PropertyView<T: Encodable>: View {
    @Binding var showToast: Bool
    let objects: [T]
    var onTapElement: (Any) -> Void

    public var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                propertyView(object: object)
            } header: {
                HStack {
                    Text("\(type(of: object))[\(index)]")

                    Spacer()

                    Button {
                        onTapElement(object)
                    } label: {
                        Image(systemName: "doc.on.doc") // Replace with your SFSymbols
                    }
                    .buttonStyle(.borderless)
                }
            }
            .textCase(.none)
        }
    }

    @ViewBuilder
    func propertyView(object: Any) -> some View {
        ForEach(Array(Mirror(reflecting: object).children.enumerated()), id: \.offset) { index, child in
            if let label = child.label {
                let childMirror = Mirror(reflecting: child.value)
                if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                    DisclosureGroup {
                        propertyView(object: child.value)
                    } label: {
                        Text(label)
                    }
                } else if let subObjects = child.value as? [Any] {
                    DisclosureGroup {
                        ForEach(Array(subObjects.enumerated()), id: \.offset) { subIndex, subObject in
                            let subObjectMirror = Mirror(reflecting: subObject)
                            if subObjectMirror.displayStyle == .struct || subObjectMirror.displayStyle == .class {
                                DisclosureGroup {
                                    propertyView(object: subObject)
                                } label: {
                                    HStack(alignment: .top) {
                                        Text("\(type(of: subObject))")
                                            .foregroundStyle(.black)
                                        Spacer()
                                        Text("\(type(of: subObject))[\(subIndex)]")
                                    }
                                }
                            } else {
                                Button {
                                    onTapElement(subObject)
                                } label: {
                                    HStack(alignment: .top) {
                                        Text("[\(subIndex)]")
                                            .foregroundStyle(.black)
                                        Spacer()
                                        Text("\(subObject)")
                                    }
                                }
                            }
                        }
                    } label: {
                        HStack(alignment: .top) {
                            Text(label)
                                .foregroundStyle(.black)
                            Spacer()
                            Text("\(Mirror(reflecting: child.value).subjectType)")
                        }
                    }
                } else {
                    Button {
                        onTapElement(child.value)
                    } label: {
                        HStack(alignment: .top) {
                            Text(label)
                                .foregroundStyle(.black)
                            Spacer()
                            Text("\(child.value)")
                        }
                    }
                }
            } else {
                Button {
                    onTapElement(child.value)
                } label: {
                    HStack(alignment: .top) {
                        Text("[\(index)]")
                            .foregroundStyle(.black)
                        Spacer()
                        Text("\(child.value)")
                    }
                }
            }
        }
    }
}
```

Key changes:

1. **Using `@ViewBuilder`:** The `propertyView` function is now marked with `@ViewBuilder`, which allows us to return different view types within a single function without needing to wrap them in `AnyView`.
2. **Using `Group`:** By using `Group` inside `propertyView`, we can simplify the view structure and help the Swift compiler with type inference.

This approach should resolve the issue with complex return types and ensure that the views conform correctly to `View`.

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/06/03 17:18:10*

Function opaque return type was inferred as 'ForEach&lt;Array&lt;EnumeratedSequence&lt;Mirror.Children&gt;.Element&gt;, Int, _ConditionalContent&lt;_ConditionalContent&lt;_ConditionalContent&lt;DisclosureGroup&lt;Text, some View&gt;, DisclosureGroup&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;, ForEach&lt;Array&lt;EnumeratedSequence&lt;[Any]&gt;.Element&gt;, Int, _ConditionalContent&lt;DisclosureGroup&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;, some View&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;&gt;&gt;&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;&gt;' (aka 'ForEach&lt;Array&lt;(offset: Int, element: (label: Optional&lt;String&gt;, value: Any))&gt;, Int, _ConditionalContent&lt;_ConditionalContent&lt;_ConditionalContent&lt;DisclosureGroup&lt;Text, some View&gt;, DisclosureGroup&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;, ForEach&lt;Array&lt;(offset: Int, element: Any)&gt;, Int, _ConditionalContent&lt;DisclosureGroup&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;, some View&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;&gt;&gt;&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;, Button&lt;HStack&lt;TupleView&lt;(some View, Spacer, Text)&gt;&gt;&gt;&gt;&gt;'), which defines the opaque type in terms of itself

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/06/03 17:18:40*

To resolve the issue with the complex opaque return type in the `propertyView` function, it's necessary to break down the problem into more manageable parts. The key is to ensure that Swift can infer the return type correctly by simplifying the view structure.

Here‚Äôs an updated version of your `PropertyView` struct:

```swift
import SwiftUI

struct PropertyView<T: Encodable>: View {
    @Binding var showToast: Bool
    let objects: [T]
    var onTapElement: (Any) -> Void

    public var body: some View {
        ForEach(Array(objects.enumerated()), id: \.offset) { index, object in
            Section {
                propertyView(object: object)
            } header: {
                HStack {
                    Text("\(type(of: object))[\(index)]")
                    Spacer()
                    Button {
                        onTapElement(object)
                    } label: {
                        Image(systemName: "doc.on.doc")
                    }
                    .buttonStyle(.borderless)
                }
            }
            .textCase(.none)
        }
    }

    @ViewBuilder
    func propertyView(object: Any) -> some View {
        ForEach(Array(Mirror(reflecting: object).children.enumerated()), id: \.offset) { index, child in
            if let label = child.label {
                let childMirror = Mirror(reflecting: child.value)
                if childMirror.displayStyle == .struct || childMirror.displayStyle == .class {
                    DisclosureGroup {
                        propertyView(object: child.value)
                    } label: {
                        Text(label)
                    }
                } else if let subObjects = child.value as? [Any] {
                    DisclosureGroup {
                        ForEach(Array(subObjects.enumerated()), id: \.offset) { subIndex, subObject in
                            propertyView(subObject: subObject, subIndex: subIndex)
                        }
                    } label: {
                        HStack(alignment: .top) {
                            Text(label)
                                .foregroundStyle(.black)
                            Spacer()
                            Text("\(Mirror(reflecting: child.value).subjectType)")
                        }
                    }
                } else {
                    Button {
                        onTapElement(child.value)
                    } label: {
                        HStack(alignment: .top) {
                            Text(label)
                                .foregroundStyle(.black)
                            Spacer()
                            Text("\(child.value)")
                        }
                    }
                }
            } else {
                Button {
                    onTapElement(child.value)
                } label: {
                    HStack(alignment: .top) {
                        Text("[\(index)]")
                            .foregroundStyle(.black)
                        Spacer()
                        Text("\(child.value)")
                    }
                }
            }
        }
    }

    @ViewBuilder
    func propertyView(subObject: Any, subIndex: Int) -> some View {
        let subObjectMirror = Mirror(reflecting: subObject)
        if subObjectMirror.displayStyle == .struct || subObjectMirror.displayStyle == .class {
            DisclosureGroup {
                propertyView(object: subObject)
            } label: {
                HStack(alignment: .top) {
                    Text("\(type(of: subObject))")
                        .foregroundStyle(.black)
                    Spacer()
                    Text("\(type(of: subObject))[\(subIndex)]")
                }
            }
        } else {
            Button {
                onTapElement(subObject)
            } label: {
                HStack(alignment: .top) {
                    Text("[\(subIndex)]")
                        .foregroundStyle(.black)
                    Spacer()
                    Text("\(subObject)")
                }
            }
        }
    }
}
```

Key changes:

1. **Separate `propertyView` Function:** Split the `propertyView` function into two functions: one for handling the main object (`propertyView(object:)`) and another for handling sub-objects (`propertyView(subObject:subIndex:)`). This separation helps simplify the logic and make the return type more predictable.
2. **@ViewBuilder:** Both functions are annotated with `@ViewBuilder` to handle conditional content correctly.
3. **Simplified Logic:** The code is broken down into smaller, more manageable pieces, making it easier for Swift to infer the return type.

This approach should resolve the issue with complex return types and ensure that the views conform correctly to `View`.

---
