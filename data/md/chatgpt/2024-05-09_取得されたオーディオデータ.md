# å–å¾—ã•ã‚ŒãŸã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ‡ãƒ¼ã‚¿

æ—¥ä»˜: 2024-05-09

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:00:14*

éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã®å†ç”Ÿæ™‚é–“ãŒå–å¾—ã—ãŸã„ã®ã ã‘ã‚Œã©ã‚‚durationãŒèª¤ã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹

public final class AudioFileManageDriver {
    private let fileManager = FileManager.default
    
    public init() {}
    
    func metadataFromAudioFile(fileUrl: URL) throws -&gt; AudioData {
        let attributes = try fileManager.attributesOfItem(atPath: fileUrl.path)
        let fileSize = (attributes[.size] as? Int) ?? 0
        let creationDate = attributes[.creationDate] as? Date ?? Date()
        let duration = CMTimeGetSeconds(AVURLAsset(url: fileUrl).duration)

        return AudioData(
            fileUrl: fileUrl,
            createdAt: creationDate,
            fileSize: fileSize,
            duration: duration
        )
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:01:10*

å–å¾—ã•ã‚Œã¦ã„ã‚‹éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®å†ç”Ÿæ™‚é–“ï¼ˆ`duration`ï¼‰ã«èª¤å·®ãŒã‚ã‚‹å ´åˆã€ãã‚Œã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ•ãƒ«ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã„ãŸã‚ã«`AVURLAsset`ãŒæ­£ç¢ºãª`duration`ã‚’æä¾›ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚`AVURLAsset`ã®`duration`ã¯ãƒ¡ãƒ‡ã‚£ã‚¢ãŒå®Œå…¨ã«èª­ã¿è¾¼ã¾ã‚Œã‚‹å‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã¨ã€æ­£ç¢ºãªå€¤ãŒå¾—ã‚‰ã‚Œãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚’è§£æ±ºã™ã‚‹ã«ã¯ã€`AVURLAsset`ã«`loadValuesAsynchronously`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€å¿…è¦ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒæ­£ã—ããƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã®ã‚’å¾…ã¤ã‚ˆã†ã«ã™ã‚‹æ–¹æ³•ãŒåŠ¹æœçš„ã§ã™ã€‚

ä»¥ä¸‹ã«ã€`duration`ã‚’ç¢ºå®Ÿã«å–å¾—ã™ã‚‹ãŸã‚ã®æ”¹å–„ã•ã‚ŒãŸ`metadataFromAudioFile`é–¢æ•°ã®ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã“ã§ã¯ã€éåŒæœŸå‡¦ç†ã‚’ä½¿ã£ã¦ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«ãƒ­ãƒ¼ãƒ‰ã—ã€å®Œäº†ã—ãŸéš›ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’é€šã˜ã¦`AudioData`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

```swift
import AVFoundation
import Foundation

public final class AudioFileManageDriver {
    private let fileManager = FileManager.default
    
    public init() {}
    
    func metadataFromAudioFile(fileUrl: URL, completion: @escaping (Result<AudioData, Error>) -> Void) {
        let asset = AVURLAsset(url: fileUrl)
        
        // 'duration' ã‚’å«ã‚€å¿…è¦ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’éåŒæœŸã§èª­ã¿è¾¼ã‚€
        let keys = ["duration"]
        
        asset.loadValuesAsynchronously(forKeys: keys) {
            var error: NSError?
            let status = asset.statusOfValue(forKey: "duration", error: &error)
            
            DispatchQueue.main.async {
                if status == .loaded {
                    do {
                        let attributes = try self.fileManager.attributesOfItem(atPath: fileUrl.path)
                        let fileSize = (attributes[.size] as? Int) ?? 0
                        let creationDate = attributes[.creationDate] as? Date ?? Date()
                        let duration = CMTimeGetSeconds(asset.duration)
                        
                        let audioData = AudioData(
                            fileUrl: fileUrl,
                            createdAt: creationDate,
                            fileSize: fileSize,
                            duration: duration
                        )
                        completion(.success(audioData))
                    } catch {
                        completion(.failure(error))
                    }
                } else if let error = error {
                    completion(.failure(error))
                } else {
                    let unknownError = NSError(domain: "com.AudioFileManager", code: 0, userInfo: [NSLocalizedDescriptionKey: "Unknown error loading audio metadata"])
                    completion(.failure(unknownError))
                }
            }
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€`AVURLAsset`ã®`duration`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å®‰å…¨ã«èª­ã¿è¾¼ã‚€ãŸã‚ã«å¿…è¦ãªã‚­ãƒ¼ã‚’æŒ‡å®šã—ã¦éåŒæœŸã§ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚`statusOfValue`ã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®çŠ¶æ…‹ã‚’ç¢ºèªã—ã€å•é¡ŒãŒãªã‘ã‚Œã°ãã®ä»–ã®ãƒ•ã‚¡ã‚¤ãƒ«å±æ€§ã‚’èª­ã¿è¾¼ã‚“ã§`AudioData`ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚ä½•ã‹å•é¡ŒãŒç™ºç”Ÿã—ãŸå ´åˆã«ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒå®Œå…¨ã«åˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã¾ã§å¾…ã£ã¦ã‹ã‚‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’èª­ã¿å–ã‚‹ãŸã‚ã€ã‚ˆã‚Šæ­£ç¢ºãª`duration`ã‚’å–å¾—ã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:01:14*

Swift Concurrencyã®ã‚³ãƒ¼ãƒ‰ã§æ›¸ãç›´ã—ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:01:55*

Swift Concurrencyã‚’åˆ©ç”¨ã—ã¦ã€`metadataFromAudioFile`é–¢æ•°ã‚’æ›¸ãç›´ã™ã“ã¨ã§ã€éåŒæœŸå‡¦ç†ã‚’ã‚ˆã‚ŠåŠ¹ç‡çš„ã‹ã¤ç›´æ„Ÿçš„ã«è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚Swift Concurrencyã¯`async`/`await`ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”¨ã„ã¦éåŒæœŸã‚³ãƒ¼ãƒ‰ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã‹ã¤å®‰å…¨ã«æ›¸ã‘ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ä½¿ç”¨ã‚’é¿ã‘ã€ã‚ˆã‚Šèª­ã¿ã‚„ã™ãä¿å®ˆã—ã‚„ã™ã„ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸‹ã®ä¾‹ã¯ã€Swift Concurrencyã‚’ä½¿ã£ã¦éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’éåŒæœŸã§å–å¾—ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã¾ã™ï¼š

```swift
import AVFoundation
import Foundation

public final class AudioFileManager {
    private let fileManager = FileManager.default
    
    public init() {}
    
    // 'async' ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’é–¢æ•°ã«è¿½åŠ ã—ã¦ã€éåŒæœŸé–¢æ•°ã¨ã—ã¦ãƒãƒ¼ã‚¯
    func metadataFromAudioFile(fileUrl: URL) async throws -> AudioData {
        let asset = AVURLAsset(url: fileUrl)
        
        // 'await' ã‚’ä½¿ã£ã¦éåŒæœŸå‡¦ç†ã®å®Œäº†ã‚’å¾…ã¤
        try await asset.load(.duration)
        
        let attributes = try fileManager.attributesOfItem(atPath: fileUrl.path)
        let fileSize = (attributes[.size] as? Int) ?? 0
        let creationDate = attributes[.creationDate] as? Date ?? Date()
        let duration = CMTimeGetSeconds(asset.duration)
        
        return AudioData(
            fileUrl: fileUrl,
            createdAt: creationDate,
            fileSize: fileSize,
            duration: duration
        )
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`AVURLAsset`ã®`load(_:)`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€å¿…è¦ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’éåŒæœŸã«èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯Swift Concurrencyã«é©åˆã—ã¦ã„ã‚‹ãŸã‚ã€`await`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã€æŒ‡å®šã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã¾ã§å®Ÿè¡Œã‚’ä¸€æ™‚åœæ­¢ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒå®Œå…¨ã«åˆ©ç”¨å¯èƒ½ã«ãªã£ã¦ã‹ã‚‰æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸é€²ã‚€ã“ã¨ãŒã§ãã‚‹ãŸã‚ã€å†ç”Ÿæ™‚é–“ã®ç²¾åº¦ãŒå‘ä¸Šã—ã¾ã™ã€‚

ã“ã®éåŒæœŸå‡¦ç†ã¯ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€å‘¼ã³å‡ºã—å´ã§`try`/`catch`ã‚’ä½¿ç”¨ã—ã¦ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:05:31*

éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãªã®ã ã‘ã‚Œã©ã‚‚å–ã‚Œã‚‹æƒ…å ±ã‚’ã‚‚ã£ã¨å–ã‚Œã‚‹ã ã‘ã¨ã£ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:06:17*

Swiftã¨AVFoundationã‚’ä½¿ç”¨ã—ã¦éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã•ã‚‰ã«å¤šãã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€`AVURLAsset`ã‹ã‚‰ã•ã¾ã–ã¾ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯é€šå¸¸ã€ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆåã€ã‚¢ãƒ«ãƒãƒ åã€ãƒˆãƒ©ãƒƒã‚¯ç•ªå·ã€ã‚¸ãƒ£ãƒ³ãƒ«ãªã©ã®æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®æƒ…å ±ã¯ã€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’é€šã˜ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ä¾‹ã§ã¯ã€æ§˜ã€…ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®æ‹¡å¼µã•ã‚ŒãŸéåŒæœŸé–¢æ•°ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã«ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®åŸºæœ¬çš„ãªå±æ€§ã«åŠ ãˆã¦ã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€ãƒ“ãƒƒãƒˆãƒ¬ãƒ¼ãƒˆã€ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆåã€ã‚¢ãƒ«ãƒãƒ åãªã©ã®è©³ç´°ãªæƒ…å ±ãŒå«ã¾ã‚Œã¾ã™ã€‚

```swift
import AVFoundation
import Foundation

public final class AudioFileManager {
    private let fileManager = FileManager.default
    
    public init() {}
    
    func metadataFromAudioFile(fileUrl: URL) async throws -> AudioData {
        let asset = AVURLAsset(url: fileUrl)
        
        // è¤‡æ•°ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’åŒæ™‚ã«ãƒ­ãƒ¼ãƒ‰
        try await asset.loadValues(forKeys: ["duration", "commonMetadata", "availableMetadataFormats"])
        
        let attributes = try fileManager.attributesOfItem(atPath: fileUrl.path)
        let fileSize = (attributes[.size] as? Int) ?? 0
        let creationDate = attributes[.creationDate] as? Date ?? Date()
        let duration = CMTimeGetSeconds(asset.duration)
        
        var artist: String? = nil
        var albumName: String? = nil
        var trackNumber: String? = nil
        var genre: String? = nil
        
        // ã‚³ãƒ¢ãƒ³ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è©³ç´°æƒ…å ±ã‚’å–å¾—
        for metadata in asset.commonMetadata {
            if let key = metadata.commonKey?.rawValue {
                switch key {
                case "artist":
                    artist = metadata.stringValue
                case "albumName":
                    albumName = metadata.stringValue
                case "trackNumber":
                    trackNumber = metadata.stringValue
                case "genre":
                    genre = metadata.stringValue
                default:
                    break
                }
            }
        }
        
        return AudioData(
            fileUrl: fileUrl,
            createdAt: creationDate,
            fileSize: fileSize,
            duration: duration,
            artist: artist,
            albumName: albumName,
            trackNumber: trackNumber,
            genre: genre
        )
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€æŒ‡å®šã•ã‚ŒãŸURLã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰åºƒç¯„ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’éåŒæœŸçš„ã«èª­ã¿è¾¼ã¿ã¾ã™ã€‚`loadValues(forKeys:)`ã‚’ä½¿ç”¨ã—ã¦ã€`duration`ã€`commonMetadata`ã€ãŠã‚ˆã³`availableMetadataFormats`ã‚’äº‹å‰ã«ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ãã®å¾Œã€ã‚³ãƒ¢ãƒ³ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆåã€ã‚¢ãƒ«ãƒãƒ åã€ãƒˆãƒ©ãƒƒã‚¯ç•ªå·ã€ã‚¸ãƒ£ãƒ³ãƒ«ãªã©ã®æƒ…å ±ã‚’å–ã‚Šå‡ºã—ã¦ã„ã¾ã™ã€‚

ã“ã®æ–¹æ³•ã§å–å¾—ã§ãã‚‹æƒ…å ±ã®ç¯„å›²ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã«ä¾å­˜ã—ã¾ã™ã€‚ã™ã¹ã¦ã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒã“ã‚Œã‚‰ã™ã¹ã¦ã®æƒ…å ±ã‚’æŒã£ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ãŸã‚ã€å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ˆã£ã¦ç•°ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:06:53*

AVURLAsset ã¨ AVAsset ã®é•ã„ã‚’æ•™ãˆã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:07:46*

`AVURLAsset`ã¨`AVAsset`ã¯ã€iOSã‚„macOSã§ãƒ¡ãƒ‡ã‚£ã‚¢ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ‰±ã†ãŸã‚ã®AVFoundationãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å†…ã®ã‚¯ãƒ©ã‚¹ã§ã™ãŒã€å½¼ã‚‰ã®ç”¨é€”ã¨æ©Ÿèƒ½æ€§ã«ã¯é‡è¦ãªé•ã„ãŒã‚ã‚Šã¾ã™ã€‚

### AVAsset

`AVAsset`ã¯æŠ½è±¡ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚„ãƒ“ãƒ‡ã‚ªãªã©ã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¢ã‚»ãƒƒãƒˆã‚’è¡¨ã—ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹è‡ªä½“ã¯å…·ä½“çš„ãªãƒ¡ãƒ‡ã‚£ã‚¢ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚„æ“ä½œã®æ©Ÿèƒ½ã‚’ç›´æ¥æä¾›ã™ã‚‹ã‚ã‘ã§ã¯ãªãã€ãƒ¡ãƒ‡ã‚£ã‚¢ã®æ§‹é€ ã‚„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£æƒ…å ±ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æŠ½è±¡çš„ã«å®šç¾©ã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã€`AVAsset`ã¯æ§˜ã€…ãªç¨®é¡ã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¢ã‚»ãƒƒãƒˆã«å…±é€šã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã—ã€å…·ä½“çš„ãªå®Ÿè£…ã¯ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã«å§”ã­ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

### AVURLAsset

`AVURLAsset`ã¯`AVAsset`ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€URLã‚’ä»‹ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªãƒ¡ãƒ‡ã‚£ã‚¢ã‚¢ã‚»ãƒƒãƒˆï¼ˆä¸»ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚„HTTP(S)ã‚¹ãƒˆãƒªãƒ¼ãƒ ãªã©ï¼‰ã«ç‰¹åŒ–ã—ã¦ã„ã¾ã™ã€‚ã“ã®ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€å…·ä½“çš„ãªURLã‹ã‚‰ãƒ¡ãƒ‡ã‚£ã‚¢ã‚’èª­ã¿è¾¼ã¿ã€ãã®ãƒ¡ãƒ‡ã‚£ã‚¢ã«å«ã¾ã‚Œã‚‹ãƒˆãƒ©ãƒƒã‚¯ã‚„ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã€ãã®ä»–ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚`AVURLAsset`ã¯ã€URLãƒ™ãƒ¼ã‚¹ã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¢ã‚»ãƒƒãƒˆã‚’æ“ä½œã™ã‚‹ãŸã‚ã®å…·ä½“çš„ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ ã§æä¾›ã—ã¦ãŠã‚Šã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ‰±ã†éš›ã«åºƒãä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

### ä¸»ãªé•ã„

- **ç”¨é€”ã®å…·ä½“æ€§**: `AVAsset`ã¯å¤šãã®ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æŠ½è±¡çš„ã«æ‰±ã†ãŸã‚ã®åŸºç›¤ã‚’æä¾›ã™ã‚‹ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ç›´æ¥çš„ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚ä¸€æ–¹ã§ã€`AVURLAsset`ã¯å…·ä½“çš„ãªURLã«åŸºã¥ããƒ¡ãƒ‡ã‚£ã‚¢ã‚¢ã‚»ãƒƒãƒˆã‚’æ‰±ã†ãŸã‚ã®ã‚¯ãƒ©ã‚¹ã§ã™ã€‚
- **æ©Ÿèƒ½**: `AVURLAsset`ã¯`AVAsset`ãŒæä¾›ã™ã‚‹åŸºæœ¬çš„ãªæ©Ÿèƒ½ã«åŠ ãˆã¦ã€URLã«åŸºã¥ããƒ¡ãƒ‡ã‚£ã‚¢ã‚’åŠ¹ç‡çš„ã«èª­ã¿è¾¼ã¿ã€è§£æã™ã‚‹ãŸã‚ã®è¿½åŠ æ©Ÿèƒ½ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ¡ãƒ‡ã‚£ã‚¢ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’åˆ¶å¾¡ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚„ã€ãƒ¡ãƒ‡ã‚£ã‚¢ã®ç‰¹å®šã®éƒ¨åˆ†ã ã‘ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ãªã©ãŒã‚ã‚Šã¾ã™ã€‚

`AVURLAsset`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒ¡ãƒ‡ã‚£ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚ˆã‚ŠæŸ”è»Ÿã«ã€åŠ¹ç‡çš„ã«æ‰±ã†ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ç‰¹ã«ã€å¤§ããªãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ä»‹ã—ãŸãƒ¡ãƒ‡ã‚£ã‚¢ã‚¢ã‚¯ã‚»ã‚¹ãŒé–¢ã‚ã‚‹å ´åˆã«æœ‰åˆ©ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:12:11*

ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ã«ãªã£ãŸ

Cannot pass function of type '(URL) async throws -&gt; AudioData' to parameter expecting synchronous function type

final class AudioListPresenter: ObservableObject {
    @Published private(set) var audioFiles: [URL] = []
    @Published private(set) var audioData: [AudioData] = []
    
    private let fileManageDriver: FileManageDriver = .init()
    private let audioFileManageDriver: AudioFileManageDriver = .init()
    
    init() {}
    
    func onAppear() {
        let tmpPath = fileManageDriver.getDirectoryURL(directoryType: .tmp)
        
        do {
            let audioFiles = try fileManageDriver.fetchFiles(directory: tmpPath, extensions: FileExtension.allCases)
            audioData = try audioFiles.map { fileUrl in
                try await audioFileManageDriver.metadataFromAudioFile(fileUrl: fileUrl)
            }.sorted(by: \.createdAt, order: .descending)
        } catch {
            OSLogger.errorLog("Failed to read audio files: \(error)")
        }
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:12:59*

Swift ã§éåŒæœŸå‡¦ç†ã‚’è¡Œã†éš›ã€`map`ã‚„ãã®ä»–ã®é«˜éšé–¢æ•°ã‚’åˆ©ç”¨ã—ã¦éåŒæœŸé–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€`map`é–¢æ•°ãŒåŒæœŸçš„ãªå‡¦ç†ã‚’æœŸå¾…ã—ã¦ã„ã‚‹ãŸã‚ã§ã€éåŒæœŸé–¢æ•°ã‚„`throws`ã‚’ä¼´ã†é–¢æ•°ã‚’ãã®ã¾ã¾æ¸¡ã™ã¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒå‹ä¸ä¸€è‡´ã¨åˆ¤æ–­ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚

ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ã«ã¯ã€éåŒæœŸå‡¦ç†ã‚’è¡Œã„ã¤ã¤é…åˆ—ã®å¤‰æ›ã‚’è¡Œã†ãŸã‚ã«ã¯ã€æ˜ç¤ºçš„ã«ãƒ«ãƒ¼ãƒ—ã‚’ç”¨ã„ã¦å„è¦ç´ ã«å¯¾ã™ã‚‹å‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`for-in`ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã—ã¦ã€ãã‚Œãã‚Œã®URLã«å¯¾ã—ã¦éåŒæœŸé–¢æ•°ã‚’å‘¼ã³å‡ºã—ã€çµæœã‚’é…åˆ—ã«æ ¼ç´ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€éåŒæœŸé–¢æ•°ã‚’é©åˆ‡ã«æ‰±ã„ã¤ã¤ã€å¿…è¦ãªãƒ‡ãƒ¼ã‚¿å¤‰æ›ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

```swift
final class AudioListPresenter: ObservableObject {
    @Published private(set) var audioFiles: [URL] = []
    @Published private(set) var audioData: [AudioData] = []
    
    private let fileManageDriver: FileManageDriver = .init()
    private let audioFileManageDriver: AudioFileManageDriver = .init()
    
    init() {}
    
    func onAppear() {
        Task {
            do {
                let tmpPath = fileManageDriver.getDirectoryURL(directoryType: .tmp)
                let audioFiles = try fileManageDriver.fetchFiles(directory: tmpPath, extensions: FileExtension.allCases)
                
                var fetchedAudioData = [AudioData]()
                for fileUrl in audioFiles {
                    do {
                        let data = try await audioFileManageDriver.metadataFromAudioFile(fileUrl: fileUrl)
                        fetchedAudioData.append(data)
                    } catch {
                        OSLogger.errorLog("Failed to fetch metadata for file \(fileUrl): \(error)")
                    }
                }
                
                // ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§UIã‚’æ›´æ–°
                await MainActor.run {
                    self.audioData = fetchedAudioData.sorted(by: { $0.createdAt > $1.createdAt })
                }
            } catch {
                OSLogger.errorLog("Failed to read audio files: \(error)")
            }
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€`onAppear` ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’é–‹å§‹ã—ã€ãã‚Œãã‚Œã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã‚’è©¦ã¿ã¦ã„ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ãƒ­ã‚°ã«ã‚¨ãƒ©ãƒ¼ã‚’è¨˜éŒ²ã—ã€æˆåŠŸã—ãŸå ´åˆã¯çµæœã‚’ `fetchedAudioData` é…åˆ—ã«è¿½åŠ ã—ã¾ã™ã€‚æœ€çµ‚çš„ã«ã¯ã€å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆæ—¥æ™‚ã§é™é †ã«ã‚½ãƒ¼ãƒˆã—ã¦UIã«åæ˜ ã•ã›ã¦ã„ã¾ã™ã€‚

ã¾ãŸã€UIé–¢é€£ã®æ›´æ–°ã¯`MainActor.run`ã‚’ä½¿ç”¨ã—ã¦ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ä¸Šã§è¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€éåŒæœŸå‡¦ç†ã®çµæœã‚’ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã«UIã«åæ˜ ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:13:36*

ã“ã‚Œã ã¨å‡¦ç†ãŒé…ããªã£ã¦ã—ã¾ã†ã®ã§éåŒæœŸã«ã‚„ã‚ŠãŸã„ã€‚å…¨éƒ¨çµ‚ã‚ã£ãŸã‚‰UIæ›´æ–°ã¨ã—ãŸã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:14:27*

ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã™ã‚‹ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚’ä¸¦è¡Œã—ã¦è¡Œã„ã€å…¨ã¦ã®å‡¦ç†ãŒå®Œäº†ã—ãŸå¾Œã«ä¸€åº¦ã ã‘UIã‚’æ›´æ–°ã™ã‚‹æ–¹æ³•ã§å‡¦ç†ã‚’æœ€é©åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚Swift Concurrencyã®`TaskGroup`ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€è¤‡æ•°ã®éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’ä¸¦è¡Œã—ã¦å®Ÿè¡Œã—ã€ãã‚Œã‚‰ã®çµæœã‚’åŠ¹ç‡çš„ã«åé›†ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã€`TaskGroup`ã‚’ä½¿ç”¨ã—ã¦ã€å„ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’éåŒæœŸã«å–å¾—ã—ã€å…¨ã¦ã®å‡¦ç†ãŒå®Œäº†ã—ãŸå¾Œã«UIã‚’æ›´æ–°ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã¾ã™ï¼š

```swift
final class AudioListPresenter: ObservableObject {
    @Published private(set) var audioFiles: [URL] = []
    @Published private(set) var audioData: [AudioData] = []

    private let fileManageDriver: FileManageDriver = .init()
    private let audioFileManageDriver: AudioFileManageDriver = .init()

    init() {}

    func onAppear() {
        Task {
            do {
                let tmpPath = fileManageDriver.getDirectoryURL(directoryType: .tmp)
                let audioFiles = try fileManageDriver.fetchFiles(directory: tmpPath, extensions: FileExtension.allCases)
                
                var fetchedAudioData: [AudioData] = []
                
                // TaskGroupã‚’ä½¿ç”¨ã—ã¦ã€å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã‚’ä¸¦è¡Œå®Ÿè¡Œ
                try await withThrowingTaskGroup(of: AudioData.self) { group in
                    for fileUrl in audioFiles {
                        group.addTask {
                            try await self.audioFileManageDriver.metadataFromAudioFile(fileUrl: fileUrl)
                        }
                    }

                    // ã™ã¹ã¦ã®çµæœã‚’åé›†
                    for try await result in group {
                        fetchedAudioData.append(result)
                    }
                }
                
                // å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆæ—¥æ™‚ã§é™é †ã«ã‚½ãƒ¼ãƒˆã—ã¦UIã«åæ˜ 
                await MainActor.run {
                    self.audioData = fetchedAudioData.sorted(by: { $0.createdAt > $1.createdAt })
                }
            } catch {
                OSLogger.errorLog("Failed to read audio files: \(error)")
            }
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`withThrowingTaskGroup`ã‚’ä½¿ç”¨ã—ã¦ã€å„ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã™ã‚‹ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¿ã‚¹ã‚¯ã‚’éåŒæœŸã«è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚`group.addTask`ã§è¿½åŠ ã•ã‚ŒãŸå„ã‚¿ã‚¹ã‚¯ã¯ä¸¦è¡Œã—ã¦å®Ÿè¡Œã•ã‚Œã€ãã®çµæœã¯`for try await`ãƒ«ãƒ¼ãƒ—ã§åé›†ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’åŠ¹ç‡çš„ã«ä¸¦è¡Œã—ã¦å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã€å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒæƒã£ãŸå¾Œã«ä¸€åº¦ã ã‘UIã‚’æ›´æ–°ã™ã‚‹å‡¦ç†ãŒè¡Œã‚ã‚Œã¾ã™ã€‚

ã“ã®æ–¹æ³•ã¯ã€å¤šæ•°ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†å ´åˆã§ã‚‚æ€§èƒ½ã‚’åŠ¹æœçš„ã«å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ãŸã‚ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ€§ã‚’é«˜ã‚ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:14:40*

func onAppear() async ã¨ã—ã¦å‡¦ç†ã‚’æ›¸ãç›´ã—ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:15:19*

`func onAppear()` ã‚’ `async` é–¢æ•°ã¨ã—ã¦æ›¸ãç›´ã™ã“ã¨ã§ã€ã‚ˆã‚Šã‚·ãƒ³ãƒ—ãƒ«ã§èª­ã¿ã‚„ã™ã„éåŒæœŸã‚³ãƒ¼ãƒ‰ã‚’å®Ÿç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚Swiftã®`async`é–¢æ•°ã‚’åˆ©ç”¨ã™ã‚‹ã¨ã€ç›´åˆ—çš„ãªã‚³ãƒ¼ãƒ‰ã®æ›¸ãæ–¹ã§éåŒæœŸå‡¦ç†ã‚’è¡¨ç¾ã§ãã€ã‚³ãƒ¼ãƒ‰ã®ç†è§£ãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ã€‚ä»¥ä¸‹ã«`onAppear`ã‚’`async`é–¢æ•°ã¨ã—ã¦æ›¸ãç›´ã—ãŸä¾‹ã‚’ç¤ºã—ã¾ã™ï¼š

```swift
final class AudioListPresenter: ObservableObject {
    @Published private(set) var audioFiles: [URL] = []
    @Published private(set) var audioData: [AudioData] = []

    private let fileManageDriver: FileManageDriver = .init()
    private let audioFileManageDriver: AudioFileManageDriver = .init()

    init() {}

    // onAppearé–¢æ•°ã‚’asyncé–¢æ•°ã¨ã—ã¦å®šç¾©
    func onAppear() async {
        do {
            let tmpPath = fileManageDriver.getDirectoryURL(directoryType: .tmp)
            let audioFiles = try fileManageDriver.fetchFiles(directory: tmpPath, extensions: FileExtension.allCases)
            
            var fetchedAudioData: [AudioData] = []

            // TaskGroupã‚’ä½¿ç”¨ã—ã¦ã€å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã‚’ä¸¦è¡Œå®Ÿè¡Œ
            try await withThrowingTaskGroup(of: AudioData.self) { group in
                for fileUrl in audioFiles {
                    group.addTask {
                        return try await self.audioFileManageDriver.metadataFromAudioFile(fileUrl: fileUrl)
                    }
                }

                // ã™ã¹ã¦ã®çµæœã‚’åé›†
                for try await result in group {
                    fetchedAudioData.append(result)
                }
            }
            
            // å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆæ—¥æ™‚ã§é™é †ã«ã‚½ãƒ¼ãƒˆã—ã¦UIã«åæ˜ 
            await MainActor.run {
                self.audioData = fetchedAudioData.sorted(by: { $0.createdAt > $1.createdAt })
            }
        } catch {
            OSLogger.errorLog("Failed to read audio files: \(error)")
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`onAppear`ãƒ¡ã‚½ãƒƒãƒ‰ãŒ`async`ãƒãƒ¼ã‚¯ã•ã‚Œã¦ãŠã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å–å¾—ã‹ã‚‰ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†ã€UIã®æ›´æ–°ã¾ã§å…¨ã¦ã®å‡¦ç†ãŒéåŒæœŸçš„ã«è¡Œã‚ã‚Œã¾ã™ã€‚`withThrowingTaskGroup`ã‚’ä½¿ç”¨ã—ã¦ä¸¦è¡Œå‡¦ç†ã‚’ç®¡ç†ã—ã€å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ãŒå®Œäº†ã—ãŸã‚‰ã€çµæœã‚’é›†ã‚ã¦UIã‚’æ›´æ–°ã—ã¦ã„ã¾ã™ã€‚

ã¾ãŸã€`MainActor.run`ã‚’ä½¿ç”¨ã—ã¦UIã®æ›´æ–°ã‚’ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®‰å…¨ã«è¡Œã†ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã®æ–¹æ³•ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’æãªã†ã“ã¨ãªãã€éåŒæœŸå‡¦ç†ã‚’é©åˆ‡ã«ç®¡ç†ã™ã‚‹ãŸã‚ã®åŠ¹ç‡çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:21:07*

[error]  âš ï¸ Error(appError: SmallTalkPackage.AppError.customError("Failed to read audio files: Error Domain=AVFoundationErrorDomain Code=-11828 \"Cannot Open\" UserInfo={NSUnderlyingError=0x600000d1b960 {Error Domain=NSOSStatusErrorDomain Code=-12847 \"(null)\"}, NSLocalizedFailureReason=This media format is not supported., AVErrorFailedDependenciesKey=(\n    Duration\n), NSURL=file:///Users/sugurutakahashi/Library/Developer/CoreSimulator/Devices/D47C0E27-0209-4242-A873-0396C604B194/data/Containers/Data/Application/B9CCCEA5-83AC-42DF-8973-4F3BC9A509D5/tmp/2024-05-08T19:52:48+09:00.acc, NSLocalizedDescription=Cannot Open}"), errorName: "customError(\"Failed to read audio files: Error Domain=AVFoundationErrorDomain Code=-11828 \\\"Cannot Open\\\" UserInfo={NSUnderlyingError=0x600000d1b960 {Error Domain=NSOSStatusErrorDomain Code=-12847 \\\"(null)\\\"}, NSLocalizedFailureReason=This media format is not supported., AVErrorFailedDependenciesKey=(\\n    Duration\\n), NSURL=file:///Users/sugurutakahashi/Library/Developer/CoreSimulator/Devices/D47C0E27-0209-4242-A873-0396C604B194/data/Containers/Data/Application/B9CCCEA5-83AC-42DF-8973-4F3BC9A509D5/tmp/2024-05-08T19:52:48+09:00.acc, NSLocalizedDescription=Cannot Open}\")"), file: AudioListPresenter.swift, function: onAppear(), line: 40

public final class AudioFileManageDriver: Sendable {
    public init() {}
    
    func metadataFromAudioFile(fileUrl: URL) async throws -&gt; AudioData {
        let attributes = try FileManager.default.attributesOfItem(atPath: fileUrl.path)
        let fileSize = (attributes[.size] as? Int) ?? 0
        let creationDate = attributes[.creationDate] as? Date ?? Date()
        
        OSLogger.errorLog("1")
        let asset = AVURLAsset(url: fileUrl)
        let duration = try await asset.load(.duration)        
        OSLogger.errorLog("2")
        
        return AudioData(
            fileUrl: fileUrl,
            createdAt: creationDate,
            fileSize: fileSize,
            duration: CMTimeGetSeconds(duration)
        )
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:22:02*

ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ `-11828` ã¨ OSStatus `â€‘12847` ã¯ã€æŒ‡å®šã•ã‚ŒãŸãƒ¡ãƒ‡ã‚£ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ã€é€šå¸¸ã€æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ãŒã‚·ã‚¹ãƒ†ãƒ ã‚„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‹ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒç ´æã—ã¦ã„ã‚‹ã‹ã€ä¸å®Œå…¨ã§ã‚ã‚‹ã“ã¨ãŒåŸå› ã§ã™ã€‚

å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ã¯ã€ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¸ã‚€ã“ã¨ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ï¼š

1. **ãƒ•ã‚¡ã‚¤ãƒ«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ç¢ºèª**: ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã‚ã‚‹`.acc`ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã¯ä¸€èˆ¬çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—`.aac`ãŒæ­£ã—ã„æ‹¡å¼µå­ã§ã‚ã‚Œã°ã€ã“ã‚ŒãŒã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã§ãªã„ã‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚æ­£ã—ã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’æ¤œè¨¼ã™ã‚‹ã“ã¨ã‚‚é‡è¦ã§ã™ã€‚

2. **ãƒ•ã‚¡ã‚¤ãƒ«ã®äº’æ›æ€§ã®ç¢ºèª**: ã‚¨ãƒ©ãƒ¼ãŒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«é–¢é€£ã—ã¦ã„ã‚‹å ´åˆã€ãã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒiOSãƒ‡ãƒã‚¤ã‚¹ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚ä¾‹ãˆã°ã€AACã‚„MP3ãªã©ã®ä¸€èˆ¬çš„ãªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚

3. **ãƒ•ã‚¡ã‚¤ãƒ«ã®å®Œå…¨æ€§ã®æ¤œè¨¼**: ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£ã—ããƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¾ãŸã¯è»¢é€ã•ã‚ŒãŸã‹ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒç ´æã—ã¦ã„ãªã„ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚

4. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ”¹å–„**: ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã„å ´åˆã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ã‹ã‚Šã‚„ã™ã„ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æä¾›ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

5. **ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®æ”¹å–„**: ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‰ã¨èª­ã¿è¾¼ã¿å¾Œã«ãƒ­ã‚°ã‚’å‡ºåŠ›ã™ã‚‹ã“ã¨ã§ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã„ã‚‹æ­£ç¢ºãªä½ç½®ã‚’ç‰¹å®šã—ã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’å«ã‚€æ”¹å–„ã•ã‚ŒãŸé–¢æ•°ã®ä¾‹ã§ã™ï¼š

```swift
public final class AudioFileManageDriver: Sendable {
    public init() {}
    
    func metadataFromAudioFile(fileUrl: URL) async throws -> AudioData {
        let attributes = try FileManager.default.attributesOfItem(atPath: fileUrl.path)
        let fileSize = (attributes[.size] as? Int) ?? 0
        let creationDate = attributes[.creationDate] as? Date ?? Date()
        
        let asset = AVURLAsset(url: fileUrl)
        
        do {
            let duration = try await asset.load(.duration)
            return AudioData(
                fileUrl: fileUrl,
                createdAt: creationDate,
                fileSize: fileSize,
                duration: CMTimeGetSeconds(duration)
            )
        } catch {
            OSLogger.errorLog("Failed to load audio file: \(error.localizedDescription)")
            throw error
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`try await asset.load(.duration)` è¡Œã§ç™ºç”Ÿã—ãŸå¯èƒ½æ€§ã®ã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒã—ã€ãã‚Œã«åŸºã¥ã„ã¦é©åˆ‡ãªãƒ­ã‚°ã‚’å‡ºåŠ›ã—ãŸå¾Œã€ã‚¨ãƒ©ãƒ¼ã‚’å†ã‚¹ãƒ­ãƒ¼ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ‡ãƒãƒƒã‚°æ™‚ã«ã‚ˆã‚Šå¤šãã®æƒ…å ±ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã€å•é¡Œã®åŸå› ã‚’ç‰¹å®šã—ã‚„ã™ããªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:54:39*

setActive(false) ã®å‡¦ç†ã«ç•°æ§˜ã«æ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã—ãŸã„

final class RecordingDriver {
    private let audioSession: AVAudioSession = AVAudioSession.sharedInstance()
    private var audioRecorder: AVAudioRecorder?
    
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let isRecordingSubject = PassthroughSubject&lt;Bool, Never&gt;()
    var isRecordingPublisher: AnyPublisher&lt;Bool, Never&gt; {
        isRecordingSubject.eraseToAnyPublisher()
    }
    
    init() {}
    
    deinit {
        try? stopRecording()
    }

    func startRecording(recordingConfig: RecordingConfig) throws {
        let audioFilename = fileManageDriver.getDirectoryURL(directoryType: .tmp)
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue
        ]

        // Ref: AVAudioSessionã®è¨­å®šã§ä½•ãŒå¤‰ã‚ã‚‹ã®ã‹ï¼Ÿ - https://zenn.dev/entaku/articles/e75c4aa914c6cf
        try audioSession.setCategory(
            recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
            mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
            options: []
        )
    
        OSLogger.debugLog("Start: session active")
        try audioSession.setActive(true)
        OSLogger.debugLog("Completed: session active")
        
        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")
    }

    func stopRecording() throws {
        OSLogger.debugLog("Start: stop recording")
        audioRecorder?.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        OSLogger.debugLog("Start: session unactive")
        try audioSession.setActive(false)
        OSLogger.debugLog("Completed: session unactive")
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:55:02*

`AVAudioSession`ã®`setActive(false)`ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ãŒç•°å¸¸ã«æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆã€ã“ã®å‡¦ç†ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã—ã¦ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚’é¿ã‘ã‚‹ã“ã¨ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚Swiftã®`DispatchQueue`ã‚’ä½¿ç”¨ã—ã¦ã€éåŒæœŸã«`setActive`ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯`stopRecording()`é–¢æ•°ã‚’æ”¹è‰¯ã—ã€`setActive(false)`ã‚’åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

```swift
final class RecordingDriver {
    private let audioSession: AVAudioSession = AVAudioSession.sharedInstance()
    private var audioRecorder: AVAudioRecorder?
    
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let isRecordingSubject = PassthroughSubject&lt;Bool, Never&gt;()
    var isRecordingPublisher: AnyPublisher&lt;Bool, Never&gt; {
        isRecordingSubject.eraseToAnyPublisher()
    }
    
    init() {}
    
    deinit {
        try? stopRecording()
    }

    func startRecording(recordingConfig: RecordingConfig) throws {
        let audioFilename = fileManageDriver.getDirectoryURL(directoryType: .tmp)
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue
        ]

        try audioSession.setCategory(
            recordingConfig.audioSessionCategory.toAVAudioSession

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 19:55:04*

Swift  Concurrency ã§è¨˜è¿°ã—ã¦ã»ã—ã„

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 19:55:49*

Swift Concurrencyã‚’ä½¿ç”¨ã—ã¦`RecordingDriver`ã‚¯ãƒ©ã‚¹ã®`stopRecording()`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ”¹è‰¯ã—ã€`setActive(false)`ã‚’éåŒæœŸã§å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯ã€`async`/`await`ã‚’ä½¿ç”¨ã—ã¦ã€`AVAudioSession`ã®çŠ¶æ…‹å¤‰æ›´ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§è¡Œã„ãªãŒã‚‰ã€ãã®çµæœã‚’å¾…æ©Ÿã™ã‚‹ã“ã¨ãªãä»–ã®å‡¦ç†ã‚’ç¶™ç¶šã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`Task`ã‚’ä½¿ã£ã¦`setActive(false)`ã‚’éåŒæœŸã«å®Ÿè¡Œã—ã€ãã®å®Œäº†ã‚’å¾…ã¤ã“ã¨ãªãéŒ²éŸ³ã‚’åœæ­¢ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚ŠUIã‚„ä»–ã®å‡¦ç†ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚

```swift
final class RecordingDriver {
    private let audioSession: AVAudioSession = AVAudioSession.sharedInstance()
    private var audioRecorder: AVAudioRecorder?
    
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let isRecordingSubject = PassthroughSubject<Bool, Never>()
    var isRecordingPublisher: AnyPublisher<Bool, Never> {
        isRecordingSubject.eraseToAnyPublisher()
    }
    
    init() {}
    
    deinit {
        Task {
            try? await stopRecording()
        }
    }

    func startRecording(recordingConfig: RecordingConfig) throws {
        let audioFilename = fileManageDriver.getDirectoryURL(directoryType: .tmp)
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue
        ]

        try audioSession.setCategory(
            recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
            mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
            options: []
        )
        
        try await audioSession.setActive(true)
        
        audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
        audioRecorder?.record()
        isRecordingSubject.send(true)
    }

    func stopRecording() async throws {
        OSLogger.debugLog("Start: stop recording")
        audioRecorder?.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        OSLogger.debugLog("Start: session unactive")
        
        // setActive(false) ã‚’éåŒæœŸã§å®Ÿè¡Œ
        Task {
            do {
                try await audioSession.setActive(false)
                OSLogger.debugLog("Completed: session unactive")
            } catch {
                OSLogger.errorLog("Failed to set session inactive: \(error)")
            }
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã®ãƒã‚¤ãƒ³ãƒˆã¯ã€`stopRecording()`ãƒ¡ã‚½ãƒƒãƒ‰ãŒ`async`ã§ã‚ã‚Šã€å†…éƒ¨ã§`Task`ã‚’ä½¿ç”¨ã—ã¦`setActive(false)`ã‚’éåŒæœŸã«å®Ÿè¡Œã—ã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–å‡¦ç†ãŒæ™‚é–“ã‚’è¦ã™ã‚‹å ´åˆã§ã‚‚ä»–ã®UIã‚„å‡¦ç†ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãŸã€`deinit`ã§`stopRecording()`ã‚’å‘¼ã³å‡ºã™éš›ã¯ã€`Task`ã‚’ä½¿ç”¨ã—ã¦éåŒæœŸã«è¡Œã†ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 20:03:46*

ã“ã®Task ã‚’åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã—ã¦å‡¦ç†ã‚’ä¸€ç¬ã§çµ‚ã‚ã‚‰ã›ãŸã„

    @MainActor
    func stopRecording() throws {
        OSLogger.debugLog("Start: stop recording")
        audioRecorder?.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")
//
//        OSLogger.debugLog("Start: session unactive")
//        try audioSession.setActive(false)
//        OSLogger.debugLog("Completed: session unactive")
        
        OSLogger.debugLog("Start: session unactive")
        
        // setActive(false) ã‚’éåŒæœŸã§å®Ÿè¡Œ
        Task {
            do {
                try audioSession.setActive(false)
                OSLogger.debugLog("Completed: session unactive")
            } catch {
                OSLogger.errorLog("Failed to set session inactive: \(error)")
                throw error
            }
        }
    }

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 20:04:34*

Swift Concurrency ã¨ `Task` ã‚’ç”¨ã„ã¦éåŒæœŸå‡¦ç†ã‚’å®Ÿè£…ã™ã‚‹éš›ã€é€šå¸¸ã® `Task` ã¯æ—¢ã«ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œã•ã‚Œã¾ã™ãŒã€ãã‚ŒãŒã€Œä¸€ç¬ã§çµ‚ã‚ã‚‹ã€ã‹ã©ã†ã‹ã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“ã€‚`setActive(false)` ãŒæ™‚é–“ã‚’è¦ã™ã‚‹ã®ã¯ã€ãã®æ“ä½œè‡ªä½“ãŒå†…éƒ¨ã§é‡ã„å‡¦ç†ã‚’ä¼´ã†å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã§ã™ã€‚ã“ã‚Œã‚’åŠ¹ç‡çš„ã«æ‰±ã†ãŸã‚ã€æœ€é©ãªã®ã¯ç¢ºã‹ã«å‡¦ç†ã‚’éåŒæœŸã«è¡Œã†ã“ã¨ã§ã™ãŒã€ã“ã‚Œã‚’ã•ã‚‰ã«æœ€é©åŒ–ã™ã‚‹ãŸã‚ã«ã¯ä»¥ä¸‹ã®æ–¹æ³•ã‚’è€ƒæ…®ã§ãã¾ã™ï¼š

1. **ä½å„ªå…ˆåº¦ã®ã‚¿ã‚¹ã‚¯ã§å®Ÿè¡Œ**: å‡¦ç†ãŒé‡ã„å ´åˆã€ãã‚Œã‚’ä½å„ªå…ˆåº¦ã§å®Ÿè¡Œã—ã€ä»–ã®å‡¦ç†ã«å½±éŸ¿ã‚’ä¸ãˆã«ããã™ã‚‹ã“ã¨ãŒä¸€ã¤ã®æ‰‹ã§ã™ã€‚`Task(priority: .background)` ã‚’ä½¿ç”¨ã—ã¦ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ä½å„ªå…ˆåº¦ã§å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

2. **ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®æ”¹å–„**: ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«ãƒ­ã‚°ã‚’å‡ºåŠ›ã—ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã‚’UIãªã©ä»–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«é€šçŸ¥ã™ã‚‹ã“ã¨ã‚‚è€ƒæ…®ã—ã¾ã—ã‚‡ã†ã€‚

ä»¥ä¸‹ã«ã€ä½å„ªå…ˆåº¦ã§éåŒæœŸå‡¦ç†ã‚’è¡Œã†æ”¹è‰¯ç‰ˆã® `stopRecording()` ã‚’ç¤ºã—ã¾ã™ï¼š

```swift
@MainActor
func stopRecording() throws {
    OSLogger.debugLog("Start: stop recording")
    audioRecorder?.stop()
    isRecordingSubject.send(false)
    OSLogger.debugLog("Completed: stop recording")

    OSLogger.debugLog("Start: session unactive")

    // setActive(false) ã‚’ä½å„ªå…ˆåº¦ã®éåŒæœŸã§å®Ÿè¡Œ
    Task(priority: .background) {
        do {
            try await audioSession.setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        } catch {
            OSLogger.errorLog("Failed to set session inactive: \(error)")
            // ã‚¨ãƒ©ãƒ¼ã‚’UIãªã©ã«é€šçŸ¥ã™ã‚‹å ´åˆã¯ã“ã“ã§å‡¦ç†
        }
    }
}
```

ã“ã®å¤‰æ›´ã«ã‚ˆã‚Šã€`setActive(false)` ã®å‘¼ã³å‡ºã—ã¯ä½å„ªå…ˆåº¦ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã§éåŒæœŸã«è¡Œã‚ã‚Œã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã®è² è·ã‚’è»½æ¸›ã—ã¤ã¤ã€ä»–ã®å‡¦ç†ã®é…å»¶ã‚’æœ€å°é™ã«æŠ‘ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãŸã ã—ã€ã“ã®æ–¹æ³•ã§ã‚ã£ã¦ã‚‚ã€å†…éƒ¨ã®å‡¦ç†æ™‚é–“è‡ªä½“ã¯çŸ­ç¸®ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ãªãã€å®Ÿéš›ã®å®Œäº†ã¾ã§ã®æ™‚é–“ã¯å¤‰ã‚ã‚Šã¾ã›ã‚“ãŒã€ä»–ã®ã‚¿ã‚¹ã‚¯ã¸ã®å½±éŸ¿ã¯è»½æ¸›ã•ã‚Œã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 20:12:48*

setActive ã«ã©ã†è¨€ã£ãŸæ„å‘³ãŒã‚ã‚‹ã®ã‹ï¼Ÿ


import AVFoundation
import Combine

final class RecordingDriver {
    private let audioSession: AVAudioSession = AVAudioSession.sharedInstance()
    private var audioRecorder: AVAudioRecorder?
    
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let isRecordingSubject = PassthroughSubject&lt;Bool, Never&gt;()
    var isRecordingPublisher: AnyPublisher&lt;Bool, Never&gt; {
        isRecordingSubject.eraseToAnyPublisher()
    }
    
    init() {}

    func startRecording(recordingConfig: RecordingConfig) throws {
        let audioFilename = fileManageDriver.getDirectoryURL(directoryType: .tmp)
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue
        ]

        // Ref: AVAudioSessionã®è¨­å®šã§ä½•ãŒå¤‰ã‚ã‚‹ã®ã‹ï¼Ÿ - https://zenn.dev/entaku/articles/e75c4aa914c6cf
        try audioSession.setCategory(
            recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
            mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
            options: []
        )
    
        OSLogger.debugLog("Start: session active")
        try audioSession.setActive(true)
        OSLogger.debugLog("Completed: session active")
        
        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")
    }

    @MainActor
    func stopRecording() throws {
        OSLogger.debugLog("Start: stop recording")
        audioRecorder?.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        OSLogger.debugLog("Start: session unactive")
        try audioSession.setActive(false)
        OSLogger.debugLog("Completed: session unactive")
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 20:13:49*

`AVAudioSession`ã®`setActive(_:)`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ãŠã‚ˆã³éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã®é‡è¦ãªæ©Ÿèƒ½ã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæŒã¤ä¸»è¦ãªå½¹å‰²ã¨æ„å‘³ã‚’ä»¥ä¸‹ã«è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚

### ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ– (`setActive(true)`)

- **ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®å„ªå…ˆæ¨©**: ã‚¢ãƒ—ãƒªãŒã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®å†ç”Ÿã‚„éŒ²éŸ³ã‚’é–‹å§‹ã™ã‚‹éš›ã€`setActive(true)`ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå‡¦ç†ã®æº–å‚™ãŒã§ããŸã“ã¨ã‚’é€šçŸ¥ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¢ãƒ—ãƒªãŒã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå‡¦ç†ã«å¿…è¦ãªãƒªã‚½ãƒ¼ã‚¹ã‚’å„ªå…ˆçš„ã«åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
- **ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®å‰²ã‚Šè¾¼ã¿ã®ç®¡ç†**: ãŸã¨ãˆã°ã€é›»è©±ãŒã‹ã‹ã£ã¦ããŸæ™‚ãªã©ã€ä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚„ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚‹ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®å‰²ã‚Šè¾¼ã¿ã‚’é©åˆ‡ã«æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯ã€ãã®ã‚ˆã†ãªã‚¤ãƒ™ãƒ³ãƒˆã«åå¿œã—ã¦é©åˆ‡ã«å‡¦ç†ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ– (`setActive(false)`)

- **ãƒªã‚½ãƒ¼ã‚¹ã®è§£æ”¾**: ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå‡¦ç†ãŒä¸è¦ã«ãªã£ãŸæ™‚ï¼ˆä¾‹ãˆã°éŒ²éŸ³ãŒåœæ­¢ã—ãŸå¾Œãªã©ï¼‰ã€`setActive(false)`ã‚’å‘¼ã³å‡ºã—ã¦ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã™ã‚‹ã“ã¨ã§ã€ä½¿ç”¨ã—ã¦ã„ãŸã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
- **ãƒãƒƒãƒ†ãƒªãƒ¼æ¶ˆè²»ã®å‰Šæ¸›**: ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã¯æ¶ˆè²»é›»åŠ›ãŒæ¯”è¼ƒçš„é«˜ã„ãŸã‚ã€ä¸ä½¿ç”¨æ™‚ã«ã¯ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹ã“ã¨ã§ãƒãƒƒãƒ†ãƒªãƒ¼ã®æ¶ˆè²»ã‚’æŠ‘ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
- **ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®æŒ™å‹•ã®å®‰å®šåŒ–**: è¤‡æ•°ã®ã‚¢ãƒ—ãƒªãŒã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç«¶åˆã•ã›ã‚‹ã“ã¨ãªãã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªæŒ™å‹•ã®å®‰å®šæ€§ã‚’ä¿ã¤ãŸã‚ã«ã‚‚é‡è¦ã§ã™ã€‚

### å®Ÿç”¨çš„ãªæ³¨æ„ç‚¹

- **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: `setActive(_:)` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€try-catchæ–‡ã§é©åˆ‡ã«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¡Œã†ã“ã¨ãŒé‡è¦ã§ã™ã€‚ç‰¹ã«ã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹éš›ã«ã¯ã€ä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚„ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚»ã‚¹ã¨ã®ç«¶åˆã«ã‚ˆã£ã¦ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
- **éåŒæœŸå‡¦ç†ã®è€ƒæ…®**: ç‰¹ã«éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã™ã‚‹éš›ã€ã‚·ã‚¹ãƒ†ãƒ ãŒã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒªã‚½ãƒ¼ã‚¹ã‚’ç¢ºå®Ÿã«è§£æ”¾ã™ã‚‹ã¾ã§æ™‚é–“ãŒã‹ã‹ã‚‹ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€éåŒæœŸçš„ã«å‡¦ç†ã‚’è¡Œã†ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€UIã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ãªãã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒå¿œç­”æ€§ã‚’ä¿ã¤ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã®ã‚ˆã†ã«ã€`AVAudioSession`ã®`setActive(_:)`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¢ãƒ—ãƒªã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 20:14:16*

å‡¦ç†ã®é–‹å§‹ã¨çµ‚äº†ã‚’ç®¡ç†ã™ã‚‹ä¸Šã§ä¸­å¿ƒçš„ãªå½¹å‰²ã‚’æœãŸã—ã¦ãŠã‚Šã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒªã‚½ãƒ¼ã‚¹ã®åŠ¹ç‡çš„ãªä½¿ç”¨ã¨ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ã®é©åˆ‡ãªç®¡ç†ã«å¯„ä¸ã—ã¦ã„ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/05/09 20:14:32*

ãŸã¨ãˆã°Apple Musicå†ç”Ÿä¸­ã«ãƒ¬ã‚³ãƒ¼ãƒ‰ãƒ‡ã‚£ãƒ³ã‚°ã‚’é–‹å§‹ã—ãŸã¨ã—ã¦ã€ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚ã‚ã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãã‚Œã‚’å†é–‹ã•ã›ãŸã„å ´åˆã¯ã©ã†ã™ã‚Œã°ã„ã„ã®ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/05/09 20:15:21*

Apple Musicãªã©ã®ä»–ã®ã‚¢ãƒ—ãƒªãŒå†ç”Ÿä¸­ã®éŸ³æ¥½ã‚’ä¸€æ™‚åœæ­¢ã—ã¦ã‹ã‚‰ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’é–‹å§‹ã—ã€ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒçµ‚äº†ã—ãŸå¾Œã«éŸ³æ¥½ã‚’å†é–‹ã•ã›ã‚‹æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã«ã¯ã€`AVAudioSession`ã®ã‚«ãƒ†ã‚´ãƒªãƒ¼ã¨ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®šãŒé‡è¦ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€é©åˆ‡ãªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### ã‚¹ãƒ†ãƒƒãƒ—1: ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®è¨­å®š
ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹å‰ã«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚«ãƒ†ã‚´ãƒªã‚’è¨­å®šã—ã¾ã™ã€‚`AVAudioSessionCategoryPlayAndRecord`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€éŒ²éŸ³ã¨ä»–ã®ã‚¢ãƒ—ãƒªã®éŸ³å£°å†ç”Ÿã®å…±å­˜ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€`AVAudioSessionModeDefault`ã¾ãŸã¯`AVAudioSessionModeSpokenAudio`ãªã©ã®ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã«ä»–ã®éŸ³å£°ãŒã©ã®ã‚ˆã†ã«æ‰±ã‚ã‚Œã‚‹ã‹ã‚’åˆ¶å¾¡ã§ãã¾ã™ã€‚

### ã‚¹ãƒ†ãƒƒãƒ—2: ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å‰²ã‚Šè¾¼ã¿é€šçŸ¥ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
ä»–ã®ã‚¢ãƒ—ãƒªï¼ˆä¾‹ãˆã°Apple Musicï¼‰ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå†ç”Ÿã‚’é©åˆ‡ã«ç®¡ç†ã™ã‚‹ãŸã‚ã«ã¯ã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å‰²ã‚Šè¾¼ã¿ã‚’æ¤œçŸ¥ã—ã¦é©åˆ‡ã«å¯¾å¿œã™ã‚‹ãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```swift
NotificationCenter.default.addObserver(
    self,
    selector: #selector(handleAudioSessionInterruption),
    name: AVAudioSession.interruptionNotification,
    object: nil
)

@objc func handleAudioSessionInterruption(notification: Notification) {
    guard let userInfo = notification.userInfo,
          let typeValue = userInfo[AVAudioSessionInterruptionTypeKey] as? UInt,
          let type = AVAudioSession.InterruptionType(rawValue: typeValue) else {
              return
    }

    if type == .began {
        // å‰²ã‚Šè¾¼ã¿é–‹å§‹æ™‚ã®å‡¦ç†ï¼ˆä¾‹ãˆã°ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ä¸€æ™‚åœæ­¢ï¼‰
    } else if type == .ended {
        if let optionsValue = userInfo[AVAudioSessionInterruptionOptionKey] as? UInt {
            let options = AVAudioSession.InterruptionOptions(rawValue: optionsValue)
            if options.contains(.shouldResume) {
                // å‰²ã‚Šè¾¼ã¿çµ‚äº†å¾Œã€ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®å†é–‹ãŒå¯èƒ½ãªå ´åˆ
                // ã“ã“ã§éŸ³æ¥½å†ç”Ÿã‚’å†é–‹ã•ã›ã‚‹
            }
        }
    }
}
```

### ã‚¹ãƒ†ãƒƒãƒ—3: ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†å¾Œã®å‡¦ç†
ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒçµ‚äº†ã—ãŸæ™‚ç‚¹ã§ã€`AVAudioSession`ã®`setActive(false)`ã‚’å‘¼ã³å‡ºã™å‰ã«ã€å‰²ã‚Šè¾¼ã‚“ã ä»–ã®ã‚¢ãƒ—ãƒªãŒéŸ³æ¥½å†ç”Ÿã‚’å†é–‹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãŸã ã—ã€ã“ã‚Œã¯ä»–ã®ã‚¢ãƒ—ãƒªã®æŒ™å‹•ã«ã‚‚ä¾å­˜ã™ã‚‹ãŸã‚ã€ä¿è¨¼ã¯ã§ãã¾ã›ã‚“ã€‚

### æ³¨æ„ç‚¹
- ä¸Šè¨˜ã®å‡¦ç†ã¯ã€ã‚¢ãƒ—ãƒªãŒãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«ã‚ã‚‹å ´åˆã‚„ç‰¹å®šã®è¨­å®šï¼ˆã‚µã‚¤ãƒ¬ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ç­‰ï¼‰ãŒå½±éŸ¿ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
- Appleã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœŸå¾…ã«åˆã‚ã›ã¦ã€é©åˆ‡ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’æä¾›ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

ã“ã‚Œã‚‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã«å¾“ã†ã“ã¨ã§ã€ä»–ã®ã‚¢ãƒ—ãƒªã¨ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é©åˆ‡ã«ç®¡ç†ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---
