# Monorepo リリース管理ツール比較

日付: 2025-06-02

---

## 👤 ユーザー
*2025/06/03 01:16:05*

この辺のライブラリの比較をして欲しい。
今、monorepoで、非公開であるでwebアプリとサーバーサイドのAPIを開発していて、タグの自動生成や、リリースノートの自動生成や、changelogの自動生成やバージョンの管理を行いたい。

すでに、Conventional Commitsにはコミットメッセージは準拠させてある。

1. **semantic-release**
2. **release-it**
3. **changelogen**
4. **release-please**

どれが最適か？

---

## 🤖 アシスタント
*2025/06/03 01:16:17*

ありがとうございます、具体的な状況はよくわかりました。
さらに適切な比較を行うために、以下の点について教えていただけますか？

1. モノレポはどのような構成ですか？（例：複数のnpmパッケージ、frontend/backendディレクトリなど）
2. バージョン管理はパッケージごとに個別に行いたいか、全体で一括か？
3. 実行環境：GitHub Actions、GitLab CIなど、使っているCI/CD環境はありますか？
4. changelogやリリースノートは、どのようなフォーマット・出力先を想定していますか？（例：Markdownファイルに出力、GitHub Releasesなど）
5. それぞれのツールで、すでに試したもの・気になっている懸念点があれば教えてください。

---

## 👤 ユーザー
*2025/06/03 01:17:40*

pnpmで packageにしている。基本的に全部node.jsである。今後はモバイルとかも増えてきそう（リアクトネイティブ）。
バージョン管理は個別で行いたい
GitHub Actions
Markdownファイルに出力、GitHub Releasesの両方である。

---

## 🤖 アシスタント
*2025/06/03 01:17:48*

了解しました。pnpmで構成されたモノレポで、パッケージごとにバージョン管理を行い、GitHub Actionsを使って、Markdownでのchangelog生成とGitHub Releasesの両方に対応したリリース管理をしたいということですね。

これらの要件に基づいて、semantic-release、release-it、changelogen、release-pleaseの4つのライブラリについて、モノレポ対応、Conventional Commits互換性、個別バージョン管理、changelog出力、GitHubリリース対応、GitHub Actionsとの統合の観点で比較し、最適な選択肢を提案します。

調査結果をまとめてご報告しますので、しばらくお待ちください。

---

## 🤖 アシスタント
*2025/06/03 01:17:42*

{
  "task_violates_safety_guidelines": false,
  "user_def_doesnt_want_research": false,
  "response": "了解しました。pnpmで構成されたモノレポで、パッケージごとにバージョン管理を行い、GitHub Actionsを使って、Markdownでのchangelog生成とGitHub Releasesの両方に対応したリリース管理をしたいということですね。\n\nこれらの要件に基づいて、semantic-release、release-it、changelogen、release-pleaseの4つのライブラリについて、モノレポ対応、Conventional Commits互換性、個別バージョン管理、changelog出力、GitHubリリース対応、GitHub Actionsとの統合の観点で比較し、最適な選択肢を提案します。\n\n調査結果をまとめてご報告しますので、しばらくお待ちください。",
  "title": "Monorepo環境でのリリース管理ツールの比較",
  "prompt": "pnpmで構成されたモノレポで、各パッケージがNode.jsベース（将来的にReact Native等モバイル対応も含む）であり、Conventional Commitsに準拠したコミットメッセージを採用しているプロジェクトにおいて、以下の4つのリリース管理ツールについて比較検討する：\n\n1. semantic-release\n2. release-it\n3. changelogen\n4. release-please\n\n比較の観点：\n- モノレポ対応（pnpmワークスペース前提）\n- パッケージごとの個別バージョン管理が可能か\n- Conventional Commits互換性\n- changelogのMarkdown出力とGitHub Releasesの両対応\n- GitHub Actionsとの統合のしやすさ\n\n上記の観点で各ツールの特徴・メリット・デメリットを比較した上で、このプロジェクトに最適な選択肢を提案すること。可能であれば、各ツールの公式ドキュメントや事例も併記する。"
}

---

## 🤖 アシスタント
*2025/06/03 01:24:52*

# pnpmモノレポ向けリリース管理ツールの比較検討

pnpmワークスペースで構成されたNode.jsモノレポ（将来はReact Nativeなどモバイルも含む）において、コミットメッセージ規約に**Conventional Commits**を採用しているプロジェクトのため、以下4つのリリース管理ツールを主要ポイントごとに比較します。また各ツールの特徴・メリット・デメリットを整理し、このプロジェクトに最適な選択肢を提案します。

- **比較観点**: 
  - モノレポ対応状況（pnpmワークスペースでの利用可否）  
  - パッケージ個別のバージョン管理が可能か  
  - Conventional Commits互換性（コミットメッセージからの自動解析）  
  - CHANGELOGのMarkdown出力とGitHub Releases対応  
  - GitHub Actionsとの統合の容易さ（CIでの自動化）  

## semantic-release

- **モノレポ対応**: *公式にはモノレポを直接サポートしていません*。コミュニティ製プラグインの **semantic-release-monorepo** を使うことでモノレポ内の複数パッケージに対応可能です【39†L133-L142】。この拡張では、コミットで変更されたファイルパスに基づき該当パッケージを判定し、パッケージごとにリリースを実行します。一つのコミットが複数パッケージに属することもあり、その場合各パッケージに対し個別にリリースが行われ、Gitタグも `<package-name>-<version>` 形式で名前空間付きで付与されます【27†L42-L50】。※ただしこのプラグインは非公式で更新も止まっている点に留意が必要です【39†L133-L142】。

- **個別パッケージのバージョン管理**: 上記プラグインを用いることで**各パッケージ独立のバージョン管理**が可能です。モノレポ内の各`package.json`でバージョンを分け、変更のあったパッケージだけ自動でバージョンを更新できます。コミットに基づき影響のあるパッケージを判断するため、不要なバージョンアップは行われません【27†L42-L50】。複数パッケージを同時に変更したコミットは、それぞれのパッケージのリリースをまとめてトリガーします。内部依存の解決についても、multi-semantic-release等のツールではローカル依存バージョンをリリース時に書き換える機能があります【1†L285-L293】（依存関係の`package.json`に新バージョンを反映することで、モノレポ内依存のバージョンずれを防止）。

- **Conventional Commits互換**: **Conventional Commits形式のメッセージを前提**としており、コミットメッセージから変更の種類（feat, fix, BREAKING CHANGE等）を解析して次のセマンティックバージョンを自動決定します【38†L344-L352】。デフォルトではAngularスタイルのコミット規約を使用しますが、設定によりプリセットを変更可能です【38†L344-L352】。コミットメッセージに基づき、`feat`ならマイナーバージョン、`fix`ならパッチバージョン、`BREAKING CHANGE`ならメジャーバージョンといったリリース種別を厳密に判定します【38†L359-L367】。このように**コミット履歴を機械的に解釈してリリースを管理**する設計になっています。

- **CHANGELOG出力とGitHub Releases**: **リリースノート（変更履歴）をMarkdownで自動生成**し、リポジトリにCHANGELOGファイルとして出力したり、GitHubのReleaseノートとして公開したりできます【38†L344-L351】。semantic-release本体では、コミットから生成したリリースノートをGitHub Releaseに投稿するプラグイン（@semantic-release/github）や、CHANGELOG.mdファイルを更新するプラグイン（@semantic-release/changelog）等が用意されています。これらを組み合わせることで、**リリース時にCHANGELOG.mdを更新コミットしつつGitHub上にもリリース情報を残す**ことが可能です。実際、semantic-releaseは「次のバージョン番号の決定・リリースノート生成・パッケージ公開」を含むワークフロー全体を自動化します【38†L313-L321】【38†L342-L351】。

- **GitHub Actions統合**: **CI環境での自動実行**を前提として設計されており、主ブランチへのコミットを検知してCI上で`semantic-release`を走らせる運用が一般的です【38†L371-L378】。GitHub Actions用の公式またはサードパーティ製Actionも存在し（例: cycjimmy/semantic-release-action【20†L5-L13】）、比較的容易にワークフローへ組み込めます。例えばActionsのジョブ内で `npx semantic-release` を実行し、適切なGitHubトークンやNPMトークンを渡せば、自動でバージョン更新・タグ付与・GitHub Release作成・（必要に応じて）npm公開まで行われます。**注意点**として、モノレポで複数パッケージに対してsemantic-releaseを走らせる場合は、各パッケージフォルダごとに上記プロセスをシリアルに実行する仕組みを自前で用意する必要があります（例えばpnpmのワークスペースコマンドで各パッケージに対して `semantic-release` を順次実行するなど）。その設定・スクリプトの作り込みがやや複雑になる点がデメリットです。

- **メリット・デメリットまとめ**: semantic-releaseは完全自動化された成熟度の高いツールで、コミットさえ規約通りなら人手を介さずリリースプロセスを進められるのが大きなメリットです【38†L313-L321】。一方で、**モノレポ対応が公式サポート外**であるため設定が煩雑になりがちで、コミュニティプラグイン頼りになる点はリスク・デメリットです【39†L133-L142】。チーム規模が大きくリリースプロセスを徹底自動化したい場合には強力ですが、現状のsemantic-release-monorepoプラグインは更新が止まっていることもあり、モノレポプロジェクトでは導入ハードルが高めです。

## release-it

- **モノレポ対応**: release-itはシングルパッケージ向けが基本ですが、**モノレポ構成にも柔軟に対応可能**です。各パッケージごとに設定ファイル（例: `.release-it.json`や`.release-it.js`）を用意し、CIやワークスペースコマンドで各パッケージに対して順番にrelease-itを実行することで、それぞれのパッケージを個別にリリースできます【41†L164-L168】。実際、モノレポ+release-itの設定方法についてはコミュニティからのテンプレートやサンプルが提供されており、比較的簡単に設定できます【41†L156-L163】。例えば「全パッケージでバージョン同期（すべて同じバージョン）で運用する場合はルートに1つの設定ファイルを置く」「パッケージごとに独立バージョンで運用する場合は各パッケージに個別の設定ファイルを置く」といった実例が公式リポジトリで紹介されています【41†L162-L168】。したがって、**pnpmワークスペースにおいてもrelease-itを利用したモノレポリリースは十分実現可能**です（必要に応じて自動で依存関係バージョンを更新する仕組みも、後述のプラグインでサポートされています）。

- **個別パッケージのバージョン管理**: release-itは基本的に単一パッケージのバージョンを管理するCLIですが、モノレポで**各パッケージごとに独立したバージョンを管理することも可能**です【41†L164-L168】。前述のようにパッケージごとに設定と実行を分けることで、変更のあったパッケージだけをリリースする運用ができます。依存関係については、公式プラグインの **@release-it/bumper** を使うことで「内部依存バージョンの自動書き換え」が可能です。例えばあるパッケージAが別のパッケージBに依存しており、Bの新バージョンリリース時にAの`package.json`内のBのバージョン範囲を自動更新するといった処理も設定できます【32†L9-L17】。もっとも簡潔な方法はモノレポ内の内部依存を`"*"`などワイルドカードにしておき、release-it実行時に適切にバージョンを書き込むアプローチで、Mediumの事例でもそのような手法が紹介されています【1†L285-L293】。

- **Conventional Commits互換**: release-it自体はコミットメッセージ規約に縛られない汎用ツールですが、**プラグインを追加することでConventional Commitsに対応**できます。公式プラグインの`@release-it/conventional-changelog`を導入すれば、コミットメッセージから変更タイプを解析して推奨される次バージョン（メジャー/マイナー/パッチ）を自動判定できます【36†L449-L457】。実際、release-itはプラグインによって現在のプロジェクトの最新バージョン取得や次バージョンの計算ロジックをカスタム可能で、Conventional Commitsプラグインはコミットログから**セマンティックリリースと同等の自動バージョン判定**を提供します【36†L449-L457】。コミットメッセージ規約の遵守は別途コミットリンター（commitlint等）で保証しつつ、release-itでそれを活用してバージョン管理することができます。

- **CHANGELOG出力とGitHub Releases**: release-itは**CHANGELOGの自動生成**および**GitHub Releasesの作成**をサポートしています。前述のConventional Changelogプラグインを利用することで、コミットから生成した変更履歴をCHANGELOG.mdファイルに追記することができます（設定で`infile: 'CHANGELOG.md'`を指定）【22†L199-L207】。さらに、GitHubリリースについてもrelease-itが直接GitHub APIを呼び出してタグに対応するReleaseノートを作成可能です【36†L464-L472】。設定で`github.release: true`を有効にし、リポジトリのGITHUB_TOKENをCI環境で使えば、**バージョンタグの作成と同時にGitHub上にリリース情報を投稿**できます【22†L219-L223】【36†L462-L470】。実例として、Valtech社のモノレポ事例では各パッケージごとにCHANGELOG.mdを更新し、その変更を含むタグ付きコミットをプッシュするよう構成されています【22†L225-L232】。

- **GitHub Actions統合**: release-itは対話型/自動の両モードがありますが、CI環境では`--ci`フラグにより全自動で動作します【36†L423-L431】。**GitHub Actionsからはnpmスクリプトまたはnpxコマンドで実行するだけで利用可能**です。例えば各パッケージのテストやビルド後に`release-it --ci`を実行するジョブを配置すれば、自動でバージョン更新コミット・タグ付与・（設定していれば）GitHub Release作成・npm公開まで行われます。公式専用のActionはありませんが、そのシンプルさゆえにYAML内でコマンドを呼ぶだけで十分です。前述のプラグインもnpm経由で導入しておけば、自動でCHANGELOG生成や内部バージョン書換えも含めて実行できます。**注意点**としては、モノレポの場合どの順序で各パッケージをリリースするか（依存関係がある場合、依存元より先に依存先をリリースする必要がある等）を自分で考慮しジョブを組む必要があります。しかしpnpmの場合、`pnpm -r exec`でワークスペースをトップロジカル順（依存順）に実行することも可能であり、その機能を使って順序制御もできます。

- **メリット・デメリットまとめ**: release-itのメリットは**設定と運用の柔軟性**です。Node.jsに限らずどんなプロジェクトでも使える汎用ツールでありながら、プラグインによりConventional Commits対応や複数ファイルのバージョン書換えなど必要十分な機能を備えています【41†L150-L158】。モノレポでも事例が多く、設定テンプレートも共有されているため導入しやすいでしょう【41†L156-L163】。加えて、semantic-releaseほどの**学習コストが高くなく**、小〜中規模プロジェクトには「シンプルで必要十分」な点も評価できます【21†L188-L192】【41†L201-L207】。デメリットとしては、完全に自動でリリースを回すというより**自分たちでスクリプトやワークフローを組み上げる必要**がある点です（逆に言えば自由度が高い）。またコミットメッセージからの自動判定もプラグイン任せであるため、semantic-releaseほど統合された体験ではありません。しかし裏を返せば、チームやリポジトリの要件に合わせて細かく挙動をカスタムできるため、「簡潔さと柔軟さ」のバランスが取れたツールと言えます【21†L188-L192】。

## changelogen

- **モノレポ対応**: **changelogen（アンジェス/UnJS製）**は主に単一プロジェクトのCHANGELOG生成に特化したツールです。モノレポ内で複数パッケージに対して利用する場合、公式には特別なサポートはありません。運用上は**各パッケージフォルダごとにchangelogenを実行し、それぞれのCHANGELOG.mdを生成・更新する**形になります。例えばpnpmワークスペースの各パッケージディレクトリに移動して `npx changelogen --release` を実行すれば、そのパッケージの直近タグからの変更履歴をまとめてCHANGELOGに追記し、`package.json`のバージョンも上げて、コミットとタグを作成する…といった処理を行えます【9†L39-L47】。しかし、**どのパッケージに変更があったかを自動で検知してくれる仕組みはない**ため、リポジトリ全体のGitログから対象パッケージを判断するロジックは独自に用意する必要があります（例えばコミットメッセージのスコープにパッケージ名を含め、その情報を基にスクリプトで各パッケージのchangelogen実行有無を決定する等）。モノレポ全体で一つのCHANGELOGにまとめる用途には向いておらず、**基本的には1パッケージ＝1CHANGELOG運用**になります。なお、非公式ながら`changelogen-monorepo`というパッケージも公開されています【11†L177-L181】が、公式ドキュメント上でモノレポ対応が前面に出ているわけではありません。

- **個別パッケージのバージョン管理**: changelogen自体はバージョンの昇格（バンプ）やタグ付けも行えますが、**複数パッケージ間でのバージョン管理連携機能はありません**。したがって、独立バージョン運用の場合は各パッケージで個別にchangelogenを使えばよく、結果としてパッケージ単位のバージョン管理が実現できます。changelogenは`--bump`オプションで`package.json`内のバージョンを更新し、`--release`オプションでCHANGELOG.mdの更新とgitコミット・タグ作成まで自動化します【9†L43-L51】。つまり、単一パッケージ内で完結する範囲では**バージョン管理から履歴生成・コミット/tag作成まで自動**で行えます。ただしモノレポで複数パッケージを一括リリースするような使い方には向いていないため、運用としては「各パッケージがそれぞれ独立にchangelogenでリリース処理を行う」形になります。内部依存のバージョン更新も自動では行われないため、必要なら別途スクリプト等でフォローする必要があります。

- **Conventional Commits互換**: **コミットメッセージの種類に基づき美しいCHANGELOGを生成**することを目的としたツールで、Conventional Commitsを前提として設計されています【9†L35-L43】。コミットの一覧から`feat`, `fix`, `perf`といった種別ごとにエントリを分類し、人間が読みやすいMarkdown形式の変更履歴を作ります。「Conventional Commits」仕様に従ったメッセージであれば、Changelogenがその内容（追加機能なのかバグ修正なのか等）を解釈し、CHANGELOG.md内でカテゴリ別のセクションを作成してくれます。例えばコミットに`feat: 新機能説明...`とあれば**新機能**の項目に追加し、`fix: 不具合説明...`なら**バグ修正**の項目に追加するといった具合です（出力レイアウトはデフォルトで用意されていますが、テンプレートを調整することも可能です）。このように、**コミットメッセージさえ規則に沿っていれば高品質なCHANGELOGを自動生成**できる点が特徴です【9†L35-L43】。

- **CHANGELOG出力とGitHub Releases**: changelogenは**Markdown形式のCHANGELOG.mdファイル**を生成・更新するのが主目的ですが、**GitHub Releasesとの連携機能も内蔵**しています。具体的には、`changelogen gh release`コマンドを使うと既存のCHANGELOG.mdからGitHubのReleaseに内容を同期（作成・更新）できます【30†L359-L367】。このコマンドはローカルまたはリモートリポジトリ内のCHANGELOG.mdを解析し、まだReleaseとして公開されていないバージョンのセクションを読み取って、新規にGitHub Releaseを作成してくれます【30†L359-L367】。環境変数`GITHUB_TOKEN`（または`CHANGELOGEN_TOKENS_GITHUB`）を設定しておけば、CI上でも自動でRelease作成まで完了可能です【30†L373-L381】。したがって、changelogenでCHANGELOG.mdを更新→その内容をGitHub Releaseに反映、といった一連の流れも自動化できます。**注意点**として、Releaseノート同期は明示的にコマンドを実行しないと行われないため、例えばActionsの中で`changelogen --release && changelogen gh release`のように2段階で実行する必要があります。また、CHANGELOG.md自体のデザインやセクション配置が洗練されている一方、カスタマイズしたい場合はテンプレートを用いた設定が必要になります。

- **GitHub Actions統合**: changelogenはシンプルなCLIツールであり、**Actionsから直接コマンドを呼び出して使用できます**。例えばPush時に特定のパッケージディレクトリに移動して`changelogen --release --dir ./packages/foo`を実行すると、そのパッケージのCHANGELOG更新とバージョンタグ付与を自動で行わせることができます。複数パッケージに対しては、ワークフロー上でループ処理を実装するか、あるいはMatrix戦略で各パッケージ名を渡して並列実行する方法などが考えられます。**公式のActionsテンプレートやBot等はありません**が、changelogen自身が単機能で副作用も少ないため、既存のCIに組み込みやすいでしょう。注意点は前述した通り、**モノレポ全体での自動検知機構がない**ため「どのパッケージをリリースするか」の判定は自前で行う必要があることです。例えば、monorepoの場合コミットメッセージのスコープを`foo: ...`（パッケージ名）とする運用にしておき、Actions内で「直近のコミットにパッケージfooへの変更が含まれるならfooのリリース処理を実行」するといったロジックを書く必要があります。このように**手動の工夫が必要な分、自由度はありますが自動化の手間は他ツールより大きい**です。

- **メリット・デメリットまとめ**: changelogenのメリットは、**Conventional Commitsに準拠した非常に読みやすいCHANGELOGを生成できる**点です。Nuxtコミュニティが開発している背景もあり、多くのOSSで使われる変更履歴スタイルに倣った美しいフォーマットで、プロジェクトのリリースノートを残せます。また、軽量なため既存プロジェクトにも導入しやすく、ローカルで試しながら調整できる点も利点です。しかしデメリットとして、**あくまでCHANGELOGジェネレータ寄りのツール**であり、semantic-releaseやrelease-itのような包括的な「リリースパイプライン自動化」機能は持ちません。モノレポ運用では追加スクリプトが不可欠で、特に多数のパッケージがある場合は運用コストが高くなるでしょう。GitHub Actions等との連携も他ツールに比べれば手作業の比重が大きいため、プロジェクトの規模や求める自動化レベルによっては補助的な役割に留まる可能性があります。

## release-please

- **モノレポ対応**: **release-please**はGoogleが開発している自動リリースツールで、**初めからモノレポ（単一リポジトリ内の複数パッケージ）を正式にサポート**しています【18†L607-L610】。設定ファイル（`.release-please-config.json`や`.release-please-manifest.json`）にモノレポ内の各パッケージ情報を記載することで、**1つのリポジトリから複数のライブラリを独立にバージョン管理・リリース可能**です【18†L607-L610】。例えばmanifestには各パッケージフォルダパスと現在のバージョンをマッピングしておき、release-pleaseはそれを基準にして変更検知・バージョン更新を行います。pnpmワークスペース環境でも問題なく動作し、実際にrelease-please-action（後述）を使ってpnpmモノレポを運用している事例もあります【25†L54-L60】。「manifest-driven」（manifestファイル駆動）という方式により、一度セットアップしてしまえば新規パッケージの追加やバージョンの管理が一元化され、モノレポの複雑な依存関係にも対応できるのが特徴です。内部依存バージョンの更新にも対応しており、たとえばパッケージAのリリース時に同じリポジトリ内でAに依存するパッケージBの依存バージョンを自動で書き換える機能も備わっています（manifestファイルで各パッケージの関係を定義することで、相互にバージョンを参照し合う）【32†L0-L8】。

- **個別パッケージのバージョン管理**: release-pleaseではモノレポ内の**各パッケージが独立したバージョン系列**を持ちます。例えばパッケージXがv1.2.3、パッケージYがv5.0.0というように、リポジトリ内で統一ではなくパッケージ単位でSemantic Versioningが適用されます。このため、片方のパッケージに変更がなければそのバージョンは上がらず、もう片方だけリリースされるという動きになります。release-pleaseは各パッケージごとに直近リリース時のGitタグ（例えば`X-v1.2.3`や`Y-v5.0.0`）を追跡し、それ以降にそのパッケージに関連するコミットがあれば新バージョンを提案します。**パッケージ間の依存**については、前述のmanifest設定によりAがBに依存している場合にBのリリース後、Aにもリリース（または依存バージョン上げ）を促すような挙動をさせることも可能です。基本的には、release-pleaseが各パッケージのCHANGELOGとバージョンを独立に管理してくれるため、モノレポでありながら**複数のnpmパッケージを別々に運用するケースに適しています**。

- **Conventional Commits互換**: release-pleaseも**Conventional Commitsに従ったコミットメッセージを解析**して変更点を分類・集計します【16†L369-L377】。具体的には、Gitのコミット履歴を見て`feat:`や`fix:`などのプレフィックスを検出し、各パッケージにおける次のリリース内容を組み立てます。コミットメッセージから**自動でセマンティックバージョンバンプを判断**する点はsemantic-release等と同様で、例えば`feat`が含まれていればマイナーバージョン、`fix`のみならパッチバージョン、`BREAKING CHANGE`があればメジャーバージョンアップとしてRelease PR（後述）に反映されます【16†L369-L377】【45†L415-L423】。コミットの粒度が細かすぎる場合に備えて、Release PRに含めるコミットメッセージはSquash Merge運用で整理することも推奨されています【45†L421-L430】（複数の修正コミットがあっても、一つの機能追加としてまとめるなど）。いずれにせよ、**Conventional Commitsスタイルで運用しているプロジェクトとの親和性は非常に高いツール**です。

- **CHANGELOG出力とGitHub Releases**: release-please最大の特徴は、**リリース内容を提案するPull Request（Release PR）を自動生成**する点です【16†L379-L387】。例えばGitHub Actions上でrelease-pleaseを実行すると、まだリリースされていない変更点をまとめて「chore: release」というタイトルのPRを作ります。このPRには各パッケージのCHANGELOG.md更新差分（追加された機能や修正がMarkdownで記述されたもの）と、各`package.json`のバージョン番号の更新差分が含まれます【45†L389-L397】。PRの中で既にCHANGELOG.mdが更新されているため、コードレビューのように**リリースノートを事前に確認・修正**することもできます。準備ができたらそのPRをマージするだけで、release-pleaseが自動的に以下を行います【45†L389-L397】:

  1. **CHANGELOG.mdの更新** – PRに含まれていた変更履歴が正式に反映されます（各パッケージごとのCHANGELOGがアップデート）。  
  2. **バージョンタグの作成** – マージコミットに対してパッケージごとに新バージョンのGitタグが付与されます（例: `X-v1.3.0`など）【45†L391-L394】。  
  3. **GitHub Releaseの作成** – 上記タグに基づいて、対応するGitHub Releaseエントリが自動公開されます【45†L391-L395】。Releaseノートの内容もCHANGELOGから取得されて反映されます。

  こうした一連の流れにより、**Pull Requestをマージする操作自体がリリース作業**となり、人が直接タグやリリースノートを書く必要はありません。また、Release PRにはラベル（`autorelease: pending`や`autorelease: tagged`など）が付与され、現在の状態（まだマージされていない、タグ付け済み、公開済み等）が分かるようになっています【45†L399-L407】。なお、release-please自体はパッケージの公開（npm publish）は行わない設計ですが、GitHub Actionsのワークフローを工夫して「Release PRマージ後にnpm publishジョブを走らせる」ことも可能です。公式ドキュメントでもrelease-pleaseによるCHANGELOG/Release生成と、npm公開など他のパイプラインと組み合わせて使うことが想定されています【25†L54-L60】。

- **GitHub Actions統合**: release-pleaseは**GitHub公式のActionが提供**されており、非常にスムーズにCIへ統合できます。公式の**Release Please Action**（google-github-actions/release-please-action）は、リポジトリへのプッシュをトリガーに自動でRelease PRを更新・作成するもので、設定ファイルを用意しワークフローに組み込むだけで利用可能です【43†L54-L62】。このActionを導入すると、**新たなコミットが積まれるたびにcommit履歴を解析し、必要なバージョン更新やCHANGELOGの追記を行ったPRが自動生成される**ようになります【43†L60-L68】。あとはメンテナーがそのPRをチェックしてマージするだけで、前述のとおりタグ作成とRelease公開まで自動で完了します【43†L54-L62】。モノレポにも対応しており、設定ファイルに複数パッケージを記述すれば一度のWorkflowで各パッケージのRelease PRをまとめて管理できます【25†L54-L60】。**つまり、GitHub Actionsとの親和性が非常に高く、最も省力的に運用できるツールの一つ**です。加えて、Release PR方式により人間が内容を確認するフェーズを挟めるため、「すべて自動」は怖いが手作業も減らしたいというニーズに合致します。

- **メリット・デメリットまとめ**: release-pleaseのメリットは、何と言っても**モノレポ対応の手厚さとGitHubプラットフォームとの統合**です。複数パッケージのバージョン管理・CHANGELOG管理を単一の仕組みで完結でき、公式Actionによりセットアップも容易です【43†L54-L62】。また、Conventional Commits準拠の開発フローとの相性が良く、既存コミットから自動でリリースノートを生成してくれるため、現在Conventional Commitsを運用している本プロジェクトには理想的にマッチします。一方のデメリットは、npm公開などについては別途設定が必要な点、およびRelease PRを経由するプロセスに馴染むまで時間がかかる可能性がある点です。Release PR方式ではリリースが即時反映されず、一度PRを作成・マージするワンクッションが発生します（CI/CDの考え方としてはメリットですが、リアルタイム性は若干落ちます）。しかしこの点は運用上大きな問題ではなく、むしろリリース内容を事前にチェックできる利点とも捉えられます。総じて、**モノレポのリリース管理に必要な要件を網羅しつつ自動化レベルも高い優れたツール**と言えるでしょう。

## 比較まとめと推奨ツール

上述の比較結果を踏まえると、各ツールの対応状況は次のように整理できます。

- **モノレポ対応**: semantic-releaseは非公式プラグインで対応可能だが設定が複雑。release-itは手動設定が必要だが柔軟に対応可能。changelogenは専用機能なし（要スクリプト対応）。release-pleaseは公式にモノレポ対応しており設定も比較的容易【18†L607-L610】。  
- **個別バージョン管理**: いずれのツールも独立バージョン運用自体は可能（semantic-releaseとrelease-pleaseは名前空間付きタグで完全自動、release-itとchangelogenは運用次第）。release-pleaseはmanifestで各パッケージを明示管理するため特に安心感がある。  
- **Conventional Commits互換**: semantic-releaseとrelease-pleaseはネイティブに対応【38†L344-L352】【16†L369-L377】。release-itもプラグインで対応【36†L449-L457】。changelogenはツール自体がそれ専用【9†L35-L43】。全ツール問題なく適合。  
- **CHANGELOGとGitHub Release**: semantic-releaseとrelease-it、release-pleaseはGitHub Releaseの自動生成に対応（semantic-release/release-itはCHANGELOG.md更新に追加設定要、release-pleaseはRelease PR経由）【45†L389-L397】。changelogenはCHANGELOG.md出力が主だがGH Release同期も可能【30†L359-L367】。  
- **GitHub Actions統合**: semantic-releaseとrelease-itはコマンド実行で対応（semantic-releaseは公式Actionあり）【20†L5-L13】。changelogenは自前スクリプトで対応。release-pleaseは公式Actionが提供されセットアップ容易【43†L54-L62】。  

以上を総合すると、**本プロジェクトには release-please を採用するのが最も適切**と考えられます。特にモノレポ内の複数パッケージを**個別に管理しつつ完全自動化**したい場合、release-pleaseは公式にサポートがあり実績も豊富だからです。GitHub Actionsと組み合わせれば、コミットメッセージさえ規約通りならあとは自動でPR作成・CHANGELOG更新・リリースまで進むため、開発フローに無理なく組み込めます【43†L60-L68】【45†L389-L397】。Conventional Commitsを既に運用している点も、release-pleaseの想定する前提と合致しており効果的です【16†L369-L377】。  

次点の選択肢は**release-it**です。プロジェクト規模や運用ポリシーによっては、release-itのシンプルさと柔軟性を好むチームもいるでしょう【21†L188-L192】。例えば「リリース作業をPull Request経由にしたくない」「もっと手動でコントロールしたい」という場合には、release-it＋Conventional Changelogプラグインの組み合わせが有力です。実際、中小規模のモノレポではrelease-it採用例も多く、設定も理解しやすいという利点があります【41†L201-L207】。  

しかしながら、モノレポかつConventional Commitsという本プロジェクトの条件下では、やはり**release-pleaseの包括的な自動化とモノレポ対応が大きなメリット**になります。semantic-releaseは機能豊富ですがモノレポへの適用にハードルがあり、changelogenはCHANGELOG生成専用ツールの域を出ないため、用途適合性で劣ります。したがって、最終的な提案としては **「release-please＋GitHub Actions」による自動リリース体制** を構築することをおすすめします。これにより、pnpmモノレポ環境でも各パッケージのバージョンアップとリリースノート作成を効率良く運用できるでしょう【43†L54-L62】【45†L389-L397】。

**参考資料・事例**: 設定方法や詳細な挙動については各公式ドキュメントを参照してください（semantic-release公式README【38†L342-L351】、semantic-release-monorepo README【27†L42-L50】、release-it公式README【36†L449-L457】、Valtechによるモノレポ×release-it事例【21†L188-L192】、changelogen README【9†L35-L43】、release-please公式README【16†L369-L377】およびGoogle提供のrelease-please Action解説【43†L54-L62】など）。特にrelease-pleaseは公式のガイドやMedium記事でもモノレポ対応が紹介されています【25†L54-L60】。以上を踏まえて最適なツールを選定し、プロジェクトのリリース工程を自動化・効率化していってください。

---
