# 制御可能なタイマーを作成

日付: 2023-09-20

---

## 👤 ユーザー
*2023/9/20 16:09:48*

いかのような毎秒秒数をインクリメントして、出力するタイマーがあるが、特定のパブリッシャーを検出して、このタイマーが進む時間を停止したり、再開したりしたい。どうすればいいか？

        var sessionDurationInSeconds = 0
        Timer.publish(every: 1.0, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                sessionDurationInSeconds += 1
                print(sessionDurationInSeconds)
            }
            .store(in: &cancellables)

---

## 🤖 アシスタント
*2023/9/20 16:11:10*

特定のパブリッシャーを使ってタイマーを停止・再開するために、`combineLatest` または `merge` などの Combine のオペレータを使用して、複数のパブリッシャーの出力を組み合わせることができます。

以下は、タイマーの動作を制御する新しいパブリッシャー `controlPublisher` を追加して、タイマーの動作を制御する例です。

1. `controlPublisher` が `true` を送出すると、タイマーが再開します。
2. `controlPublisher` が `false` を送出すると、タイマーが停止します。

```swift
import Combine

class YourClass {
    var sessionDurationInSeconds = 0
    var cancellables: Set<AnyCancellable> = []
    var timerActive: Bool = true // タイマーのアクティブ状態を制御する変数

    let controlPublisher = PassthroughSubject<Bool, Never>() // タイマーの動作を制御するためのパブリッシャー

    func setup() {
        // controlPublisher でタイマーのアクティブ状態を更新
        controlPublisher
            .sink { [weak self] isActive in
                self?.timerActive = isActive
            }
            .store(in: &cancellables)

        Timer.publish(every: 1.0, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                guard let self = self, self.timerActive else { return } // timerActive が true の場合のみカウントアップ
                self.sessionDurationInSeconds += 1
                print(self.sessionDurationInSeconds)
            }
            .store(in: &cancellables)
    }

    func stopTimer() {
        controlPublisher.send(false) // タイマーを停止
    }

    func startTimer() {
        controlPublisher.send(true) // タイマーを再開
    }
}
```

この例では、`YourClass` 内でタイマーを設定し、`setup` メソッドを呼び出してタイマーを開始します。その後、`stopTimer` メソッドや `startTimer` メソッドを使用して、タイマーの動作を停止・再開できます。

---

## 👤 ユーザー
*2023/9/20 16:11:15*

timerActive というグローバルな変数を使用したくないんだ。

---

## 🤖 アシスタント
*2023/9/20 16:12:28*

了解しました。`timerActive`を使わずに、`combineLatest`を使用して2つのパブリッシャーの結果を組み合わせる方法を示します。これにより、制御パブリッシャーの値に基づいてタイマーの動作を直接制御できます。

以下の例では:

1. `controlPublisher` が `true` を送出すると、タイマーが再開します。
2. `controlPublisher` が `false` を送出すると、タイマーが停止します。

```swift
import Combine

class YourClass {
    var sessionDurationInSeconds = 0
    var cancellables: Set<AnyCancellable> = []

    let controlPublisher = CurrentValueSubject<Bool, Never>(true) // タイマーの動作を制御するためのパブリッシャー、初期値としてtrueを設定

    func setup() {
        // タイマーと制御パブリッシャーをcombineLatestを使って組み合わせる
        Timer.publish(every: 1.0, on: .main, in: .common)
            .autoconnect()
            .combineLatest(controlPublisher) { (_, isActive) in isActive }
            .sink { [weak self] isActive in
                guard let self = self, isActive else { return } // isActive が true の場合のみカウントアップ
                self.sessionDurationInSeconds += 1
                print(self.sessionDurationInSeconds)
            }
            .store(in: &cancellables)
    }

    func stopTimer() {
        controlPublisher.send(false) // タイマーを停止
    }

    func startTimer() {
        controlPublisher.send(true) // タイマーを再開
    }
}
```

この方法では、`combineLatest`を使用してタイマーのイベントと`controlPublisher`のイベントを組み合わせ、タイマーの動作を制御することができます。

---

## 👤 ユーザー
*2023/9/20 16:14:05*

controlPublisher はそのままで、controlPublisher は別のAnyPublisherの値からくる値を使いたい。どうすればいいか？

---

## 🤖 アシスタント
*2023/9/20 16:15:32*

了解しました。`controlPublisher`が`AnyPublisher`の出力に従って動作するようにしたいということを理解しました。この場合、外部から提供される`AnyPublisher`を使用して`controlPublisher`の動作を制御するための変数を定義し、それをサブスクライブします。

以下はその方法を示す例です：

```swift
import Combine

class YourClass {
    var sessionDurationInSeconds = 0
    var cancellables: Set<AnyCancellable> = []

    // 外部から提供されるAnyPublisher
    var externalControlPublisher: AnyPublisher<Bool, Never>!

    func setup() {
        // タイマーと外部からの制御パブリッシャーをcombineLatestを使って組み合わせる
        Timer.publish(every: 1.0, on: .main, in: .common)
            .autoconnect()
            .combineLatest(externalControlPublisher) { (_, isActive) in isActive }
            .sink { [weak self] isActive in
                guard let self = self, isActive else { return } // isActive が true の場合のみカウントアップ
                self.sessionDurationInSeconds += 1
                print(self.sessionDurationInSeconds)
            }
            .store(in: &cancellables)
    }

    // 外部から制御用のパブリッシャーをセットするメソッド
    func setControlPublisher(_ publisher: AnyPublisher<Bool, Never>) {
        self.externalControlPublisher = publisher
    }
}

// 例えば以下のようにYourClassを使う場合
let yourInstance = YourClass()

// 外部からの制御用パブリッシャーの例（ここではPassthroughSubjectを使っていますが、他のAnyPublisherも使用可能です）
let controlSubject = PassthroughSubject<Bool, Never>()

yourInstance.setControlPublisher(controlSubject.eraseToAnyPublisher())
yourInstance.setup()

// ある時点でタイマーを停止
controlSubject.send(false)

// ある時点でタイマーを再開
controlSubject.send(true)
```

この方法では、`YourClass`は外部から制御用の`AnyPublisher`を受け取ることができます。そして、この制御用の`AnyPublisher`が`true`や`false`を送出すると、タイマーの動作がそれに従って制御されます。

---

## 👤 ユーザー
*2023/9/20 16:15:43*

AnyPublisher ってcombineLatestできるんだっけ？

---

## 🤖 アシスタント
*2023/9/20 16:17:05*

申し訳ございません。おっしゃる通り、`AnyPublisher`はそのまま`combineLatest`を使用することはできません。`AnyPublisher`は具体的なPublisherの型を隠蔽するラッパーであり、型に関連する具体的なオペレータは`AnyPublisher`自体には存在しません。

代わりに、オリジナルのPublisher（`AnyPublisher`にラップする前のPublisher）に対して`combineLatest`を使用する必要があります。

しかし、`AnyPublisher`を使用している場合、オリジナルのPublisherに直接アクセスできないので、少し工夫が必要です。

以下は、`AnyPublisher`と`Timer`を組み合わせる方法を示す例です：

```swift
import Combine

class YourClass {
    var sessionDurationInSeconds = 0
    var cancellables: Set<AnyCancellable> = []

    var externalControlPublisher: AnyPublisher<Bool, Never>!

    func setup() {
        let timerPublisher = Timer.publish(every: 1.0, on: .main, in: .common).autoconnect()

        // AnyPublisherをcombineLatestするために、mapでBoolをラップして再度unwrapする手法を取る
        let controlStream = externalControlPublisher.map { Optional.some($0) }.eraseToAnyPublisher()
        
        timerPublisher
            .combineLatest(controlStream) { (_, isActive) -> Bool? in isActive }
            .compactMap { $0 }  // nilの場合は無視してBoolだけを取り出す
            .sink { [weak self] isActive in
                guard let self = self, isActive else { return }
                self.sessionDurationInSeconds += 1
                print(self.sessionDurationInSeconds)
            }
            .store(in: &cancellables)
    }

    func setControlPublisher(_ publisher: AnyPublisher<Bool, Never>) {
        self.externalControlPublisher = publisher
    }
}

// 使用例
let yourInstance = YourClass()

let controlSubject = PassthroughSubject<Bool, Never>()

yourInstance.setControlPublisher(controlSubject.eraseToAnyPublisher())
yourInstance.setup()

controlSubject.send(true)
```

この方法で、`AnyPublisher`と`Timer`を組み合わせて使用することができます。

---

## 👤 ユーザー
*2023/9/20 16:27:42*

以下のようなplaygroundで実行できるコードになった

import Combine
import Foundation

var sessionDurationInSeconds = 0
var cancellables: Set&lt;AnyCancellable&gt; = []

let hogeSubject: PassthroughSubject&lt;Int, Never&gt; = .init()
let hogePunlisher = hogeSubject.map { $0 != 0 }

// タイマーと制御パブリッシャーをcombineLatestを使って組み合わせる
Timer.publish(every: 1.0, on: .main, in: .common)
    .autoconnect()
    .combineLatest(hogePunlisher)
    .filter { _, isActive in
        return isActive
    }
    .sink { _ in
        sessionDurationInSeconds += 1
        print(sessionDurationInSeconds)
    }
    .store(in: &cancellables)

hogeSubject.send(0) // タイマーを停止
hogeSubject.send(1) // タイマーを再開
hogeSubject.send(0) // タイマーを再開

---

## 🤖 アシスタント
*2023/9/20 16:29:18*

良いですね！コードはシンプルになり、`hogeSubject`を使用してタイマーの動作を制御しています。`hogePublisher`を介して0でなければタイマーが動作し、0の場合に停止するようになっています。

ただ、一つのポイントとして、Playgroundでの非同期処理を確認する際、通常の終了処理の前に非同期処理が完了することを確認するために、`PlaygroundPage`の`needsIndefiniteExecution`を`true`に設定する必要があります。これを設定しないと、非同期処理が完了する前にPlaygroundの実行が終了してしまいます。

以下のようにPlaygroundの上部に追加してください：

```swift
import PlaygroundSupport
PlaygroundPage.current.needsIndefiniteExecution = true
```

また、最後のコメント `// タイマーを再開` は実際には停止の動作に対応しているので、コメントを修正することをおすすめします。

それを考慮に入れたコードは以下のようになります：

```swift
import Combine
import Foundation
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

var sessionDurationInSeconds = 0
var cancellables: Set<AnyCancellable> = []

let hogeSubject: PassthroughSubject<Int, Never> = .init()
let hogePunlisher = hogeSubject.map { $0 != 0 }

// タイマーと制御パブリッシャーをcombineLatestを使って組み合わせる
Timer.publish(every: 1.0, on: .main, in: .common)
    .autoconnect()
    .combineLatest(hogePunlisher)
    .filter { _, isActive in
        return isActive
    }
    .sink { _ in
        sessionDurationInSeconds += 1
        print(sessionDurationInSeconds)
    }
    .store(in: &cancellables)

hogeSubject.send(0) // タイマーを停止
hogeSubject.send(1) // タイマーを再開
hogeSubject.send(0) // タイマーを停止
```

このコードで、Playgroundでの動作を適切に確認することができます。

---

## 👤 ユーザー
*2023/9/20 16:29:34*

ここにタイマーを3秒後に開始するようにして欲しい

hogeSubject.send(0) // タイマーを停止
hogeSubject.send(1) // タイマーを再開
hogeSubject.send(0) // タイマーを停止

---

## 🤖 アシスタント
*2023/9/20 16:29:58*

3秒後にタイマーを開始するためには、`DispatchQueue`を使用して非同期に`hogeSubject.send(1)`を実行することができます。以下のように修正してみました。

```swift
hogeSubject.send(0) // タイマーを停止

DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    hogeSubject.send(1) // タイマーを再開
}

DispatchQueue.main.asyncAfter(deadline: .now() + 6) {
    hogeSubject.send(0) // タイマ

---
