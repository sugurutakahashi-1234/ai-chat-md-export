# 非同期処理をSwift Concurrencyで書く

日付: 2023-05-23

---

## 👤 ユーザー
*2023/5/23 19:45:48*

DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { 何かの処理 } をSwift Concurrency で書いて欲しい

---

## 🤖 アシスタント
*2023/5/23 19:46:13*

Swift 5.5から、Swiftは非同期処理の新しい機能である「Swift Concurrency」を導入しました。これは非同期処理をよりシンプルで理解しやすいものにし、また安全性を向上させるためのものです。

そのため、Swift Concurrencyを用いて`DispatchQueue.main.asyncAfter`に相当する処理を書くと以下のようになります。

```swift
import Foundation

// 非同期タスクの宣言
async func delayTask() {
    await Task.sleep(NSEC_PER_SEC) // 1 second delay
    // ここに処理を書く
}

// 非同期タスクの呼び出し
Task {
    await delayTask()
}
```

ここで、`Task.sleep(NSEC_PER_SEC)`は1秒間の遅延を表しています（`NSEC_PER_SEC`は1秒をナノ秒で表したものです）。そしてその遅延後にあなたが実行したい処理を書くことができます。

---

## 👤 ユーザー
*2023/5/23 19:47:35*

NSEC\_PER\_SEC って一般的な表現？

---

## 🤖 アシスタント
*2023/5/23 19:47:53*

すみません、その説明は混乱を招くかもしれません。

`NSEC_PER_SEC`は、1秒をナノ秒で表した定数ですが、Swift Concurrencyの`Task.sleep`関数ではミリ秒単位の`UInt64`を引数として取ります。したがって、1秒のスリープは次のように書くことができます。

```swift
await Task.sleep(1_000_000_000) // 1 second delay
```

なお、1秒をミリ秒で表すと1000ミリ秒、マイクロ秒で表すと1,000,000マイクロ秒、ナノ秒で表すと1,000,000,000ナノ秒となります。したがって、上記のコードでは1,000,000,000ナノ秒（すなわち1秒）スリープしています。

---

## 👤 ユーザー
*2023/5/23 19:51:34*

@Published な変数には @MainActor  をつけるべきか？

---

## 🤖 アシスタント
*2023/5/23 19:52:24*

`@MainActor`属性は、メソッドやプロパティがメインスレッド（またはメインディスパッチキュー）でのみ実行されることを保証します。Swift Concurrencyの導入により、この属性を使用してUIの更新など、メインスレッドで実行すべき操作を明示的に指定することができます。

一方、`@Published`はSwiftUIと共に導入された属性で、プロパティの変更を監視し、変更があるたびに`ObservableObject`プロトコルの`objectWillChange`イベントを発火します。このイベントはSwiftUIのビューを再描画するために使用されます。

一般的には、SwiftUIのビューの更新はメインスレッドで行われるため、UIの更新が関わる`@Published`プロパティに対して`@MainActor`を使用することは理にかなっています。しかし、必ずしもすべての`@Published`プロパティに`@MainActor`を使用すべきとは限りません。プロパティの変更がUIの更新に直接関連しない場合や、プロパティの変更がバックグラウンドスレッドで行われることが期待される場合などは、`@MainActor`を使用する必要はありません。

また、全体のアーキテクチャにもよります。例えば、ViewModelが`@MainActor`で修飾されていて、その中の`@Published`プロパティが主にUIの更新に使用される場合、個々の`@Published`プロパティに`@MainActor`を付ける必要はありません。これは`@MainActor`がクラス全体に適用され、その中のすべてのメソッドやプロパティがメインスレッドで実行されるためです。

したがって、`@Published`な変数に`@MainActor`をつけるべきかどうかは、その変数がどのように使用されるかによります。

---
