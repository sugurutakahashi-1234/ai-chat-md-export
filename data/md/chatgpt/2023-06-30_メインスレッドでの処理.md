# メインスレッドでの処理

日付: 2023-06-30

---

## 👤 ユーザー
*2023/6/30 18:11:46*

Task ブロック内の処理をメインスレッドで行うにはどうすればいいか？

NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: avPlayer.currentItem)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                guard let self else { return }
                Task {
                    await self.endedVideo()
                }
            }
            .store(in: &cancellableSet)

---

## 🤖 アシスタント
*2023/6/30 18:12:25*

上記のコードでは、Swiftの`Task`を使用して非同期処理を行っています。Swift 5.5以降の非同期/待機機能を活用することで、メインスレッド以外で実行する可能性のあるブロック内の処理をメインスレッドで行うことができます。

既に`receive(on: DispatchQueue.main)`でメインスレッドに切り替えていますが、さらにその後のTask内の処理もメインスレッドで行いたいということであれば、以下のようにTaskをメインスレッドで実行するように指定することができます。

```swift
NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: avPlayer.currentItem)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                guard let self = self else { return }
                DispatchQueue.main.async { // 追加
                    Task {
                        await self.endedVideo()
                    }
                }
            }
            .store(in: &cancellableSet)
```

このコードでは、`DispatchQueue.main.async` を使用して、メインスレッド上で `Task` を作成し実行しています。

ただし、Swift 5.5以降の非同期タスクは既にメインスレッドであることが保証されているため、一般的には`receive(on: DispatchQueue.main)`が呼ばれた後の非同期タスクを明示的にメインスレッドで実行する必要はありません。これは重要な点で、冗長な操作や不要なオーバーヘッドを避けるために理解しておくべきです。

---

## 👤 ユーザー
*2023/6/30 18:12:54*

DispatchQueue.main.async ではなく、Swift Concurrencyで記述するとどうなるか？

---

## 🤖 アシスタント
*2023/6/30 18:13:34*

Swift Concurrencyは非同期のタスクをより安全かつ簡単に管理するための仕組みを提供しています。Swift 5.5以降では、メインスレッドでの実行が必要な非同期タスクに対しては、@MainActor属性を使用することが推奨されています。

この属性をメソッドや関数に適用すると、そのメソッドや関数は自動的にメインスレッドで実行されるようになります。なお、@MainActor属性を適用することでメインスレッド以外からそのメソッドや関数を呼び出す場合、暗黙的に非同期になるため、呼び出し元も非同期である必要があります。

コードは以下のようになります:

```swift
@MainActor // このクラスのメソッドはデフォルトでメインスレッドで実行されます
class MyClass {
    ...
    func endedVideo() async {
        // do something on main thread
    }
    ...
}

// ...

NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: avPlayer.currentItem)
    .sink { [weak self] _ in
        guard let self = self else { return }
        Task {
            await self.endedVideo()
        }
    }
    .store(in: &cancellableSet)
```

これで、`endedVideo()`メソッドは必ずメインスレッドで実行されます。ただし、`endedVideo()`が@MainActor属性を持つ場合、`Task`の作成とその中での`endedVideo()`の呼び出しも非同期である必要があります。

Swift Concurrencyを使うことで、非同期コードがより明確かつ安全になります。これはメインスレッドでの実行が必要なUI操作などに非常に有用です。

---
