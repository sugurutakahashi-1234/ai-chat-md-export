# パフォーマンス改善方法

日付: 2025-02-20

---

## 👤 ユーザー
*2025/02/21 00:56:28*

この画面で件数が多すぎる（200件ほど）とクラッシュするのですが、処理が重くならない様にしたい。  import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/rarity.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/infrastructure/entities/extensions/convert_to_domain.dart';
import 'package:snpit_guild_app/presentation/extensions/font_weight_extensions.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/flavor_provider.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/location_utils.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';

class SpotListPage extends HookConsumerWidget {
  const SpotListPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final myGuildId = ref.watch(getMyGuildNotifierProvider).value?.guildId;
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);

    Future&lt;void&gt; onTapSpot(String spotId) async {
      // キャッシュをクリア
      await ref.read(getSpotDetailNotifierProvider.notifier).clear();

      if (context.mounted) {
        await context.push(Screen.spotDetail.path, extra: spotId);
      }
    }

    Future&lt;void&gt; onRefresh() async {
      try {
        final flavor = ref.watch(flavorProvider);
        final location = await getCurrentLocation(flavor: flavor).timeout(
          const Duration(seconds: 5),
          onTimeout: () {
            throw Exception(
              // ignore: lines_longer_than_80_chars
              'Getting current location timed out. Please try again in an area with better signal.',
            );
          },
        );
        await ref
            .read(getSpotListNotifierProvider.notifier)
            .getAllSpotList(location);
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await onRefresh();
        });
        return null;
      },
      [],
    );

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: false,
        centerTitle: false,
        title: Text(
          'Spot list',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeightX.semiBold,
          ),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: () async {
              // ボトムシート全体を閉じる
              Navigator.of(context, rootNavigator: true).pop();
            },
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () async {
          await onRefresh();
        },
        color: ColorToken.primary,
        backgroundColor: ColorToken.bgLight,
        child: spotListAsyncValue.when(
          data: (spotList) {
            if (spotList == null || spotList.isEmpty) {
              return const SizedBox.shrink();
            }

            return SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: Column(
                children: [
                  const SizedBox(height: 8),
                  GridView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    padding: const EdgeInsets.all(16),
                    gridDelegate:
                        const SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 3,
                      crossAxisSpacing: 16,
                      mainAxisSpacing: 16,
                    ),
                    itemCount: spotList.length,
                    itemBuilder: (context, index) {
                      final spot = spotList[index];
                      final spotId = spot.spotId ?? '';
                      final imageUrl = spot.photoUrl;
                      final rarity = spot.rarity;
                      final guildId = spot.guildId;

                      return GestureDetector(
                        onTap: () async {
                          await onTapSpot(spotId);
                        },
                        child: _SpotTile(
                          imageUrl: imageUrl,
                          rarity: rarity?.domainRarity,
                          guildId: guildId,
                          isMyGuild: guildId == myGuildId,
                        ),
                      );
                    },
                  ),
                  const SizedBox(height: 180),
                ],
              ),
            );
          },
          loading: () {
            return const Center(child: CircularProgressIndicator());
          },
          error: (error, _) {
            return Center(
              child: Text('Error: $error'),
            );
          },
        ),
      ),
    );
  }
}

class _SpotTile extends StatelessWidget {
  const _SpotTile({
    required this.imageUrl,
    required this.rarity,
    required this.guildId,
    required this.isMyGuild,
  });

  final String? imageUrl;
  final Rarity? rarity;
  final String? guildId;
  final bool isMyGuild;

  @override
  Widget build(BuildContext context) {
    return Stack(
      alignment: Alignment.bottomCenter,
      children: [
        // 枠線付きの画像
        DecoratedBox(
          decoration: BoxDecoration(
            border: Border.all(
              color: guildId == null ? ColorPallet.white : ColorPallet.black,
              width: 3,
            ),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Padding(
            padding: const EdgeInsets.all(2),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(8),
              child: SquareImage(
                imageUrl: imageUrl,
                size: double.infinity,
              ),
            ),
          ),
        ),

        // ギルド済みの場合は下部に影をかける
        if (guildId != null)
          Positioned.fill(
            child: Container(
              decoration: BoxDecoration(
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withValues(alpha: 0.25),
                    offset: const Offset(0, 12),
                    blurRadius: 24,
                  ),
                ],
              ),
            ),
          ),

        // ギルドラベル
        if (guildId != null)
          Positioned.fill(
            child: Align(
              child: _GuildLabel(isMyGuild: isMyGuild),
            ),
          ),

        // レアリティラベル
        if (rarity != null)
          Positioned(
            top: 8,
            left: 8,
            child: CircleAvatar(
              backgroundColor: ColorPallet.gray1000,
              radius: 10,
              child: Center(
                child: Text(
                  rarity!.label,
                  style: TextStyle(
                    color: rarity!.color,
                    fontSize: 12,
                  ),
                ),
              ),
            ),
          ),
      ],
    );
  }
}

class _GuildLabel extends StatelessWidget {
  const _GuildLabel({required this.isMyGuild});

  final bool isMyGuild;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          Icons.flag,
          size: 32,
          color: isMyGuild ? ColorToken.owner : ColorToken.enemy,
        ),
        const SizedBox(width: 4),
        Text(
          isMyGuild ? 'your guild' : 'enemies',
          style: TextStyle(
            color: isMyGuild ? ColorToken.owner : ColorToken.enemy,
            fontSize: 10,
          ),
        ),
      ],
    );
  }
}

---

## 🔧 ツール
*2025/02/21 00:58:16*

**UIの最適化を模索**

UIが200件のアイテムでクラッシュしている。`ListView.builder`や`Lazy loading`を検討し、`GridView.builder`に`SingleChildScrollView`を外すアイデアが浮上している。

**メモリ管理の改善**

`CustomScrollView`と`SliverGrid`を使用するか、`SingleChildScrollView`を外して`GridView`にスクロールを任せ、メモリ使用量を大幅に減らす方法を検討中。

**`GridView.builder`の工夫**

`RefreshIndicator`で`GridView.builder`をラップし、メモリ使用を最適化している。アイテム追加には`ListView.builder`が検討されているが、`GridView.builder`を直接使用する方法も模索中。

**最適化の視点を持つ**

`CachedNetworkImage`や`Image.network`でメモリ消費を抑え、`SquareImage`や`fadeInImage`を使って画像の管理を工夫している。大きな画像のメモリ使用に注意。

**メモリ使用量の削減**

`GridView.builder`を使って非表示のアイテムをバックグラウンドで効率的にビルドし、メモリ使用量を減らしている。

**スクロールの最適化**

`GridView.builder`を`RefreshIndicator`の子として使用し、スクロールを`GridView`に任せ、`SingleChildScrollView`を外している。必要に応じて、ボトムパディングを追加する案もある。

---

## 🤖 アシスタント
*2025/02/21 00:58:16*

大量の `Widget` を一度に描画していることが原因で、メモリ使用量が増えクラッシュする可能性が高いです。  
`shrinkWrap: true` や `SingleChildScrollView` ＋ `GridView` を同時に使っている場合、実質的に全要素を一度にビルドしてしまうため、要素数が多いほどパフォーマンスが急激に落ちます。  

## 改善のポイント

1. **`SingleChildScrollView` を使わない**  
   `GridView` 自体にスクロール機能があるため、スクロール可能にしたい場合は `SingleChildScrollView` を外してあげましょう。  
2. **`shrinkWrap: true` や `NeverScrollableScrollPhysics()` を使わない**  
   `shrinkWrap: true` は、全要素の高さを計算するために最初からすべての子ウィジェットをビルドしにいきます。  
   スクロールを `GridView` に任せる場合は、`physics` に `AlwaysScrollableScrollPhysics()` を指定するか、デフォルト (`ScrollPhysics()`) のままにします。  

## 例: 修正コード

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/rarity.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/infrastructure/entities/extensions/convert_to_domain.dart';
import 'package:snpit_guild_app/presentation/extensions/font_weight_extensions.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/flavor_provider.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/location_utils.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';

class SpotListPage extends HookConsumerWidget {
  const SpotListPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final myGuildId = ref.watch(getMyGuildNotifierProvider).value?.guildId;
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);

    Future<void> onTapSpot(String spotId) async {
      // キャッシュをクリア
      await ref.read(getSpotDetailNotifierProvider.notifier).clear();

      if (context.mounted) {
        await context.push(Screen.spotDetail.path, extra: spotId);
      }
    }

    Future<void> onRefresh() async {
      try {
        final flavor = ref.watch(flavorProvider);
        final location = await getCurrentLocation(flavor: flavor).timeout(
          const Duration(seconds: 5),
          onTimeout: () {
            throw Exception(
              'Getting current location timed out. Please try again in an area with better signal.',
            );
          },
        );
        await ref
            .read(getSpotListNotifierProvider.notifier)
            .getAllSpotList(location);
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    useEffect(() {
      Future.microtask(() async {
        await onRefresh();
      });
      return null;
    }, []);

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: false,
        centerTitle: false,
        title: Text(
          'Spot list',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeightX.semiBold,
          ),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: () async {
              Navigator.of(context, rootNavigator: true).pop();
            },
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () => onRefresh(),
        color: ColorToken.primary,
        backgroundColor: ColorToken.bgLight,
        child: spotListAsyncValue.when(
          data: (spotList) {
            if (spotList == null || spotList.isEmpty) {
              return const Center(
                child: Text('No spots available'),
              );
            }

            // GridViewでスクロールを管理する
            return GridView.builder(
              // shrinkWrapはしない
              // shrinkWrap: true,
              // GridViewにスクロールさせる
              physics: const AlwaysScrollableScrollPhysics(),
              padding: const EdgeInsets.only(
                top: 8,
                left: 16,
                right: 16,
                bottom: 180,
              ),
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 3,
                crossAxisSpacing: 16,
                mainAxisSpacing: 16,
              ),
              itemCount: spotList.length,
              itemBuilder: (context, index) {
                final spot = spotList[index];
                final spotId = spot.spotId ?? '';
                final imageUrl = spot.photoUrl;
                final rarity = spot.rarity;
                final guildId = spot.guildId;

                return GestureDetector(
                  onTap: () async {
                    await onTapSpot(spotId);
                  },
                  child: _SpotTile(
                    imageUrl: imageUrl,
                    rarity: rarity?.domainRarity,
                    guildId: guildId,
                    isMyGuild: guildId == myGuildId,
                  ),
                );
              },
            );
          },
          loading: () => const Center(child: CircularProgressIndicator()),
          error: (error, _) => Center(
            child: Text('Error: $error'),
          ),
        ),
      ),
    );
  }
}

class _SpotTile extends StatelessWidget {
  const _SpotTile({
    required this.imageUrl,
    required this.rarity,
    required this.guildId,
    required this.isMyGuild,
  });

  final String? imageUrl;
  final Rarity? rarity;
  final String? guildId;
  final bool isMyGuild;

  @override
  Widget build(BuildContext context) {
    return Stack(
      alignment: Alignment.bottomCenter,
      children: [
        // 枠線付きの画像
        DecoratedBox(
          decoration: BoxDecoration(
            border: Border.all(
              color: guildId == null ? ColorPallet.white : ColorPallet.black,
              width: 3,
            ),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Padding(
            padding: const EdgeInsets.all(2),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(8),
              child: SquareImage(
                imageUrl: imageUrl,
                size: double.infinity,
              ),
            ),
          ),
        ),

        // ギルド済みの場合は下部に影をかける
        if (guildId != null)
          Positioned.fill(
            child: Container(
              decoration: BoxDecoration(
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withAlpha(64),
                    offset: const Offset(0, 12),
                    blurRadius: 24,
                  ),
                ],
              ),
            ),
          ),

        // ギルドラベル
        if (guildId != null)
          Positioned.fill(
            child: Align(
              child: _GuildLabel(isMyGuild: isMyGuild),
            ),
          ),

        // レアリティラベル
        if (rarity != null)
          Positioned(
            top: 8,
            left: 8,
            child: CircleAvatar(
              backgroundColor: ColorPallet.gray1000,
              radius: 10,
              child: Center(
                child: Text(
                  rarity!.label,
                  style: TextStyle(
                    color: rarity!.color,
                    fontSize: 12,
                  ),
                ),
              ),
            ),
          ),
      ],
    );
  }
}

class _GuildLabel extends StatelessWidget {
  const _GuildLabel({required this.isMyGuild});

  final bool isMyGuild;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          Icons.flag,
          size: 32,
          color: isMyGuild ? ColorToken.owner : ColorToken.enemy,
        ),
        const SizedBox(width: 4),
        Text(
          isMyGuild ? 'your guild' : 'enemies',
          style: TextStyle(
            color: isMyGuild ? ColorToken.owner : ColorToken.enemy,
            fontSize: 10,
          ),
        ),
      ],
    );
  }
}
```

- **`GridView.builder`** にすれば、リストが画面外にある一部の要素は都度破棄・ビルドされるため、一気にメモリを消費しづらくなります。  
- `SingleChildScrollView` ＋ `GridView.builder(shrinkWrap: true, physics: NeverScrollableScrollPhysics())` の組み合わせは基本的に「全要素を先にレイアウト計算しよう」としてしまい、要素数が多い場合にパフォーマンス悪化の原因になります。

上記の修正により、**要素数が増えても描画パフォーマンスが改善**し、クラッシュのリスクを下げられます。必要に応じて、画像のキャッシュ (`CachedNetworkImage` など) を導入するなどの追加最適化も検討してみてください。

---

## 👤 ユーザー
*2025/02/21 01:09:32*

なるほど、ただ、今後 GridView の上にフィルタリングするボタン（例えば Within 100Km radius など）をおきたいんだ。その場合はどうなるの？それでもパフォーマンスは維持したくて、そのボタンはスクロールしても見える様に固定にするか、そのままスクロールして一番上までいかないと見えなくするかを迷っている。

---

## 🔧 ツール
*2025/02/21 01:10:47*

**選び出すオプションを検討**

フィルタリングボタンをどこに置くかの二つのオプションを見ています。一つはスライバーリスト/スライバーグリッドのアプローチで、もう一つはスクロールビュー外に置く方法です。

**ピン留めとスライバーリストのメリット**

ピン留めされたフィルターバーは常に見える状態ですが、一方でスライバーリストを使うとスクロールとともにフィルターバーが移動し、残りはグリッドビューで処理されます。

**ピン留めされたフィルターバー**

ピン留めされたフィルターボタンとスライバーリストを使ってグリッドビューを表示するアプローチを検討中。ユーザーの要求に応じてフィルターバーの表示を調整する。

---

## 🤖 アシスタント
*2025/02/21 01:10:47*

スクロール可能なリスト（GridView など）「の上に」何らかのフィルタリングボタンや操作ウィジェットを配置したい場合、大きく分けて次の2パターンがあります。

---

## 1. 常に画面上部に固定（スクロールしても見えるようにする）

### メリット
- ユーザーがリストの下部までスクロールしていても、いつでもフィルターを変更できる  
- ボタンが隠れないので操作性が高い

### デメリット
- 常時表示されるため、画面が狭い場合にリストが狭く見えてしまう

### 実装イメージ

#### パターンA: Scaffold の上部（AppBar 内など）に置く
一番簡単なのは **AppBar のアクション部分**や、`SliverAppBar` の領域にフィルター用のボタンを置いてしまう方法です。

```dart
Scaffold(
  appBar: AppBar(
    title: const Text('Spot List'),
    actions: [
      IconButton(
        icon: const Icon(Icons.filter_alt),
        onPressed: () {
          // フィルターアクション
        },
      ),
      // その他ボタンを並べる
    ],
  ),
  body: GridView.builder(
    // 先述の通り shrinkWrap: false, 物理スクロールなど注意
    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
      crossAxisCount: 3,
      // ...
    ),
    itemBuilder: (context, index) {
      // ...
    },
  ),
);
```

#### パターンB: AppBar の下に並べる（カスタムで固定）
```dart
return Scaffold(
  appBar: AppBar(
    title: Text('Spot List'),
  ),
  body: Column(
    children: [
      // フィルターボタン
      Container(
        color: Colors.grey[200],
        padding: const EdgeInsets.all(8),
        child: Row(
          children: [
            ElevatedButton(
              onPressed: () {},
              child: const Text('Within 100km'),
            ),
            // 他のボタン
          ],
        ),
      ),
      // リスト本体
      Expanded(
        child: RefreshIndicator(
          onRefresh: onRefresh,
          child: GridView.builder(
            physics: const AlwaysScrollableScrollPhysics(),
            // shrinkWrap: false が推奨
            padding: const EdgeInsets.only(bottom: 16),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3,
              // ...
            ),
            itemCount: 200, // spotList.length
            itemBuilder: (context, index) {
              return /* _SpotTile(...) */;
            },
          ),
        ),
      ),
    ],
  ),
);
```

- この方法だと、**フィルターボタンはリストのスクロールに合わせて隠れず、画面上部に固定**される形になります。  
- `Column` &gt; `Expanded` の中に `GridView.builder` を入れることで、リスト部分のみスクロールが発生するようにして、フィルターボタンは常に見えるようにします。  

---

## 2. リストをスクロールするとボタンが上にスクロールアウトして見えなくなる

### メリット
- 画面スペースが広く使える  
- 縦が狭い端末でもリストをできるだけ多く表示できる

### デメリット
- フィルターを変更したい場合は、一番上までスクロールしなければならない

### 実装イメージ

```dart
return Scaffold(
  appBar: AppBar(
    title: const Text('Spot List'),
  ),
  body: RefreshIndicator(
    onRefresh: onRefresh,
    child: CustomScrollView(
      slivers: [
        // フィルターボタン
        SliverToBoxAdapter(
          child: Container(
            color: Colors.grey[200],
            padding: const EdgeInsets.all(8),
            child: Row(
              children: [
                ElevatedButton(
                  onPressed: () {},
                  child: const Text('Within 100km'),
                ),
                // 他のボタン
              ],
            ),
          ),
        ),
        // Grid
        SliverGrid(
          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3,
            crossAxisSpacing: 16,
            mainAxisSpacing: 16,
          ),
          delegate: SliverChildBuilderDelegate(
            (context, index) {
              return /* _SpotTile(...) */;
            },
            childCount: 200, // spotList.length
          ),
        ),
      ],
    ),
  ),
);
```

このように `CustomScrollView` + `SliverToBoxAdapter` + `SliverGrid` で構成すれば、**フィルタ部分 → リスト部分**と自然にスクロールできるレイアウトが可能です。  
ただしフィルタは画面上部へスクロールしきらないと再度見えなくなるため、**「常に見える」ようにはなりません**。

---

## まとめ: パフォーマンス維持のポイント

1. **`SingleChildScrollView` + `GridView/shrinkWrap: true` を組み合わせない**  
   - これをしてしまうと、全要素を一度にビルドするため大量要素でパフォーマンスが低下します。
2. **`GridView.builder` や `SliverGrid` でリストを構築する**  
   - 画面外の要素は破棄・再ビルドを行うので、メモリ使用量を抑えられます。
3. **フィルターボタンを常に表示するか、スクロールアウトさせるかは UI/UX に応じて決める**  
   - 常に固定表示したいなら、AppBar 内や `Column` の先頭に置いて `Expanded` でリストを包む（リストだけスクロール）  
   - スクロールアウトでよいなら、`CustomScrollView` + `SliverToBoxAdapter` + `SliverGrid` などを利用し、1つのスクロールとして扱う

いずれの方法でも、**GridView によるビルドの再利用**（リストの仮想化）を使えば、200件以上あってもパフォーマンスが劇的に落ちることを防ぐことができます。

---
