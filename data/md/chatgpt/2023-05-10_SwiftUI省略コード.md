# SwiftUI省略コード

日付: 2023-05-10

---

## 👤 ユーザー
*2023/5/10 14:35:28*

Siwftで以下のコードはもっと省略して書けないの？

Button(action: {
                        Task {
                            await loginPresenter.createUser()
                        }
                    }) {
                        Text("Register")
                            .padding()
                    }
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)

---

## 🤖 アシスタント
*2023/5/10 14:35:46*

はい、SwiftUIでは省略しても良い部分がいくつかあります。以下のように書くことができます。

```swift
Button {
    Task { await loginPresenter.createUser() }
} label: {
    Text("Register")
        .padding()
        .background(Color.blue)
        .foregroundColor(.white)
        .cornerRadius(8)
}
```

この例では、`action` と `label` を省略して、より簡潔な構文を使用しています。また、`Task` の実装に関しても、`{}` を使って短縮形を採用しました。このように省略して書くことで、コードがスッキリと見えるようになります。

---

## 👤 ユーザー
*2023/5/10 14:36:06*

以下もお願い
                    Button(action: {
                        Task {
                            await loginPresenter.signIn()
                        }
                    }) {
                        Text("Login")
                            .padding()
                    }
                    .background(Color.green)
                    .foregroundColor(.white)
                    .cornerRadius(8)

---

## 🤖 アシスタント
*2023/5/10 14:36:20*

もちろんです。以下のように省略形で書くことができます。

```swift
Button {
    Task { await loginPresenter.signIn() }
} label: {
    Text("Login")
        .padding()
        .background(Color.green)
        .foregroundColor(.white)
        .cornerRadius(8)
}
```

この例でも、`action` と `label` を省略して、より簡潔な構文を使用しています。また、`Task` の実装に関しても、`{}` を使って短縮形を採用しました。このように省略して書くことで、コードがスッキリと見えるようになります。

---

## 👤 ユーザー
*2023/5/10 15:17:34*

以下のコードを縦のscrollViewに対応させてほしい

public struct LoginView: View {
    @StateObject private var loginPresenter = LoginPresenter()

    public init() {}

    public var body: some View {
        if #available(iOS 16.0, *) {
            NavigationStack {
                VStack {
                    TextField("Email", text: $loginPresenter.email)
                        .padding()
                        .autocapitalization(.none)
                        .disableAutocorrection(true)

                    SecureField("Password", text: $loginPresenter.password)
                        .padding()
                        .autocapitalization(.none)
                        .disableAutocorrection(true)

                    Text("Welcome, \(loginPresenter.idToken)")
                        .padding()

                    Button {
                        Task { await loginPresenter.createUser() }
                    } label: {
                        Text("Register")
                            .padding()
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }

                    Button {
                        Task { await loginPresenter.signIn() }
                    } label: {
                        Text("Login")
                            .padding()
                            .background(Color.green)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }
                }
                .padding()
                .alert(isPresented: $loginPresenter.showAlert) {
                    Alert(title: Text("Error"), message: Text(loginPresenter.alertMessage), dismissButton: .default(Text("OK")))
                }
            }
        } else {
            EmptyView()
        }
    }
}

---

## 🤖 アシスタント
*2023/5/10 15:18:16*

縦方向のScrollViewに対応させるには、`VStack` を `ScrollView` で囲んであげます。以下に修正後のコードを示します。

```swift
public struct LoginView: View {
    @StateObject private var loginPresenter = LoginPresenter()

    public init() {}

    public var body: some View {
        if #available(iOS 16.0, *) {
            NavigationStack {
                ScrollView(.vertical, showsIndicators: false) {
                    VStack {
                        TextField("Email", text: $loginPresenter.email)
                            .padding()
                            .autocapitalization(.none)
                            .disableAutocorrection(true)

                        SecureField("Password", text: $loginPresenter.password)
                            .padding()
                            .autocapitalization(.none)
                            .disableAutocorrection(true)

                        Text("Welcome, \(loginPresenter.idToken)")
                            .padding()

                        Button {
                            Task { await loginPresenter.createUser() }
                        } label: {
                            Text("Register")
                                .padding()
                                .background(Color.blue)
                                .foregroundColor(.white)
                                .cornerRadius(8)
                        }

                        Button {
                            Task { await loginPresenter.signIn() }
                        } label: {
                            Text("Login")
                                .padding()
                                .background(Color.green)
                                .foregroundColor(.white)
                                .cornerRadius(8)
                        }
                    }
                    .padding()
                }
                .alert(isPresented: $loginPresenter.showAlert) {
                    Alert(title: Text("Error"), message: Text(loginPresenter.alertMessage), dismissButton: .default(Text("OK")))
                }
            }
        } else {
            EmptyView()
        }
    }
}
```

`ScrollView` コンポーネントを追加し、縦方向にスクロールできるように `.vertical` を指定しました。`showsIndicators` を `false` に設定して、スクロールインジケーターを非表示にしています。これにより、画面の内容が縦方向にスクロール可能になります。

---

## 👤 ユーザー
*2023/5/10 15:32:52*

SwiftUIでFirebaseのログイン/ログアウト状態を監視する制御をいれたいんだけどおしえてほしい。FireabseAuthの入れ方はしっているからそこは省略してほしい。

---

## 🤖 アシスタント
*2023/5/10 15:33:53*

SwiftUIでFirebaseのログイン/ログアウト状態を監視するには、`Auth.auth().addStateDidChangeListener` を使ってリスナーを設定し、`@EnvironmentObject` と組み合わせることができます。

まず、`AuthState` クラスを作成し、`ObservableObject` プロトコルに準拠させます。

```swift
import SwiftUI
import FirebaseAuth

class AuthState: ObservableObject {
    @Published var user: User?

    private var handle: AuthStateDidChangeListenerHandle?

    init() {
        handle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            self?.user = user
        }
    }

    deinit {
        if let handle = handle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
}
```

このクラスは、Firebaseのログイン/ログアウト状態を監視し、ユーザー情報を`@Published`プロパティ`user`に格納します。`addStateDidChangeListener` でリスナーを設定し、状態が変化した際にクロージャが呼ばれます。クロージャ内で `self?.user` を更新することで、ログイン状態の変化を監視します。また、`deinit`でリスナーを解除します。

次に、アプリケーションのエントリーポイントである `@main` ストラクトに `AuthState` を`EnvironmentObject`として注入します。

```swift
import SwiftUI

@main
struct YourAppName: App {
    @StateObject private var authState = AuthState()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authState)
        }
    }
}
```

これで、`@EnvironmentObject` を使って `AuthState` をどのビューでも参照できるようになります。

例えば、ログイン状態に応じて表示を切り替える場合、以下のように実装できます。

```swift
import SwiftUI

struct ContentView: View {
    @EnvironmentObject var authState: AuthState

    var body: some View {
        if let user = authState.user {
            Text("Logged in as \(user.displayName ?? user.email ?? "unknown")")
        } else {
            Text("Not logged in")
        }
    }
}
```

このように、`@EnvironmentObject` を使って `AuthState` を注入し、ログイン状態の変化を監視できます。

---

## 👤 ユーザー
*2023/5/10 15:37:04*

@main ストラクトに AuthState をEnvironmentObjectとして注入するときは、YourAppName に@StateObject private var authState  として変数に保持する必要ってあるんだっけ？

---

## 🤖 アシスタント
*2023/5/10 15:37:35*

おっしゃる通り、`@StateObject` で `authState` を保持することは必要です。その理由は、`@StateObject` がインスタンスのライフサイクルと一致するオブジェクトを作成し、管理する役割を持っているためです。これにより、アプリの実行中にオブジェクトが破棄されることがなく、全体で一貫した状態を保持できます。

`@StateObject` を使わずに `@EnvironmentObject` で直接注入すると、オブジェクトが破棄されるタイミングが不明確になり、アプリケーション全体で共有する状態の管理が困難になります。

したがって、以下のように `@StateObject` を使って `AuthState` インスタンスを作成し、その後 `@EnvironmentObject` を使って注入するのが適切です。

```swift
import SwiftUI

@main
struct YourAppName: App {
    @StateObject private var authState = AuthState()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authState)
        }
    }
}
```

---

## 👤 ユーザー
*2023/5/10 15:38:55*

あと、FirebaseAuth でログアウトするコードを教えて、async await で

---

## 🤖 アシスタント
*2023/5/10 15:39:42*

FirebaseAuthでログアウトするには、`Auth` クラスの `signOut` メソッドを使います。ただし、このメソッドは現状`async`/`await`に対応していません。ですので、次のように`async`関数にラップして使用することができます。

まず、`async`関数を定義しましょう。

```swift
import FirebaseAuth

func signOutAsync() async throws {
    try await withCheckedThrowingContinuation { continuation in
        do {
            try Auth.auth().signOut()
            continuation.resume(returning: ())
        } catch {
            continuation.resume(throwing: error)
        }
    }
}
```

これで、`async`/`await`構文でログアウトを実行できます。

例えば、ログアウトボタンを押すことでログアウトを実行する場合は、以下のように書けます。

```swift
import SwiftUI

struct ContentView: View {
    @EnvironmentObject var authState: AuthState

    var body: some View {
        if let user = authState.user {
            VStack {
                Text("Logged in as \(user.displayName ?? user.email ?? "unknown")")

                Button {
                    Task {
                        do {
                            try await signOutAsync()
                        } catch {
                            print("Error signing out: \(error)")
                        }
                    }
                } label: {
                    Text("Logout")
                }
            }
        } else {
            Text("Not logged in")
        }
    }
}
```

この例では、`signOutAsync` 関数を `Task` で実行しています。エラーが発生した場合は、コンソールにエラーを出力します。

---

## 👤 ユーザー
*2023/5/10 16:25:35*

ログインとログアウトの状態の変化を感じたらトーストとかでユーザーに伝えたいんだけどどう書けばいい？

---

## 🤖 アシスタント
*2023/5/10 16:29:03*

ログインとログアウトの状態変化をトーストで表示するには、まず独自の`Toast`ビューを作成し、表示内容や表示状態を管理するための`ToastManager`クラスを作成します。次に、`AuthState`の変更を監視して、トーストを表示するようにします。

1. まず、`Toast`ビューを作成します。

```swift
import SwiftUI

struct Toast: View {
    let message: String

    var body: some View {
        Text(message)
            .padding()
            .background(Color.black.opacity(0.7))
            .foregroundColor(.white)
            .cornerRadius(8)
    }
}
```

2. 次に、表示内容や表示状態を管理するための`ToastManager`クラスを作成します。

```swift
import Combine
import SwiftUI

class ToastManager: ObservableObject {
    @Published var isShowing: Bool = false
    @Published var message: String = ""

    func show(message: String, duration: TimeInterval = 2) {
        self.message = message
        isShowing = true

        DispatchQueue.main.asyncAfter(deadline: .now() + duration) {
            self.isShowing = false
        }
    }
}
```

3. その後、`AuthState`でログイン/ログアウトの状態変化を監視し、トーストを表示するようにします。

```swift
class AuthState: ObservableObject {
    @Published var user: User?
    @Published var toastManager = ToastManager()

    private var handle: AuthStateDidChangeListenerHandle?

    init() {
        handle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            if let previousUser = self?.user, let newUser = user, previousUser != newUser {
                self?.toastManager.show(message: "Logged in as \(newUser.email ?? "unknown")")
            } else if self?.user != nil, user == nil {
                self?.toastManager.show(message: "Logged out")
            }
            self?.user = user
        }
    }

    deinit {
        if let handle = handle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
}
```

4. 最後に、`ContentView`で`ToastManager`の状態を監視し、トーストを表示します。

```swift
struct ContentView: View {
    @EnvironmentObject var authState: AuthState

    var body: some View {
        ZStack {
            if let user = authState.user {
                Text("Logged in as \(user.displayName ?? user.email ?? "unknown")")
            } else {
                Text("Not logged in")
            }

            if authState.toastManager.isShowing {
                Toast(message: authState.toastManager.message)
                    .transition(.opacity.animation(.easeInOut(duration: 0.2)))
            }
        }
        .animation(.default, value: authState.toastManager.isShowing)
    }
}
```

この実装では、`AuthState`の変更を監視してトーストを表示するようにしています。`AuthState`が変更されたとき、`ToastManager`の`show(message:duration:)`メソッドが呼び出され、トーストが表示されます。`Toast`ビュ

---

## 👤 ユーザー
*2023/5/10 16:29:23*

ToastManager はアプリ全体で共有して管理したんだけどどうすればいい？今は、AuthStateで@Published var toastManager = ToastManager() で保持しているのが気になっています。

---

## 🤖 アシスタント
*2023/5/10 16:32:02*

アプリ全体で`ToastManager`を共有して管理するには、`ToastManager`を`@StateObject`として`@main`ストラクトに定義し、`@EnvironmentObject`を使って注入します。

1. まず、`@main` ストラクトに `ToastManager` を`@StateObject`として定義します。

```swift
import SwiftUI

@main
struct YourAppName: App {
    @StateObject private var authState = AuthState()
    @StateObject private var toastManager = ToastManager()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authState)
                .environmentObject(toastManager)
        }
    }
}
```

2. 次に、`AuthState`の`toastManager`プロパティを削除し、代わりに`@EnvironmentObject`を使って`ToastManager`を参照します。

```swift
import FirebaseAuth

class AuthState: ObservableObject {
    @Published var user: User?
    @EnvironmentObject var toastManager: ToastManager

    private var handle: AuthStateDidChangeListenerHandle?

    init() {
        handle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            if let previousUser = self?.user, let newUser = user, previousUser != newUser {
                self?.toastManager.show(message: "Logged in as \(newUser.email ?? "unknown")")
            } else if self?.user != nil, user == nil {
                self?.toastManager.show(message: "Logged out")
            }
            self?.user = user
        }
    }

    deinit {
        if let handle = handle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
}
```

3. 最後に、`ContentView`で`ToastManager`の状態を監視し、トーストを表示します。

```swift
struct ContentView: View {
    @EnvironmentObject var authState: AuthState
    @EnvironmentObject var toastManager: ToastManager

    var body: some View {
        ZStack {
            if let user = authState.user {
                Text("Logged in as \(user.displayName ?? user.email ?? "unknown")")
            } else {
                Text("Not logged in")
            }

            if toastManager.isShowing {
                Toast(message: toastManager.message)
                    .transition(.opacity.animation(.easeInOut(duration: 0.2)))
            }
        }
        .animation(.default, value: toastManager.isShowing)
    }
}
```

これで、`ToastManager`がアプリ全体で共有され、`@EnvironmentObject`を使って参照できるようになります。

---

## 👤 ユーザー
*2023/5/10 16:58:12*

AuthState は ObservableObject が適応されているけど、その中で EnvironmentObject って使えるんでしたっけ？

---

## 🤖 アシスタント
*2023/5/10 17:00:09*

すみません、ご指摘の通り、`ObservableObject`の中で`EnvironmentObject`を使うことはできません。`AuthState`の中で`ToastManager`を参照する代わりに、ログイン/ログアウト時に`ToastManager`の`show(message:duration:)`メソッドを呼び出すように変更しましょう。

1. `AuthState`から`@EnvironmentObject`を削除し、ログインとログアウト時に`ToastManager`を渡すようにします。

```swift
import FirebaseAuth

class AuthState: ObservableObject {
    @Published var user: User?

    private var handle: AuthStateDidChangeListenerHandle?

    init(toastManager: ToastManager) {
        handle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            if let previousUser = self?.user, let newUser = user, previousUser != newUser {
                toastManager.show(message: "Logged in as \(newUser.email ?? "unknown")")
            } else if self?.user != nil, user == nil {
                toastManager.show(message: "Logged out")
            }
            self?.user = user
        }
    }

    deinit {
        if let handle = handle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
}
```

2. `@main`ストラクトで`AuthState`を初期化する際に、`ToastManager`を引数として渡します。

```swift
import SwiftUI

@main
struct YourAppName: App {
    @StateObject private var authState: AuthState
    @StateObject private var toastManager = ToastManager()

    init() {
        let toastManager = ToastManager()
        let authState = AuthState(toastManager: toastManager)
        _authState = StateObject(wrappedValue: authState)
        _toastManager = StateObject(wrappedValue: toastManager)
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authState)
                .environmentObject(toastManager)
        }
    }
}
```

このように変更することで、`AuthState`内で`ToastManager`を参照でき、ログインとログアウト時にトーストを表示できます。

---

## 👤 ユーザー
*2023/5/10 17:03:35*

YourAppName の init なんか違和感があるけどこれで大丈夫？

---

## 🤖 アシスタント
*2023/5/10 17:04:27*

おっしゃる通り、`YourAppName`の`init()`の実装に違和感があります。もっとシンプルに書くことができます。`AuthState`のイニシャライザに`ToastManager`を渡すようにしましょう。

```swift
import SwiftUI

@main
struct YourAppName: App {
    @StateObject private var toastManager = ToastManager()
    @StateObject private var authState: AuthState

    init() {
        let toastManager = ToastManager()
        let authState = AuthState(toastManager: toastManager)
        _authState = StateObject(wrappedValue: authState)
        _toastManager = StateObject(wrappedValue: toastManager)
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authState)
                .environmentObject(toastManager)
        }
    }
}
```

これで、`YourAppName`の`init()`がよりシンプルになり、`AuthState`と`ToastManager`が正しく初期化されます。

---

## 👤 ユーザー
*2023/5/10 17:15:40*

@StateObject private var toastManager = ToastManager() での初期化宣言っているの？ちょうふくしていない？

---

## 🤖 アシスタント
*2023/5/10 17:16:31*

ご指摘の通り、重複しています。失礼しました。`@StateObject`の初期化は一度だけ行う必要があります。以下のように修正しましょう。

```swift
import SwiftUI

@main
struct YourAppName: App {
    @StateObject private var toastManager = ToastManager()
    @StateObject private var authState: AuthState

    init() {
        let authState = AuthState(toastManager: toastManager)
        _authState = StateObject(wrappedValue: authState)
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authState)
                .environmentObject(toastManager)
        }
    }
}
```

この修正により、`ToastManager`は`@StateObject`で一度だけ初期化され、`AuthState`に渡されます。

---

## 👤 ユーザー
*2023/5/10 17:18:00*

ContentView() 側の実装で ContentViewModelを作成して、そこでToastManagerでの値を変更したいんだけど

---

## 🤖 アシスタント
*2023/5/10 17:20:12*

ContentView で使用する `ContentViewModel` を作成し、その中で `ToastManager` を操作するように変更します。

1. `ContentViewModel` を作成し、`ToastManager` を `@EnvironmentObject` として参照します。

```swift
import SwiftUI
import FirebaseAuth

class ContentViewModel: ObservableObject {
    @Published var user: User?
    @EnvironmentObject var toastManager: ToastManager

    private var handle: AuthStateDidChangeListenerHandle?

    init() {
        handle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            if let previousUser = self?.user, let newUser = user, previousUser != newUser {
                self?.toastManager.show(message: "Logged in as \(newUser.email ?? "unknown")")
            } else if self?.user != nil, user == nil {
                self?.toastManager.show(message: "Logged out")
            }
            self?.user = user
        }
    }

    deinit {
        if let handle = handle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
}
```

2. `ContentView` で `ContentViewModel` を `@StateObject` として定義し、`ToastManager` を `@EnvironmentObject` として参照します。

```swift
struct ContentView: View {
    @StateObject private var contentViewModel = ContentViewModel()
    @EnvironmentObject var toastManager: ToastManager

    var body: some View {
        ZStack {
            if let user = contentViewModel.user {
                Text("Logged in as \(user.displayName ?? user.email ?? "unknown")")
            } else {
                Text("Not logged in")
            }

            if toastManager.isShowing {
                Toast(message: toastManager.message)
                    .transition(.opacity.animation(.easeInOut(duration: 0.2)))
            }
        }
        .animation(.default, value: toastManager.isShowing)
    }
}
```

3. `YourAppName` で `ContentViewModel` を `@StateObject` として定義する必要はありません。また、`AuthState` を削除し、代わりに `ContentViewModel` を使います。

```swift
import SwiftUI

@main
struct YourAppName: App {
    @StateObject private var toastManager = ToastManager()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(toastManager)
        }
    }
}
```

これで、`ContentViewModel` で Firebase のログイン/ログアウトの状態を監視し、`ToastManager` での値を変更できます。

---

## 👤 ユーザー
*2023/5/10 17:20:30*

class ContentViewModel: ObservableObject で　EnvironmentObject 使えない気がします

---

## 🤖 アシスタント
*2023/5/10 17:22:10*

おっしゃる通り、`ObservableObject`の中で`EnvironmentObject`を使うことはできません。代わりに、`ToastManager`を`ContentViewModel`のイニシャライザで渡すことができます。

1. `ContentViewModel`のイニシャライザで`ToastManager`を受け取り、プロパティとして保持します。

```swift
import SwiftUI
import FirebaseAuth

class ContentViewModel: ObservableObject {
    @Published var user: User?
    private let toastManager: ToastManager

    private var handle: AuthStateDidChangeListenerHandle?

    init(toastManager: ToastManager) {
        self.toastManager = toastManager
        handle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            if let previousUser = self?.user, let newUser = user, previousUser != newUser {
                self?.toastManager.show(message: "Logged in as \(newUser.email ?? "unknown")")
            } else if self?.user != nil, user == nil {
                self?.toastManager.show(message: "Logged out")
            }
            self?.user = user
        }
    }

    deinit {
        if let handle = handle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
}
```

2. `ContentView`で`ContentViewModel`を初期化する際に、`toastManager`を引数として渡します。

```swift
struct ContentView: View {
    @StateObject private var contentViewModel: ContentViewModel
    @EnvironmentObject var toastManager: ToastManager

    init() {
        let contentViewModel = ContentViewModel(toastManager: toastManager)
        _contentViewModel = StateObject(wrappedValue: contentViewModel)
    }

    var body: some View {
        // 既存のコードをここに記述
    }
}
```

この変更により、`ContentViewModel`で`ToastManager`を正しく参照し、ログインとログアウト時にトーストを表示できます。

---

## 👤 ユーザー
*2023/5/10 17:24:35*

ありがとう、たとえば、テスト時にはAuthStateやToastManagerをモックとして使いたいんだけど、どうすればいいのかな

---

## 🤖 アシスタント
*2023/5/10 17:27:13*

テスト時に`AuthState`や`ToastManager`をモックとして使用するには、プロトコルを使って依存性を抽象化し、テスト時にモック実装を注入できるようにします。

1. `AuthStateProtocol`と`ToastManagerProtocol`プロトコルを定義します。

```swift
protocol AuthStateProtocol: ObservableObject {
    var user: User? { get }
}

protocol ToastManagerProtocol: ObservableObject {
    func show(message: String, duration: TimeInterval)
}
```

2. `AuthState`と`ToastManager`がこれらのプロトコルに準拠するようにします。

```swift
class AuthState: ObservableObject, AuthStateProtocol {
    // 既存の実装を維持
}

class ToastManager: ObservableObject, ToastManagerProtocol {
    // 既存の実装を維持
}
```

3. `ContentViewModel`のイニシャライザでプロトコルを受け取るように変更します。

```swift
class ContentViewModel: ObservableObject {
    @Published var user: User?
    private let authState: AuthStateProtocol
    private let toastManager: ToastManagerProtocol

    init(authState: AuthStateProtocol, toastManager: ToastManagerProtocol) {
        self.authState = authState
        self.toastManager = toastManager
        // 以降の実装
    }
}
```

4. `ContentView`のイニシャライザで`ContentViewModel`を初期化する際に、プロトコルの実装を渡します。

```swift
struct ContentView: View {
    @StateObject private var contentViewModel: ContentViewModel

    init(authState: AuthStateProtocol, toastManager: ToastManagerProtocol) {
        let contentViewModel = ContentViewModel(authState: authState, toastManager: toastManager)
        _contentViewModel = StateObject(wrappedValue: contentViewModel)
    }

    // 既存のコードをここに記述
}
```

5. `YourAppName`で`ContentView`を初期化する際に、実装を渡します。

```swift
@main
struct YourAppName: App {
    @StateObject private var authState = AuthState()
    @StateObject private var toastManager = ToastManager()

    var body: some Scene {
        WindowGroup {
            ContentView(authState: authState, toastManager: toastManager)
        }
    }
}
```

これで、テスト時に`AuthState`や`ToastManager`のモック実装を使用することができます。モック実装は、プロトコルに準拠したクラスを作成し、テスト用の振る舞いを実装します。その後、テスト時に`ContentView`を初期化する際に、モック実装を渡すことで、テストを実行できます。

---

## 👤 ユーザー
*2023/5/10 17:28:12*

ToastManager は @EnvironmentObject として他の画面でも使いたいんだけど、どうすればいい？

---

## 🤖 アシスタント
*2023/5/10 17:29:23*

すでに`ToastManager`を`@EnvironmentObject`としてアプリ全体で共有するように設定しているので、他の画面でも`ToastManager`を使用できます。他の画面で`ToastManager`を使用するには、`@EnvironmentObject`プロパティラッパーを使って参照します。

例として、新しい`AnotherView`を作成し、`ToastManager`を使用する方法を示します。

```swift
struct AnotherView: View {
    @EnvironmentObject var toastManager: ToastManager

    var body: some View {
        VStack {
            Button(action: {
                toastManager.show(message: "Hello from AnotherView!")
            }) {
                Text("Show toast")
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
        }
    }
}
```

この`AnotherView`は、`ToastManager`を`@EnvironmentObject`として使用しており、ボタンを押すことでトーストを表示します。

他の画面でも`ToastManager`を使いたい場合、同様に`@EnvironmentObject`プロパティラッパーを使って`ToastManager`を参照してください。ただし、`ToastManager`を`@EnvironmentObject`として注入した`YourAppName`から遷移したビューでのみ利用できることに注意してください。

---
