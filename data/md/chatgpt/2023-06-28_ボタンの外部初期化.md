# ボタンの外部初期化

日付: 2023-06-28

---

## 👤 ユーザー
*2023/6/29 7:14:31*

ボタンを押した時の処理を外側から初期化時に設定できる方法を教えて欲しい

struct SkipButtonView: View {
    @Binding var resultType: MissionVideoWatchResultType?

    var body: some View {
        Button {
            // 本来はスキップボタンを非表示にする仕様だが、開発中はスキップするようにしておく。後ほど修正
//            presenter.shouldShowSkipButton = false
            resultType = .didSkip
        } label: {
            HStack(spacing: 8) {
                Text(CoreStrings.EmomilMission.WatchVideo.skip)
                    // TODO: Replace to ColorAsset name
                    .foregroundColor(CoreAssets.Color.Primary.primary100.swiftUIColor)
                    .typographyStyle(.button3)
                MissionAssets.skipIcon.swiftUIImage
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
        }
        .tint(CoreAssets.Color.Neutral.white.swiftUIColor)
        .buttonStyle(.bordered)
        .buttonBorderShape(.capsule)
    }
}

struct SkipButtonView\_Previews: PreviewProvider {
    @State static var resultType: MissionVideoWatchResultType?
    static var previews: some View {
        SkipButtonView(resultType: $resultType)
    }
}

---

## 🤖 アシスタント
*2023/6/29 7:15:07*

この場合、ボタンがタップされたときに呼び出されるクロージャを引数として渡すことができます。そのクロージャをボタンのアクションとして設定することで、ボタンが押されたときに呼び出されるメソッドを外部から設定できます。

以下に示すように、`SkipButtonView`の定義を変更しましょう：

```swift
struct SkipButtonView: View {
    var onSkip: () -> Void

    var body: some View {
        Button(action: onSkip) {
            HStack(spacing: 8) {
                Text(CoreStrings.EmomilMission.WatchVideo.skip)
                    .foregroundColor(CoreAssets.Color.Primary.primary100.swiftUIColor)
                    .typographyStyle(.button3)
                MissionAssets.skipIcon.swiftUIImage
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
        }
        .tint(CoreAssets.Color.Neutral.white.swiftUIColor)
        .buttonStyle(.bordered)
        .buttonBorderShape(.capsule)
    }
}
```

このようにすることで、`SkipButtonView`を使用するときに、スキップボタンが押されたときに何を行うべきかを定義できます。例えば、次のように使用することができます：

```swift
@State var resultType: MissionVideoWatchResultType?

var body: some View {
    SkipButtonView {
        resultType = .didSkip
    }
}
```

この例では、ボタンが押されたときに`resultType`を`.didSkip`に設定しています。しかし、ボタンのアクションを別のものに変更することも可能です。この変更は、`SkipButtonView`の使用方法をより柔軟にし、再利用可能にします。

---

## 👤 ユーザー
*2023/6/29 7:15:33*

onSkip はnilもいけるようにしたいのと、イニシャライザをちゃんと定義したい

---

## 🤖 アシスタント
*2023/6/29 7:16:04*

`onSkip`が`nil`の可能性を考慮に入れるためには、`onSkip`をオプショナル型にする必要があります。その上で、イニシャライザを定義して引数のデフォルト値を`nil`に設定すれば、この引数を省略して`SkipButtonView`を作成することができます。

以下のように変更してみてください：

```swift
struct SkipButtonView: View {
    var onSkip: (() -> Void)?

    init(onSkip: (() -> Void)? = nil) {
        self.onSkip = onSkip
    }

    var body: some View {
        Button(action: {
            self.onSkip?()
        }) {
            HStack(spacing: 8) {
                Text(CoreStrings.EmomilMission.WatchVideo.skip)
                    .foregroundColor(CoreAssets.Color.Primary.primary100.swiftUIColor)
                    .typographyStyle(.button3)
                MissionAssets.skipIcon.swiftUIImage
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
        }
        .tint(CoreAssets.Color.Neutral.white.swiftUIColor)
        .buttonStyle(.bordered)
        .buttonBorderShape(.capsule)
    }
}
```

ここで`onSkip`はオプショナル型で、デフォルト値は`nil`に設定されています。ボタンのアクションで`onSkip`を呼び出すときには、`self.onSkip?()`とすることで`nil`チェックを行います。`onSkip`が`nil`の場合、アクションは何も実行されません。

これにより、以下のように`SkipButtonView`を初期化することが可能になります：

```swift
SkipButtonView()
```

または、アクションを提供することもできます：

```swift
SkipButtonView {
    print("Button pressed!")
}
```

---

## 👤 ユーザー
*2023/6/29 7:17:16*

@escapingはいらないの？

---

## 🤖 アシスタント
*2023/6/29 7:17:45*

`@escaping`属性は、関数やメソッドの引数として渡されるクロージャが、関数やメソッドのスコープを「逃れる」（escaping）場合、つまり関数やメソッドの実行が終了した後も存続する可能性がある場合に必要です。 

しかし、この場合には`onSkip`クロージャは、ボタンがタップされた時にすぐに実行され、関数またはメソッドのスコープを「逃れる」必要はありません。そのため、この特定のケースでは`@escaping`属性は必要ないと言えます。

ただし、ある状況では`@escaping`が必要になることもあります。例えば、非同期の処理を扱う場合や、クロージャをプロパティやグローバル変数に保存して後で使用する場合などは`@escaping`属性が必要となります。そのような状況に直面した場合は、Swiftのコンパイラが`@escaping`属性の必要性を教えてくれます。

現在の`SkipButtonView`の定義においては、`@escaping`は必要ないと考えられますが、もし`onSkip`クロージャを保存して後で使用するような処理を追加する場合には、`@escaping`属性が必要になることを念頭に置いてください。

---
