# Bash配列文字列処理

日付: 2023-09-14

---

## 👤 ユーザー
*2023/9/15 2:25:06*

bash で以下の処理は何をしているかわかる？


TARGETS=("EmomilCore" "EmomilMiddleware" "EmomilDataTransfer" \
        "EmomilAnalysis" "EmomilOnboarding" "EmomilLogin" "EmomilRecommend" \
        "EmomilResearch" "EmomilPoint" "EmomilSetting" "SampleAppGazeTracker" \
        "SampleAppWebViewTracker" "EmomilGazeTrackCalibration" "EmomilGazeTracker" \
        "EmomilDebug" "EmomilBase")
TARGETS=$(printf '%s,' "${TARGETS[@]}")
TARGETS=${TARGETS%,}

---

## 🤖 アシスタント
*2023/9/15 2:25:42*

このbashの処理は以下のことを行っています：

1. `TARGETS` という配列にいくつかの文字列を初期化しています。
2. `printf` コマンドを使用して、配列のすべての要素をカンマ `,` で連結しています。
3. 最後のカンマを削除しています。

具体的な手順としては：

1. `TARGETS`という配列は、多くの文字列を含んでいます。
2. `printf '%s,' "${TARGETS[@]}"` の部分は、配列の各要素を`,`（カンマ）で連結します。たとえば、`("A" "B" "C")` の場合、結果は `A,B,C,` となります。
3. `TARGETS=${TARGETS%,}` この部分は、文字列の末尾のカンマを削除します。`A,B,C,` の場合、`A,B,C` に変換されます。

最終的に、`TARGETS` 変数はカンマで連結された文字列を保持しますが、末尾にカンマはありません。

---

## 👤 ユーザー
*2023/9/15 2:25:43*

これをもっと簡単な記述でできないのかな？

---

## 🤖 アシスタント
*2023/9/15 2:26:11*

もちろん、bash で提供されている配列の結合機能を使用することで、より簡潔に同じ処理を行うことができます。

以下のように書き換えることができます：

```bash
TARGETS=("EmomilCore" "EmomilMiddleware" "EmomilDataTransfer" \
        "EmomilAnalysis" "EmomilOnboarding" "EmomilLogin" "EmomilRecommend" \
        "EmomilResearch" "EmomilPoint" "EmomilSetting" "SampleAppGazeTracker" \
        "SampleAppWebViewTracker" "EmomilGazeTrackCalibration" "EmomilGazeTracker" \
        "EmomilDebug" "EmomilBase")

TARGETS=$(IFS=,; echo "${TARGETS[*]}")
```

この方法で、IFS（Internal Field Separator）変数を一時的にカンマ `,` に変更して、`${TARGETS[*]}` という配列を一つの文字列として出力することができます。

---

## 👤 ユーザー
*2023/9/15 2:27:42*

以下をアルファベット順にならべてほしい

TARGETS=("EmomilCore" "EmomilMiddleware" "EmomilDataTransfer" \
        "EmomilAnalysis" "EmomilOnboarding" "EmomilLogin" "EmomilRecommend" \
        "EmomilResearch" "EmomilPoint" "EmomilSetting" "SampleAppGazeTracker" \
        "SampleAppWebViewTracker" "EmomilGazeTrackCalibration" "EmomilGazeTracker" \
        "EmomilDebug" "EmomilBase")

---

## 🤖 アシスタント
*2023/9/15 2:28:20*

まず、配列をアルファベット順にソートする方法を示します：

```bash
TARGETS=("EmomilCore" "EmomilMiddleware" "EmomilDataTransfer" \
        "EmomilAnalysis" "EmomilOnboarding" "EmomilLogin" "EmomilRecommend" \
        "EmomilResearch" "EmomilPoint" "EmomilSetting" "SampleAppGazeTracker" \
        "SampleAppWebViewTracker" "EmomilGazeTrackCalibration" "EmomilGazeTracker" \
        "EmomilDebug" "EmomilBase")

# 配列をソート
sorted_targets=( $(printf "%s\n" "${TARGETS[@]}" | sort) )
```

ソートした結果の`sorted_targets`配列は以下の通りになります：

```bash
("EmomilAnalysis" "EmomilBase" "EmomilCore" "EmomilDataTransfer" "EmomilDebug" \
"EmomilGazeTrackCalibration" "EmomilGazeTracker" "EmomilLogin" "EmomilMiddleware" \
"EmomilOnboarding" "EmomilPoint" "EmomilRecommend" "EmomilResearch" "EmomilSetting" \
"SampleAppGazeTracker" "SampleAppWebViewTracker")
```

この方法で、`TARGETS` 配列の要素がアルファベット順にソートされた新しい配列 `sorted_targets` を得ることができます。

---
