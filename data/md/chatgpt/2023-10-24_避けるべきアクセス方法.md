# 避けるべきアクセス方法

日付: 2023-10-24

---

## 👤 ユーザー
*2023/10/24 19:27:36*

あまり、indexによるアクセスを行わないようにしたい。

@MainActor
final class AgreementsPresenter: ObservableObject {
    @Published private(set) var currentAgreement: Agreement
    private let agreements: \[Agreement\]

    @Published private(set) var appError: AppError?
    @Published var shouldShowAlert = false
    @Published private(set) var shouldDismiss = false

    private let apiRequestManager: ApiRequestManagerProtocol

    init(agreements: \[Agreement\],
         apiRequestManager: ApiRequestManagerProtocol = AmplifyApiRequestManager())
    {
        self.agreements = agreements
        currentAgreement = agreements\[0\]
        self.apiRequestManager = apiRequestManager
    }

    func onAgreeButtonTapped() {
        guard currentAgreement == agreements.last else {
            if let index = agreements.firstIndex(of: currentAgreement) {
                currentAgreement = agreements\[index + 1\]
            }
            return
        }

        Task {
            do {
                try await apiRequestManager.agreeAgreements(agreements: agreements.map { $0.id })
                shouldDismiss = true
            } catch {
                LoggerContainer.logError("\\(error): \\(error.localizedDescription)")
            }
        }
    }

    func onNotAgreeButtonTapped() {
        switch currentAgreement.type {
        case .termsOfUse:
            appError = .notAgreementTermsOfUse
        case .privacyPolicy:
            appError = .notAgreementPrivacyPolicy
        }
        shouldShowAlert = true
    }
}

---

## 🤖 アシスタント
*2023/10/24 19:28:28*

コードを見ると、`AgreementsPresenter`は複数の`Agreement`を処理し、ユーザーが各`Agreement`に同意するかどうかを制御することがわかります。現在、`currentAgreement`を更新する際にインデックスベースのアクセスが使用されていますが、これを避けるには、`Agreement`のインスタンス自体を直接操作するか、またはイテレータパターンを使用するなどのアプローチがあります。

以下の方法でインデックスアクセスを避けることができます：

1. **イテレータパターンの使用**:
    `agreements`配列に対してカスタムイテレータを作成することができます。このイテレータは、`next()`メソッドを使用して、配列の次の要素を提供できます。これにより、現在の`Agreement`を追跡する際にインデックスを使用する必要がなくなります。

    ```swift
    struct AgreementsIterator {
        private let agreements: [Agreement]
        private var current = 0

        init(agreements: [Agreement]) {
            self.agreements = agreements
        }

        mutating func next() -> Agreement? {
            guard current < agreements.count else { return nil }
            let agreement = agreements[current]
            current += 1
            return agreement
        }
    }
    ```

    そして、`AgreementsPresenter`にこのイテレータを追加します：

    ```swift
    final class AgreementsPresenter: ObservableObject {
        //...
        private var agreementsIterator: AgreementsIterator

        init(agreements: [Agreement],
             apiRequestManager: ApiRequestManagerProtocol = AmplifyApiRequestManager())
        {
            self.agreements = agreements
            self.agreementsIterator = AgreementsIterator(agreements: agreements)
            self.currentAgreement = agreementsIterator.next()!
            //...
        }
    ```

    この変更により、`onAgreeButtonTapped`メソッドは、`agreementsIterator.next()`を呼び出すことで次の`Agreement`に簡単にアクセスできます。

2. **キューベースのアプローチ**:
    また、`Agreement`オブジェクトのキューを維持し、ユーザーが同意するたびにキューから要素を削除することもできます。これにより、常にキューの先頭にある`Agreement`が現在のものになります。

    ```swift
    final class AgreementsPresenter: ObservableObject {
        //...
        private var agreementsQueue: Queue<Agreement>

        init(agreements: [Agreement],
             apiRequestManager: ApiRequestManagerProtocol = AmplifyApiRequestManager())
        {
            self.agreementsQueue = Queue<Agreement>(agreements)
            self.currentAgreement = agreementsQueue.dequeue()!
            //...
        }
    ```

    ここで、`Queue`はあなたが実装するシンプルなジェネリックキューです。`dequeue`メソッドはキューの先頭の要素を削除し、それを返します。これにより、`onAgreeButtonTapped`が呼び出されるたびに、`currentAgreement`はキューの次の要素に自動的に更新されます。

これらの方法は、インデックスに依存する代わりに、コレクションの現在の位置を自動的に追跡します。これにより、特定のインデックスの要素にアクセスする必要性が軽減され、コードがより直感的でエラーが発生しにくくなります。

---

## 👤 ユーザー
*2023/10/24 19:28:42*

もっとsimpleにできないの？

---

## 🤖 アシスタント
*2023/10/24 19:29:07*

もちろんです。もっとシンプルにするために、`Agreements`配列を`ArraySlice`として管理し、要素を処理するたびにそのスライスを更新することができます。この方法では、`currentAgreement`を更新する際にインデックスを使用する必要がなくなります。

以下がその実装です：

```swift
final class AgreementsPresenter: ObservableObject {
    @Published private(set) var currentAgreement: Agreement
    private var remainingAgreements: ArraySlice<Agreement>

    //... その他の変数は変更なし ...

    init(agreements: [Agreement],
         apiRequestManager: ApiRequestManagerProtocol = AmplifyApiRequestManager())
    {
        self.remainingAgreements = ArraySlice(agreements)
        self.currentAgreement = remainingAgreements.popFirst()!  // 最初のAgreementを取得し、スライスを更新
        //... その他の初期化は変更なし ...
    }

    func onAgreeButtonTapped() {
        if let nextAgreement = remainingAgreements.popFirst() { // 次のAgreementがあるか確認し、スライスを更新
            currentAgreement = nextAgreement
        } else {
            // 残りのAgreementがない場合の処理 (API呼び出し等)
            Task {
                // ... 既存のコード ...
            }
        }
    }

    //... その他のメソッドは変更なし ...
}
```

この変更により、`ArraySlice`の`popFirst()`メソッドを使用して、次の`Agreement`を取得しながら`remainingAgreements`スライスを更新します。これにより、インデックスを直接操作する必要がなくなり、コードがよりシンプルかつ直感的になります。さらに、`ArraySlice`は元の配列の一部を表すため、新しいストレージを必要とせず、メモリ効率も良好です。

---

## 👤 ユーザー
*2023/10/24 19:29:39*

なるほどちなみに、空配列が来たらどうなるの？’

---

## 🤖 アシスタント
*2023/10/24 19:30:19*

空の配列が`AgreementsPresenter`の`init`メソッドに渡された場合、現在のコードではクラッシュが発生する可能性があります。これは、`currentAgreement`を設定する際に、配列の最初の要素を強制的にアンラップ（`!`）しているためです。配列が空の場合、これは`nil`になり、強制アンラップ時にランタイムエラーが発生します。

この問題を解決するためには、空の配列を適切に処理する必要があります。以下のいくつかのアプローチがあります：

1. **初期化時に空の配列をチェックする**:
   `init`メソッド内で配列が空でないことを確認し、空の場合はエラーをスローするか、デフォルト値を設定します。

   ```swift
   init(agreements: [Agreement], apiRequestManager: ApiRequestManagerProtocol = AmplifyApiRequestManager()) throws {
       guard !agreements.isEmpty else {
           throw SomeInitError.emptyAgreements
           // または適切なデフォルト値を設定
       }
       self.remainingAgreements = ArraySlice(agreements)
       self.currentAgreement = remainingAgreements.popFirst()!
       // ...
   }
   ```

2. **`currentAgreement`をオプショナルにする**:
   `currentAgreement`をオプショナル（`Agreement?`）として宣言し、それに対するアクセスを安全に行います。

   ```swift
   @Published private(set) var currentAgreement: Agreement?

   init(agreements: [Agreement], apiRequestManager: ApiRequestManagerProtocol = AmplifyApiRequestManager()) {
       self.remainingAgreements = ArraySlice(agreements)
       self.currentAgreement = remainingAgreements.popFirst()  // 強制アンラップを使用しない
       // ...
   }

   func onAgreeButtonTapped() {
       if let nextAgreement = remainingAgreements.popFirst() {
           currentAgreement = nextAgreement
       } else {
           // ...
       }
   }
   ```

   この変更により、`currentAgreement`が`nil`の場合でもアプリはクラッシュしませんが、UIを更新する際やその他のメソッドで`currentAgreement`を使用する際には、その値が`nil`でないことを確認する必要があります。

これらのアプローチは、空の配列が渡された場合のエラー処理を提供し、アプリの安全性と安定性を向上させます。どの方法を選択するかは、アプリの要件と期待されるユーザーエクスペリエンスによって異なります。

---

## 👤 ユーザー
*2023/10/24 19:32:15*

guard 文より if 文のほうがわかりやすいかも、最後のインデックスだったら同意処理を実行して、最後のインデックスでなければ次のインデックスに移動するイメージです。

func onAgreeButtonTapped() {
        guard currentAgreement == agreements.last else {
            if let index = agreements.firstIndex(of: currentAgreement) {
                currentAgreement = agreements\[index + 1\]
            }
            return
        }

        Task {
            do {
                try await apiRequestManager.agreeAgreements(agreements: agreements.map { $0.id })
                shouldDismiss = true
            } catch {
                LoggerContainer.logError("\\(error): \\(error.localizedDescription)")
            }
        }
    }

---

## 🤖 アシスタント
*2023/10/24 19:32:46*

`guard`文の代わりに`if`文を使用し、処理の流れをより明確にすることができます。また、最後のインデックスをチェックする場面で、`ArraySlice`を使用すると、配列が空である場合にも対応できる安全なコードになります。

以下はそのように改良された`onAgreeButtonTapped`メソッドです：

```swift
func onAgreeButtonTapped() {
    if currentAgreement == agreements.last {
        // 最後の契約に到達した場合、同意の処理を行う
        Task {
            do {
                try await apiRequestManager.agreeAgreements(agreements: agreements.map { $0.id })
                shouldDismiss = true
            } catch {
                LoggerContainer.logError("\(error): \(error.localizedDescription)")
            }
        }
    } else {
        // 最後の契約でなければ、次の契約に進む
        if let nextAgreement = remainingAgreements.popFirst() {
            currentAgreement = nextAgreement
        }
    }
}
```

このコードでは、`if`文を使用して`currentAgreement`が`agreements`配列の最後の要素かどうかをチェックしています。もし最後の要素であれば、同意のAPIリクエストを実行し、そうでなければ、`remainingAgreements`から次の`Agreement`を取得して`currentAgreement`を更新します。

`ArraySlice`の`popFirst()`メソッドは、スライスから要素を安全に取り出し、同時にスライスを更新します。このメソッドは`nil`を返す可能性があるため、`if let`を使用して安全にアンラップしています。これにより、空の配列や最後の要素を超えてアクセスしようとする場合に、アプリがクラッシュするのを防ぎます。

---
