# ボタンタップで画面遷移を制御する

日付: 2023-06-27

---

## 👤 ユーザー
*2023/06/28 05:42:46*

NavigationLink 内のボタンをタップするとpresenter.nextButtonTapped()の処理がよばれる前にshouldPushPageがtrueとなってしまって画面が遷移してしまう。どうすればいいのか？

struct MissionPreparationView: View {
    @EnvironmentObject private var navigator: MissionPageNavigator
    @StateObject private var presenter: MissionPreparationPresenter
    @Binding var finishedMissionType: MissionValueType?

    init(missionTypeDetail: MissionTypeDetail,
         stepType: MissionPreparationPresenter.MissionStepType, finishedMissionType: Binding&lt;MissionValueType?&gt;)
    {
        _presenter = .init(wrappedValue: .init(missionTypeDetail: missionTypeDetail, stepType: stepType))
        _finishedMissionType = finishedMissionType
    }

    var body: some View {
        ZStack {
            VStack(alignment: .leading) {
                if let missionType = presenter.missionType {
                    EmomilIconBubbleView(text: bubbleText, type: .horizontal, multilineTextAlignment: .leading)
                    MissionPreparationIconViewView(missionType: missionType)
                    Spacer()
                }

                NavigationLink(isActive: $presenter.shouldPushPage) {
                    nextPageView
                } label: {
                    Button {
                        Task {
                            await presenter.nextButtonTapped()
                        }
                    } label: {
                        Text(buttonText)
                    }
                }
            }
            RetryButton(didTap: $presenter.retryTapEvent)
                .isHidden(presenter.error == nil, remove: true)
        }
        .padding()
        .frame(maxWidth: .infinity)
        .overlayLoading(isPresented: $presenter.isLoading, allowsGesture: false)
        .background(CoreAssets.Color.Neutral.neutral5.swiftUIColor)
        .buttonStyle(CustomButtonStyle(.primary))
        .navigationTitle(CoreStrings.Common.request)
        .navigationBarBackButtonHidden(true)
        .toolbar {
            ToolbarItem(placement: .navigationBarLeading) {
                CloseButton(dismissEnable: false) {
                    navigator.shouldShowMissionPage = false
                }
            }
        }
        .task {
            await presenter.fetchMissionType()
        }
    }
}

---

## 🤖 アシスタント
*2023/06/28 05:43:24*

`NavigationLink`が自動的に画面遷移を行うのはその設計上の特性です。一般的に`NavigationLink`の`isActive`パラメータは画面遷移のトリガーとなるため、あなたのコードにおける`presenter.shouldPushPage`がtrueになるとすぐに遷移が始まります。このため、`presenter.nextButtonTapped()`が完了する前に遷移が開始されてしまいます。

この問題を解決するための一つのアプローチは、`presenter.nextButtonTapped()`が終了するまで遷移を遅らせることです。具体的には、`NavigationLink`の`isActive`が直接`presenter.shouldPushPage`にバインドされるのではなく、新たな`@State`変数を作成してそれにバインドします。そして、`presenter.nextButtonTapped()`が終了した後で、その新たな`@State`変数を`presenter.shouldPushPage`の値で更新します。こうすることで、`NavigationLink`の`isActive`がtrueになり、画面遷移が始まるタイミングを制御することができます。

コードは以下のようになります:

```swift
struct MissionPreparationView: View {
    //...
    @State private var shouldPush = false

    var body: some View {
        //...
        NavigationLink(destination: nextPageView, isActive: $shouldPush) {
            EmptyView()
        }
        //...
        Button {
            Task {
                await presenter.nextButtonTapped()
                shouldPush = presenter.shouldPushPage
            }
        } label: {
            Text(buttonText)
        }
        //...
    }
    //...
}
```

この修正により、ボタンがタップされると`presenter.nextButtonTapped()`が呼び出され、その処理が完了した後に画面遷移が開始されます。

---

## 👤 ユーザー
*2023/06/28 05:43:52*

もっとスマートな方法ないの？

---

## 🤖 アシスタント
*2023/06/28 05:44:35*

はい、もう一つのアプローチとして、画面遷移を管理する責任を`presenter`に委ねることが考えられます。それにより、画面遷移のタイミングを`presenter`の制御下に置くことができます。

`MissionPreparationPresenter`に`nextPage`という`@Published`プロパティを追加します。この`nextPage`は遷移先の画面（ビュー）を保持します。そして、`nextButtonTapped`メソッド内で、必要な処理が全て完了した後に`nextPage`を設定します。

それから、`MissionPreparationView`内の`NavigationLink`の遷移先を`presenter.nextPage`にバインドします。こうすることで、`presenter.nextPage`がnilでない場合にのみ遷移が行われるようになります。

ここに具体的なコードを示します:

```swift
class MissionPreparationPresenter: ObservableObject {
    //...
    @Published var nextPage: AnyView? = nil

    func nextButtonTapped() async {
        //...
        // do your logic
        //...
        DispatchQueue.main.async {
            self.nextPage = AnyView(NextView()) // Replace `NextView()` with your actual next view.
        }
    }
}

struct MissionPreparationView: View {
    //...
    var body: some View {
        //...
        if let nextPage = presenter.nextPage {
            NavigationLink(destination: nextPage) {
                EmptyView()
            }
        }
        Button {
            Task {
                await presenter.nextButtonTapped()
            }
        } label: {
            Text(buttonText)
        }
        //...
    }
    //...
}
```

このように、遷移先の画面を`presenter`で管理することで、画面遷移のタイミングをより正確に制御することができます。ただし、この方法では`AnyView`を使用していますので、型安全性が失われてしまいます。また、`AnyView`はパフォーマンスに影響を及ぼす可能性もありますので、ご注意ください。

---
