# リスナー制御方法

日付: 2025-01-12

---

## 👤 ユーザー
*2025/01/12 17:48:18*

..listen&lt;AsyncValue&lt;String?&gt;&gt;(
        requestCodeNotifierProvider,
        (previous, next) {
          next.whenOrNull(
            data: (data) {
              if (data != null) {
                context.push(Screen.verificationCode.path);
              }
            },
            error: (error, stackTrace) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Failed to send request: $error'),
                ),
              );
              context.push(Screen.verificationCode.path);
            },
          );
        },
      );
このlistenが残り続けて困っている。このlistenの処理はこのページでしか処理しないように制御したい。つまりpush先でrequestCodeNotifierProviderを使っても問題なくしたい

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/design_token/color_token.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_accounts_info.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/auth/request_code.dart';

class LoginPage extends HookConsumerWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final textEditingController = useTextEditingController();

    useEffect(
      () {
        Future.microtask(() {
          ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
        });
        return null;
      },
      [],
    );

    ref
      ..listen&lt;AsyncValue&lt;AccountResponseDTOData?&gt;&gt;(
        getMyAccountNotifierProvider,
        (previous, next) {
          next.whenOrNull(
            data: (account) {
              if (account != null) {
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  // TODO: 一時的にコメントアウト
                  // context.go(Screen.map.path);
                });
              }
            },
            error: (error, stack) {
              debugPrint('Failed to fetch account info: $error');
            },
          );
        },
      )
      ..listen&lt;AsyncValue&lt;String?&gt;&gt;(
        requestCodeNotifierProvider,
        (previous, next) {
          next.whenOrNull(
            data: (data) {
              if (data != null) {
                context.push(Screen.verificationCode.path);
              }
            },
            error: (error, stackTrace) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Failed to send request: $error'),
                ),
              );
              context.push(Screen.verificationCode.path);
            },
          );
        },
      );

    return Scaffold(
      body: GestureDetector(
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: Center(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  GestureDetector(
                    onLongPress: () {
                      // TODO: flavor が dev の場合のみの機能
                      context.push(Screen.debugMenu.path);
                    },
                    child: SvgPicture.asset(
                      Assets.images.logoLogin.path,
                    ),
                  ),
                  const SizedBox(height: 38),
                  Image.asset(
                    Assets.images.loginFig.path,
                  ),
                  const SizedBox(height: 54),
                  TextField(
                    controller: textEditingController,
                    decoration: const InputDecoration(
                      prefixIcon: Padding(
                        padding: EdgeInsets.all(12),
                        child: Icon(
                          Icons.email_outlined,
                          color: ColorToken.text,
                          size: 24,
                        ),
                      ),
                      hintText: 'Enter your email',
                    ),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () async {
                      final email = textEditingController.text.trim();

                      if (email.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Please enter a valid email.'),
                          ),
                        );
                        return;
                      }

                      await ref
                          .read(requestCodeNotifierProvider.notifier)
                          .requestCode(email);
                    },
                    child: const Text('Login'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

---

## 🔧 ツール
*2025/01/12 17:48:40*

**Addressing persistent listening**

I’m thinking through how to handle the ongoing `listen` in Dart/Flutter with hooks_riverpod. The issue is that it persists, causing problems. The goal is to keep processing limited to a specific page, ensuring smooth navigation on the pushed screen.

**Balancing listeners**

OK, I’m thinking through the use of listeners in the widget. The challenge is managing listeners efficiently while ensuring seamless navigation without conflicts.

**Revisiting listener scope**

I’m addressing that `ref.listen` is inside the build method, leading to repeated listener attachments. This means the widget rebuilds triggering unnecessary execution, which can be optimized.

**Optimizing listener setup**

Interestingly enough, the `ref.listen` method, often mistakenly reattached during rebuilds, can be improved by wrapping it in `useEffect` with a dependency array, ensuring a single subscription post-widget creation.

**Handling listener persistence on navigation**

OK, I’m exploring how listeners stay active on new pages unless explicitly removed. Using hooks_riverpod, ensure careful management to avoid unintended reactivity and conflicts during navigation.

**Managing listener state**

OK, let me see. To manage listener state on navigation, I’m thinking about a local provider resetting its state after each event, or using `ref.listen` within `useEffect` for automatic unsubscription upon disposal.

**Crafting listener management**

I’m piecing together that `ref.listen` with a `listenWhen` argument can toggle listeners based on page activity, or resetting the notifier state in the provider after navigating to `Screen.verificationCode` might work better.

**Navigating provider scoping**

I’m thinking about using `ProviderScope` to create a new provider instance when a new page is pushed, ensuring the listener doesn’t carry over, maintaining clarity and avoiding conflicts.

**Separating concerns**

Taking a closer look, I’m thinking about stopping the listen on the login page when moving to `Screen.verificationCode` to avoid conflicts, ensuring clear separation across routes.

**Canceling listeners**

I’m exploring methods to manage listener subscriptions dynamically, such as calling a cancellation method or conditionally subscribing via `useEffect` based on the current route, possibly with a local variable.

**Enhancing navigation management**

I’m creating a `didNavigate` flag to control the listener's behavior in `useEffect`, ensuring it only activates when necessary, preventing unwanted navigational triggers.

**Enhancing navigation stability**

I’m developing a `didNavigate` flag to control listener activation, ensuring adherence to the current route, and preventing cascading navigation triggers.

**Choosing the best method** 

I’m thinking about using a local flag to dismiss changes after the first push or creating a new provider instance to isolate listeners, ensuring smoother navigation and app stability.

**Mapping out listener management**

I’ll consider a flagged listener for handled navigation, or using `ProviderScope` to unsubscribe the listener in the next screen if overriding the provider. This ensures seamless navigation control.

**Managing listener workflows**

I’m piecing together the strategy of using `useEffect` to manage navigation listeners, ensuring they only activate when needed and easily disposing of them upon route changes.

**Enhancing listener control**

I’m exploring `useEffect` to manage navigation listeners, ensuring they activate specifically when needed. However, canceling `ref.listen` directly remains an ongoing challenge, limiting precise listener deactivation.

---

## 🤖 アシスタント
*2025/01/12 17:48:40*

以下のページ専用のリスナーにしたい場合、たとえば以下のような対策があります。

1. **一度のみ処理するためのフラグを用意する**  
　ログインページに入った後、該当のイベントが発火したら「既に処理済み」とするフラグを立て、その後はリスナー内で何もしないようにする方法です。これにより、すでに遷移後の画面で同じプロバイダーを利用していても、ログインページのリスナーは以降の変更を無視できます。

2. **プロバイダーのスコープを分離する**  
　もし画面遷移時にプロバイダーの状態をリセット（または新たなインスタンスを利用）できるのであれば、`ProviderScope` などを利用して該当画面だけ別スコープにする方法も考えられます。しかし、多くの場合は最初の方法で十分対応できるケースが多いです。

以下は、【1】のフラグを使ったサンプルコードです。  
（※`flutter_hooks`を利用している場合、`useState`でフラグを用意します。）

```dart
class LoginPage extends HookConsumerWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final textEditingController = useTextEditingController();
    final navigationPerformed = useState(false);

    useEffect(() {
      // getMyAccount を呼び出す処理（初回のみ）
      Future.microtask(() {
        ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
      });
      return null;
    }, []);

    // getMyAccount のリスナー（ログインページ用）
    ref.listen<AsyncValue<AccountResponseDTOData?>>(
      getMyAccountNotifierProvider,
      (previous, next) {
        next.whenOrNull(
          data: (account) {
            if (account != null) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                // TODO: 必要に応じて遷移
                // context.go(Screen.map.path);
              });
            }
          },
          error: (error, stack) {
            debugPrint('Failed to fetch account info: $error');
          },
        );
      },
    );

    // requestCodeNotifierProvider 用のリスナー
    ref.listen<AsyncValue<String?>>(
      requestCodeNotifierProvider,
      (previous, next) {
        // すでにナビゲーション済みなら何もしない
        if (navigationPerformed.value) return;

        next.whenOrNull(
          data: (data) {
            if (data != null) {
              navigationPerformed.value = true; // 一度だけ実行
              context.push(Screen.verificationCode.path);
            }
          },
          error: (error, stackTrace) {
            // エラーハンドリングしつつ画面遷移
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Failed to send request: $error'),
              ),
            );
            navigationPerformed.value = true;
            context.push(Screen.verificationCode.path);
          },
        );
      },
    );

    return Scaffold(
      body: GestureDetector(
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: Center(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  GestureDetector(
                    onLongPress: () {
                      // TODO: flavor が dev の場合のみの機能
                      context.push(Screen.debugMenu.path);
                    },
                    child: SvgPicture.asset(
                      Assets.images.logoLogin.path,
                    ),
                  ),
                  const SizedBox(height: 38),
                  Image.asset(
                    Assets.images.loginFig.path,
                  ),
                  const SizedBox(height: 54),
                  TextField(
                    controller: textEditingController,
                    decoration: const InputDecoration(
                      prefixIcon: Padding(
                        padding: EdgeInsets.all(12),
                        child: Icon(
                          Icons.email_outlined,
                          color: ColorToken.text,
                          size: 24,
                        ),
                      ),
                      hintText: 'Enter your email',
                    ),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () async {
                      final email = textEditingController.text.trim();

                      if (email.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Please enter a valid email.'),
                          ),
                        );
                        return;
                      }

                      await ref
                          .read(requestCodeNotifierProvider.notifier)
                          .requestCode(email);
                    },
                    child: const Text('Login'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

### 補足説明

- **navigationPerformed フラグ**  
  このフラグ（`useState<bool>`）を用いることで、`requestCodeNotifierProvider` の状態が更新された際に「すでに画面遷移（または処理済み）である」ことを確認し、以降の更新では何も実行しないようにしています。

- **リスナーの登録タイミング**  
  `ref.listen` は `build` 内で呼び出すと、そのウィジェットがツリー上にある間ずっと登録され続けます。そのため、遷移してもウィジェットが破棄されない（push でスタックに残る）場合に備え、上記のようにフラグで制御するのが有効です。

- **プロバイダーのスコープ分離について**  
  今回はシンプルな解決策としてフラグを用いましたが、場合によっては新しい画面で `ProviderScope` を利用してプロバイダーのインスタンスを上書きすることでも、親ウィジェットのリスナーの影響を受けないようにできます。

このようにすれば、ログインページで発火したイベントに対してのみナビゲーションが実行され、後続の画面で同じプロバイダーの更新があったとしても影響を与えなくなります。

---

## 👤 ユーザー
*2025/01/12 17:50:35*

この画面にpopで戻ってきたらnavigationPerformedをfalseに戻したい

---

## 🔧 ツール
*2025/01/12 17:50:51*

**Tracking screen navigation**

OK, let me see. Implementing `useEffect` or hooking into the widget lifecycle to detect when the screen is revisited after a pop is a viable strategy. Considering `addPostFrameCallback` or a `RouteAware` mixin for mechanism.

**Assessing integration**

I'm mapping out integrating `RouteObserver` into `LoginPage`. Given mixin constraints with Hooks, pondering a custom observer or switching to `ConsumerStatefulWidget`. Riverpod code could simplify this.

**Understanding `RouteAware`**

I’m noting `RouteAware` and `didPopNext` for resetting `navigationPerformed`. Considering `ConsumerStatefulWidget` to ensure hooks are properly utilized, avoiding mixin constraints.

---

## 🤖 アシスタント
*2025/01/12 17:50:51*

戻ってきた際に `navigationPerformed` をリセットするには、ルートのライフサイクルイベント（例えば、`didPopNext`）を利用する方法が有効です。  
以下に、`RouteAware` を利用して画面復帰時にフラグをリセットする実装例を示します。  

## 1. ルートオブザーバーを用意する

まず、`MaterialApp`（または `GoRouter` の場合は、同様の仕組みがある場合があります）に `RouteObserver` を設定します。  
たとえば、`lib/main.dart` の中で以下のようにルートオブザーバーを定義します。

```dart
import 'package:flutter/material.dart';

final RouteObserver<ModalRoute<dynamic>> routeObserver = RouteObserver<ModalRoute<dynamic>>();

void main() {
  runApp(
    MaterialApp(
      navigatorObservers: [routeObserver],
      home: const LoginPage(),
    ),
  );
}
```

## 2. LoginPage を Stateful にして RouteAware を実装する

`HookConsumerWidget` を使っている場合でも、ライフサイクルのイベントを扱うには StatefulWidget に変更する方法が一般的です。  
Riverpod を利用した StatefuWidget は `ConsumerStatefulWidget` とその State (`ConsumerState`) を使います。  
以下にサンプルコードを示します。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/design_token/color_token.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_accounts_info.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/auth/request_code.dart';

class LoginPage extends ConsumerStatefulWidget {
  const LoginPage({Key? key}) : super(key: key);

  @override
  ConsumerState<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends ConsumerState<LoginPage> with RouteAware {
  final TextEditingController _textEditingController = TextEditingController();
  bool navigationPerformed = false;

  @override
  void initState() {
    super.initState();
    // 初期処理が必要ならこちらで実施
    Future.microtask(() {
      ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // RouteObserver に登録
    final ModalRoute<dynamic>? route = ModalRoute.of(context);
    if (route != null) {
      routeObserver.subscribe(this, route);
    }
  }

  @override
  void dispose() {
    _textEditingController.dispose();
    // RouteObserver から退会
    routeObserver.unsubscribe(this);
    super.dispose();
  }

  @override
  void didPopNext() {
    // 他のページからpopで戻ってきた際に呼ばれる
    setState(() {
      navigationPerformed = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    // getMyAccount のリスナー
    ref.listen<AsyncValue<AccountResponseDTOData?>>(
      getMyAccountNotifierProvider,
      (previous, next) {
        next.whenOrNull(
          data: (account) {
            if (account != null) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                // TODO: 必要に応じて遷移
                // context.go(Screen.map.path);
              });
            }
          },
          error: (error, stack) {
            debugPrint('Failed to fetch account info: $error');
          },
        );
      },
    );

    // requestCodeNotifierProvider 用のリスナー
    ref.listen<AsyncValue<String?>>(
      requestCodeNotifierProvider,
      (previous, next) {
        // すでにナビゲーション済みなら何もしない
        if (navigationPerformed) return;

        next.whenOrNull(
          data: (data) {
            if (data != null) {
              setState(() {
                navigationPerformed = true;
              });
              context.push(Screen.verificationCode.path);
            }
          },
          error: (error, stackTrace) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Failed to send request: $error'),
              ),
            );
            setState(() {
              navigationPerformed = true;
            });
            context.push(Screen.verificationCode.path);
          },
        );
      },
    );

    return Scaffold(
      body: GestureDetector(
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: Center(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  GestureDetector(
                    onLongPress: () {
                      // TODO: flavor が dev の場合のみの機能
                      context.push(Screen.debugMenu.path);
                    },
                    child: SvgPicture.asset(
                      Assets.images.logoLogin.path,
                    ),
                  ),
                  const SizedBox(height: 38),
                  Image.asset(
                    Assets.images.loginFig.path,
                  ),
                  const SizedBox(height: 54),
                  TextField(
                    controller: _textEditingController,
                    decoration: const InputDecoration(
                      prefixIcon: Padding(
                        padding: EdgeInsets.all(12),
                        child: Icon(
                          Icons.email_outlined,
                          color: ColorToken.text,
                          size: 24,
                        ),
                      ),
                      hintText: 'Enter your email',
                    ),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () async {
                      final email = _textEditingController.text.trim();

                      if (email.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Please enter a valid email.'),
                          ),
                        );
                        return;
                      }

                      await ref
                          .read(requestCodeNotifierProvider.notifier)
                          .requestCode(email);
                    },
                    child: const Text('Login'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

### サンプル解説

1. **RouteObserver の設定**  
   - メインの `MaterialApp` で `navigatorObservers` に `routeObserver` を指定し、全画面共通でルートの変更を監視します。

2. **RouteAware の実装**  
   - `ConsumerStatefulWidget` の State `_LoginPageState` に `RouteAware` をミックスインして、`didPopNext` をオーバーライドします。  
   - `didPopNext` は、他画面からこの画面へ戻ってきたときに呼ばれるので、そのタイミングで `navigationPerformed` を `false` にリセットしています。

3. **プロバイダーリスナー内でのフラグ管理**  
   - `requestCodeNotifierProvider` のリスナー内で、画面遷移が実行された場合に `navigationPerformed` を `true` に設定し、それ以降、同じプロバイダーの変化があっても処理が走らないようにしています。

この実装により、他の画面から `pop` で戻ってきた際に `navigationPerformed` が `false` に戻り、再度この画面上でプロバイダーの更新に応じた処理が実行できるようになります。

---
