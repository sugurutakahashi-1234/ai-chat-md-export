# ãƒªã‚¹ãƒŠãƒ¼åˆ¶å¾¡æ–¹æ³•

æ—¥ä»˜: 2025-01-12

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/01/12 17:48:18*

..listen&lt;AsyncValue&lt;String?&gt;&gt;(
        requestCodeNotifierProvider,
        (previous, next) {
          next.whenOrNull(
            data: (data) {
              if (data != null) {
                context.push(Screen.verificationCode.path);
              }
            },
            error: (error, stackTrace) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Failed to send request: $error'),
                ),
              );
              context.push(Screen.verificationCode.path);
            },
          );
        },
      );
ã“ã®listenãŒæ®‹ã‚Šç¶šã‘ã¦å›°ã£ã¦ã„ã‚‹ã€‚ã“ã®listenã®å‡¦ç†ã¯ã“ã®ãƒšãƒ¼ã‚¸ã§ã—ã‹å‡¦ç†ã—ãªã„ã‚ˆã†ã«åˆ¶å¾¡ã—ãŸã„ã€‚ã¤ã¾ã‚Špushå…ˆã§requestCodeNotifierProviderã‚’ä½¿ã£ã¦ã‚‚å•é¡Œãªãã—ãŸã„

import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/design_token/color_token.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_accounts_info.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/auth/request_code.dart';

class LoginPage extends HookConsumerWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final textEditingController = useTextEditingController();

    useEffect(
      () {
        Future.microtask(() {
          ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
        });
        return null;
      },
      [],
    );

    ref
      ..listen&lt;AsyncValue&lt;AccountResponseDTOData?&gt;&gt;(
        getMyAccountNotifierProvider,
        (previous, next) {
          next.whenOrNull(
            data: (account) {
              if (account != null) {
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  // TODO: ä¸€æ™‚çš„ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
                  // context.go(Screen.map.path);
                });
              }
            },
            error: (error, stack) {
              debugPrint('Failed to fetch account info: $error');
            },
          );
        },
      )
      ..listen&lt;AsyncValue&lt;String?&gt;&gt;(
        requestCodeNotifierProvider,
        (previous, next) {
          next.whenOrNull(
            data: (data) {
              if (data != null) {
                context.push(Screen.verificationCode.path);
              }
            },
            error: (error, stackTrace) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Failed to send request: $error'),
                ),
              );
              context.push(Screen.verificationCode.path);
            },
          );
        },
      );

    return Scaffold(
      body: GestureDetector(
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: Center(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  GestureDetector(
                    onLongPress: () {
                      // TODO: flavor ãŒ dev ã®å ´åˆã®ã¿ã®æ©Ÿèƒ½
                      context.push(Screen.debugMenu.path);
                    },
                    child: SvgPicture.asset(
                      Assets.images.logoLogin.path,
                    ),
                  ),
                  const SizedBox(height: 38),
                  Image.asset(
                    Assets.images.loginFig.path,
                  ),
                  const SizedBox(height: 54),
                  TextField(
                    controller: textEditingController,
                    decoration: const InputDecoration(
                      prefixIcon: Padding(
                        padding: EdgeInsets.all(12),
                        child: Icon(
                          Icons.email_outlined,
                          color: ColorToken.text,
                          size: 24,
                        ),
                      ),
                      hintText: 'Enter your email',
                    ),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () async {
                      final email = textEditingController.text.trim();

                      if (email.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Please enter a valid email.'),
                          ),
                        );
                        return;
                      }

                      await ref
                          .read(requestCodeNotifierProvider.notifier)
                          .requestCode(email);
                    },
                    child: const Text('Login'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/01/12 17:48:40*

**Addressing persistent listening**

Iâ€™m thinking through how to handle the ongoing `listen` in Dart/Flutter with hooks_riverpod. The issue is that it persists, causing problems. The goal is to keep processing limited to a specific page, ensuring smooth navigation on the pushed screen.

**Balancing listeners**

OK, Iâ€™m thinking through the use of listeners in the widget. The challenge is managing listeners efficiently while ensuring seamless navigation without conflicts.

**Revisiting listener scope**

Iâ€™m addressing that `ref.listen` is inside the build method, leading to repeated listener attachments. This means the widget rebuilds triggering unnecessary execution, which can be optimized.

**Optimizing listener setup**

Interestingly enough, the `ref.listen` method, often mistakenly reattached during rebuilds, can be improved by wrapping it in `useEffect` with a dependency array, ensuring a single subscription post-widget creation.

**Handling listener persistence on navigation**

OK, Iâ€™m exploring how listeners stay active on new pages unless explicitly removed. Using hooks_riverpod, ensure careful management to avoid unintended reactivity and conflicts during navigation.

**Managing listener state**

OK, let me see. To manage listener state on navigation, Iâ€™m thinking about a local provider resetting its state after each event, or using `ref.listen` within `useEffect` for automatic unsubscription upon disposal.

**Crafting listener management**

Iâ€™m piecing together that `ref.listen` with a `listenWhen` argument can toggle listeners based on page activity, or resetting the notifier state in the provider after navigating to `Screen.verificationCode` might work better.

**Navigating provider scoping**

Iâ€™m thinking about using `ProviderScope` to create a new provider instance when a new page is pushed, ensuring the listener doesnâ€™t carry over, maintaining clarity and avoiding conflicts.

**Separating concerns**

Taking a closer look, Iâ€™m thinking about stopping the listen on the login page when moving to `Screen.verificationCode` to avoid conflicts, ensuring clear separation across routes.

**Canceling listeners**

Iâ€™m exploring methods to manage listener subscriptions dynamically, such as calling a cancellation method or conditionally subscribing via `useEffect` based on the current route, possibly with a local variable.

**Enhancing navigation management**

Iâ€™m creating a `didNavigate` flag to control the listener's behavior in `useEffect`, ensuring it only activates when necessary, preventing unwanted navigational triggers.

**Enhancing navigation stability**

Iâ€™m developing a `didNavigate` flag to control listener activation, ensuring adherence to the current route, and preventing cascading navigation triggers.

**Choosing the best method** 

Iâ€™m thinking about using a local flag to dismiss changes after the first push or creating a new provider instance to isolate listeners, ensuring smoother navigation and app stability.

**Mapping out listener management**

Iâ€™ll consider a flagged listener for handled navigation, or using `ProviderScope` to unsubscribe the listener in the next screen if overriding the provider. This ensures seamless navigation control.

**Managing listener workflows**

Iâ€™m piecing together the strategy of using `useEffect` to manage navigation listeners, ensuring they only activate when needed and easily disposing of them upon route changes.

**Enhancing listener control**

Iâ€™m exploring `useEffect` to manage navigation listeners, ensuring they activate specifically when needed. However, canceling `ref.listen` directly remains an ongoing challenge, limiting precise listener deactivation.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/01/12 17:48:40*

ä»¥ä¸‹ã®ãƒšãƒ¼ã‚¸å°‚ç”¨ã®ãƒªã‚¹ãƒŠãƒ¼ã«ã—ãŸã„å ´åˆã€ãŸã¨ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ãªå¯¾ç­–ãŒã‚ã‚Šã¾ã™ã€‚

1. **ä¸€åº¦ã®ã¿å‡¦ç†ã™ã‚‹ãŸã‚ã®ãƒ•ãƒ©ã‚°ã‚’ç”¨æ„ã™ã‚‹**  
ã€€ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«å…¥ã£ãŸå¾Œã€è©²å½“ã®ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã—ãŸã‚‰ã€Œæ—¢ã«å‡¦ç†æ¸ˆã¿ã€ã¨ã™ã‚‹ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã€ãã®å¾Œã¯ãƒªã‚¹ãƒŠãƒ¼å†…ã§ä½•ã‚‚ã—ãªã„ã‚ˆã†ã«ã™ã‚‹æ–¹æ³•ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã™ã§ã«é·ç§»å¾Œã®ç”»é¢ã§åŒã˜ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚’åˆ©ç”¨ã—ã¦ã„ã¦ã‚‚ã€ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã®ãƒªã‚¹ãƒŠãƒ¼ã¯ä»¥é™ã®å¤‰æ›´ã‚’ç„¡è¦–ã§ãã¾ã™ã€‚

2. **ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚’åˆ†é›¢ã™ã‚‹**  
ã€€ã‚‚ã—ç”»é¢é·ç§»æ™‚ã«ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆã¾ãŸã¯æ–°ãŸãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆ©ç”¨ï¼‰ã§ãã‚‹ã®ã§ã‚ã‚Œã°ã€`ProviderScope` ãªã©ã‚’åˆ©ç”¨ã—ã¦è©²å½“ç”»é¢ã ã‘åˆ¥ã‚¹ã‚³ãƒ¼ãƒ—ã«ã™ã‚‹æ–¹æ³•ã‚‚è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€å¤šãã®å ´åˆã¯æœ€åˆã®æ–¹æ³•ã§ååˆ†å¯¾å¿œã§ãã‚‹ã‚±ãƒ¼ã‚¹ãŒå¤šã„ã§ã™ã€‚

ä»¥ä¸‹ã¯ã€ã€1ã€‘ã®ãƒ•ãƒ©ã‚°ã‚’ä½¿ã£ãŸã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚  
ï¼ˆâ€»`flutter_hooks`ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹å ´åˆã€`useState`ã§ãƒ•ãƒ©ã‚°ã‚’ç”¨æ„ã—ã¾ã™ã€‚ï¼‰

```dart
class LoginPage extends HookConsumerWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final textEditingController = useTextEditingController();
    final navigationPerformed = useState(false);

    useEffect(() {
      // getMyAccount ã‚’å‘¼ã³å‡ºã™å‡¦ç†ï¼ˆåˆå›ã®ã¿ï¼‰
      Future.microtask(() {
        ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
      });
      return null;
    }, []);

    // getMyAccount ã®ãƒªã‚¹ãƒŠãƒ¼ï¼ˆãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ç”¨ï¼‰
    ref.listen<AsyncValue<AccountResponseDTOData?>>(
      getMyAccountNotifierProvider,
      (previous, next) {
        next.whenOrNull(
          data: (account) {
            if (account != null) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                // TODO: å¿…è¦ã«å¿œã˜ã¦é·ç§»
                // context.go(Screen.map.path);
              });
            }
          },
          error: (error, stack) {
            debugPrint('Failed to fetch account info: $error');
          },
        );
      },
    );

    // requestCodeNotifierProvider ç”¨ã®ãƒªã‚¹ãƒŠãƒ¼
    ref.listen<AsyncValue<String?>>(
      requestCodeNotifierProvider,
      (previous, next) {
        // ã™ã§ã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
        if (navigationPerformed.value) return;

        next.whenOrNull(
          data: (data) {
            if (data != null) {
              navigationPerformed.value = true; // ä¸€åº¦ã ã‘å®Ÿè¡Œ
              context.push(Screen.verificationCode.path);
            }
          },
          error: (error, stackTrace) {
            // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã—ã¤ã¤ç”»é¢é·ç§»
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Failed to send request: $error'),
              ),
            );
            navigationPerformed.value = true;
            context.push(Screen.verificationCode.path);
          },
        );
      },
    );

    return Scaffold(
      body: GestureDetector(
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: Center(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  GestureDetector(
                    onLongPress: () {
                      // TODO: flavor ãŒ dev ã®å ´åˆã®ã¿ã®æ©Ÿèƒ½
                      context.push(Screen.debugMenu.path);
                    },
                    child: SvgPicture.asset(
                      Assets.images.logoLogin.path,
                    ),
                  ),
                  const SizedBox(height: 38),
                  Image.asset(
                    Assets.images.loginFig.path,
                  ),
                  const SizedBox(height: 54),
                  TextField(
                    controller: textEditingController,
                    decoration: const InputDecoration(
                      prefixIcon: Padding(
                        padding: EdgeInsets.all(12),
                        child: Icon(
                          Icons.email_outlined,
                          color: ColorToken.text,
                          size: 24,
                        ),
                      ),
                      hintText: 'Enter your email',
                    ),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () async {
                      final email = textEditingController.text.trim();

                      if (email.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Please enter a valid email.'),
                          ),
                        );
                        return;
                      }

                      await ref
                          .read(requestCodeNotifierProvider.notifier)
                          .requestCode(email);
                    },
                    child: const Text('Login'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

### è£œè¶³èª¬æ˜

- **navigationPerformed ãƒ•ãƒ©ã‚°**  
  ã“ã®ãƒ•ãƒ©ã‚°ï¼ˆ`useState<bool>`ï¼‰ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€`requestCodeNotifierProvider` ã®çŠ¶æ…‹ãŒæ›´æ–°ã•ã‚ŒãŸéš›ã«ã€Œã™ã§ã«ç”»é¢é·ç§»ï¼ˆã¾ãŸã¯å‡¦ç†æ¸ˆã¿ï¼‰ã§ã‚ã‚‹ã€ã“ã¨ã‚’ç¢ºèªã—ã€ä»¥é™ã®æ›´æ–°ã§ã¯ä½•ã‚‚å®Ÿè¡Œã—ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

- **ãƒªã‚¹ãƒŠãƒ¼ã®ç™»éŒ²ã‚¿ã‚¤ãƒŸãƒ³ã‚°**  
  `ref.listen` ã¯ `build` å†…ã§å‘¼ã³å‡ºã™ã¨ã€ãã®ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆãŒãƒ„ãƒªãƒ¼ä¸Šã«ã‚ã‚‹é–“ãšã£ã¨ç™»éŒ²ã•ã‚Œç¶šã‘ã¾ã™ã€‚ãã®ãŸã‚ã€é·ç§»ã—ã¦ã‚‚ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆãŒç ´æ£„ã•ã‚Œãªã„ï¼ˆpush ã§ã‚¹ã‚¿ãƒƒã‚¯ã«æ®‹ã‚‹ï¼‰å ´åˆã«å‚™ãˆã€ä¸Šè¨˜ã®ã‚ˆã†ã«ãƒ•ãƒ©ã‚°ã§åˆ¶å¾¡ã™ã‚‹ã®ãŒæœ‰åŠ¹ã§ã™ã€‚

- **ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®ã‚¹ã‚³ãƒ¼ãƒ—åˆ†é›¢ã«ã¤ã„ã¦**  
  ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ãªè§£æ±ºç­–ã¨ã—ã¦ãƒ•ãƒ©ã‚°ã‚’ç”¨ã„ã¾ã—ãŸãŒã€å ´åˆã«ã‚ˆã£ã¦ã¯æ–°ã—ã„ç”»é¢ã§ `ProviderScope` ã‚’åˆ©ç”¨ã—ã¦ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä¸Šæ›¸ãã™ã‚‹ã“ã¨ã§ã‚‚ã€è¦ªã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã®ãƒªã‚¹ãƒŠãƒ¼ã®å½±éŸ¿ã‚’å—ã‘ãªã„ã‚ˆã†ã«ã§ãã¾ã™ã€‚

ã“ã®ã‚ˆã†ã«ã™ã‚Œã°ã€ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã§ç™ºç«ã—ãŸã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾ã—ã¦ã®ã¿ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œã•ã‚Œã€å¾Œç¶šã®ç”»é¢ã§åŒã˜ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®æ›´æ–°ãŒã‚ã£ãŸã¨ã—ã¦ã‚‚å½±éŸ¿ã‚’ä¸ãˆãªããªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/01/12 17:50:35*

ã“ã®ç”»é¢ã«popã§æˆ»ã£ã¦ããŸã‚‰navigationPerformedã‚’falseã«æˆ»ã—ãŸã„

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/01/12 17:50:51*

**Tracking screen navigation**

OK, let me see. Implementing `useEffect` or hooking into the widget lifecycle to detect when the screen is revisited after a pop is a viable strategy. Considering `addPostFrameCallback` or a `RouteAware` mixin for mechanism.

**Assessing integration**

I'm mapping out integrating `RouteObserver` into `LoginPage`. Given mixin constraints with Hooks, pondering a custom observer or switching to `ConsumerStatefulWidget`. Riverpod code could simplify this.

**Understanding `RouteAware`**

Iâ€™m noting `RouteAware` and `didPopNext` for resetting `navigationPerformed`. Considering `ConsumerStatefulWidget` to ensure hooks are properly utilized, avoiding mixin constraints.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/01/12 17:50:51*

æˆ»ã£ã¦ããŸéš›ã« `navigationPerformed` ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã«ã¯ã€ãƒ«ãƒ¼ãƒˆã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆä¾‹ãˆã°ã€`didPopNext`ï¼‰ã‚’åˆ©ç”¨ã™ã‚‹æ–¹æ³•ãŒæœ‰åŠ¹ã§ã™ã€‚  
ä»¥ä¸‹ã«ã€`RouteAware` ã‚’åˆ©ç”¨ã—ã¦ç”»é¢å¾©å¸°æ™‚ã«ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹å®Ÿè£…ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚  

## 1. ãƒ«ãƒ¼ãƒˆã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã‚’ç”¨æ„ã™ã‚‹

ã¾ãšã€`MaterialApp`ï¼ˆã¾ãŸã¯ `GoRouter` ã®å ´åˆã¯ã€åŒæ§˜ã®ä»•çµ„ã¿ãŒã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ï¼‰ã« `RouteObserver` ã‚’è¨­å®šã—ã¾ã™ã€‚  
ãŸã¨ãˆã°ã€`lib/main.dart` ã®ä¸­ã§ä»¥ä¸‹ã®ã‚ˆã†ã«ãƒ«ãƒ¼ãƒˆã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã‚’å®šç¾©ã—ã¾ã™ã€‚

```dart
import 'package:flutter/material.dart';

final RouteObserver<ModalRoute<dynamic>> routeObserver = RouteObserver<ModalRoute<dynamic>>();

void main() {
  runApp(
    MaterialApp(
      navigatorObservers: [routeObserver],
      home: const LoginPage(),
    ),
  );
}
```

## 2. LoginPage ã‚’ Stateful ã«ã—ã¦ RouteAware ã‚’å®Ÿè£…ã™ã‚‹

`HookConsumerWidget` ã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã§ã‚‚ã€ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ‰±ã†ã«ã¯ StatefulWidget ã«å¤‰æ›´ã™ã‚‹æ–¹æ³•ãŒä¸€èˆ¬çš„ã§ã™ã€‚  
Riverpod ã‚’åˆ©ç”¨ã—ãŸ StatefuWidget ã¯ `ConsumerStatefulWidget` ã¨ãã® State (`ConsumerState`) ã‚’ä½¿ã„ã¾ã™ã€‚  
ä»¥ä¸‹ã«ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¾ã™ã€‚

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/screen.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/design_token/color_token.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/accounts/get_accounts_info.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/auth/request_code.dart';

class LoginPage extends ConsumerStatefulWidget {
  const LoginPage({Key? key}) : super(key: key);

  @override
  ConsumerState<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends ConsumerState<LoginPage> with RouteAware {
  final TextEditingController _textEditingController = TextEditingController();
  bool navigationPerformed = false;

  @override
  void initState() {
    super.initState();
    // åˆæœŸå‡¦ç†ãŒå¿…è¦ãªã‚‰ã“ã¡ã‚‰ã§å®Ÿæ–½
    Future.microtask(() {
      ref.read(getMyAccountNotifierProvider.notifier).getMyAccount();
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // RouteObserver ã«ç™»éŒ²
    final ModalRoute<dynamic>? route = ModalRoute.of(context);
    if (route != null) {
      routeObserver.subscribe(this, route);
    }
  }

  @override
  void dispose() {
    _textEditingController.dispose();
    // RouteObserver ã‹ã‚‰é€€ä¼š
    routeObserver.unsubscribe(this);
    super.dispose();
  }

  @override
  void didPopNext() {
    // ä»–ã®ãƒšãƒ¼ã‚¸ã‹ã‚‰popã§æˆ»ã£ã¦ããŸéš›ã«å‘¼ã°ã‚Œã‚‹
    setState(() {
      navigationPerformed = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    // getMyAccount ã®ãƒªã‚¹ãƒŠãƒ¼
    ref.listen<AsyncValue<AccountResponseDTOData?>>(
      getMyAccountNotifierProvider,
      (previous, next) {
        next.whenOrNull(
          data: (account) {
            if (account != null) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                // TODO: å¿…è¦ã«å¿œã˜ã¦é·ç§»
                // context.go(Screen.map.path);
              });
            }
          },
          error: (error, stack) {
            debugPrint('Failed to fetch account info: $error');
          },
        );
      },
    );

    // requestCodeNotifierProvider ç”¨ã®ãƒªã‚¹ãƒŠãƒ¼
    ref.listen<AsyncValue<String?>>(
      requestCodeNotifierProvider,
      (previous, next) {
        // ã™ã§ã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
        if (navigationPerformed) return;

        next.whenOrNull(
          data: (data) {
            if (data != null) {
              setState(() {
                navigationPerformed = true;
              });
              context.push(Screen.verificationCode.path);
            }
          },
          error: (error, stackTrace) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Failed to send request: $error'),
              ),
            );
            setState(() {
              navigationPerformed = true;
            });
            context.push(Screen.verificationCode.path);
          },
        );
      },
    );

    return Scaffold(
      body: GestureDetector(
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: Center(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  GestureDetector(
                    onLongPress: () {
                      // TODO: flavor ãŒ dev ã®å ´åˆã®ã¿ã®æ©Ÿèƒ½
                      context.push(Screen.debugMenu.path);
                    },
                    child: SvgPicture.asset(
                      Assets.images.logoLogin.path,
                    ),
                  ),
                  const SizedBox(height: 38),
                  Image.asset(
                    Assets.images.loginFig.path,
                  ),
                  const SizedBox(height: 54),
                  TextField(
                    controller: _textEditingController,
                    decoration: const InputDecoration(
                      prefixIcon: Padding(
                        padding: EdgeInsets.all(12),
                        child: Icon(
                          Icons.email_outlined,
                          color: ColorToken.text,
                          size: 24,
                        ),
                      ),
                      hintText: 'Enter your email',
                    ),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () async {
                      final email = _textEditingController.text.trim();

                      if (email.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Please enter a valid email.'),
                          ),
                        );
                        return;
                      }

                      await ref
                          .read(requestCodeNotifierProvider.notifier)
                          .requestCode(email);
                    },
                    child: const Text('Login'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

### ã‚µãƒ³ãƒ—ãƒ«è§£èª¬

1. **RouteObserver ã®è¨­å®š**  
   - ãƒ¡ã‚¤ãƒ³ã® `MaterialApp` ã§ `navigatorObservers` ã« `routeObserver` ã‚’æŒ‡å®šã—ã€å…¨ç”»é¢å…±é€šã§ãƒ«ãƒ¼ãƒˆã®å¤‰æ›´ã‚’ç›£è¦–ã—ã¾ã™ã€‚

2. **RouteAware ã®å®Ÿè£…**  
   - `ConsumerStatefulWidget` ã® State `_LoginPageState` ã« `RouteAware` ã‚’ãƒŸãƒƒã‚¯ã‚¹ã‚¤ãƒ³ã—ã¦ã€`didPopNext` ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¾ã™ã€‚  
   - `didPopNext` ã¯ã€ä»–ç”»é¢ã‹ã‚‰ã“ã®ç”»é¢ã¸æˆ»ã£ã¦ããŸã¨ãã«å‘¼ã°ã‚Œã‚‹ã®ã§ã€ãã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ `navigationPerformed` ã‚’ `false` ã«ãƒªã‚»ãƒƒãƒˆã—ã¦ã„ã¾ã™ã€‚

3. **ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãƒªã‚¹ãƒŠãƒ¼å†…ã§ã®ãƒ•ãƒ©ã‚°ç®¡ç†**  
   - `requestCodeNotifierProvider` ã®ãƒªã‚¹ãƒŠãƒ¼å†…ã§ã€ç”»é¢é·ç§»ãŒå®Ÿè¡Œã•ã‚ŒãŸå ´åˆã« `navigationPerformed` ã‚’ `true` ã«è¨­å®šã—ã€ãã‚Œä»¥é™ã€åŒã˜ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®å¤‰åŒ–ãŒã‚ã£ã¦ã‚‚å‡¦ç†ãŒèµ°ã‚‰ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

ã“ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ä»–ã®ç”»é¢ã‹ã‚‰ `pop` ã§æˆ»ã£ã¦ããŸéš›ã« `navigationPerformed` ãŒ `false` ã«æˆ»ã‚Šã€å†åº¦ã“ã®ç”»é¢ä¸Šã§ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®æ›´æ–°ã«å¿œã˜ãŸå‡¦ç†ãŒå®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---
