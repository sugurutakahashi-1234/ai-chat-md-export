# モバイルアプリフレームワーク比較

日付: 2025-05-12

---

## 👤 ユーザー
*2025/5/12 16:07:01*

最新のTypeScriptで実装できるモバイルのネイティブアプリとして勢いのあるSDKやフレームワークを教えて欲しく、それがもっている課題について制して欲しく、またその技術を採用すべきかどうかを検討して欲しい。

---

## 🤖 アシスタント
*2025/5/12 16:07:36*

最新の TypeScript で開発できる “ネイティブ級” モバイルアプリ向け SDK／フレームワークの中から、現在とくに勢いのある 5 つを整理し、それぞれの課題と採用判断のポイントをまとめました。結論だけ先に言えば **React Native (+ Expo) と Capacitor 6 が依然王道**。ただし **NativeScript 8.9** はネイティブ API 直アクセス派には面白く、**Tauri v2** はデスクトップ資産を流用したい場合の“次候補”として注視すべき段階――という位置付けになります。

---

## 1. React Native (New Architecture) ✕ TypeScript

### モメンタム  
* 新アーキテクチャ（Fabric／TurboModules）が正式サポートされ、Concurrent Rendering など React 18 の最新 API がそのまま使えるように citeturn0search6turn0search0。  
* Hermes VM が標準になり、ランタイムサイズと起動性能が改善。  

### 主な課題  
* **移行コスト** ― 旧ブリッジから新アーキテクチャへ段階移行が必要。公式 Upgrade Helper はあるが差分マージは手作業も多い citeturn1search3。  
* **開発体験のブレ** ― Android/iOS プロジェクトを直接触るため、Xcode／Gradle の知識が必須という指摘がコミュニティでも散見 citeturn1search2。  

### 採用判断  
* **チームに React/Web 経験者が多いなら鉄板**。ただし中長期プロダクトなら “New Architecture 前提” で新規開発を始めた方が後々ラク。  

---

## 2. Expo SDK 51

### モメンタム  
* React Native をラップしたクラウドビルド基盤。SDK 51（RN 0.74 ベース）が 2024 Q2 に安定版となり、新アーキテクチャ試験導入を推奨 citeturn0search1。  
* Metro Bundler のカスタマイズ性が強化され、大規模アプリでもビルド時間を短縮 citeturn0search7。  

### 主な課題  
* **ロックイン** ― EAS Build や Expo Go 依存のライフサイクル。純 RN へ後から戻す場合は eject が必要。  
* **ネイティブモジュール不足** ― 新アーキテクチャ対応のサードパーティ SDK がまだ少ない。  

### 採用判断  
* MVP〜中規模までは **最速でストア公開したいケースに◎**。長期運用 or 独自ネイティブ拡張を多用する予定なら純 RN 構成を検討。  

---

## 3. Capacitor 6 (+ Ionic 8)

### モメンタム  
* Web 技術をそのままネイティブラッパーで公開。2024 Q4 に Capacitor 6 正式版、Node 18+ 要件で Swift Package Manager 対応が実験的に入り話題 citeturn2search0turn2search3。  
* Ionic 8.5 系は毎月パッチが出る活発さ citeturn0search3。  

### 主な課題  
* **パフォーマンス上限** ― WebView 越し実装ゆえ 3D／ハイフレームレート描画は苦手。  
* **意見の強い UI レイヤー** ― 「Ionic UI が合わなければ Capacitor 単体で」 というコミュニティ議論が続く citeturn0search9。  
* バージョン間でプラグイン API 名が微変わり、アップグレード時のプラグイン追従が必要 citeturn2search2。  

### 採用判断  
* **既存 Web アプリを最小工数でネイティブ化したい**・**トライ＆エラーが速い IA／PoC** には有力。Heavy UI ネイティブ体験を重視する場合は慎重に。  

---

## 4. NativeScript 8.9 (＋10 Year Anniversary)

### モメンタム  
* Node-API 対応エンジンをプレビュー開始し、Hermes/QuickJS も選択可能に citeturn0search8。  
* 2025 で 10 周年、コミュニティ主導で継続開発 citeturn0search2。  

### 主な課題  
* **コミュニティ規模** が React Native・Ionic と比べて小さく、日本語情報も少ない。  
* Angular/Svelte/Vue など UI Layer は豊富だが、公式ドキュメントがフラグメント化しがち。  

### 採用判断  
* **フルネイティブ API を TypeScript で直接操りたい**・**Java/Kotlin／Swift/Obj-C をなるべく書きたくない** プロジェクト向き。  
* 将来の保守要員確保（育成 or 英語圏採用）が現実的かどうかで判断。  

---

## 5. Tauri v2 (beta) for Mobile

### モメンタム  
* v2 βで **Android / iOS サポートが追加** – 既存デスクトップ Tauri アプリをモバイルへシームレス移行可能 citeturn3search0turn3search8。  
* CLI からエミュレータ起動までサポートし、Rust コマンドでネイティブ呼び出し citeturn0search4turn3search7。  

### 主な課題  
* まだ **β版**。公式プラグインもモバイル対応は限定的で、iOS/Android のコードサイン設定は自前で調整が必要 citeturn3search3turn3search5。  
* Widget など OS 特有機能は Issue ベースで議論中 citeturn3search6。  

### 採用判断  
* **デスクトップ版 (Electron/Tauri) のロジックをそのままモバイルへ展開したい** プロダクトで将来性◎。ただし **2025 時点では本番採用は慎重に PoC から**。  

---

## 6. 採用を決めるチェックリスト

| 重点項目 | React Native (+Expo) | Capacitor 6 | NativeScript 8.9 | Tauri v2 β |
|---------|---------------------|-------------|------------------|------------|
| **完成度** | ★★★★★ | ★★★★☆ | ★★★☆☆ | ★★☆☆☆ |
| **TypeScript DX** | 優 | 優 | 良 | 良 |
| **ネイティブ API 網羅** | 広 (多数プラグイン) | 中 (プラグイン依存) | 広 (直接呼び出し) | 途上 |
| **パフォーマンス天井** | 高 | 中 | 高 | 高 |
| **初期学習コスト** | 中 | 低 | 中 | 中 |
| **コミュニティ／求人** | 最大 | 大 | 中 | 小 |

※星は成熟度の目安（5 段階）。  

---

## 7. まとめと推奨アクション

1. **React Native をベースに、新規なら「New Architecture 前提 +💡Expo EAS を活用」** が依然ベストバランス。エコシステムが最大で、人材確保も容易。  
2. **既存 Web 技術の流用・リリース速度を最優先** → **Capacitor 6**。SwiftPM 対応や OS SDK 追随も速いので“ハイブリッド派”は要検討。  
3. **プラグインではなくネイティブ API を直接叩きたい** → **NativeScript**。小規模プロダクトで尖った体験を作るのに向く。  
4. **デスクトップ版 Tauri とのコード共有を見据える** → **Tauri v2 β を PoC**。本番導入は正式版リリース（予定: 2025 H2）を待ちたい。  

プロダクトの **寿命 (3〜5 年)** と **チームスキルセット** を照らし合わせ、まずはトップ 2 候補 (React Native / Capacitor) でスパイク → 要件を満たせない場合に NativeScript or Tauri を検証する段階的評価が現実的です。

---

## 👤 ユーザー
*2025/5/12 16:10:30*

React Native (+Expo)で、通知などの基本的なことはできるのか？

---

## 🤖 アシスタント
*2025/5/12 16:11:01*

以下に要点を先にまとめると── **React Native 単独でも Expo SDK（expo-notifications）でも「プッシュ通知」「ローカル通知」「バッジ更新」「スケジュール通知」などの** “モバイルアプリで最低限ほしい通知系機能” **は一通り実装可能** です。Expo Go ではプッシュを送れない・サイレント通知など一部制限があるため **EAS Dev/Production ビルドか Bare/開 eject が実質必須**、というのが最大の注意点になります。

---

## 1. Expo (+React Native) で出来ること

| 機能 | 対応 | 主要 API / 備考 |
|------|------|----------------|
| **リモートプッシュ通知** | ○ | `expo-notifications` + Expo Push Service。iOS は APNs キー/FCM、Android は FCM を内部でラップ citeturn0search0turn0search3 |
| **ローカル通知（即時/日時指定）** | ○ | `scheduleNotificationAsync()` で予約送信可 citeturn0search2 |
| **バッジ数更新** | ○ | `setBadgeCountAsync()` (iOS/Android) citeturn0search2 |
| **受信時ハンドリング (foreground/background/quit)** | ○ | `addNotificationReceivedListener`, `setNotificationHandler` 等で制御 citeturn0search2 |
| **サイレント通知 / バックグラウンド実行** | △ | iOS の `content-available:1` や Android data-only は **EAS dev/prod ビルド or Bare** で可。Expo Go では不可 citeturn0search6turn0search5 |

### 実装の流れ（概略）

1. **ライブラリ導入**  
   ```bash
   npx expo install expo-notifications
   ```
2. **権限取得**  
   ```ts
   await Notifications.requestPermissionsAsync();
   ```
3. **プッシュトークン取得 & サーバ保存**  
   ```ts
   const token = (await Notifications.getExpoPushTokenAsync()).data;
   ```
4. **バックエンドから Expo Push API へ POST**（または FCM/APNs ダイレクト送信）

詳しい手順は公式 “Push Notifications setup” ガイドが最新 SDK 51 対応でまとまっています citeturn0search0。

---

## 2. Expo 特有の制限と回避策

| 制限 | 解説 | 主な回避策 |
|------|------|-----------|
| **Expo Go ではプッシュ不可** | Go には通知用ネイティブコードが含まれない citeturn0search6 | **EAS Dev Build** で署名付きビルドを作る |
| **サイレント / 高優先データ通知の制限** | 旧 Expo Managed ではバックグラウンド JS が走らない指摘あり citeturn0search5 | `app.config.js` で `expo-buildProperties`→Bare equivalent に移行 |
| **iOS アクションボタン、カテゴリ定義** | SDK 50 以降 Config Plugin 経由で対応したが手動設定も残る citeturn0search2 | `react-native-notifications` などと組み合わせる |
| **APNs/FCM 証明書管理** | Expo Push Service を使う場合でも最終的に APNs/FCM 資格情報は必須 citeturn0search0 | EAS CLI の `expo credentials:manager` で自動化 |

---

## 3. React Native（Bare / 新アーキテクチャ）での選択肢

* **react-native-firebase/messaging**：FCM と APNs を直接扱い、バックグラウンド JS ハンドラやサイレント通知も自由度高い citeturn1view0  
* **notifee/react-native**：ローカル通知 UI を細かくカスタマイズでき、messaging と組み合わせるケースが増加中 citeturn0search4  
こちらは iOS/Android ネイティブ設定（Entitlement、Manifest、Capability）を手動で行う必要がありますが、**高度な要件（チャット既読・VoIP・アクション付き通知等）は Bare 構成の方が実装しやすい** という結論になりやすいです。

---

## 4. 採用判断のポイント

1. **MVP 〜 中規模アプリで “通知は一般的なプッシュ＋ローカル” 程度**  
   → **Expo Managed + EAS Build** で十分。ビルド速度と OTA Update の恩恵が大きい。
2. **サイレント通知・大量同報配信・カスタム UI など高度要件**  
   → **React Native Bare + Firebase Messaging / Notifee** が安全。Expo から eject も可。
3. **既存 Web 技術や CI/CD の簡便さを優先**  
   → Expo を保ちながら Config Plugin で必要機能だけネイティブ追加するハイブリッド戦略も有効。

---

## 5. まとめ

* **「通知ができるか？」という問いには “Yes”**。Expo でも公式サポートが整備済み。  
* ただし **Expo Go だけではプッシュが動かない** ため、**EAS Dev/Prod ビルド** を作る運用が前提。  
* **サイレント・カスタマイズ通知など一歩踏み込むとネイティブ設定が増える**。この時点で **Bare へ移行 or Config Plugin 活用** を検討するとスムーズです。  

これらを踏まえて、まずは Expo Managed で PoC → 要件が増したら Bare へ“段階的アップグレード”する戦略を推奨します。

---

## 👤 ユーザー
*2025/5/12 16:12:49*

Expoにはいくつか種類があるということですか？どれを選択したほうがいいか教えて欲しい

---

## 🤖 アシスタント
*2025/5/12 16:13:04*

まず結論から — **Expo に “複数のモード（ワークフロー）とビルド種類” がある** のは事実ですが、日常的に選ぶべき選択肢は次の 4 つに整理できます。

| # | 名前 | 何が動くか | 代表コマンド | 向いている段階 |
|---|------|-----------|-------------|---------------|
| 1 | **Expo Go（クラシック managed）** | 汎用クライアントアプリ | QR で即実機検証 | PoC／学習 |
| 2 | **Development Build（＝Custom Dev Client）** | あなた専用の Expo Go | `eas build --profile development` | 開発〜中規模 |
| 3 | **Prebuild（Managed + ネイティブ生成）** | `android/-`, `ios/-` が自動生成 | `npx expo prebuild` | ネイティブ設定が増えた頃 |
| 4 | **Bare / Eject** | 完全な React Native プロジェクト | `npx expo prebuild && expo eject` | 高度要件・長期運用 |

---  

## 1. そもそも “Expo” はツールチェーンの総称

Expo CLI は `package.json` を見て JS -&gt; ネイティブへ構成を橋渡しするツールで、**どのワークフローを使うかは _expo-config_ の扱い方とビルド方法の違い**で決まります。公式ドキュメントも “Expo Go → Development Build → Prebuild → Bare” の４段階として整理しています citeturn0search11turn0search0。

---

## 2. 各ワークフローの特徴と注意点

### 2-1. Expo Go（クラシック managed）

* App Store/Google Play にある汎用クライアント。JS を即時ホットリロードできるので学習に最適 citeturn0search9。  
* **ネイティブコードを含むライブラリが使えない**、Push 通知など一部 SDK が制限される citeturn0search4。  

### 2-2. Development Build（Custom Dev Client）

* あなたのアプリだけを含む「自家製 Expo Go」 — Expo Go と同じ DX で **任意のネイティブモジュールを組み込める** citeturn0search0。  
* `eas build --profile development` で生成し、QR や OTA 更新も可能 citeturn0search7。  
* Expo Go から移行しても JS/TS 側の変更はそのままホットリロードできるので、**実運用の第一歩** として推奨されます citeturn0search5。  

### 2-3. Prebuild（Managed + ネイティブ生成）

* `npx expo prebuild` 実行で `android/` と `ios/` ディレクトリが生成され、**config-plugin（mod）で Gradle・Pod 設定を自動合成** citeturn0search6。  
* 以降は EAS Build でも Xcode/Android Studio でもビルド可能。**ビルド成果物は EAS Build “preview/production” プロファイル**で配布するのが一般的 citeturn0search2。  
* ネイティブフォルダを直接編集すると _prebuild 差分管理_ が必要になる点に注意 citeturn0search3。  

### 2-4. Bare / Eject

* React Native CLI と同じ構成。Expo ランタイムを残すかどうかも選択できる citeturn0search8。  
* **最も自由度が高い** 代わりに Xcode／Gradle 知識が必須。Expo OTA 更新も自力で組み込む必要がある。  

---

## 3. EAS Build の３プロファイル

| プロファイル | 目的 | 主コマンド |
|--------------|------|------------|
| **development** | Dev Client 用；高速ビルド・debuggable | `eas build --profile development` |
| **preview** | QA / テスト配布；Release 設定だが内部署名 | `eas build --profile preview` |
| **production** | 本番ストア提出用；Release + Store 署名 | `eas build --profile production` |

これらは `eas.json` で自由に追加・カスタム可能です citeturn0search2。  

---

## 4. 選択基準と推奨フロー

1. **まず Expo Go** で PoC／画面モック。  
2. **ネイティブ SDK（推し SDK / Notifee など）を導入したら Development Build** に切替え。Push 通知や広告 SDK はここで解決できるケースが多い。  
3. **App Store／Play 配信フローを試す段階で Prebuild + EAS preview**。CI とストア審査に向けた証明書管理を早期に整える。  
4. **OS 拡張（App Clip・Widget・Watch など）が必要** になったら Bare に移行か、新規ネイティブモジュールを Config Plugin で追加。  

この段階的アプローチを公式も推奨し、SDK 51 リリースノートでも「Expo Go は実験用、実案件は Dev Build 以上を推奨」と明言しています citeturn0search9。

---

## 5. まとめ

* Expo は **ワークフローが 4 段階、ビルドが 3 プロファイル**。  
* **日常開発は “Development Build” が最適解**：Expo Go の DX を保ちつつネイティブ自由度を確保。  
* **Prebuild + EAS preview/production** がストア提出の王道。  
* Bare へは高度要求が出たときだけ。  

これを基本方針として、まず Development Build で運用を始め、要件に応じて Prebuild → Bare へスムーズに拡張していくのが現時点（2025）のベストプラクティスです。

---
