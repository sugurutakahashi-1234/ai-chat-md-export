# 共通のAppErrorを使ってアラートを表示

日付: 2023-06-15

---

## 👤 ユーザー
*2023/06/15 20:44:01*

以下のような共通のAppErrorという型を用意している

 ```swift public enum ApiRequestError: Error {}

// SDK の AuthError と重複するため AppXXX としている
public enum AppAuthError: Error {}

public enum AppError: LocalizedError {
    case apiRequestError(ApiRequestError)
    case authError(AppAuthError)
    case customError(message: String)
    case unknownError
    
    var description: String {
        switch self {
        case .apiRequestError(let error):
            return error.localizedDescription
        case .authError(let error):
            return error.localizedDescription
        case .customError(message: let message):
            return message
        case .unknownError:
            return "予期せぬエラーです"
        }
    }
}
```

iOS15から使える以下のアラートを使って共通化したい。
AppError をextension してアラートのタイトル、ボタン名、メッセージであったりをある程度、共通化したい。

MVVMを想定していて、VMに @Published  appError: AppError? を保持して、それだけでうまくアラートを表現したい。難しかったらshowAlert: Bool のフラグもいれていいです

```swift
func alert<E, A, M>(
    isPresented: Binding<Bool>,
    error: E?,
    @ViewBuilder actions: (E) -> A,
    @ViewBuilder message: (E) -> M
) -> some View where E : LocalizedError, A : View, M : View
```

いい案とそれの使い方とかあればおしえてほしい。

---

## 🤖 アシスタント
*2023/06/15 20:45:04*

以下に、`AppError`を拡張して、あなたが望む振る舞いを追加し、そしてこの新しい機能を使って`alert`を呼び出す方法を示します。

まず、`AppError`を拡張してアラートのタイトルとボタンの名前を提供する方法です：

```swift
extension AppError {
    var alertTitle: String {
        return "エラー"  // もしくは他の適切なタイトルを返す
    }
    
    var alertButtonTitle: String {
        return "OK" // もしくは他の適切なボタン名を返す
    }
}
```

次に、アラートを表示するための新しい`alert`メソッドを定義します。これは`@Published var appError: AppError?`を使用してViewModel内でエラーを表示します。そして、エラーが存在する場合に`alert`を表示します。

ViewModelは次のようになります：

```swift
class ViewModel: ObservableObject {
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
    
    // appErrorの変更を監視してshowAlertを更新します
    private var cancellable: AnyCancellable?
    
    init() {
        cancellable = $appError
            .sink { [weak self] in self?.showAlert = $0 != nil }
    }
    
    deinit {
        cancellable?.cancel()
    }
    
    // エラーハンドリングの処理をここに書く
    func handleError() {
        // ...
        self.appError = .apiRequestError(ApiRequestError())
    }
}
```

そして、`View`は次のようになります：

```swift
struct ContentView: View {
    @ObservedObject var viewModel: ViewModel

    var body: some View {
        // あなたのビューのコードをここに書く
        
        // エラーアラートを表示するためのアラートメソッド
        .alert(isPresented: $viewModel.showAlert) {
            Alert(
                title: Text(viewModel.appError?.alertTitle ?? "エラー"),
                message: Text(viewModel.appError?.description ?? "予期せぬエラーです"),
                dismissButton: .default(Text(viewModel.appError?.alertButtonTitle ?? "OK")) {
                    // ボタンのアクションをここに書く
                    viewModel.showAlert = false
                    viewModel.appError = nil
                }
            )
        }
    }
}
```

この方法は、`AppError`から直接アラートを生成するため、エラーハンドリングを一元化し、`ViewModel`をクリーンに保つことができます。これにより、どの`View`でもエラーメッセージを一貫して表示できます。

---

## 👤 ユーザー
*2023/06/15 20:45:44*

以下をつかってほしい。iOS15以降はそのAlertの表示の仕方は非推奨のはずだ

```swift
func alert<E, A, M>(
    isPresented: Binding<Bool>,
    error: E?,
    @ViewBuilder actions: (E) -> A,
    @ViewBuilder message: (E) -> M
) -> some View where E : LocalizedError, A : View, M : View
```

---

## 🤖 アシスタント
*2023/06/15 20:46:31*

申し訳ありません、それを見落としていました。iOS 15以降で推奨されている`alert`関数を使い、`ViewModel`の`appError`を使用して、それに基づいたアクションとメッセージを表示する方法を以下に示します：

まず`AppError`にタイトルとボタンの名前を追加します：

```swift
extension AppError {
    var title: String {
        return "エラー"
    }

    var buttonTitle: String {
        return "OK"
    }
}
```

そして、`ViewModel`の定義は以下のようになります：

```swift
class ViewModel: ObservableObject {
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
    
    // appErrorの変更を監視してshowAlertを更新します
    private var cancellable: AnyCancellable?
    
    init() {
        cancellable = $appError
            .sink { [weak self] in self?.showAlert = $0 != nil }
    }
    
    deinit {
        cancellable?.cancel()
    }
    
    // エラーハンドリングの処理をここに書く
    func handleError() {
        // ...
        self.appError = .apiRequestError(ApiRequestError())
    }
}
```

最後に、`View`の定義です：

```swift
struct ContentView: View {
    @ObservedObject var viewModel: ViewModel

    var body: some View {
        // あなたのビューのコードをここに書く
    }
    .alert(
        isPresented: $viewModel.showAlert,
        error: viewModel.appError,
        actions: { error in
            Button(error.buttonTitle) {
                viewModel.appError = nil
                viewModel.showAlert = false
            }
        },
        message: { error in
            VStack {
                Text(error.title)
                Text(error.description)
            }
        }
    )
}
```

この方法では、アラートの生成が`AppError`の情報に基づいているため、エラーハンドリングの一元化と`ViewModel`のクリーンな保持が可能です。また、新しい`alert`メソッドを使用することで、iOS 15以降の推奨方法に従っています。

---

## 👤 ユーザー
*2023/06/15 20:46:57*

その方針は合っているよ

---

## 🤖 アシスタント
*2023/06/15 20:47:08*

素晴らしいです！もし他に質問や手助けが必要なことがあれば、お気軽にお知らせください。また、このコードがあなたのプロジェクトに有益であればとても嬉しいです。どのように改善できるかについてのフィードバックも常に歓迎しています。

---

## 👤 ユーザー
*2023/06/15 20:48:35*

以下の処理はView側でも同じような処理を書いたら良くないのかな？

```
cancellable = $appError
            .sink { [weak self] in self?.showAlert = $0 != nil }
```

また、その処理はよく使いそうなので、extension で Bool を返すようなものを作った方がいいと思った。

---

## 🤖 アシスタント
*2023/06/15 20:49:34*

`$appError.sink { [weak self] in self?.showAlert = $0 != nil }` は `ViewModel` 内でエラーの有無により `showAlert` フラグを更新しています。これにより、エラーが発生した際に自動的にアラートが表示されます。

この処理を `View` 側に移動することも可能ですが、その場合、各 `View` でエラーハンドリングのロジックを書く必要があります。それに対して、このロジックを `ViewModel` に一元化することで、よりクリーンな `View` コードを保つことができます。

しかし、あなたのアプリケーションの設計やニーズにより、 `View` 側でこのロジックを書くことが適切である場合もあります。その場合は、各 `View` の `body` プロパティで `onReceive` メソッドを使用して、 `appError` の変更を監視し、それに応じて `showAlert` を更新することができます。

また、あなたの提案について、 `Publisher` の値が `nil` かどうかをチェックし、それに基づいて `Bool` を返すような汎用的な `Publisher` 拡張を作るというのは良い考えです。これにより、このようなパターンを頻繁に使用する場合にコードの重複を避けることができます。以下にそのような拡張の一例を示します：

```swift
extension Publisher where Output: OptionalProtocol {
    var isNotNil: AnyPublisher<Bool, Failure> {
        return map { $0.optional != nil }
            .eraseToAnyPublisher()
    }
}

protocol OptionalProtocol {
    associatedtype Wrapped
    var optional: Wrapped? { get }
}

extension Optional: OptionalProtocol {
    var optional: Wrapped? { self }
}
```

これにより、ViewModelで `isNotNil` メソッドを利用できます：

```swift
cancellable = $appError
    .isNotNil
    .assign(to: &$showAlert)
```

ここで、`OptionalProtocol`を用いる理由は、Swiftのジェネリックシステムが直接`Optional`型に対する制約を許可しないためです。このプロトコルは`Optional`が実装しており、`Optional`型の値に対して拡張を提供します。

---

## 👤 ユーザー
*2023/06/15 20:54:08*

それ結構いいかも。そうするとViewModelやViewでshowAlertの更新はするひつようがなくなるきがしていて、AppError? への Errorの代入や nil の代入で全てうまくいく気がしている。
なので@Published var showAlertのように代入ができる型だと良くない気がしてきた。それを踏まえてViewとViewModelを修正できないかな

class ViewModel: ObservableObject {
    @Published var appError: AppError?
    @Published var showAlert: Bool = false
}

---

## 🤖 アシスタント
*2023/06/15 20:54:51*

あなたの提案通り、`showAlert`の管理を自動化するために、`showAlert`を`AnyPublisher<Bool, Never>`型にして、`appError`の変更を監視し、それに基づいて`showAlert`の値を自動的に更新することができます。以下にそれを行うための修正を示します：

まず、`ViewModel`を次のように修正します：

```swift
class ViewModel: ObservableObject {
    @Published var appError: AppError?
    
    // showAlertをBoolからAnyPublisherに変更します。
    var showAlert: AnyPublisher<Bool, Never> {
        $appError
            .isNotNil
    }
    
    // エラーハンドリングの処理をここに書く
    func handleError() {
        // ...
        self.appError = .apiRequestError(ApiRequestError())
    }
}
```

次に、Viewを以下のように修正します：

```swift
struct ContentView: View {
    @ObservedObject var viewModel: ViewModel

    @State private var showAlert = false
    
    var body: some View {
        // あなたのビューのコードをここに書く
        
        // appErrorの変更を監視し、それに基づいてshowAlertを更新します
        .onReceive(viewModel.showAlert) { showAlert in
            self.showAlert = showAlert
        }
        .alert(
            isPresented: $showAlert,
            error: viewModel.appError,
            actions: { error in
                Button(error.buttonTitle) {
                    viewModel.appError = nil
                }
            },
            message: { error in
                VStack {
                    Text(error.title)
                    Text(error.description)
                }
            }
        )
    }
}
```

これにより、`showAlert`の更新は`appError`の変更に基づいて自動的に行われます。そのため、エラーハンドリングは`appError`の更新だけを行うことで完結します。これにより、`ViewModel`と`View`のコードがさらに簡潔になりました。

---

## 👤 ユーザー
*2023/06/15 20:56:48*

バインディングしないといけないんだ、、なるほど。じゃあやっぱり、ViewModelに@Published var showAlert: Boolをおいた方がいいね。

ちょっと質問なんだけど、代入はさせないけど、ViewのisPresentedにバインディングできるようなshowAlertみたいなものを設定することはできないのかん？

---

## 🤖 アシスタント
*2023/06/15 20:57:31*

そうです、SwiftUIでは`Binding<Bool>`が必要となるため、`ViewModel`に`@Published var showAlert: Bool`を保持するのが一般的なパターンです。

しかしながら、`showAlert`を`ReadOnly`（読み取り専用）にしたいというニーズがある場合、`@Published`プロパティをprivateにし、それに対する読み取り専用のプロパティを公開することで達成できます。

以下にそのような実装の一例を示します：

```swift
class ViewModel: ObservableObject {
    @Published var appError: AppError?
    
    // showAlert を private にします
    @Published private var _showAlert: Bool = false
    
    // showAlert を読み取り専用のプロパティとして公開します
    var showAlert: Binding<Bool> {
        Binding(
            get: { [weak self] in self?._showAlert ?? false },
            set: { _ in } // 何もしない
        )
    }
    
    private var cancellable: AnyCancellable?
    
    init() {
        cancellable = $appError
            .isNotNil
            .assign(to: &_showAlert)
    }
    
    // エラーハンドリングの処理をここに書く
    func handleError() {
        // ...
        self.appError = .apiRequestError(ApiRequestError())
    }
}
```

ここでは、`_showAlert`は`ViewModel`内部でのみ変更可能で、外部からは読み取り専用の`showAlert`を介してのみアクセス可能となっています。`showAlert`は`Binding<Bool>`型の値として公開され、これは読み取り専用です（`set`関数は何も行わない）。したがって、この`showAlert`はViewからバインドできますが、Viewから直接変更することはできません。

---

## 👤 ユーザー
*2023/06/15 20:58:56*

そこまでする必要はなさそうだね。

extension Publisher where Output: OptionalProtocol {
    var isNotNil: AnyPublisher&lt;Bool, Failure&gt; {
        return map { $0.optional != nil }
            .eraseToAnyPublisher()
    }
}

protocol OptionalProtocol {
    associatedtype Wrapped
    var optional: Wrapped? { get }
}

extension Optional: OptionalProtocol {
    var optional: Wrapped? { self }
}

を使ってシンプルにViewModelに@Published var appError: AppError?と@Published var showAlert: Bool = falseを定義するような記述をもう一回書いて欲しい

---

## 🤖 アシスタント
*2023/06/15 20:59:45*

もちろんです、以下にその実装を示します。

```swift
import Combine

class ViewModel: ObservableObject {
    @Published var appError: AppError?
    @Published var showAlert: Bool = false

    private var cancellable: AnyCancellable?

    init() {
        cancellable = $appError
            .isNotNil
            .assign(to: &$showAlert)
    }
    
    // エラーハンドリングの処理をここに書く
    func handleError() {
        // ...
        self.appError = .apiRequestError(ApiRequestError())
    }
}
```

このコードでは、`appError`が更新されるたびに、`showAlert`も自動的に更新されます。`nil`ではないエラーが`appError`に設定されると、`showAlert`は`true`に設定され、アラートが表示されます。また、`appError`が`nil`に設定されると、`showAlert`は`false`に設定され、アラートは非表示になります。

`showAlert`は`View`にバインドでき、エラーが発生した場合にアラートを表示することができます。以下はそのためのサンプル`View`です：

```swift
struct ContentView: View {
    @ObservedObject var viewModel: ViewModel

    var body: some View {
        // あなたのビューのコードをここに書く
        
        .alert(
            isPresented: $viewModel.showAlert,
            error: viewModel.appError,
            actions: { error in
                Button(error.buttonTitle) {
                    viewModel.appError = nil
                }
            },
            message: { error in
                VStack {
                    Text(error.title)
                    Text(error.description)
                }
            }
        )
    }
}
```

上記のようにすれば、`ViewModel`内でエラーを発生させる（`appError`に値を設定する）だけで、アラートが表示されます。エラーが解決したら（`appError`を`nil`に設定すると）、アラートが自動的に非表示になります。

---

## 👤 ユーザー
*2023/06/15 22:03:50*

アラートのタイトルはerror: viewModel.appErrorで決まるみたいだけど上書きする方法はどうすればいいの？

---

## 🤖 アシスタント
*2023/06/15 22:05:04*

SwiftUIの`alert`関数では、エラーのタイトルは`Error`プロトコルの`localizedDescription`プロパティによって自動的に決定されます。したがって、エラータイトルを上書きするには、エラータイプで`localizedDescription`プロパティをオーバーライドする必要があります。

しかしながら、すでにあなたの`AppError` enumは`LocalizedError`プロトコルを実装していて、独自のエラーメッセージを定義しています。そのため、以下のように`errorDescription`プロパティをオーバーライドすれば、アラートのタイトルを上書きできます。

```swift
public enum AppError: LocalizedError {
    case apiRequestError(ApiRequestError)
    case authError(AppAuthError)
    case customError(message: String)
    case unknownError
    
    public var errorDescription: String? {
        switch self {
        case .apiRequestError:
            return "APIリクエストエラー"
        case .authError:
            return "認証エラー"
        case .customError:
            return "カスタムエラー"
        case .unknownError:
            return "予期せぬエラーです"
        }
    }
    
    // 以前定義した description を errorMessage にリネーム
    var errorMessage: String {
        switch self {
        case .apiRequestError(let error):
            return error.localizedDescription
        case .authError(let error):
            return error.localizedDescription
        case .customError(message: let message):
            return message
        case .unknownError:
            return "予期せぬエラーが発生しました。"
        }
    }
}
```

上記の修正を行った後、以下のように`View`を修正すれば、`errorMessage`をアラートのメッセージとして表示できます。

```swift
struct ContentView: View {
    @ObservedObject var viewModel: ViewModel

    var body: some View {
        // あなたのビューのコードをここに書く
        
        .alert(
            isPresented: $viewModel.showAlert,
            error: viewModel.appError,
            actions: { error in
                Button("OK") {
                    viewModel.appError = nil
                }
            },
            message: { error in
                VStack {
                    Text(error.errorDescription ?? "エラー") // エラータイトル
                    Text((error as? AppError)?.errorMessage ?? "") // エラーメッセージ
                }
            }
        )
    }
}
```

以上の修正により、各エラータイプごとに独自のエラーメッセージとエラータイトルを表示できます。

---

## 👤 ユーザー
*2023/06/15 22:12:42*

以下をsomeとかに直せるのかな

extension Publisher where Output: OptionalProtocol {
    func isNotNil() -&gt; AnyPublisher&lt;Bool, Failure&gt; {
        map { $0.optional != nil }
            .eraseToAnyPublisher()
    }
}

protocol OptionalProtocol {
    associatedtype Wrapped
    var optional: Wrapped? { get }
}

extension Optional: OptionalProtocol {
    var optional: Wrapped? { self }
}

---

## 🤖 アシスタント
*2023/06/15 22:13:32*

Swift 5.1以降の場合、あなたが探している`some`キーワードは一部の場合に使えますが、その使用は`Publisher`プロトコルや関連する型推論のような広範な状況では利用できません。それは、`some`キーワードは具体的な型を返す場合のみに使用可能で、プロトコルタイプを返す場合には使用できません。

なので、あなたが提示したコードの`AnyPublisher`を`some Publisher`に直接変換することはできません。これは、`some`キーワードがオブジェクトの具体的な型を返すことを保証する一方で、`Publisher`プロトコルは関連型を含むため、具体的な型を指定せずには利用できないからです。

それでも、`AnyPublisher`を避けるための一つの解決策は、具体的な型を使用することです。つまり、`AnyPublisher`を返す代わりに、`isNotNil`関数から直接`Publishers.Map`を返すことです。ただし、このアプローチの欠点は、関数の使用者がこの具体的な型を意識しなければならない点です。

以下にその例を示します:

```swift
extension Publisher where Output: OptionalProtocol {
    func isNotNil() -> Publishers.Map<Self, Bool> {
        map { $0.optional != nil }
    }
}
```

このコードの`isNotNil`関数は`Publishers.Map`のインスタンスを直接返しますが、これは利用者に具体的な型を公開してしまいます。

---
