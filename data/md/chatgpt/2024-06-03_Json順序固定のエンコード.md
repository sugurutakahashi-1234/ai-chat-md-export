# Json順序固定のエンコード

日付: 2024-06-03

---

## 👤 ユーザー
*2024/6/3 19:12:46*

Swiftでjsonをエンコードするが、毎回keyの順番が固定ではない。固定にしたい場合はどうすればいいか？

class JSONHandleDriver {
    func encodeToJSONString(anyObject: Any) throws -&gt; String {
        guard let encodableObject = anyObject as? (any Encodable) else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        let data = try encoder.encode(encodableObject)

        guard let jsonString = String(data: data, encoding: .utf8) else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        return jsonString
    }

    func encodeToJSONString(object: some Encodable) throws -&gt; String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        let data = try encoder.encode(object)

        guard let jsonString = String(data: data, encoding: .utf8) else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        return jsonString
    }

    func encodeToJSONString(objects: \[some Encodable\]) throws -&gt; String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        let data = try encoder.encode(objects)
        guard let jsonString = String(data: data, encoding: .utf8) else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        return jsonString
    }
}

---

## 🤖 アシスタント
*2024/6/3 19:13:14*

Swiftの`JSONEncoder`を使用してJSONをエンコードする際、キーの順序は保証されません。しかし、キーの順序を固定にする方法があります。JSONエンコード前に、辞書形式に変換して、キーをソートしてからエンコードすることが一つの解決策です。

以下は、キーの順序を固定にするための修正案です：

1. `JSONSerialization`を使用して、オブジェクトを辞書形式に変換。
2. 辞書のキーをソートして、新しい辞書を作成。
3. 再びエンコード。

以下のように実装します。

```swift
class JSONHandleDriver {
    func encodeToJSONString(anyObject: Any) throws -> String {
        guard let encodableObject = anyObject as? (any Encodable) else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        let data = try encoder.encode(encodableObject)
        guard let jsonObject = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        let sortedJsonData = try JSONSerialization.data(withJSONObject: sortDictionary(jsonObject), options: .prettyPrinted)
        guard let jsonString = String(data: sortedJsonData, encoding: .utf8) else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        return jsonString
    }

    func encodeToJSONString(object: some Encodable) throws -> String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        let data = try encoder.encode(object)
        guard let jsonObject = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        let sortedJsonData = try JSONSerialization.data(withJSONObject: sortDictionary(jsonObject), options: .prettyPrinted)
        guard let jsonString = String(data: sortedJsonData, encoding: .utf8) else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        return jsonString
    }

    func encodeToJSONString(objects: [some Encodable]) throws -> String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        let data = try encoder.encode(objects)
        guard let jsonArray = try JSONSerialization.jsonObject(with: data) as? [[String: Any]] else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        let sortedJsonArray = jsonArray.map { sortDictionary($0) }
        let sortedJsonData = try JSONSerialization.data(withJSONObject: sortedJsonArray, options: .prettyPrinted)
        guard let jsonString = String(data: sortedJsonData, encoding: .utf8) else {
            OSLogger.debugLog("JSON Encode Error")
            throw AppError.customError("JSON Encode Error")
        }

        return jsonString
    }

    private func sortDictionary(_ dictionary: [String: Any]) -> [String: Any] {
        let sortedKeys = dictionary.keys.sorted()
        var sortedDictionary = [String: Any]()
        for key in sortedKeys {
            if let value = dictionary[key] as? [String: Any] {
                sortedDictionary[key] = sortDictionary(value)
            } else if let value = dictionary[key] as? [[String: Any]] {
                sortedDictionary[key] = value.map { sortDictionary($0) }
            } else {
                sortedDictionary[key] = dictionary[key]
            }
        }
        return sortedDictionary
    }
}
```

この修正により、エンコードされたJSON文字列のキーの順序が保証されます。辞書内のキーをソートすることで、一定の順序を維持します。

---
