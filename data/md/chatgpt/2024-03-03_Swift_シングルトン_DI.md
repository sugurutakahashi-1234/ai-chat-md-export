# Swift シングルトン DI

日付: 2024-03-03

---

## 👤 ユーザー
*2024/03/03 17:52:29*

SwiftでのシングルトンのDIのサンプルコード

---

## 🤖 アシスタント
*2024/03/03 17:53:12*

Swiftでシングルトンパターンを使用し、依存性注入（DI）を行う方法には、いくつかのアプローチがあります。ここでは、基本的なシングルトンクラスを作成し、それを他のクラスに注入する簡単な例を示します。

### シングルトンクラスの定義

まず、シングルトンとして機能するクラスを定義します。このクラスは、自身の唯一のインスタンスへの静的アクセスポイントを提供します。

```swift
class MySingleton {
    static let shared = MySingleton()
    
    private init() {
        // Private initialization to ensure just one instance is created.
    }
    
    func doSomething() {
        // 実際の処理
        print("Doing something...")
    }
}
```

### 依存性注入（DI）を使用するクラス

次に、シングルトンを使用するクラスを定義します。このクラスは、コンストラクタ注入を通じてシングルトンへの参照を受け取ります。これにより、テストのしやすさが向上し、シングルトンの使用による強固な依存関係を緩和できます。

```swift
class ConsumerClass {
    private let singleton: MySingleton
    
    init(singleton: MySingleton = .shared) {
        self.singleton = singleton
    }
    
    func useSingleton() {
        singleton.doSomething()
    }
}
```

この例では、`ConsumerClass`は`MySingleton`のインスタンスをコンストラクタを通じて受け取りますが、デフォルト引数として`.shared`を使用しています。これにより、特に指定しない場合は自動的にシングルトンインスタンスが使用されますが、テストなどの目的で異なるインスタンスを注入することも可能になります。

### 使用例

```swift
let consumer = ConsumerClass()
consumer.useSingleton()
```

テスト時には、`MySingleton`をモックまたはスタブに置き換え、`ConsumerClass`に注入することができます。これにより、単体テストが容易になります。

この例は、Swiftでシングルトンと依存性注入を組み合わせる一般的な方法を示していますが、プロジェクトの具体的な要件に応じてカスタマイズする必要があるかもしれません。

---

## 👤 ユーザー
*2024/03/03 17:53:38*

そうじゃなくてdosomethingをするクラスを2つ用意して本番用とテスト用で分けるイメージ

---

## 🤖 アシスタント
*2024/03/03 17:54:11*

理解しました。シングルトンの使用例として、`doSomething`メソッドを持つプロトコルを定義し、それを実装する2つのクラス（本番用とテスト用）を用意し、依存性注入を通じて切り替えられるようにするアプローチを紹介します。

### プロトコルの定義

まず、`doSomething`メソッドを持つプロトコルを定義します。これにより、異なる実装を容易に切り替えられるようになります。

```swift
protocol DoSomethingProtocol {
    func doSomething()
}
```

### 本番用クラスとテスト用クラスの定義

次に、上記プロトコルに準拠する本番用クラスとテスト用クラスを定義します。

```swift
class ProductionDoSomething: DoSomethingProtocol {
    static let shared = ProductionDoSomething()
    
    private init() {}
    
    func doSomething() {
        // 本番環境での具体的な処理
        print("Doing something in production...")
    }
}

class TestDoSomething: DoSomethingProtocol {
    func doSomething() {
        // テスト環境での具体的な処理
        print("Doing something in test...")
    }
}
```

### 依存性注入（DI）を使用するクラスの定義

`DoSomethingProtocol`プロトコルを使用するクラスを定義し、コンストラクタ注入を通じて依存性を注入します。

```swift
class ConsumerClass {
    private let doSomethingService: DoSomethingProtocol
    
    init(doSomethingService: DoSomethingProtocol) {
        self.doSomethingService = doSomethingService
    }
    
    func performAction() {
        doSomethingService.doSomething()
    }
}
```

### 使用例

本番環境での使用例として、`ProductionDoSomething`のシングルトンインスタンスを`ConsumerClass`に注入します。

```swift
let productionConsumer = ConsumerClass(doSomethingService: ProductionDoSomething.shared)
productionConsumer.performAction()
```

テスト時には、`TestDoSomething`のインスタンスを注入します。

```swift
let testConsumer = ConsumerClass(doSomethingService: TestDoSomething())
testConsumer.performAction()
```

この方法により、`doSomething`の実装を本番用とテスト用で切り替えられるようになり、依存性注入を通じて柔軟性とテストのしやすさを確保できます。

---
