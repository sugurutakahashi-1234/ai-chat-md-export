# リファクタリングの提案

Date: 2023-05-18

---

## 👤 User
*2023-05-19 01:29:28*

以下のコードをリファクタリングしたい。

Fruit と Vegetable が共通の String, CaseIterable, Identifiable, IdentifiableDestination というprotocol を継承しているところと var id: String { rawValue } が共通なところとかがリファクタできるんじゃないかな

```swift
enum TransitionMethod {
    case push, modal
}

enum Fruit: String, CaseIterable, Identifiable, IdentifiableDestination {
    case apple = "Apple"
    case banana = "Banana"
    case cherry = "Cherry"
    
    var id: String { rawValue }
    
    var transitionMethod: TransitionMethod {
        switch self {
        case .apple:
            return .push
        case .banana, .cherry:
            return .modal
        }
    }
    
    @ViewBuilder
    var destinationView: some View {
        switch self {
        case .apple:
            AppleView()
        case .banana:
            BananaView()
        case .cherry:
            CherryView()
        }
    }
}

enum Vegetable: String, CaseIterable, Identifiable, IdentifiableDestination {
    case carrot = "Carrot"
    case tomato = "Tomato"
    case pepper = "Pepper"
    
    var id: String { rawValue }
    
    var transitionMethod: TransitionMethod {
        switch self {
        case .carrot, .pepper:
            return .push
        case .tomato:
            return .modal
        }
    }
    
    @ViewBuilder
    var destinationView: some View {
        DetailView(item: rawValue)
    }
}
```

---

## 🤖 Assistant
*2023-05-19 01:31:01*

Swiftでは、protocolを使用して共通部分を抽出し、適用することで、コードをリファクタリングできます。すでに `Identifiable` と `IdentifiableDestination` プロトコルが使われていますが、それに加えて、新たなプロトコル `Navigatable` を定義することで、共通の振る舞いを定義できます。

以下のようにリファクタリングできます：

```swift
protocol Navigatable: String, CaseIterable, Identifiable {
    associatedtype DestinationView: View
    var transitionMethod: TransitionMethod { get }
    @ViewBuilder var destinationView: DestinationView { get }
}

extension Navigatable {
    var id: String { rawValue }
}

enum TransitionMethod {
    case push, modal
}

enum Fruit: Navigatable {
    case apple = "Apple"
    case banana = "Banana"
    case cherry = "Cherry"

    var transitionMethod: TransitionMethod {
        switch self {
        case .apple:
            return .push
        case .banana, .cherry:
            return .modal
        }
    }
    
    @ViewBuilder
    var destinationView: some View {
        switch self {
        case .apple:
            AppleView()
        case .banana:
            BananaView()
        case .cherry:
            CherryView()
        }
    }
}

enum Vegetable: Navigatable {
    case carrot = "Carrot"
    case tomato = "Tomato"
    case pepper = "Pepper"
    
    var transitionMethod: TransitionMethod {
        switch self {
        case .carrot, .pepper:
            return .push
        case .tomato:
            return .modal
        }
    }
    
    @ViewBuilder
    var destinationView: some View {
        DetailView(item: rawValue)
    }
}
```

このコードでは、`Navigatable` プロトコルを新たに作成し、共通の `id` の実装と `transitionMethod`、`destinationView` の要件を定義しています。その後、`Fruit` と `Vegetable` enumにこのプロトコルを適用しています。これにより、各enumが要件を満たすようにコードを書くだけで良くなり、コードの重複が減少します。

---

## 👤 User
*2023-05-19 01:33:51*

protocol Navigatable: String, CaseIterable, Identifiable の記述で以下の記述がでてきた。enum を想定して記述しないといけなのかもしれない

Inheritance from non-protocol, non-class type 'String'
Type 'Self' constrained to non-protocol, non-class type 'String'

---

## 🤖 Assistant
*2023-05-19 01:35:15*

すみません、Swiftのプロトコルは直接クラスや列挙型を継承することはできません。代わりに、String, CaseIterable, Identifiableを継承するような具体的な型を指定するassociatedtypeを使用することができます。

しかし、このケースではそれは難しいので、Navigatableプロトコルを一部修正しましょう。Navigatableプロトコルは具体的な型に紐付けることなく、単に必要な動作を定義するものとします。

```swift
protocol Navigatable: Identifiable {
    associatedtype RawValue: StringProtocol
    associatedtype DestinationView: View
    var rawValue: RawValue { get }
    var transitionMethod: TransitionMethod { get }
    @ViewBuilder var destinationView: DestinationView { get }
}

extension Navigatable {
    var id: Self { self }
}
```

ただし、この変更によりFruitとVegetableの定義が少し複雑になります。それらは直接Stringを継承できないため、rawValueプロパティを自分自身で提供する必要があります：

```swift
enum Fruit: CaseIterable, Navigatable {
    case apple = "Apple"
    case banana = "Banana"
    case cherry = "Cherry"
    
    typealias RawValue = String
    
    var rawValue: RawValue {
        switch self {
        case .apple:
            return "Apple"
        case .banana:
            return "Banana"
        case .cherry:
            return "Cherry"
        }
    }

    // Rest of the code
}
```

これでプロトコルとenumの定義が正しくなり、期待通りに動作するはずです。

---

## 👤 User
*2023-05-19 01:35:57*

RawRepresentable とか使った方が綺麗に書けたりしない？

---

## 🤖 Assistant
*2023-05-19 01:36:06*

はい、ご指摘の通り、Swiftの `RawRepresentable` というプロトコルを使用するとよりスッキリとしたコードになります。

---
