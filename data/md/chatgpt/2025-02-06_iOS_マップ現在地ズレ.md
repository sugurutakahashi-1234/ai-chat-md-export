# iOS ãƒãƒƒãƒ—ç¾åœ¨åœ°ã‚ºãƒ¬

æ—¥ä»˜: 2025-02-06

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/02/06 19:33:49*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-8Y3YNcfdZy5xE4KFLLAkr1",
  "size_bytes": 1237012,
  "width": 806,
  "height": 1638,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
å·¦ä¸Šã®éš…ã«ç¾åœ¨åœ°ãŒã‚ã‚‹çŠ¶æ…‹ã®ãŒFlutterä¸Šã§ã¯GoogleMapä¸Šã®ç¾åœ¨åœ°ã¨ãªã£ã¦ã—ã¾ã£ã¦ã„ã‚‹ã€‚

ã“ã‚Œã¯æ¯å›ç™ºç”Ÿã™ã‚‹ãƒã‚°ã§ã¯ãªã„ã—ã€iOSã§ã®ã¿ç™ºç”Ÿã™ã‚‹ã€‚

initialCameraPositionã§æ¸¡ã—ã¦ã„ã‚‹ç·¯åº¦çµŒåº¦ã¯åˆã£ã¦ã„ã‚‹ã“ã¨ã‚„onTapNearMeã—ãŸéš›ã«animateCameraã•ã›ã¦ã„ã‚‹ã¨ãã®ç·¯åº¦çµŒåº¦ã¯ç¢ºå®Ÿã«ã‚ã£ã¦ã„ã‚‹ã€‚

ã©ã®ã‚ˆã†ã«å¯¾å¿œã™ã¹ãã‹æ¡ˆãŒæ¬²ã—ã„

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/spot_type.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/entities/extensions/convert_to_domain.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/flavor_provider.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/location_access_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/item_box_icon.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_icon.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/location_utils.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

/// é€†ä¸‰è§’å½¢ã‚’æç”»ã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãª Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // å·¦ä¸Š
      ..lineTo(size.width, 0) // å³ä¸Š
      ..lineTo(size.width / 2, size.height) // åº•è¾ºã®ä¸­å¤®
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final flavor = ref.watch(flavorProvider);
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isLoadingState = useState(false);

    Future&lt;void&gt; zoomToFitCircle({
      required LatLng center,
      required double radiusMeters,
    }) async {
      // 1km â‰ˆ 0.009åº¦ (å³å¯†ã§ãªãã¦OK)
      // ä»Šå›ã¯ 1~10km ç¨‹åº¦ãªã®ã§ã“ã‚Œã§ååˆ†
      final radiusKm = radiusMeters / 1000.0;
      final delta = 0.009 * radiusKm;

      // å—è¥¿ç«¯ã¨åŒ—æ±ç«¯ã‚’ã–ã£ãã‚Šæ±ºã‚ã‚‹
      final southwest = LatLng(
        center.latitude - delta,
        center.longitude - delta,
      );
      final northeast = LatLng(
        center.latitude + delta,
        center.longitude + delta,
      );

      // LatLngBounds ã‚’ä½œæˆ
      final bounds = LatLngBounds(southwest: southwest, northeast: northeast);

      const padding = 72.0; // ç”»é¢å››éš…ã¨ã®ä½™ç™½
      final cameraUpdate = CameraUpdate.newLatLngBounds(bounds, padding);

      if (!context.mounted) {
        return;
      }

      await googleMapControllerState.value?.animateCamera(cameraUpdate);
    }

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              SpotIcon(spotType: spotType),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final rarity = itemBox.rarity?.domainRarity;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: ItemBoxIcon(
                        rarity: rarity,
                        size: 64,
                      ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(242, 275),
        waitToRender: const Duration(milliseconds: 10),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 10),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    Future&lt;void&gt; refreshAllMarkers({
      required List&lt;GuildSpotDTO&gt; newSpotList,
      required List&lt;ItemBoxDTO&gt; newItemBoxList,
      required String? myGuildId,
    }) async {
      final currentMarkers = markersState.value.toSet();

      final neededMarkerIds = &lt;String&gt;{};
      for (final spot in newSpotList) {
        final spotId = spot.spotId ?? '';
        neededMarkerIds.add('spot_$spotId');
      }
      for (final box in newItemBoxList) {
        final boxId = box.itemBoxId ?? '';
        neededMarkerIds.add('itemBox_$boxId');
      }

      // æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ã€Œä¸è¦ã«ãªã£ãŸã‚‚ã®ã€ã‚’å‰Šé™¤ã™ã‚‹
      currentMarkers.removeWhere(
        (marker) =&gt; !neededMarkerIds.contains(marker.markerId.value),
      );

      if (!context.mounted) {
        return;
      }

      // ã„ã£ãŸã‚“å‰Šé™¤çµæœã‚’åæ˜ (ä¸è¦ãƒãƒ¼ã‚«ãƒ¼ãŒæ¶ˆãˆã‚‹)
      markersState.value = {...currentMarkers};

      // Spot ã®ãƒªã‚¹ãƒˆã‚’é †ã«å‡¦ç†ã—ã€1ã¤ãšã¤å†æç”»ã—ã¦åæ˜ 
      for (final spot in newSpotList) {
        final markerId = MarkerId('spot_${spot.spotId}');
        // buildSpotMarker (å¿…ãšå†ç”Ÿæˆã—ã¦å†æç”»ã™ã‚‹)
        final newMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // æ—¢å­˜ã«åŒã˜ ID ã®ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        // æ–°ãŸã«è¿½åŠ ã•ã‚Œã‚‹ or æ›´æ–°ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼ã‚’ã™ãåæ˜ 
        markersState.value = {...currentMarkers};

        // UI ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã«ããã™ã‚‹ãŸã‚ã«å°‘ã—å¾…æ©Ÿ
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox ã‚‚åŒæ§˜ã«å‡¦ç†
      for (final itemBox in newItemBoxList) {
        final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
        final newMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (box) async {
            await onTapItemBoxMarker(box);
          },
        );

        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        markersState.value = {...currentMarkers};

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

    Future&lt;void&gt; onTapLocationAccess() async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return const LocationAccessDialog();
        },
      );
    }

    Future&lt;void&gt; onTapNearMe() async {
      try {
        final currentLocation = await getCurrentLocation(flavor: flavor);

        if (googleMapControllerState.value == null) {
          return;
        }

        await googleMapControllerState.value?.animateCamera(
          CameraUpdate.newLatLng(currentLocation),
        );
      } on PlatformException catch (error) {
        // ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸èƒ½ã®ãŸã‚ã‚¹ãƒ«ãƒ¼
        debugPrint('Error: $error');
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; startExploring(OnExploringState exploringState) async {
      try {
        final currentLocation = await getCurrentLocation(flavor: flavor);

        // range ã¯ km å˜ä½ãªã®ã§ã€ãƒ¡ãƒ¼ãƒˆãƒ«ã«æ›ç®—ï¼ˆÃ—1000ï¼‰
        final explorerRangeKm = exploringState.explorer?.range ?? 0;
        final rangeInMeters = explorerRangeKm * 1000.0;

        final circle = Circle(
          circleId: const CircleId('explorerCircle'),
          center: currentLocation,
          radius: rangeInMeters,
          strokeColor: const Color(0xFF004DFF), // ãƒ–ãƒ«ãƒ¼
          strokeWidth: 1,
          fillColor: const Color(0x40004DFF), // 25%ãã‚‰ã„é€éã®ãƒ–ãƒ«ãƒ¼
        );

        if (!context.mounted) {
          return;
        }

        circlesState.value = {circle};

        await zoomToFitCircle(
          center: currentLocation,
          radiusMeters: rangeInMeters,
        );
      } on PlatformException catch (error) {
        // ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸èƒ½ã®ãŸã‚ã‚¹ãƒ«ãƒ¼
        debugPrint('Error: $error');
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; endExploring() async {
      if (!context.mounted) {
        return;
      }

      circlesState.value = {};
      final explodedSpotList = ref.read(explodedSpotListNotifierProvider);
      final spotPhotoItems = explodedSpotList
              ?.where((spot) =&gt; spot.photoUrl != null)
              .map(
                (spot) =&gt; SpotPhotoItem(
                  photoId: spot.photoId ?? '',
                  spotPhotoUrl: spot.photoUrl ?? '',
                  spotOwnership: spot.guildId == null
                      ? SpotOwnership.neutral
                      : spot.guildId == myGuildIdState.value
                          ? SpotOwnership.owner
                          : SpotOwnership.enemy,
                ),
              )
              .toList() ??
          [];

      ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) =&gt; ExploredResultDialog(
          spotPhotoItemList: spotPhotoItems,
        ),
      );

      ref.read(explodedSpotListNotifierProvider.notifier).clear();
    }

    Future&lt;void&gt; onRefresh() async {
      try {
        if (!context.mounted) {
          return;
        }

        isLoadingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        if (!context.mounted) {
          return;
        }

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshAllMarkers(
            newSpotList: spotList,
            newItemBoxList: itemBoxList,
            myGuildId: myGuildId,
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        if (context.mounted) {
          isLoadingState.value = false;
        }
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await onRefresh();
        });

        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!isLoadingState.value) {
          // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°
          await onRefresh();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          await startExploring(next);
        } else {
          await endExploring();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) {
          return Stack(
            children: [
              GoogleMap(
                initialCameraPosition: CameraPosition(
                  target: currentLocation,
                  zoom: 16,
                ),
                onMapCreated: (controller) {
                  if (context.mounted) {
                    debugPrint('Map created');
                    googleMapControllerState.value = controller;
                  }
                },
                markers: markersState.value,
                circles: circlesState.value,
                myLocationEnabled: true,
                myLocationButtonEnabled: false,
                zoomControlsEnabled: false,
                mapToolbarEnabled: false,
                rotateGesturesEnabled: false,
                compassEnabled: false,
              ),

              // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ã‚ãšã‚‰ã‚ã—ã„ã®ã§ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
              // if (isLoadingState.value)
              //   const Center(child: CircularProgressIndicator()),

              Positioned(
                bottom: 16,
                left: 16,
                right: 16,
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                      SizedBox(
                        width: 48,
                        height: 48,
                        child: FloatingActionButton(
                          heroTag: 'CurrentLocationButton',
                          onPressed: () async {
                            await onTapNearMe();
                          },
                          child: const Icon(
                            Icons.near_me,
                            size: 24,
                            color: ColorToken.secondaryDark,
                          ),
                        ),
                      ),
                      // Explore ãƒªã‚¹ãƒˆ
                      SizedBox(
                        width: 138,
                        height: 48,
                        child: FloatingActionButton(
                          heroTag: 'ShowExploreListButton',
                          onPressed: onExploringStateValue.isExploring
                              ? null
                              : () async {
                                  await onTapExplorer();
                                },
                          backgroundColor: onExploringStateValue.isExploring
                              ? ColorPallet.gray800.withValues(alpha: 0.8)
                              : Theme.of(context)
                                  .floatingActionButtonTheme
                                  .backgroundColor,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(40),
                            side: BorderSide(
                              color: onExploringStateValue.isExploring
                                  ? Colors.transparent
                                  : ColorToken.secondaryLight,
                            ),
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(left: 4),
                                child: onExploringStateValue.isExploring
                                    ? Transform.translate(
                                        offset: const Offset(4, 0),
                                        child: const SizedBox(
                                          width: 24,
                                          height: 24,
                                          child: CircularProgressIndicator(
                                            strokeWidth: 2,
                                          ),
                                        ),
                                      )
                                    : Image.asset(
                                        Assets.images.explorerIconFig.path,
                                        width: 40,
                                        height: 40,
                                      ),
                              ),
                              const Spacer(),
                              Text(
                                onExploringStateValue.isExploring
                                    ? 'Exploring...'
                                    : 'Explore',
                                style: TextStyle(
                                  fontSize: 16,
                                  color: onExploringStateValue.isExploring
                                      ? ColorToken.text
                                      : ColorToken.secondaryDark,
                                ),
                              ),
                              const Spacer(),
                            ],
                          ),
                        ),
                      ),
                      // Spot ãƒªã‚¹ãƒˆ
                      spotListAsyncValue.when(
                        data: (spotList) {
                          // ä¸Šä½2ã¤ã‚’å–ã‚Šå‡ºã—ã€é †åºã‚’é€†ã«ã™ã‚‹
                          final displaySpotList =
                              (spotList?.take(2).toList() ?? [])
                                  .reversed
                                  .toList();
                          return SizedBox(
                            width: 48,
                            height: 48,
                            child: FloatingActionButton(
                              backgroundColor: Colors.transparent,
                              shape: const RoundedRectangleBorder(
                                side: BorderSide(
                                  color: Colors.transparent,
                                ),
                              ),
                              onPressed: () async {
                                await onTapSpotList();
                              },
                              child: Transform.translate(
                                offset: const Offset(4, 4),
                                child: Stack(
                                  clipBehavior: Clip.none,
                                  alignment: Alignment.bottomRight,
                                  children: [
                                    for (var i = 0; i &lt; 2; i++)
                                      if (i &lt; displaySpotList.length)
                                        Positioned(
                                          left: i * -4.0,
                                          top: i * -4.0,
                                          child: SizedBox(
                                            width: 44,
                                            height: 44,
                                            child: DecoratedBox(
                                              decoration: BoxDecoration(
                                                border: Border.all(
                                                  color: ColorToken.bgWhite,
                                                  width: 2,
                                                ),
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                              ),
                                              child: Padding(
                                                padding:
                                                    const EdgeInsets.all(2),
                                                child: ClipRRect(
                                                  borderRadius:
                                                      BorderRadius.circular(
                                                    4,
                                                  ),
                                                  child: SquareImage(
                                                    imageUrl: displaySpotList[i]
                                                        .photoUrl,
                                                    size: 44,
                                                  ),
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                  ],
                                ),
                              ),
                            ),
                          );
                        },
                        loading: () {
                          return const SizedBox.shrink();
                        },
                        error: (error, _) {
                          return SizedBox(
                            width: 48,
                            height: 48,
                            child: FloatingActionButton(
                              heroTag: 'ErrorShowSpotListButton',
                              onPressed: () async {
                                await onTapSpotList();
                              },
                              child: const Icon(
                                Icons.photo,
                                size: 24,
                                color: ColorToken.secondaryDark,
                              ),
                            ),
                          );
                        },
                      ),
                    ],
                  ),
                ),
              ),
            ],
          );
        },
        loading: () {
          return const Center(
            child: CircularProgressIndicator(),
          );
        },
        error: (error, _) {
          return Padding(
            padding: const EdgeInsets.all(24),
            child: Center(
              child: ElevatedButton(
                onPressed: () async {
                  await onTapLocationAccess();
                },
                child: const Text(
                  'Please enable location access',
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/02/06 19:34:48*

iOS ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ã®ã¿ã”ãã¾ã‚Œã«ç™ºç”Ÿã™ã‚‹ã‚ˆã†ãªã€Œç¾åœ¨åœ°ãŒãƒãƒƒãƒ—ã®å·¦ä¸Šç«¯ã«å›ºå®šã•ã‚ŒãŸã¾ã¾ã«ãªã£ã¦ã—ã¾ã†ã€ç¾è±¡ã¯ã€GoogleMapâ€Flutter ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç‰¹æœ‰ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚„ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«å‘¨ã‚Šã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãšã‚Œã§èµ·ã“ã‚‹ã‚±ãƒ¼ã‚¹ãŒå¤šã„ã§ã™ã€‚ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚„ç¢ºèªé …ç›®ã‚’è©¦ã—ã¦ã¿ã‚‹ã¨ã€æ”¹å–„ã™ã‚‹å¯èƒ½æ€§ãŒé«˜ã„ã§ã™ã€‚

---

## 1. ãƒãƒƒãƒ—ç”Ÿæˆå¾Œã«å†åº¦ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã™ã‚‹

`onMapCreated` ã‚„ `addPostFrameCallback` ã®ã‚ˆã†ãªã€Œæç”»å®Œäº†å¾Œã€ã‚’ãƒˆãƒªã‚¬ãƒ¼ã«ã—ã¦ã€ã‚‚ã†ä¸€åº¦ `animateCamera` ã‚„ `moveCamera` ã‚’å‘¼ã³å‡ºã™æ–¹æ³•ã§ã™ã€‚  
åˆå›ã® `initialCameraPosition` ãŒåŠ¹ããã‚‰ãªã„ã¾ã¾ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã¦ã—ã¾ã„ã€ç”»é¢å·¦ä¸Šã«ãšã‚Œã¦æç”»ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ã€æ˜ç¤ºçš„ã«ã‚‚ã†ä¸€åº¦å‘¼ã¶ã¨ãšã‚ŒãŒè§£æ¶ˆã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚

```dart
onMapCreated: (controller) async {
  googleMapControllerState.value = controller;
  // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®Œäº†å¾Œã«å†åº¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã•ã›ã‚‹
  WidgetsBinding.instance.addPostFrameCallback((_) {
    controller.animateCamera(
      CameraUpdate.newLatLngZoom(currentLocation, 16),
    );
  });
},
```

ã‚ã‚‹ã„ã¯å°‘ã— `Future.delayed(Duration(milliseconds: 200))` ãªã©ã‚’å…¥ã‚Œã¦ã€æç”»ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’å¾…ã£ã¦ã‹ã‚‰å‘¼ã¶æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚

---

## 2. iOS Simulator ã®ä½ç½®æƒ…å ±ï¼ˆLocationï¼‰è¨­å®šã‚’ç¢ºèªã™ã‚‹

iOS ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ä¸Šã§ãƒ†ã‚¹ãƒˆã™ã‚‹éš›ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã® Debug â†’ Location ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã€Œã‚«ã‚¹ã‚¿ãƒ ä½ç½®æƒ…å ±ã€ã‚„ã€ŒNoneã€ã«ãªã£ã¦ã„ã‚‹ã¨ã€åˆæœŸåº§æ¨™ãŒ (0,0) æ‰±ã„ã«ãªã‚ŠãŒã¡ã§ã™ã€‚  
çµæœã¨ã—ã¦åœ°å›³ã®å·¦ä¸Šç«¯ã«ãƒãƒƒãƒ—ä¸Šã® â€œç¾åœ¨åœ°â€ ãŒã¨ã©ã¾ã£ã¦ã—ã¾ã†ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã® location è¨­å®šã‚’å›ºå®šã™ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯ä»»æ„ã®å ´æ‰€ã«å¤‰æ›´ã—ãŸçŠ¶æ…‹ã§ãƒ†ã‚¹ãƒˆã—ã¦ã¿ã¦ãã ã•ã„ã€‚

---

## 3. Info.plist ã§ã®ä½ç½®æƒ…å ±ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³è¨­å®šã‚„å®Ÿç«¯æœ«ã§ã®æŒ™å‹•ã‚’ç¢ºèªã™ã‚‹

- iOS ã§ä½ç½®æƒ…å ±ã‚’æ­£ã—ãä½¿ã†ã«ã¯ã€`Info.plist` ã« `NSLocationWhenInUseUsageDescription`ï¼ˆã‚ã‚‹ã„ã¯ `NSLocationAlwaysAndWhenInUseUsageDescription`ï¼‰ã®ã‚­ãƒ¼ãŒå¿…è¦ã§ã™ã€‚  
- ã“ã‚ŒãŒç„¡ã„ãƒ»ã‚ã‚‹ã„ã¯æ–‡è¨€ã«å•é¡ŒãŒã‚ã‚‹ã¨æ­£ã—ãä½ç½®ã‚’å–å¾—ã§ããšã€åˆæœŸå€¤ãŒãšã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚  
- ã‚‚ã—å¯èƒ½ã§ã‚ã‚Œã°å®Ÿç«¯æœ«ã§ã‚‚ãƒ“ãƒ«ãƒ‰ã—ã¦ã¿ã¦ã€åŒæ§˜ã®ç¾è±¡ãŒèµ·ãã‚‹ã‹ã©ã†ã‹ã‚’åˆ‡ã‚Šåˆ†ã‘ã‚‹ã®ãŒãŠã™ã™ã‚ã§ã™ã€‚

---

## 4. SafeArea ã‚„ä½™ç™½ã«ã‚ˆã‚‹ã‚ºãƒ¬ãŒç„¡ã„ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹

iPhone ã®ä¸Šéƒ¨ãƒãƒƒãƒãªã©ã§ SafeArea ãŒå…¥ã£ã¦ã„ã‚‹ã¨ã€Widget å…¨ä½“ãŒæ„å›³ã›ãšã‚ªãƒ•ã‚»ãƒƒãƒˆã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚  
`Scaffold` ã®ç›´ä¸‹ã« `SafeArea` ãŒå…¥ã£ã¦ã„ã‚‹å ´åˆã‚„ã€ã»ã‹ã®ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã§ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ ã—ã¦ã„ã‚‹å ´åˆã€ä¸€æ™‚çš„ã«ãã‚Œã‚’å¤–ã—ãŸçŠ¶æ…‹ã§ãƒãƒƒãƒ—ãŒã©ã†ãªã‚‹ã‹ç¢ºèªã—ã¦ã¿ã¦ãã ã•ã„ã€‚

---

## 5. ãƒãƒƒãƒ—ã®å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ»ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã¨ã®ç«¶åˆã‚’ç–‘ã†

Flutter ã§ `GoogleMap` ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’ä½¿ã†ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã¨ãã«ãƒãƒƒãƒ—ãŒå†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã‚‹ãƒ»ä½ç½®ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

- ç”»é¢å›è»¢ï¼ˆç”»é¢ã‚µã‚¤ã‚ºå¤‰æ›´ï¼‰ãŒèµ·ããŸã¨ã
- ã‚¢ãƒ—ãƒªãŒãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«æˆ»ã£ã¦ããŸã¨ã
- Provider ç­‰ã®ã‚¹ãƒ†ãƒ¼ãƒˆãƒªãƒ“ãƒ«ãƒ‰ã«ã‚ˆã‚Š `build` ãŒèµ°ã£ãŸã¨ã

ã“ã‚Œã‚‰ã§åº§æ¨™æ›´æ–°ãŒç«¶åˆã—ã¦ã—ã¾ã†å ´åˆã€æ„å›³ã—ãªã„ã‚«ãƒ¡ãƒ©ä½ç½®ï¼ˆå·¦ä¸Šãªã©ï¼‰ã«é£›ã¶ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚å¯¾ç­–ã¨ã—ã¦ã¯

1. ã™ã¹ã¦ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã§ `animateCamera` ã‚’å‘¼ã°ãšã€å¿…è¦ãªã¨ãã ã‘å‘¼ã¶  
2. `onMapCreated` ã‚„ `didChangeAppLifecycleState` å†…ã§åº§æ¨™ã‚’æ›´æ–°ã™ã‚‹éš›ã€å†æç”»ã¨ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒè¡çªã—ãªã„ã‚ˆã†å°‘ã—é…å»¶ (`Future.delayed`) ã‚’æŒŸã‚€

ãªã©ã‚’è©¦ã™ã¨æ”¹å–„ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

---

## 6. Google Maps Flutter ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ»æ—¢çŸ¥ã®ä¸å…·åˆã‚’ç¢ºèªã™ã‚‹

Google Maps Flutter ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚ˆã£ã¦ iOS ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§æç”»ãŒå´©ã‚Œã‚‹æ—¢çŸ¥ã®ä¸å…·åˆãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚  
`pubspec.yaml` ã§ä½¿ã£ã¦ã„ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆã¨ãã®ä¾å­˜é–¢ä¿‚ï¼‰ã‚’æœ€æ–°ã«ä¸Šã’ã¦ã¿ã‚‹ã®ã‚‚ä¸€ã¤ã®æ‰‹ã§ã™ã€‚

---

## 7. ï¼ˆæœ€çµ‚æ‰‹æ®µï¼‰ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒãƒ£ãƒãƒ«ãƒ¬ãƒ™ãƒ«ã§å¼·åˆ¶çš„ã«ãƒªã‚µã‚¤ã‚ºã‚„å†æç”»

ã©ã†ã—ã¦ã‚‚è§£æ±ºã—ãªã„å ´åˆã¯ã€`PlatformView` ã‚’æ‰±ã†éš›ã®ãƒã‚°ã¨ã„ã†å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`mapController.setMapStyle(...)` ã‚„ `controller.animateCamera(...)` ãªã©ã‚’ã€Œå†æç”»ã®ãƒˆãƒªã‚¬ãƒ¼ã€ã¨ã—ã¦å‘¼ã³å‡ºã—ã¦å•é¡Œå›é¿ã‚’å›³ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚  
ã—ã‹ã—é€šå¸¸ã¯ã“ã“ã¾ã§ã‚„ã‚‰ãšã¨ã‚‚ã€ä¸Šè¨˜ã®ã‚ˆã†ãªé…å»¶ã‚„ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«èª¿æ•´ã§å¤§æŠµè§£æ¶ˆã™ã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚

---

## ã¾ã¨ã‚

1. **æç”»å¾Œã«æ”¹ã‚ã¦ `animateCamera` ã™ã‚‹**  
2. **iOS ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã® Location è¨­å®šã‚„ `Info.plist` ã®ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚’å†ãƒã‚§ãƒƒã‚¯**  
3. **SafeArea ã‚„ä½™è¨ˆãªãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã§ã‚ªãƒ•ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã„ã‹**  
4. **ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚„ã‚¹ãƒ†ãƒ¼ãƒˆå†ãƒ“ãƒ«ãƒ‰ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ãšã‚‰ã™**  
5. **Google Maps Flutter ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚„ä¾å­˜é–¢ä¿‚ã‚’æœ€æ–°ã«ã—ã¦ã¿ã‚‹**

ã“ã®ã‚ãŸã‚Šã‚’ä¸€é€šã‚Šè©¦ã—ã¦ã¿ã‚‹ã¨ã€iOS ã§ã®ã¿ç™ºç”Ÿã™ã‚‹ç¾åœ¨åœ°è¡¨ç¤ºã®ã‚ºãƒ¬ãŒæ”¹å–„ã§ãã‚‹å¯èƒ½æ€§ãŒé«˜ã„ã§ã™ã€‚ç‰¹ã«å†æç”»ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ãšã‚ŒãŒåŸå› ã«ãªã‚Šã‚„ã™ã„ã®ã§ã€ã€Œãƒãƒƒãƒ—ãŒç”Ÿæˆã•ã‚ŒãŸç›´å¾Œã«å°‘ã—é…ã‚‰ã›ã¦ã‚‚ã†ä¸€åº¦ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã€æ–¹æ³•ãŒãŠã™ã™ã‚ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/02/06 19:39:45*

å†æç”»ã•ã›ãŸã„ã€‚å†æç”»ã•ã›ã‚‹ã®ãŒä¸€ç•ªå„åœ°å›³ã«ç›´ã‚‹ã‚“ã 

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/02/06 19:40:51*

**å†æç”»ï¼ˆãƒªãƒ“ãƒ«ãƒ‰ï¼‰ã‚’å¼·åˆ¶çš„ã«ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹**ã«ã¯ã€Flutter Widget ã® `key` ã‚’ä»˜ã‘æ›¿ãˆã‚‹æ–¹æ³•ãŒã‚·ãƒ³ãƒ—ãƒ«ã§ç¢ºå®Ÿã§ã™ã€‚`GoogleMap` ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã«ãƒ¦ãƒ‹ãƒ¼ã‚¯ãª `Key` ã‚’ä¸ãˆã€ãã‚Œã‚’å·®ã—æ›¿ãˆã‚‹ã“ã¨ã§ã€Flutter ã¯ã€Œåˆ¥ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã€ã¨ã—ã¦èªè­˜ã—å†ç”Ÿæˆï¼ˆå†æç”»ï¼‰ã—ã¦ãã‚Œã¾ã™ã€‚

ä¸‹è¨˜ã¯ `HookConsumerWidget` ã§æ›¸ãå ´åˆã®ä¸€ä¾‹ã§ã™ï¼ˆRiverpod+Hooks ã‚’æƒ³å®šï¼‰ã€‚`useState(UniqueKey())` ã§ç®¡ç†ã—ã¦ã„ã‚‹ `mapKey` ã‚’å·®ã—æ›¿ãˆã‚‹ã“ã¨ã§ã€GoogleMap ã‚’å†æç”»ã•ã›ã‚‹ä»•çµ„ã¿ã«ãªã£ã¦ã„ã¾ã™ã€‚

```dart
class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // GoogleMapç”¨ã®Keyã‚’stateã§ç®¡ç†ã™ã‚‹
    final mapKeyState = useState(UniqueKey());

    return Scaffold(
      body: Stack(
        children: [
          GoogleMap(
            key: mapKeyState.value, // ãƒ¦ãƒ‹ãƒ¼ã‚¯ãª Key ã‚’æŒ‡å®š
            initialCameraPosition: const CameraPosition(
              target: LatLng(35.0, 135.0),
              zoom: 16,
            ),
            // ä»¥é™ã®è¨­å®š...
          ),
          Positioned(
            bottom: 16,
            left: 16,
            child: ElevatedButton(
              onPressed: () {
                // ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ã«Keyã‚’æ›´æ–° -> GoogleMap ãŒå†ç”Ÿæˆã•ã‚Œã‚‹
                mapKeyState.value = UniqueKey();
              },
              child: const Text('Re-render Map'),
            ),
          ),
        ],
      ),
    );
  }
}
```

ã“ã‚Œã§ `mapKeyState.value = UniqueKey();` ã¨å·®ã—æ›¿ãˆã‚‹ãŸã³ã« `GoogleMap` ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã¯ã€Œåˆ¥ç‰©ã€ã¨ã—ã¦èªè­˜ã•ã‚Œã€**å†æç”»ï¼ˆå†ç”Ÿæˆï¼‰** ã•ã‚Œã¾ã™ã€‚  
å®Ÿé‹ç”¨ã§ â€œåœ°å›³ã‚’ã¾ã‚‹ã£ã¨ä½œã‚Šç›´ã™â€ ã®ã¯ã‚„ã‚„é‡ã„å‡¦ç†ã§ã™ãŒã€ã€Œã©ã†ã—ã¦ã‚‚ iOS ã§ä½ç½®ãŒãšã‚Œã‚‹ãƒã‚°ã‚’ç›´ã—ãŸã„ã®ã§å†æç”»ã—ã¦ãƒªã‚»ãƒƒãƒˆã—ãŸã„ã€ã¨ã„ã†å ´åˆã«ã¯ã‚·ãƒ³ãƒ—ãƒ«ã‹ã¤ç¢ºå®Ÿãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã™ã€‚

---

### ä»–ã®å†æç”»æ‰‹æ³•ã¨ã®æ¯”è¼ƒ

1. **`controller.animateCamera` ç­‰ã§å†æç”»ã‚’ãƒˆãƒªã‚¬ãƒ¼**  
   - ã“ã¡ã‚‰ã¯ã€Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’å¤‰æ›´ã™ã‚‹ã€ã ã‘ã§ã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒ“ãƒ¥ãƒ¼è‡ªä½“ã®å†åˆæœŸåŒ–ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è»½é‡ã§ã™ãŒã€è¡¨ç¤ºãšã‚ŒãŒæ ¹æœ¬çš„ã«ç›´ã‚‰ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚

2. **`setState` ã‚„çŠ¶æ…‹å¤‰åŒ–ã®ã¿ã§ãƒ“ãƒ«ãƒ‰ã‚’å†èµ°ã•ã›ã‚‹**  
   - ã“ã¡ã‚‰ã‚‚åŒã˜ã‚­ãƒ¼ã‚’ä½¿ã£ãŸã¾ã¾å†ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã ã‘ã ã¨ã€GoogleMap ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒ“ãƒ¥ãƒ¼è‡ªä½“ã¯å†ç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã€‚è¦‹ãŸç›®ä¸Šã¯ã‚ã¾ã‚Šå¤‰ã‚ã‚‰ãªã„ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚

3. **`mapKey` ã‚’å·®ã—æ›¿ãˆã¦ã€Œåˆ¥Widgetã€ã¨ã—ã¦å†åº¦ç”Ÿæˆã•ã›ã‚‹**  
   - é‡ã„ä»£ã‚ã‚Šã«ã€ãƒãƒƒãƒ—ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¾ã‚‹ã”ã¨ä½œã‚Šç›´ã•ã‚Œã¾ã™ã€‚è¡¨ç¤ºãƒã‚°ãŒè§£æ¶ˆã•ã‚Œã‚‹å¯èƒ½æ€§ãŒä¸€ç•ªé«˜ã„æ–¹æ³•ã§ã™ã€‚

---

ã€ŒiOS ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ã¾ã‚Œã«ãƒãƒƒãƒ—ãŒå·¦ä¸Šã«å›ºå®šã•ã‚Œã‚‹ï¼å†æç”»ã—ãŸã‚‰ç›´ã‚‹ã€ã‚ˆã†ãªå ´åˆã«ã¯ã€ä¸Šè¨˜ã®**ã‚­ãƒ¼å·®ã—æ›¿ãˆ**ã§ãƒãƒƒãƒ—ã‚’å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã—ã¦ã‚ã’ã‚‹ã®ãŒç°¡å˜ã‹ã¤ç¢ºå®Ÿã§ã™ã€‚åŠ ãˆã¦ã€ä»¥å‰è¿°ã¹ãŸã‚ˆã†ã«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã® Location è¨­å®šã‚„ `Info.plist` ã®ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³è¨­å®šãªã©ã‚‚åˆã‚ã›ã¦ç¢ºèªã—ã¦ã¿ã¦ãã ã•ã„ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/02/06 20:29:50*

ã“ã®ã‚ˆã†ã«mapKeyStateã«ã‚ˆã£ã¦å†æç”»ã™ã‚‹ã“ã¨ã§è§£æ±ºã—ãŸã€‚
ãŸã ã€ã“ã‚Œã‚’è¡Œã†ã¨ã“ã®ç”»é¢ã«é·ç§»ã—ãŸç¬é–“ã€mapã®å†æç”»ãŒå…¥ã‚‹ã®ã§ãƒãƒ©ã¤ã„ã¦ã—ã¾ã†ã€‚
ãªã«ã‹ã†ã¾ã„æ–¹æ³•ã§ãƒãƒ©ã¤ãã‚’ç„¡ãã—ãŸã„ã€‚

æ–¹æ³•ã‚’æ¤œè¨ã—ã¦æ¬²ã—ã„ã€‚

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/domain/spot_type.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/entities/extensions/convert_to_domain.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/flavor_provider.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/location_access_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/item_box_icon.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_icon.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/location_utils.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

/// é€†ä¸‰è§’å½¢ã‚’æç”»ã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãª Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // å·¦ä¸Š
      ..lineTo(size.width, 0) // å³ä¸Š
      ..lineTo(size.width / 2, size.height) // åº•è¾ºã®ä¸­å¤®
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final flavor = ref.watch(flavorProvider);
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isLoadingState = useState(false);
    final isInitialForcedRefreshed = useState(false);
    final mapKeyState = useState(UniqueKey());

    Future&lt;void&gt; zoomToFitCircle({
      required LatLng center,
      required double radiusMeters,
    }) async {
      // 1km â‰ˆ 0.009åº¦ (å³å¯†ã§ãªãã¦OK)
      // ä»Šå›ã¯ 1~10km ç¨‹åº¦ãªã®ã§ã“ã‚Œã§ååˆ†
      final radiusKm = radiusMeters / 1000.0;
      final delta = 0.009 * radiusKm;

      // å—è¥¿ç«¯ã¨åŒ—æ±ç«¯ã‚’ã–ã£ãã‚Šæ±ºã‚ã‚‹
      final southwest = LatLng(
        center.latitude - delta,
        center.longitude - delta,
      );
      final northeast = LatLng(
        center.latitude + delta,
        center.longitude + delta,
      );

      // LatLngBounds ã‚’ä½œæˆ
      final bounds = LatLngBounds(southwest: southwest, northeast: northeast);

      const padding = 72.0; // ç”»é¢å››éš…ã¨ã®ä½™ç™½
      final cameraUpdate = CameraUpdate.newLatLngBounds(bounds, padding);

      if (!context.mounted) {
        return;
      }

      await googleMapControllerState.value?.animateCamera(cameraUpdate);
    }

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              SpotIcon(spotType: spotType),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final rarity = itemBox.rarity?.domainRarity;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: ItemBoxIcon(
                        rarity: rarity,
                        size: 64,
                      ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(242, 275),
        waitToRender: const Duration(milliseconds: 10),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 10),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    Future&lt;void&gt; refreshAllMarkers({
      required List&lt;GuildSpotDTO&gt; newSpotList,
      required List&lt;ItemBoxDTO&gt; newItemBoxList,
      required String? myGuildId,
    }) async {
      final currentMarkers = markersState.value.toSet();

      final neededMarkerIds = &lt;String&gt;{};
      for (final spot in newSpotList) {
        final spotId = spot.spotId ?? '';
        neededMarkerIds.add('spot_$spotId');
      }
      for (final box in newItemBoxList) {
        final boxId = box.itemBoxId ?? '';
        neededMarkerIds.add('itemBox_$boxId');
      }

      // æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ã€Œä¸è¦ã«ãªã£ãŸã‚‚ã®ã€ã‚’å‰Šé™¤ã™ã‚‹
      currentMarkers.removeWhere(
        (marker) =&gt; !neededMarkerIds.contains(marker.markerId.value),
      );

      if (!context.mounted) {
        return;
      }

      // ã„ã£ãŸã‚“å‰Šé™¤çµæœã‚’åæ˜ (ä¸è¦ãƒãƒ¼ã‚«ãƒ¼ãŒæ¶ˆãˆã‚‹)
      markersState.value = {...currentMarkers};

      // Spot ã®ãƒªã‚¹ãƒˆã‚’é †ã«å‡¦ç†ã—ã€1ã¤ãšã¤å†æç”»ã—ã¦åæ˜ 
      for (final spot in newSpotList) {
        final markerId = MarkerId('spot_${spot.spotId}');
        // buildSpotMarker (å¿…ãšå†ç”Ÿæˆã—ã¦å†æç”»ã™ã‚‹)
        final newMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // æ—¢å­˜ã«åŒã˜ ID ã®ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        // æ–°ãŸã«è¿½åŠ ã•ã‚Œã‚‹ or æ›´æ–°ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼ã‚’ã™ãåæ˜ 
        markersState.value = {...currentMarkers};

        // UI ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã«ããã™ã‚‹ãŸã‚ã«å°‘ã—å¾…æ©Ÿ
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox ã‚‚åŒæ§˜ã«å‡¦ç†
      for (final itemBox in newItemBoxList) {
        final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
        final newMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (box) async {
            await onTapItemBoxMarker(box);
          },
        );

        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        markersState.value = {...currentMarkers};

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

    Future&lt;void&gt; onTapLocationAccess() async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return const LocationAccessDialog();
        },
      );
    }

    Future&lt;void&gt; onTapNearMe() async {
      try {
        final currentLocation = await getCurrentLocation(flavor: flavor);

        if (googleMapControllerState.value == null) {
          return;
        }

        await googleMapControllerState.value?.animateCamera(
          CameraUpdate.newLatLng(currentLocation),
        );
      } on PlatformException catch (error) {
        // ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸èƒ½ã®ãŸã‚ã‚¹ãƒ«ãƒ¼
        debugPrint('Error: $error');
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; startExploring(OnExploringState exploringState) async {
      try {
        final currentLocation = await getCurrentLocation(flavor: flavor);

        // range ã¯ km å˜ä½ãªã®ã§ã€ãƒ¡ãƒ¼ãƒˆãƒ«ã«æ›ç®—ï¼ˆÃ—1000ï¼‰
        final explorerRangeKm = exploringState.explorer?.range ?? 0;
        final rangeInMeters = explorerRangeKm * 1000.0;

        final circle = Circle(
          circleId: const CircleId('explorerCircle'),
          center: currentLocation,
          radius: rangeInMeters,
          strokeColor: const Color(0xFF004DFF), // ãƒ–ãƒ«ãƒ¼
          strokeWidth: 1,
          fillColor: const Color(0x40004DFF), // 25%ãã‚‰ã„é€éã®ãƒ–ãƒ«ãƒ¼
        );

        if (!context.mounted) {
          return;
        }

        circlesState.value = {circle};

        await zoomToFitCircle(
          center: currentLocation,
          radiusMeters: rangeInMeters,
        );
      } on PlatformException catch (error) {
        // ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸èƒ½ã®ãŸã‚ã‚¹ãƒ«ãƒ¼
        debugPrint('Error: $error');
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; endExploring() async {
      if (!context.mounted) {
        return;
      }

      circlesState.value = {};
      final explodedSpotList = ref.read(explodedSpotListNotifierProvider);
      final spotPhotoItems = explodedSpotList
              ?.where((spot) =&gt; spot.photoUrl != null)
              .map(
                (spot) =&gt; SpotPhotoItem(
                  photoId: spot.photoId ?? '',
                  spotPhotoUrl: spot.photoUrl ?? '',
                  spotOwnership: spot.guildId == null
                      ? SpotOwnership.neutral
                      : spot.guildId == myGuildIdState.value
                          ? SpotOwnership.owner
                          : SpotOwnership.enemy,
                ),
              )
              .toList() ??
          [];

      ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) =&gt; ExploredResultDialog(
          spotPhotoItemList: spotPhotoItems,
        ),
      );

      ref.read(explodedSpotListNotifierProvider.notifier).clear();
    }

    Future&lt;void&gt; onRefresh() async {
      try {
        if (!context.mounted) {
          return;
        }

        isLoadingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        if (!context.mounted) {
          return;
        }

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshAllMarkers(
            newSpotList: spotList,
            newItemBoxList: itemBoxList,
            myGuildId: myGuildId,
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        if (context.mounted) {
          isLoadingState.value = false;
        }
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await onRefresh();
        });

        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    useEffect(
      () {
        if (isInitialForcedRefreshed.value) {
          // ç¾åœ¨ä½ç½®ãŒä¸­å¤®ã«æ¥ãªã„å•é¡Œã‚’ã™ã“ã—ã§ã‚‚æ¸›ã‚‰ã—ãŸã„ãŸã‚å®Ÿæ–½
          Future.microtask(() async {
            debugPrint('Forced refresh start');
            mapKeyState.value = UniqueKey();
            debugPrint('Forced refresh done');
          });
        }
        return null;
      },
      [isInitialForcedRefreshed.value],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!isLoadingState.value) {
          // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°
          await onRefresh();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          await startExploring(next);
        } else {
          await endExploring();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) {
          return Stack(
            children: [
              GoogleMap(
                key: mapKeyState.value,
                initialCameraPosition: CameraPosition(
                  target: currentLocation,
                  zoom: 16,
                ),
                onMapCreated: (controller) {
                  if (context.mounted) {
                    debugPrint('Map created');
                    googleMapControllerState.value = controller;
                    isInitialForcedRefreshed.value = true;
                  }
                },
                markers: markersState.value,
                circles: circlesState.value,
                myLocationEnabled: true,
                myLocationButtonEnabled: false,
                zoomControlsEnabled: false,
                mapToolbarEnabled: false,
                rotateGesturesEnabled: false,
                compassEnabled: false,
              ),

              // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¯ã‚ãšã‚‰ã‚ã—ã„ã®ã§ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
              // if (isLoadingState.value)
              //   const Center(child: CircularProgressIndicator()),

              Positioned(
                bottom: 16,
                left: 16,
                right: 16,
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                      SizedBox(
                        width: 48,
                        height: 48,
                        child: FloatingActionButton(
                          heroTag: 'CurrentLocationButton',
                          onPressed: () async {
                            await onTapNearMe();
                          },
                          child: const Icon(
                            Icons.near_me,
                            size: 24,
                            color: ColorToken.secondaryDark,
                          ),
                        ),
                      ),
                      // Explore ãƒªã‚¹ãƒˆ
                      SizedBox(
                        width: 138,
                        height: 48,
                        child: FloatingActionButton(
                          heroTag: 'ShowExploreListButton',
                          onPressed: onExploringStateValue.isExploring
                              ? null
                              : () async {
                                  await onTapExplorer();
                                },
                          backgroundColor: onExploringStateValue.isExploring
                              ? ColorPallet.gray800.withValues(alpha: 0.8)
                              : Theme.of(context)
                                  .floatingActionButtonTheme
                                  .backgroundColor,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(40),
                            side: BorderSide(
                              color: onExploringStateValue.isExploring
                                  ? Colors.transparent
                                  : ColorToken.secondaryLight,
                            ),
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(left: 4),
                                child: onExploringStateValue.isExploring
                                    ? Transform.translate(
                                        offset: const Offset(4, 0),
                                        child: const SizedBox(
                                          width: 24,
                                          height: 24,
                                          child: CircularProgressIndicator(
                                            strokeWidth: 2,
                                          ),
                                        ),
                                      )
                                    : Image.asset(
                                        Assets.images.explorerIconFig.path,
                                        width: 40,
                                        height: 40,
                                      ),
                              ),
                              const Spacer(),
                              Text(
                                onExploringStateValue.isExploring
                                    ? 'Exploring...'
                                    : 'Explore',
                                style: TextStyle(
                                  fontSize: 16,
                                  color: onExploringStateValue.isExploring
                                      ? ColorToken.text
                                      : ColorToken.secondaryDark,
                                ),
                              ),
                              const Spacer(),
                            ],
                          ),
                        ),
                      ),
                      // Spot ãƒªã‚¹ãƒˆ
                      spotListAsyncValue.when(
                        data: (spotList) {
                          // ä¸Šä½2ã¤ã‚’å–ã‚Šå‡ºã—ã€é †åºã‚’é€†ã«ã™ã‚‹
                          final displaySpotList =
                              (spotList?.take(2).toList() ?? [])
                                  .reversed
                                  .toList();
                          return SizedBox(
                            width: 48,
                            height: 48,
                            child: FloatingActionButton(
                              backgroundColor: Colors.transparent,
                              shape: const RoundedRectangleBorder(
                                side: BorderSide(
                                  color: Colors.transparent,
                                ),
                              ),
                              onPressed: () async {
                                await onTapSpotList();
                              },
                              child: Transform.translate(
                                offset: const Offset(4, 4),
                                child: Stack(
                                  clipBehavior: Clip.none,
                                  alignment: Alignment.bottomRight,
                                  children: [
                                    for (var i = 0; i &lt; 2; i++)
                                      if (i &lt; displaySpotList.length)
                                        Positioned(
                                          left: i * -4.0,
                                          top: i * -4.0,
                                          child: SizedBox(
                                            width: 44,
                                            height: 44,
                                            child: DecoratedBox(
                                              decoration: BoxDecoration(
                                                border: Border.all(
                                                  color: ColorToken.bgWhite,
                                                  width: 2,
                                                ),
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                              ),
                                              child: Padding(
                                                padding:
                                                    const EdgeInsets.all(2),
                                                child: ClipRRect(
                                                  borderRadius:
                                                      BorderRadius.circular(
                                                    4,
                                                  ),
                                                  child: SquareImage(
                                                    imageUrl: displaySpotList[i]
                                                        .photoUrl,
                                                    size: 44,
                                                  ),
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                  ],
                                ),
                              ),
                            ),
                          );
                        },
                        loading: () {
                          return const SizedBox.shrink();
                        },
                        error: (error, _) {
                          return SizedBox(
                            width: 48,
                            height: 48,
                            child: FloatingActionButton(
                              heroTag: 'ErrorShowSpotListButton',
                              onPressed: () async {
                                await onTapSpotList();
                              },
                              child: const Icon(
                                Icons.photo,
                                size: 24,
                                color: ColorToken.secondaryDark,
                              ),
                            ),
                          );
                        },
                      ),
                    ],
                  ),
                ),
              ),
            ],
          );
        },
        loading: () {
          return const Center(
            child: CircularProgressIndicator(),
          );
        },
        error: (error, _) {
          return Padding(
            padding: const EdgeInsets.all(24),
            child: Center(
              child: ElevatedButton(
                onPressed: () async {
                  await onTapLocationAccess();
                },
                child: const Text(
                  'Please enable location access',
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/02/06 20:31:15*

`key` ã‚’å·®ã—æ›¿ãˆã¦ **GoogleMap ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆè‡ªä½“ã‚’ä½œã‚Šç›´ã™** æ–¹æ³•ã¯ã€æç”»ãšã‚Œç­‰ã‚’ç¢ºå®Ÿã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã®ã«ä¾¿åˆ©ã§ã™ãŒã€ãã®åˆ†ã€Œå†ãƒã‚¦ãƒ³ãƒˆæ™‚ã«ä¸€ç¬ãƒãƒ©ã¤ãã€å•é¡ŒãŒã©ã†ã—ã¦ã‚‚èµ·ãã‚„ã™ã„ã§ã™ã€‚  
ä»¥ä¸‹ã§ã¯ã€**ãƒãƒ©ã¤ãã‚’ç›®ç«‹ãŸãªãã™ã‚‹** ãŸã‚ã«ä½¿ãˆã‚‹ä»£è¡¨çš„ãªãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

---

## 1. AnimatedSwitcher ã§ãƒ•ã‚§ãƒ¼ãƒ‰é·ç§»ã•ã›ã‚‹

Flutter æ¨™æº–ã® `AnimatedSwitcher` ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’ä½¿ã„ã€ GoogleMap ã®å·®ã—æ›¿ãˆæ™‚ã«ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ã‚„ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆãƒ»ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’è¡Œã†æ–¹æ³•ã§ã™ã€‚

```dart
return Scaffold(
  body: currentLocationAsyncValue.when(
    data: (currentLocation) {
      return AnimatedSwitcher(
        duration: const Duration(milliseconds: 300),
        transitionBuilder: (child, animation) {
          // ã“ã“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒ‡å®š
          return FadeTransition(
            opacity: animation,
            child: child,
          );
        },
        child: Stack(
          key: ValueKey(mapKeyState.value), // AnimatedSwitcherã§åˆ¤åˆ¥ã•ã›ã‚‹ãŸã‚
          children: [
            GoogleMap(
              key: mapKeyState.value, // mapKey ã®å·®ã—æ›¿ãˆã§å†ãƒã‚¦ãƒ³ãƒˆ
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 16,
              ),
              // ...çœç•¥...
            ),
            // ãƒœã‚¿ãƒ³ãªã©
          ],
        ),
      );
    },
    // ...çœç•¥...
  ),
);
```

- **ãƒã‚¤ãƒ³ãƒˆ**  
  - `Stack` å…¨ä½“ã« `key` ã¨ã—ã¦ `mapKeyState.value` ã‚’ä»˜ä¸ã—ã€  
  - `AnimatedSwitcher` ã® `child` ã«æ¸¡ã™ã€‚  
  - ã™ã‚‹ã¨ã€`mapKeyState` ãŒåˆ‡ã‚Šæ›¿ã‚ã£ãŸéš›ã« `child` ãŒåˆ¥ç‰©ã¨åˆ¤å®šã•ã‚Œã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã§å·®ã—æ›¿ãˆãŒè¡Œã‚ã‚Œã¾ã™ã€‚  
  - ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ã®çµæœã€**ä¸€ç¬ã®ãƒãƒ©ã¤ããŒå¤šå°‘æŸ”ã‚‰ã‹ã„ãƒ•ã‚§ãƒ¼ãƒ‰ã«ãªã‚Š**ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®é•å’Œæ„ŸãŒæ¸›ã‚Šã¾ã™ã€‚

---

## 2. å¤ã„ãƒãƒƒãƒ—ã‚’æ®‹ã—ãŸã¾ã¾æ–°ã—ã„ãƒãƒƒãƒ—ã‚’ã€Œè£ã§ã€ãƒ­ãƒ¼ãƒ‰ã—ã€åˆ‡ã‚Šæ›¿ãˆã‚‹

ã€Œãƒ€ãƒ–ãƒ«ãƒãƒƒãƒ•ã‚¡ã€ã®ã‚ˆã†ã«ã€**æ—§ãƒãƒƒãƒ—ã‚’ã™ãç ´æ£„ã›ãšã€æ–°ãƒãƒƒãƒ—ãŒã§ãã‚ãŒã£ã¦ã‹ã‚‰é‡ã­ã¦åˆ‡ã‚Šæ›¿ãˆã‚‹**æ‰‹æ³•ã§ã™ã€‚  
å˜ç´”ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæµã‚Œã«ãªã‚Šã¾ã™ã€‚

1. æ—¢å­˜ã® GoogleMap ã‚’ãã®ã¾ã¾è¡¨ç¤ºã—ãŸã¾ã¾ã«ã™ã‚‹  
2. æ–°ã—ã„ã‚­ãƒ¼ã‚’ä½¿ã£ãŸ GoogleMap ã‚’ã€Œä¸‹ï¼ˆã¾ãŸã¯ä¸Šï¼‰ã«é‡ã­ã¦ã‚ªãƒ•ã‚¹ãƒ†ãƒ¼ã‚¸çŠ¶æ…‹ã€ã§å…ˆã«ç”Ÿæˆã—ã¦ãŠã  
3. `onMapCreated` ãªã©ã§ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å®Œäº†ã‚’å—ã‘å–ã£ãŸã‚‰ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ or ãƒ‘ãƒƒã¨åˆ‡ã‚Šæ›¿ãˆ  
4. å¤ã„ã»ã†ã‚’ç ´æ£„ã™ã‚‹

ãŸã ã—ã€ã“ã‚Œã¯ **PlatformView ã®äºŒé‡èµ·å‹•** ã«ãªã‚‹ãŸã‚ã€ç«¯æœ«ã‚„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚ˆã£ã¦ã¯å•é¡ŒãŒèµ·ãã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚è©¦ã—ã¦ã¿ã¦å¤§ä¸ˆå¤«ãã†ãªã‚‰æ¡ç”¨ã§ãã¾ã™ãŒã€è¤‡é›‘åŒ–ã—ã‚„ã™ã„ãŸã‚æœ€çµ‚æ‰‹æ®µã«è¿‘ã„ã§ã™ã€‚

---

## 3. ãã‚‚ãã‚‚ã‚­ãƒ¼å·®ã—æ›¿ãˆã‚’ â€œæœ€åˆã®1å›â€ ã ã‘é…ã‚‰ã›ã‚‹

ã€Œç”»é¢ãŒç”Ÿæˆã•ã‚ŒãŸç¬é–“ã«å¼·åˆ¶å†æç”»ã€ã‚’ã—ãªã„ã‚ˆã†ã€**ã‚­ãƒ¼å·®ã—æ›¿ãˆã‚’å°‘ã—å¾Œã«é…ã‚‰ã›ã‚‹** ã ã‘ã§ãƒãƒ©ã¤ããŒè»½æ¸›ã§ãã‚‹ã‚±ãƒ¼ã‚¹ã‚‚ã‚ã‚Šã¾ã™ã€‚

ãŸã¨ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã€ã€Œãƒãƒƒãƒ—ä½œæˆã‹ã‚‰300ãƒŸãƒªç§’å¾Œãã‚‰ã„ã«å†æç”»ã™ã‚‹ã€ãªã©ã€äººé–“ã®ç›®ã«è¿½ã„ã¤ã‹ã‚Œã«ãã„ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¾ã§å¾…ã¤æ–¹æ³•ã§ã™ã€‚

```dart
onMapCreated: (controller) {
  googleMapControllerState.value = controller;
  // å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†ç”Ÿæˆ
  Future.delayed(const Duration(milliseconds: 300), () {
    if (context.mounted) {
      mapKeyState.value = UniqueKey();
    }
  });
},
```

ã“ã†ã™ã‚‹ã¨ã€ã€Œãƒãƒƒãƒ—ãŒä¸€æ—¦è¡¨ç¤ºã•ã‚Œã€ã»ã‚“ã®å°‘ã—é–“ã‚’ãŠã„ã¦ã‹ã‚‰ã‚µãƒƒã¨å†æç”»ã€ã™ã‚‹ã®ã§ã€  
ãƒ“ãƒ«ãƒ‰ç›´å¾Œã«ç™½ç”»é¢ãŒè¦‹ãˆã‚‹ã‚ˆã†ãªãƒãƒ©ã¤ãã‚ˆã‚Šã¯ã€å¤šå°‘æ»‘ã‚‰ã‹ã«ãªã‚Šã¾ã™ã€‚

---

## 4. ã§ãã‚‹ã ã‘ã€Œã‚­ãƒ¼å·®ã—æ›¿ãˆã€ã‚’æ¸›ã‚‰ã™

å½“ç„¶ã§ã™ãŒã€å†ãƒã‚¦ãƒ³ãƒˆãŒå°‘ãªã‘ã‚Œã°å°‘ãªã„ã»ã©ãƒãƒ©ã¤ãã®ç™ºç”Ÿã‚‚æŠ‘ãˆã‚‰ã‚Œã¾ã™ã€‚  
ã‚‚ã—ã€Œã¨ã«ã‹ã **iOS ã®åˆæœŸè¡¨ç¤ºãŒãšã‚Œã‚‹** å•é¡Œã‚’è§£æ±ºã—ãŸã„ã ã‘ã€ã§ã‚ã‚Œã°ã€

- **ä¸€åº¦ã ã‘ `onMapCreated` å¾Œã« `animateCamera`** ã™ã‚‹  
- ã•ã‚‰ã«ãƒ€ãƒ¡ãªã¨ãã ã‘ â€œKey å·®ã—æ›¿ãˆï¼‹å†ãƒã‚¦ãƒ³ãƒˆâ€ ã‚’èµ°ã‚‰ã›ã‚‹  

ã¨ã„ã£ãŸæ‰‹é †ã«ã—ã¦ã€å†ãƒã‚¦ãƒ³ãƒˆé »åº¦ã‚’ **æœ€å°é™** ã«æŠ‘ãˆã‚‹ã“ã¨ã‚‚æ¤œè¨ã—ã¦ã¿ã¦ãã ã•ã„ã€‚  
ãƒã‚°ãŒå‡ºã‚‹ã‚±ãƒ¼ã‚¹ã‚’ãƒˆãƒªã‚¬ãƒ¼ã«ã®ã¿ã‚­ãƒ¼å·®ã—æ›¿ãˆã‚’è¡Œãˆã°ã€ä¸è¦ãªãƒãƒ©ã¤ãã‚’æ¸›ã‚‰ã›ã¾ã™ã€‚

---

### ã¾ã¨ã‚

- **AnimatedSwitcher ã§ãƒ•ã‚§ãƒ¼ãƒ‰é·ç§»**  
  - ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ã‚’ã‹ã‘ã‚‹ã“ã¨ã§ã€å†æç”»ã«ã‚ˆã‚‹ã€Œãƒãƒƒã¨ç™½ããªã‚‹ã€ãƒãƒ©ã¤ãã‚’å’Œã‚‰ã’ã‚‹  
- **å¤ã„ãƒãƒƒãƒ—ã¨æ–°ãƒãƒƒãƒ—ã‚’é‡ã­ã‚‹**  
  - å…ˆã«è£ã§æ–°ãƒãƒƒãƒ—ã‚’æç”»ã—ã¦ãŠãã€æº–å‚™å®Œäº†ã—ã¦ã‹ã‚‰åˆ‡ã‚Šæ›¿ãˆã‚‹  
  - PlatformView ã‚’äºŒé‡ã«æ‰±ã†ãŸã‚ã€æŒ™å‹•ãŒç«¯æœ«ä¾å­˜ã«ãªã‚‹ãƒªã‚¹ã‚¯ã‚ã‚Š  
- **ã‚­ãƒ¼å·®ã—æ›¿ãˆã‚’ â€œå°‘ã—é…å»¶â€ or â€œæœ€å°å›æ•°â€ ã«ã™ã‚‹**  
  - ç”»é¢ç”Ÿæˆç›´å¾Œã®ãƒãƒ©ã¤ãã‚’é¿ã‘ã‚‹ãŸã‚ã€åœ°å›³è¡¨ç¤ºå¾Œã«ãƒ¯ãƒ³ãƒ†ãƒ³ãƒãŠã„ã¦ã‹ã‚‰å†æç”»  
  - ã©ã†ã—ã¦ã‚‚å¿…è¦ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã ã‘å†ãƒã‚¦ãƒ³ãƒˆã™ã‚‹

ã“ã‚Œã‚‰ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€**ã‚„ã‚€ã‚’å¾—ãªã„ã‚­ãƒ¼å·®ã—æ›¿ãˆã«ã‚ˆã‚‹ãƒãƒ©ã¤ã** ã‚’ã€ã§ãã‚‹ã ã‘ç›®ç«‹ãŸãªãã§ãã¾ã™ã€‚ç‰¹ã«æœ€ã‚‚ç°¡å˜ãªã®ã¯ **AnimatedSwitcher ã‚’æŒŸã‚€** ã‚„ã‚Šæ–¹ãªã®ã§ã€ã¾ãšã¯ãƒ•ã‚§ãƒ¼ãƒ‰ãªã©ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è©¦ã—ã¦ã¿ã‚‹ã®ãŒãŠã™ã™ã‚ã§ã™ã€‚

---
