# 緯度経度近似検索方法

Date: 2025-02-19

---

## 👤 User
*2025-02-19 22:41:18*

自分の緯度経度がわかっていて、1万件の緯度経度がわかるデータから近いものを二十件取り出す処理を書きたい。ただ、全部計算するのはコストが高いので、正確ではなくても簡易的に20件に絞りたい。

---

## 🤖 Assistant
*2025-02-19 22:42:46*

簡易的に1万件の緯度経度データから近いものを20件に絞る方法として、以下の手順を取るのが効率的です。

### 1. **緯度・経度のフィルタリング**
   - まず、緯度と経度の**範囲で絞り込む**ことで計算コストを抑えます。
   - 1度の緯度変化は約111km、経度は緯度によって変化しますが日本周辺なら約88km程度と考えられます。
   - 例えば、自分の位置 `(lat, lon)` から ±0.1度の範囲でフィルタリングすると、約10km四方のデータに限定できます。

### 2. **マンハッタン距離（簡易的な距離計算）で絞る**
   - より計算コストを減らすため、正確な球面距離（Haversine 公式など）ではなく、**マンハッタン距離** を使って近いものを20件に絞る。
   - `マンハッタン距離 ≈ |Δlat| + |Δlon|` で計算。

---

### **コード例 (Python)**
以下のコードでは、簡易的に±0.1度の範囲でフィルタし、その中からマンハッタン距離を使って上位20件を取得します。

```python
import numpy as np

# 自分の緯度経度
my_lat, my_lon = 35.6895, 139.6917  # 例: 東京の緯度経度

# 1万件のダミーデータを作成 (ランダムな範囲)
np.random.seed(42)
data = np.random.uniform(
    [my_lat - 1, my_lon - 1],  # 範囲
    [my_lat + 1, my_lon + 1], 
    (10000, 2)  # 1万件の緯度経度データ
)

# 簡易フィルタ: ±0.1度の範囲で事前に絞る
filtered = data[
    (data[:, 0] >= my_lat - 0.1) & (data[:, 0] <= my_lat + 0.1) &
    (data[:, 1] >= my_lon - 0.1) & (data[:, 1] <= my_lon + 0.1)
]

# マンハッタン距離で並べ替え
distances = np.abs(filtered[:, 0] - my_lat) + np.abs(filtered[:, 1] - my_lon)
sorted_indices = np.argsort(distances)

# 近い20件を取得
nearest_20 = filtered[sorted_indices[:20]]

# 結果を表示
import pandas as pd
df = pd.DataFrame(nearest_20, columns=["Latitude", "Longitude"])
import ace_tools as tools
tools.display_dataframe_to_user(name="Nearest 20 Locations", dataframe=df)
```

---

### **ポイント**
1. **事前に±0.1度の範囲でフィルタリング**  
   → これで1万件 → 数百件程度まで絞れる。
2. **マンハッタン距離で簡易計算**  
   → 正確な距離計算（Haversineなど）をせず、計算コストを削減。
3. **並び替え後に20件を取得**  
   → 最も近いものだけを選択。

---

### **改善案**
- **ヒルベルトカーブ（空間インデックス）を利用する**  
  → 大規模データなら、**KD-Tree** や **BallTree** を使って距離計算を効率化できる。
- **Haversine 公式で正確な距離を計算**（より正確な順位が必要な場合）
- **データベースなら GEOSpatial Index（PostGIS, MongoDB）を利用**

この方法なら、手軽にコストを抑えて近い20件を取得できます！

---

## 👤 User
*2025-02-19 22:43:05*

約10km四方のデータではなくて約1Kmぐらいのデータがほしい

---

## 🤖 Assistant
*2025-02-19 22:43:45*

約1km四方のデータに絞るには、**±0.01度の範囲**でフィルタリングすると良いです。  
- 緯度1度 ≈ 111km なので、0.01度 ≈ **1.11km**
- 経度の距離は場所によるが、東京近辺なら 0.01度 ≈ **0.88km**

この修正を反映したコードを示します。

---

### **改良版コード**
```python
import numpy as np
import pandas as pd
import ace_tools as tools

# 自分の緯度経度
my_lat, my_lon = 35.6895, 139.6917  # 例: 東京の緯度経度

# 1万件のダミーデータを作成 (ランダムな範囲)
np.random.seed(42)
data = np.random.uniform(
    [my_lat - 1, my_lon - 1],  # 範囲
    [my_lat + 1, my_lon + 1], 
    (10000, 2)  # 1万件の緯度経度データ
)

# **簡易フィルタ: ±0.01度の範囲 (約1km四方)**
filtered = data[
    (data[:, 0] >= my_lat - 0.01) & (data[:, 0] <= my_lat + 0.01) &
    (data[:, 1] >= my_lon - 0.01) & (data[:, 1] <= my_lon + 0.01)
]

# マンハッタン距離で並べ替え
distances = np.abs(filtered[:, 0] - my_lat) + np.abs(filtered[:, 1] - my_lon)
sorted_indices = np.argsort(distances)

# 近い20件を取得
nearest_20 = filtered[sorted_indices[:20]]

# 結果を表示
df = pd.DataFrame(nearest_20, columns=["Latitude", "Longitude"])
tools.display_dataframe_to_user(name="Nearest 20 Locations (1km range)", dataframe=df)
```

---

### **変更点**
1. **±0.01度の範囲でフィルタリング**  
   → これにより約1km四方のデータに限定。
2. **マンハッタン距離で並べ替え**  
   → 計算コストを抑えつつ近い20件を選択。

---

### **次のステップ**
もし精度を上げたい場合：
- **球面距離（Haversine 公式）** を使う
- **KD-Tree などの空間検索アルゴリズム** を使う
- **PostGIS / MongoDB の Geospatial クエリ** を使う

この方法なら、手軽に約1kmの範囲から近い20件を取得できます！

---

## 👤 User
*2025-02-19 22:43:46*

Javaスクリプトで書くとどうなりますか

---
