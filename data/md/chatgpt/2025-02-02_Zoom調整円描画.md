# Zoomèª¿æ•´å††æç”»

æ—¥ä»˜: 2025-02-02

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/2/2 16:20:12*

Flutter ã§è¡¨ç¤ºã—ã¦ã„ã‚‹Googleãƒãƒƒãƒ—ã«ã¤ã„ã¦ã€zoomç‡ã‚’è‡ªç”±ã«å¤‰ãˆãŸã„å‡¦ç†ãŒã‚ã‚‹ã€‚
circlesState.value = {circle}; ã™ã‚‹ã¨ã“ã‚ã§ zoom ç‡ã‚’å¤‰ãˆãŸã„ã‚“ã ã€‚
explorer?.range(ãƒ¡ãƒ¼ãƒˆãƒ«) ã®å††ã‚’æãã®ã§ã€ãã‚ŒãŒåã¾ã‚‹ã‚ˆã†ãªé©åˆ‡ãªzoomç‡ã«ã—ãŸã„ã€‚


@freezed
class ExplorerDTO with _$ExplorerDTO {
  factory ExplorerDTO({
    @JsonKey(name: 'explorerId') required String? explorerId,
    @JsonKey(name: 'tokenId') required String? tokenId,
    @JsonKey(name: 'explorerName') required String? explorerName,
    @JsonKey(name: 'explorerDescription') String? explorerDescription,
    @JsonKey(name: 'explorerImage') required String? explorerImage,
    @JsonKey(name: 'explorerCategory')
    required ExplorerDTOExplorerCategory? explorerCategory,
    @JsonKey(name: 'energy') required num? energy,
    @JsonKey(name: 'rarity') required ExplorerDTORarity? rarity,
    @JsonKey(name: 'energyConsumption') required num? energyConsumption,
    @JsonKey(name: 'range') required num? range,
    @JsonKey(name: 'decoyFinding') required bool? decoyFinding,
    @JsonKey(name: 'totalSearch') required num? totalSearch,
    @JsonKey(name: 'totalSpotFound') required num? totalSpotFound,
  }) = _ExplorerDTO;

  factory ExplorerDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$ExplorerDTOFromJson(jsonMap);
}



class OnExploringState {
  const OnExploringState({
    required this.isExploring,
    required this.explorer,
  });

  final bool isExploring;
  final ExplorerDTO? explorer;
}

@Riverpod(keepAlive: true)
class OnExploringNotifier extends _$OnExploringNotifier {
  @override
  OnExploringState build() {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ isExploring=false, explorer=null ã®çŠ¶æ…‹ã§é–‹å§‹
    return const OnExploringState(
      isExploring: false,
      explorer: null,
    );
  }

  void show(ExplorerDTO explorer) {
    state = OnExploringState(
      isExploring: true,
      explorer: explorer,
    );

    // å††ãŒå‡ºã¦ã„ã‚‹æ™‚é–“
    Timer(const Duration(seconds: 5), () async {
      hide();
    });
  }

  void hide() {
    state = const OnExploringState(
      isExploring: false,
      explorer: null,
    );
  }
}



import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

enum SpotType {
  noneGuild, // spotGuildId == null
  myGuild, // spotGuildId == myGuildId
  enemyGuild // spotGuildId != myGuildId
}

/// é€†ä¸‰è§’å½¢ã‚’æç”»ã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãª Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // å·¦ä¸Š
      ..lineTo(size.width, 0) // å³ä¸Š
      ..lineTo(size.width / 2, size.height) // åº•è¾ºã®ä¸­å¤®
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isLoadingState = useState(false);

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);
      final photoUrl = spot.photoUrl;
      Widget content;

      switch (spotType) {
        case SpotType.noneGuild:
          content = DecoratedBox(
            decoration: BoxDecoration(
              border: Border.all(
                color: ColorPallet.white,
                width: 4,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: ColoredBox(
                color: ColorToken.bgWhite,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: (photoUrl != null && photoUrl.isNotEmpty)
                      ? CachedNetworkImage(
                          imageUrl: photoUrl,
                          fit: BoxFit.cover,
                          width: 64,
                          height: 64,
                          errorWidget: (context, url, error) {
                            return Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.broken_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            );
                          },
                        )
                      : Container(
                          width: 64,
                          height: 64,
                          color: ColorToken.bgDark,
                          child: const Icon(
                            Icons.hide_image_outlined,
                            size: 48,
                            color: ColorToken.text,
                          ),
                        ),
                ),
              ),
            ),
          );

        case SpotType.myGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorPallet.green500,
              child: Icon(
                Icons.flag,
                color: ColorPallet.green100,
                size: 24,
              ),
            ),
          );

        case SpotType.enemyGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorToken.bgEnemy,
              child: Icon(
                Icons.flag,
                color: ColorToken.enemy,
                size: 24,
              ),
            ),
          );
      }

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              content,
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final photoUrl = itemBox.itemBoxImage;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: (photoUrl != null && photoUrl.isNotEmpty)
                          ? CachedNetworkImage(
                              imageUrl: photoUrl,
                              fit: BoxFit.cover,
                              width: 64,
                              height: 64,
                              errorWidget: (context, url, error) {
                                return Container(
                                  width: 64,
                                  height: 64,
                                  color: ColorToken.bgDark,
                                  child: const Icon(
                                    Icons.broken_image_outlined,
                                    size: 48,
                                    color: ColorToken.text,
                                  ),
                                );
                              },
                            )
                          : Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.hide_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: spotType == SpotType.noneGuild
            ? const Size(198, 225)
            : const Size(242, 275),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    Future&lt;void&gt; refreshAllMarkers({
      required List&lt;GuildSpotDTO&gt; newSpotList,
      required List&lt;ItemBoxDTO&gt; newItemBoxList,
      required String? myGuildId,
    }) async {
      final currentMarkers = markersState.value.toSet();

      final neededMarkerIds = &lt;String&gt;{};
      for (final spot in newSpotList) {
        final spotId = spot.spotId ?? '';
        neededMarkerIds.add('spot_$spotId');
      }
      for (final box in newItemBoxList) {
        final boxId = box.itemBoxId ?? '';
        neededMarkerIds.add('itemBox_$boxId');
      }

      // æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ã€Œä¸è¦ã«ãªã£ãŸã‚‚ã®ã€ã‚’å‰Šé™¤ã™ã‚‹
      currentMarkers.removeWhere(
        (marker) =&gt; !neededMarkerIds.contains(marker.markerId.value),
      );

      if (!context.mounted) {
        return;
      }

      // ã„ã£ãŸã‚“å‰Šé™¤çµæœã‚’åæ˜ (ä¸è¦ãƒãƒ¼ã‚«ãƒ¼ãŒæ¶ˆãˆã‚‹)
      markersState.value = {...currentMarkers};

      // Spot ã®ãƒªã‚¹ãƒˆã‚’é †ã«å‡¦ç†ã—ã€1ã¤ãšã¤å†æç”»ã—ã¦åæ˜ 
      for (final spot in newSpotList) {
        final markerId = MarkerId('spot_${spot.spotId}');
        // buildSpotMarker (å¿…ãšå†ç”Ÿæˆã—ã¦å†æç”»ã™ã‚‹)
        final newMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // æ—¢å­˜ã«åŒã˜ ID ã®ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        // æ–°ãŸã«è¿½åŠ ã•ã‚Œã‚‹ or æ›´æ–°ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼ã‚’ã™ãåæ˜ 
        markersState.value = {...currentMarkers};

        // UI ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã«ããã™ã‚‹ãŸã‚ã«å°‘ã—å¾…æ©Ÿ
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox ã‚‚åŒæ§˜ã«å‡¦ç†
      for (final itemBox in newItemBoxList) {
        final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
        final newMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (box) async {
            await onTapItemBoxMarker(box);
          },
        );

        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        markersState.value = {...currentMarkers};

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

    Future&lt;void&gt; onTanNearMe() async {
      try {
        final refreshedLocation = await ref
            .read(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();
        final controller = googleMapControllerState.value;
        if (controller != null) {
          await controller.animateCamera(
            CameraUpdate.newLatLng(refreshedLocation),
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; initializeMarkers() async {
      try {
        if (!context.mounted) {
          return;
        }

        isLoadingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        if (!context.mounted) {
          return;
        }

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshAllMarkers(
            newSpotList: spotList,
            newItemBoxList: itemBoxList,
            myGuildId: myGuildId,
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        if (context.mounted) {
          isLoadingState.value = false;
        }
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await initializeMarkers();
        });
        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!isLoadingState.value) {
          // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°
          await initializeMarkers();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          try {
            final currentLocation = await ref
                .watch(currentLocationNotifierProvider.notifier)
                .getCurrentLocation();

            // range ã¯ km å˜ä½ãªã®ã§ã€ãƒ¡ãƒ¼ãƒˆãƒ«ã«æ›ç®—ï¼ˆÃ—1000ï¼‰
            final explorerRangeKm = next.explorer?.range ?? 0;
            final rangeInMeters = explorerRangeKm * 1000.0;

            final circle = Circle(
              circleId: const CircleId('explorerCircle'),
              center: currentLocation,
              radius: rangeInMeters,
              strokeColor: const Color(0xFF004DFF), // ãƒ–ãƒ«ãƒ¼
              strokeWidth: 1,
              fillColor: const Color(0x40004DFF), // 25%ãã‚‰ã„é€éã®ãƒ–ãƒ«ãƒ¼
            );

            if (!context.mounted) {
              return;
            }

            circlesState.value = {circle};

            await googleMapControllerState.value?.animateCamera(
              CameraUpdate.newLatLng(currentLocation),
            );
          } on Exception catch (error) {
            if (context.mounted) {
              showErrorSnackBar(context, error);
            }
          }
        } else {
          if (!context.mounted) {
            return;
          }

          circlesState.value = {};
          final explodedSpotList = ref.read(explodedSpotListNotifierProvider);

          final spotPhotoItems = explodedSpotList
                  ?.where((spot) =&gt; spot.photoUrl != null)
                  .map(
                    (spot) =&gt; SpotPhotoItem(
                      photoId: spot.photoId ?? '',
                      spotPhotoUrl: spot.photoUrl ?? '',
                      spotOwnership: spot.guildId == null
                          ? SpotOwnership.neutral
                          : spot.guildId == myGuildIdState.value
                              ? SpotOwnership.owner
                              : SpotOwnership.enemy,
                    ),
                  )
                  .toList() ??
              [];

          ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

          await showDialog&lt;void&gt;(
            context: context,
            builder: (_) =&gt; ExploredResultDialog(
              spotPhotoItemList: spotPhotoItems,
            ),
          );

          ref.read(explodedSpotListNotifierProvider.notifier).clear();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                if (context.mounted) {
                  googleMapControllerState.value = controller;
                }
              },
              markers: markersState.value,
              circles: circlesState.value,
            ),
            if (isLoadingState.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTanNearMe();
                        },
                        child: const Icon(
                          Icons.near_me,
                          size: 24,
                          color: ColorToken.secondaryDark,
                        ),
                      ),
                    ),
                    // Explore ãƒªã‚¹ãƒˆ
                    SizedBox(
                      width: 138,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: onExploringStateValue.isExploring
                            ? null
                            : () async {
                                await onTapExplorer();
                              },
                        backgroundColor: onExploringStateValue.isExploring
                            ? ColorPallet.gray800.withValues(alpha: 0.8)
                            : Theme.of(context)
                                .floatingActionButtonTheme
                                .backgroundColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: BorderSide(
                            color: onExploringStateValue.isExploring
                                ? Colors.transparent
                                : ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(left: 4),
                              child: onExploringStateValue.isExploring
                                  ? Transform.translate(
                                      offset: const Offset(4, 0),
                                      child: const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        ),
                                      ),
                                    )
                                  : Image.asset(
                                      Assets.images.explorerIconFig.path,
                                      width: 40,
                                      height: 40,
                                    ),
                            ),
                            const Spacer(),
                            Text(
                              onExploringStateValue.isExploring
                                  ? 'Exploring...'
                                  : 'Explore',
                              style: TextStyle(
                                fontSize: 16,
                                color: onExploringStateValue.isExploring
                                    ? ColorToken.text
                                    : ColorToken.secondaryDark,
                              ),
                            ),
                            const Spacer(),
                          ],
                        ),
                      ),
                    ),
                    // Spot ãƒªã‚¹ãƒˆ
                    spotListAsyncValue.when(
                      data: (spotList) {
                        // ä¸Šä½2ã¤ã‚’å–ã‚Šå‡ºã—ã€é †åºã‚’é€†ã«ã™ã‚‹
                        final displaySpotList =
                            (spotList?.take(2).toList() ?? [])
                                .reversed
                                .toList();
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            backgroundColor: Colors.transparent,
                            shape: const RoundedRectangleBorder(
                              side: BorderSide(
                                color: Colors.transparent,
                              ),
                            ),
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: Transform.translate(
                              offset: const Offset(4, 4),
                              child: Stack(
                                clipBehavior: Clip.none,
                                alignment: Alignment.bottomRight,
                                children: [
                                  for (var i = 0; i &lt; 2; i++)
                                    if (i &lt; displaySpotList.length)
                                      Positioned(
                                        left: i * -4.0,
                                        top: i * -4.0,
                                        child: SizedBox(
                                          width: 44,
                                          height: 44,
                                          child: DecoratedBox(
                                            decoration: BoxDecoration(
                                              border: Border.all(
                                                color: ColorToken.bgWhite,
                                                width: 2,
                                              ),
                                              borderRadius:
                                                  BorderRadius.circular(4),
                                            ),
                                            child: Padding(
                                              padding: const EdgeInsets.all(2),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: SquareImage(
                                                  imageUrl: displaySpotList[i]
                                                      .photoUrl,
                                                  size: 44,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                      loading: () {
                        return const SizedBox.shrink();
                      },
                      error: (error, _) {
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            heroTag: 'ErrorShowSpotListButton',
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: const Icon(
                              Icons.photo,
                              size: 24,
                              color: ColorToken.secondaryDark,
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Center(
            child: ElevatedButton(
              onPressed: () async {
                await openAppSettings();
              },
              child: const Text(
                'Please enable location access in the Settings App',
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/2/2 16:20:35*

**Mapping zoom level**

I'm exploring how to ensure a circle with a specific radius on Google Maps in Flutter is fully visible by adjusting the camera's zoom level. The aim is to make the bounding box of the circle completely visible, possibly using LatLngBounds and CameraUpdate.newLatLngBounds.

**Crafting a bounding box**

Iâ€™m digging into computing a bounding box around a circle's center and radius, translating these into latitude and longitude degrees, and using CameraUpdate.newLatLngBounds for visibility.

**Ensuring visibility**

I'm verifying that the LatLngBounds constructor utilizes either the southwestern or northeastern corners to ensure the circle's complete visibility on the screen.

**Adjusting my approach**

I'm refining the function to ensure accurate zooming for circles near poles by separately calculating latitude and longitude deltas, particularly when dealing with radii meters.

**Tweaking calculations**

I'm adjusting for latitude and longitude differences near the poles by refining delta calculations for radii in meters, ensuring visibility and addressing issues like "Bounds too small."

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/2/2 16:20:35*

GoogleMap ã§å††ã‚’è¡¨ç¤ºã™ã‚‹ã¨åŒæ™‚ã«ã€ãã®å††ãŒç”»é¢å†…ã«åã¾ã‚‹ã‚ˆã†ã« zoom ã‚’è‡ªå‹•èª¿æ•´ã—ãŸã„å ´åˆã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã« **`LatLngBounds` ã‚’ä½¿ã£ãŸ `CameraUpdate.newLatLngBounds(bounds, padding)`** ã‚’åˆ©ç”¨ã™ã‚‹ã¨ç°¡å˜ã«å®Ÿç¾ã§ãã¾ã™ã€‚  

---

## ã‚„ã‚ŠãŸã„ã“ã¨

- `explorer?.range` (ãƒ¡ãƒ¼ãƒˆãƒ«) ã‹ã‚‰åŠå¾„ã‚’æŒã¤å††ã‚’æç”»ã™ã‚‹
- ãã®å††ãŒç”»é¢ã«åã¾ã‚‹ã‚ˆã†ã« GoogleMap ã®ã‚«ãƒ¡ãƒ©ä½ç½®ï¼†ã‚ºãƒ¼ãƒ ã‚’è‡ªå‹•èª¿æ•´ã—ãŸã„

---

## å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ

1. **å††ã®ä¸­å¿ƒç‚¹**ï¼ˆ= ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç¾åœ¨åœ°ãªã©ï¼‰
2. **åŠå¾„ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰**
   
ã“ã®2ã¤ã®æƒ…å ±ã‹ã‚‰ã€  
- å—è¥¿ï¼ˆsouthwestï¼‰ç«¯
- åŒ—æ±ï¼ˆnortheastï¼‰ç«¯  

ã®åº§æ¨™ã‚’è¨ˆç®—ã—ã€ `LatLngBounds` ã‚’ç”Ÿæˆã—ã¦ã€ `animateCamera(CameraUpdate.newLatLngBounds(bounds, padding))` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚

---

## ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…

ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€ `onExploringState` ãŒå¤‰æ›´ã•ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼ˆ= å††ã‚’è¡¨ç¤ºã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼‰ã§ã€  
`circlesState.value = {circle};` ã®ã‚ã¨ã« **ã€Œå††ãŒç”»é¢ã«åã¾ã‚‹ã‚ˆã†ã«ã‚«ãƒ¡ãƒ©ã‚’å‹•ã‹ã™ã€** ãŸã‚ã®å‡¦ç†ã‚’å…¥ã‚ŒãŸä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

```dart
ref.listen<OnExploringState>(
  onExploringNotifierProvider,
  (previous, next) async {
    if (next.isExploring) {
      try {
        final currentLocation = await ref
            .watch(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();

        // range ã¯ã€Œkmã€ã§ã¯ãªãã€Œãƒ¡ãƒ¼ãƒˆãƒ«ã€æƒ³å®šãªã‚‰ã€ã“ã®ã¾ã¾ä½¿ã†ã€‚ 
        // km ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãªã‚‰ (range * 1000) ã—ã¦ãƒ¡ãƒ¼ãƒˆãƒ«ã«æ›ç®—ã—ã¦ãã ã•ã„ã€‚
        final rangeInMeters = next.explorer?.range ?? 0;

        // å††ã‚’è¡¨ç¤º
        final circle = Circle(
          circleId: const CircleId('explorerCircle'),
          center: currentLocation,
          radius: rangeInMeters,
          strokeColor: const Color(0xFF004DFF),
          strokeWidth: 1,
          fillColor: const Color(0x40004DFF), // åŠé€æ˜ãƒ–ãƒ«ãƒ¼
        );
        circlesState.value = {circle};

        // ---- ã“ã“ã§ã‚ºãƒ¼ãƒ ã‚’å††ã«åˆã‚ã›ã‚‹å‡¦ç†ã‚’è¿½åŠ ã™ã‚‹ ----
        await _zoomToFitCircle(
          googleMapController: googleMapControllerState.value,
          center: currentLocation,
          radiusInMeters: rangeInMeters,
        );

      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    } else {
      // å††ã‚’æ¶ˆã™ãªã©ã®å‡¦ç† ...
      circlesState.value = {};
      // ...
    }
  },
);
```

### `_zoomToFitCircle` ã®å®Ÿè£…ä¾‹

```dart
/// æŒ‡å®šã—ãŸ [center] ã¨ [radiusInMeters] ã®å††ãŒç”»é¢å†…ã«åã¾ã‚‹ã‚ˆã†ã«ã‚«ãƒ¡ãƒ©ã‚’å‹•ã‹ã™
Future<void> _zoomToFitCircle({
  required GoogleMapController? googleMapController,
  required LatLng center,
  required double radiusInMeters,
}) async {
  if (googleMapController == null) {
    return;
  }

  // ç·¯åº¦ãƒ»çµŒåº¦ã‚’åº¦æ•°ã«æ›ç®—ã™ã‚‹ãŸã‚ã®ä¿‚æ•°ã‚’æ±‚ã‚ã‚‹
  // (ã–ã£ãã‚Šã¨ã—ãŸåœ°çƒåŠå¾„ã‹ã‚‰ç®—å‡ºã—ã¦ã„ã‚‹ãŸã‚å³å¯†ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€
  //  ä¸€èˆ¬çš„ãªã‚±ãƒ¼ã‚¹ã§ã¯ååˆ†å®Ÿç”¨çš„ã§ã™)
  const double earthCircumferencePerDegree = 111320; // m/degree (ç·¯åº¦)
  final double latRadians = center.latitude * (math.pi / 180);

  // ç·¯åº¦æ–¹å‘(1åº¦ã‚ãŸã‚Šç´„111.32km)
  final double deltaLat = radiusInMeters / earthCircumferencePerDegree;
  // çµŒåº¦æ–¹å‘(ç·¯åº¦ã«ã‚ˆã£ã¦å¤‰åŒ–ã™ã‚‹ã€‚èµ¤é“ä»˜è¿‘ ~111.32km/åº¦ã€æ¥µåœ°ä»˜è¿‘ ~0km/åº¦)
  final double deltaLng =
      radiusInMeters / (earthCircumferencePerDegree * math.cos(latRadians));

  // å—è¥¿ç«¯(southwest)ã¨åŒ—æ±ç«¯(northeast)ã‚’è¨ˆç®—
  final southwest = LatLng(
    center.latitude - deltaLat,
    center.longitude - deltaLng,
  );
  final northeast = LatLng(
    center.latitude + deltaLat,
    center.longitude + deltaLng,
  );

  // Bounds ãŒå°ã•ã™ãã‚‹ (ä¾‹: range=0) å ´åˆã®ãŸã‚ã®ã‚¬ãƒ¼ãƒ‰
  if (southwest == northeast) {
    // ã‚ã‚‹ç¨‹åº¦å›ºå®šã‚ºãƒ¼ãƒ ã«é£›ã°ã™ãªã©ã®å‡¦ç†
    await googleMapController.animateCamera(
      CameraUpdate.newLatLngZoom(center, 17),
    );
    return;
  }

  // LatLngBounds ã¯å¼•æ•°ãŒ southWest < northEast ã«ãªã‚‹ã‚ˆã†ã«æŒ‡å®šã™ã‚‹
  final bounds = LatLngBounds(
    southwest: LatLng(
      math.min(southwest.latitude, northeast.latitude),
      math.min(southwest.longitude, northeast.longitude),
    ),
    northeast: LatLng(
      math.max(southwest.latitude, northeast.latitude),
      math.max(southwest.longitude, northeast.longitude),
    ),
  );

  // å°‘ã—ä½™ç™½ã‚’ã¨ã£ã¦ã‚ºãƒ¼ãƒ 
  final cameraUpdate = CameraUpdate.newLatLngBounds(bounds, 80);
  await googleMapController.animateCamera(cameraUpdate);
}
```

---

## ã‚ˆãã‚ã‚‹ãƒãƒã‚Šã©ã“ã‚

1. `LatLngBounds` ã¯ `southwest` ã¨ `northeast` ã‚’æ­£ã—ã„é †åºã§ä¸ãˆãªã„ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹  
   - ç·¯åº¦ (latitude) ãªã‚‰ã€Œå°ã•ã„æ–¹ãŒ southã€å¤§ãã„æ–¹ãŒ northã€  
   - çµŒåº¦ (longitude) ãªã‚‰ã€Œå°ã•ã„æ–¹ãŒ westã€å¤§ãã„æ–¹ãŒ eastã€

2. å††ã®åŠå¾„ãŒ 0ã€œæ•°åãƒ¡ãƒ¼ãƒˆãƒ«ãªã©æ¥µç«¯ã«å°ã•ã„å ´åˆã¯ã€ `newLatLngBounds` ãŒã€ŒBounds ãŒå°ã•ã™ãã‚‹ã€ã¨ã„ã†ç†ç”±ã§å¤±æ•—ã—ãŸã‚Šã€æƒ³å®šã—ãªã„ã‚ºãƒ¼ãƒ ã«ãªã£ãŸã‚Šã™ã‚‹  
   - ãã®å ´åˆã¯ fallback å‡¦ç†ã¨ã—ã¦ã€ `newLatLngZoom(center, 17)` ãªã©ã€Œã¨ã‚Šã‚ãˆãšå›ºå®šå€ç‡ã€ã§æ˜ ã™ã‚ˆã†ã«ã™ã‚‹ã¨å®‰å®šã—ã¾ã™ã€‚

3. çµŒåº¦å·®ã®è¨ˆç®—ã«ã¯ã€åº§æ¨™ã®ç·¯åº¦ã«å¿œã˜ã¦ `cos(latitude)` ã‚’æ›ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹  
   - ã“ã‚Œã‚’ã—ãªã„ã¨ã€é«˜ç·¯åº¦åœ°åŸŸ (æ—¥æœ¬ã§ã‚‚åŒ—æµ·é“æ±éƒ¨ãªã©) ã§ã¯èª¤å·®ãŒå¤§ãããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™  
   - ä¸Šè¨˜ã‚µãƒ³ãƒ—ãƒ«ã§ã¯ç°¡æ˜“è¨ˆç®—ã«ã¨ã©ã‚ã¦ã„ã¾ã™ãŒã€æ™®é€šã®åˆ©ç”¨ã‚±ãƒ¼ã‚¹ã§ã‚ã‚Œã°å•é¡Œãªãæ©Ÿèƒ½ã—ã¾ã™ã€‚

4. åœ°å›³ãŒä½œæˆã•ã‚Œã¦ã„ãªã„ã‚¿ã‚¤ãƒŸãƒ³ã‚° (`onMapCreated` ãŒæœªå®Œäº†) ã§ `animateCamera` ã‚’å‘¼ã¶ã¨ä½•ã‚‚èµ·ã“ã‚‰ãªã„å ´åˆãŒã‚ã‚‹  
   - ã€Œãƒãƒƒãƒ—ãŒä½œã‚‰ã‚ŒãŸã‚ã¨ã«ã‚ºãƒ¼ãƒ ã™ã‚‹ã€ãƒ•ãƒ­ãƒ¼ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚

---

## ã¾ã¨ã‚

- å††ã‚’æç”»ã—ãŸã‚ã¨ã«ã€ `LatLngBounds` ã§è‡ªå‹•ã‚ºãƒ¼ãƒ ã™ã‚Œã°ã€æŒ‡å®šã—ãŸåŠå¾„ã®å††ã‚’ç”»é¢å†…ã«åã‚ã‚‰ã‚Œã¾ã™ã€‚  
- è·é›¢ã‚’ã€Œç·¯åº¦ãƒ»çµŒåº¦ã®åº¦æ•°ã€ã«æ›ç®—ã—ã€å—è¥¿ç«¯ãƒ»åŒ—æ±ç«¯ã‚’è¨ˆç®—ã—ã¦ `CameraUpdate.newLatLngBounds(bounds, padding)` ã‚’å‘¼ã³å‡ºã™ã ã‘ã§ã™ã€‚  

ã“ã‚Œã§ `explorer?.range` ãƒ¡ãƒ¼ãƒˆãƒ«ã®å††ãŒã—ã£ã‹ã‚Šè¦‹ãˆã‚‹ã‚ˆã†ã«è‡ªå‹•ã§åœ°å›³ãŒã‚ºãƒ¼ãƒ ï¼†ç§»å‹•ã™ã‚‹ã‚ˆã†ã«ãªã‚‹ã¯ãšã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/2/2 16:23:12*

1kmã‹ã‚‰10kmã®å††ã—ã‹æã‹ãªã„ã®ã§ã€ã‚‚ã£ã¨ç°¡æ˜“çš„ãªå‡¦ç†ã§ã„ã„ã‚ˆã€‚
ã‚ã‚“ã¾ã‚Šè¤‡é›‘ãªå‡¦ç†ã‚’ã—ã¦ã»ã—ããªã„ã€‚å¯èª­æ€§é‡è¦–ã§ã€‚

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/2/2 16:23:31*

**Mapping the approach**

Iâ€™m thinking of defining a small function to calculate the bounding box in degrees, allowing for quick and easy adjustment of zoom levels for circles ranging from 1km to 10km.

**Mapping bounding box**

Iâ€™m detailing steps to define the bounding box for circles from 1km to 10km, using simpler latitude and longitude adjustments without considering latitude's cosine influence.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/2/2 16:23:31*

ã€Œ**1km ã€œ 10km ã®å††** ã—ã‹æã‹ãªã„ã€ã¨ã„ã†å‰æã§ã‚ã‚Œã°ã€  
**ã€Œ1km â‰ˆ 0.009åº¦ã€** ã¨ã„ã†å˜ç´”æ›ç®—ã§ååˆ†å®Ÿç”¨çš„ã§ã™ã€‚  
ç·¯åº¦ãƒ»çµŒåº¦ã¨ã‚‚ã“ã®å€¤ã‚’ä½¿ã£ã¦ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’ä½œã‚‹ã¨å¯èª­æ€§ãŒé«˜ãã€å®Ÿè£…ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ã«ã§ãã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚ˆã†ã« **`zoomToFitCircle`** é–¢æ•°ã‚’ä½œã£ã¦å‘¼ã³å‡ºã™ã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚

---

## ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ä¾‹

```dart
/// åŠå¾„ [radiusMeters] ã®å††ãŒã¡ã‚‡ã†ã©åã¾ã‚‹ã‚ˆã†ã«ã‚ºãƒ¼ãƒ ã™ã‚‹ç°¡æ˜“ç‰ˆ
/// â€» 1km ã€œ 10km ç¨‹åº¦ã®ç¯„å›²ã§ã‚ã‚Œã°èª¤å·®æ°—ã«ã›ãš 1km â‰ˆ 0.009åº¦ ã§OKã€‚
Future<void> _zoomToFitCircle({
  required GoogleMapController? googleMapController,
  required LatLng center,
  required double radiusMeters,
}) async {
  if (googleMapController == null) return;

  // 1km â‰ˆ 0.009åº¦ (å³å¯†ã§ãªãã¦OK)
  // ä»Šå›ã¯ 1~10km ç¨‹åº¦ãªã®ã§ã“ã‚Œã§ååˆ†
  final radiusKm = radiusMeters / 1000.0;
  final delta = 0.009 * radiusKm;

  // å—è¥¿ç«¯ã¨åŒ—æ±ç«¯ã‚’ã–ã£ãã‚Šæ±ºã‚ã‚‹
  final sw = LatLng(center.latitude - delta, center.longitude - delta);
  final ne = LatLng(center.latitude + delta, center.longitude + delta);

  // LatLngBounds ã‚’ä½œæˆ
  final bounds = LatLngBounds(southwest: sw, northeast: ne);

  // å°‘ã—ä½™ç™½ã‚’ã‚ã‘ãŸã„å ´åˆã¯ padding ã‚’è¨­å®š
  const padding = 50.0; // ç”»é¢å››éš…ã¨ã®ä½™ç™½
  final cameraUpdate = CameraUpdate.newLatLngBounds(bounds, padding);

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ã‚ºãƒ¼ãƒ 
  await googleMapController.animateCamera(cameraUpdate);
}
```

### å‘¼ã³å‡ºã—ã‚¤ãƒ¡ãƒ¼ã‚¸

```dart
if (next.isExploring) {
  // ... å††ã®æç”» ...

  // 1ã€œ10km ç¨‹åº¦ã®æƒ³å®šãªã®ã§å˜ç´”æ›ç®—ã§ OK
  final rangeInMeters = next.explorer?.range ?? 0;

  circlesState.value = {
    Circle(
      circleId: const CircleId('explorerCircle'),
      center: currentLocation,
      radius: rangeInMeters,
      strokeColor: const Color(0xFF004DFF),
      strokeWidth: 1,
      fillColor: const Color(0x40004DFF),
    )
  };

  // å††ãŒç”»é¢å†…ã«åã¾ã‚‹ã‚ˆã†ã«ã‚«ãƒ¡ãƒ©ã‚’ã‚ºãƒ¼ãƒ 
  await _zoomToFitCircle(
    googleMapController: googleMapControllerState.value,
    center: currentLocation,
    radiusMeters: rangeInMeters,
  );
}
```

---

## ãƒã‚¤ãƒ³ãƒˆ

- **1km â‰ˆ 0.009åº¦** ã¨ã„ã†ç°¡æ˜“çš„ãªä¿‚æ•°ã‚’ä½¿ã†ã ã‘ã§ã€1ã€œ10kmç¨‹åº¦ã®ã‚ºãƒ¬ã§ã‚ã‚Œã°ã»ã¼å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚  
- å—è¥¿ç«¯ (`southwest`) ã¨åŒ—æ±ç«¯ (`northeast`) ã‚’å˜ç´”è¨ˆç®—ã§å‡ºã—ã¦ `LatLngBounds` ã«çªã£è¾¼ã‚€ã ã‘ãªã®ã§ã€ã¨ã¦ã‚‚èª­ã¿ã‚„ã™ã„ã§ã™ã€‚  
- èª¤å·®ã‚’å³å¯†ã«è¨ˆç®—ã—ãŸã„å ´åˆã‚„ 100km ä»¥ä¸Šã®å¤§ããªç¯„å›²ã§æ‰±ã„ãŸã„å ´åˆã¯ã€ç·¯åº¦ã«ã‚ˆã£ã¦çµŒåº¦ã®è·é›¢ä¿‚æ•°ãŒå¤‰ã‚ã‚‹è¨ˆç®— (`cos(latitude)`) ãŒå¿…è¦ã«ãªã‚Šã¾ã™ãŒã€ä»Šå›ã¯ãã“ã¾ã§ä¸è¦ãªã®ã§çœç•¥ã—ã¦ã„ã¾ã™ã€‚  

ã“ã‚Œã ã‘ã§ã€**1ã€œ10km ã®å††ãŒã—ã£ã‹ã‚Šç”»é¢å†…ã«åã¾ã‚‹ã‚ˆã†ã«è‡ªå‹•èª¿æ•´**ã§ãã¾ã™ã€‚

---
