# ZoomË™øÊï¥ÂÜÜÊèèÁîª

Êó•‰ªò: 2025-02-02

---

## üë§ „É¶„Éº„Ç∂„Éº
*2025/2/2 16:20:12*

Flutter „ÅßË°®Á§∫„Åó„Å¶„ÅÑ„ÇãGoogle„Éû„ÉÉ„Éó„Å´„Å§„ÅÑ„Å¶„ÄÅzoomÁéá„ÇíËá™Áî±„Å´Â§â„Åà„Åü„ÅÑÂá¶ÁêÜ„Åå„ÅÇ„Çã„ÄÇ
circlesState.value = {circle}; „Åô„Çã„Å®„Åì„Çç„Åß zoom Áéá„ÇíÂ§â„Åà„Åü„ÅÑ„Çì„Å†„ÄÇ
explorer?.range(„É°„Éº„Éà„É´) „ÅÆÂÜÜ„ÇíÊèè„Åè„ÅÆ„Åß„ÄÅ„Åù„Çå„ÅåÂèé„Åæ„Çã„Çà„ÅÜ„Å™ÈÅ©Âàá„Å™zoomÁéá„Å´„Åó„Åü„ÅÑ„ÄÇ


@freezed
class ExplorerDTO with _$ExplorerDTO {
  factory ExplorerDTO({
    @JsonKey(name: 'explorerId') required String? explorerId,
    @JsonKey(name: 'tokenId') required String? tokenId,
    @JsonKey(name: 'explorerName') required String? explorerName,
    @JsonKey(name: 'explorerDescription') String? explorerDescription,
    @JsonKey(name: 'explorerImage') required String? explorerImage,
    @JsonKey(name: 'explorerCategory')
    required ExplorerDTOExplorerCategory? explorerCategory,
    @JsonKey(name: 'energy') required num? energy,
    @JsonKey(name: 'rarity') required ExplorerDTORarity? rarity,
    @JsonKey(name: 'energyConsumption') required num? energyConsumption,
    @JsonKey(name: 'range') required num? range,
    @JsonKey(name: 'decoyFinding') required bool? decoyFinding,
    @JsonKey(name: 'totalSearch') required num? totalSearch,
    @JsonKey(name: 'totalSpotFound') required num? totalSpotFound,
  }) = _ExplorerDTO;

  factory ExplorerDTO.fromJson(Map&lt;String, dynamic&gt; jsonMap) =&gt;
      _$ExplorerDTOFromJson(jsonMap);
}



class OnExploringState {
  const OnExploringState({
    required this.isExploring,
    required this.explorer,
  });

  final bool isExploring;
  final ExplorerDTO? explorer;
}

@Riverpod(keepAlive: true)
class OnExploringNotifier extends _$OnExploringNotifier {
  @override
  OnExploringState build() {
    // „Éá„Éï„Ç©„É´„Éà„ÅØ isExploring=false, explorer=null „ÅÆÁä∂ÊÖã„ÅßÈñãÂßã
    return const OnExploringState(
      isExploring: false,
      explorer: null,
    );
  }

  void show(ExplorerDTO explorer) {
    state = OnExploringState(
      isExploring: true,
      explorer: explorer,
    );

    // ÂÜÜ„ÅåÂá∫„Å¶„ÅÑ„ÇãÊôÇÈñì
    Timer(const Duration(seconds: 5), () async {
      hide();
    });
  }

  void hide() {
    state = const OnExploringState(
      isExploring: false,
      explorer: null,
    );
  }
}



import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

enum SpotType {
  noneGuild, // spotGuildId == null
  myGuild, // spotGuildId == myGuildId
  enemyGuild // spotGuildId != myGuildId
}

/// ÈÄÜ‰∏âËßíÂΩ¢„ÇíÊèèÁîª„Åô„Çã„Ç∑„É≥„Éó„É´„Å™ Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // Â∑¶‰∏ä
      ..lineTo(size.width, 0) // Âè≥‰∏ä
      ..lineTo(size.width / 2, size.height) // Â∫ïËæ∫„ÅÆ‰∏≠Â§Æ
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isLoadingState = useState(false);

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);
      final photoUrl = spot.photoUrl;
      Widget content;

      switch (spotType) {
        case SpotType.noneGuild:
          content = DecoratedBox(
            decoration: BoxDecoration(
              border: Border.all(
                color: ColorPallet.white,
                width: 4,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: ColoredBox(
                color: ColorToken.bgWhite,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: (photoUrl != null && photoUrl.isNotEmpty)
                      ? CachedNetworkImage(
                          imageUrl: photoUrl,
                          fit: BoxFit.cover,
                          width: 64,
                          height: 64,
                          errorWidget: (context, url, error) {
                            return Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.broken_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            );
                          },
                        )
                      : Container(
                          width: 64,
                          height: 64,
                          color: ColorToken.bgDark,
                          child: const Icon(
                            Icons.hide_image_outlined,
                            size: 48,
                            color: ColorToken.text,
                          ),
                        ),
                ),
              ),
            ),
          );

        case SpotType.myGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorPallet.green500,
              child: Icon(
                Icons.flag,
                color: ColorPallet.green100,
                size: 24,
              ),
            ),
          );

        case SpotType.enemyGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorToken.bgEnemy,
              child: Icon(
                Icons.flag,
                color: ColorToken.enemy,
                size: 24,
              ),
            ),
          );
      }

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              content,
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final photoUrl = itemBox.itemBoxImage;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: (photoUrl != null && photoUrl.isNotEmpty)
                          ? CachedNetworkImage(
                              imageUrl: photoUrl,
                              fit: BoxFit.cover,
                              width: 64,
                              height: 64,
                              errorWidget: (context, url, error) {
                                return Container(
                                  width: 64,
                                  height: 64,
                                  color: ColorToken.bgDark,
                                  child: const Icon(
                                    Icons.broken_image_outlined,
                                    size: 48,
                                    color: ColorToken.text,
                                  ),
                                );
                              },
                            )
                          : Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.hide_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: spotType == SpotType.noneGuild
            ? const Size(198, 225)
            : const Size(242, 275),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    Future&lt;void&gt; refreshAllMarkers({
      required List&lt;GuildSpotDTO&gt; newSpotList,
      required List&lt;ItemBoxDTO&gt; newItemBoxList,
      required String? myGuildId,
    }) async {
      final currentMarkers = markersState.value.toSet();

      final neededMarkerIds = &lt;String&gt;{};
      for (final spot in newSpotList) {
        final spotId = spot.spotId ?? '';
        neededMarkerIds.add('spot_$spotId');
      }
      for (final box in newItemBoxList) {
        final boxId = box.itemBoxId ?? '';
        neededMarkerIds.add('itemBox_$boxId');
      }

      // Êó¢Â≠ò„Éû„Éº„Ç´„Éº„Åã„Çâ„Äå‰∏çË¶Å„Å´„Å™„Å£„Åü„ÇÇ„ÅÆ„Äç„ÇíÂâäÈô§„Åô„Çã
      currentMarkers.removeWhere(
        (marker) =&gt; !neededMarkerIds.contains(marker.markerId.value),
      );

      if (!context.mounted) {
        return;
      }

      // „ÅÑ„Å£„Åü„ÇìÂâäÈô§ÁµêÊûú„ÇíÂèçÊò†(‰∏çË¶Å„Éû„Éº„Ç´„Éº„ÅåÊ∂à„Åà„Çã)
      markersState.value = {...currentMarkers};

      // Spot „ÅÆ„É™„Çπ„Éà„ÇíÈ†Ü„Å´Âá¶ÁêÜ„Åó„ÄÅ1„Å§„Åö„Å§ÂÜçÊèèÁîª„Åó„Å¶ÂèçÊò†
      for (final spot in newSpotList) {
        final markerId = MarkerId('spot_${spot.spotId}');
        // buildSpotMarker (ÂøÖ„ÅöÂÜçÁîüÊàê„Åó„Å¶ÂÜçÊèèÁîª„Åô„Çã)
        final newMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // Êó¢Â≠ò„Å´Âêå„Åò ID „ÅÆ„Éû„Éº„Ç´„Éº„Åå„ÅÇ„Çå„Å∞ÂâäÈô§„Åó„Å¶„Åã„ÇâËøΩÂä†
        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        // Êñ∞„Åü„Å´ËøΩÂä†„Åï„Çå„Çã or Êõ¥Êñ∞„Åï„Çå„Åü„Éû„Éº„Ç´„Éº„Çí„Åô„ÅêÂèçÊò†
        markersState.value = {...currentMarkers};

        // UI „Çí„Éñ„É≠„ÉÉ„ÇØ„Åó„Å´„Åè„Åè„Åô„Çã„Åü„ÇÅ„Å´Â∞ë„ÅóÂæÖÊ©ü
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox „ÇÇÂêåÊßò„Å´Âá¶ÁêÜ
      for (final itemBox in newItemBoxList) {
        final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
        final newMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (box) async {
            await onTapItemBoxMarker(box);
          },
        );

        currentMarkers
          ..removeWhere((marker) =&gt; marker.markerId == markerId)
          ..add(newMarker);

        if (!context.mounted) {
          return;
        }

        markersState.value = {...currentMarkers};

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

    Future&lt;void&gt; onTanNearMe() async {
      try {
        final refreshedLocation = await ref
            .read(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();
        final controller = googleMapControllerState.value;
        if (controller != null) {
          await controller.animateCamera(
            CameraUpdate.newLatLng(refreshedLocation),
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; initializeMarkers() async {
      try {
        if (!context.mounted) {
          return;
        }

        isLoadingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        if (!context.mounted) {
          return;
        }

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshAllMarkers(
            newSpotList: spotList,
            newItemBoxList: itemBoxList,
            myGuildId: myGuildId,
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      } finally {
        if (context.mounted) {
          isLoadingState.value = false;
        }
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await initializeMarkers();
        });
        // „Éï„Ç©„Ç¢„Ç∞„É©„Ç¶„É≥„ÉâÂæ©Â∏∞„Åß‰ΩçÁΩÆÊÉÖÂ†±ÂÜçÂèñÂæó
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // „Éû„Éº„Ç´„Éº„ÅÆÊõ¥Êñ∞‰∏≠„ÅØ„Çπ„Ç≠„ÉÉ„Éó
        if (!isLoadingState.value) {
          // „Éû„Éº„Ç´„Éº„ÅÆÊõ¥Êñ∞
          await initializeMarkers();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          try {
            final currentLocation = await ref
                .watch(currentLocationNotifierProvider.notifier)
                .getCurrentLocation();

            // range „ÅØ km Âçò‰Ωç„Å™„ÅÆ„Åß„ÄÅ„É°„Éº„Éà„É´„Å´ÊèõÁÆóÔºà√ó1000Ôºâ
            final explorerRangeKm = next.explorer?.range ?? 0;
            final rangeInMeters = explorerRangeKm * 1000.0;

            final circle = Circle(
              circleId: const CircleId('explorerCircle'),
              center: currentLocation,
              radius: rangeInMeters,
              strokeColor: const Color(0xFF004DFF), // „Éñ„É´„Éº
              strokeWidth: 1,
              fillColor: const Color(0x40004DFF), // 25%„Åê„Çâ„ÅÑÈÄèÈÅé„ÅÆ„Éñ„É´„Éº
            );

            if (!context.mounted) {
              return;
            }

            circlesState.value = {circle};

            await googleMapControllerState.value?.animateCamera(
              CameraUpdate.newLatLng(currentLocation),
            );
          } on Exception catch (error) {
            if (context.mounted) {
              showErrorSnackBar(context, error);
            }
          }
        } else {
          if (!context.mounted) {
            return;
          }

          circlesState.value = {};
          final explodedSpotList = ref.read(explodedSpotListNotifierProvider);

          final spotPhotoItems = explodedSpotList
                  ?.where((spot) =&gt; spot.photoUrl != null)
                  .map(
                    (spot) =&gt; SpotPhotoItem(
                      photoId: spot.photoId ?? '',
                      spotPhotoUrl: spot.photoUrl ?? '',
                      spotOwnership: spot.guildId == null
                          ? SpotOwnership.neutral
                          : spot.guildId == myGuildIdState.value
                              ? SpotOwnership.owner
                              : SpotOwnership.enemy,
                    ),
                  )
                  .toList() ??
              [];

          ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

          await showDialog&lt;void&gt;(
            context: context,
            builder: (_) =&gt; ExploredResultDialog(
              spotPhotoItemList: spotPhotoItems,
            ),
          );

          ref.read(explodedSpotListNotifierProvider.notifier).clear();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                if (context.mounted) {
                  googleMapControllerState.value = controller;
                }
              },
              markers: markersState.value,
              circles: circlesState.value,
            ),
            if (isLoadingState.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // ÁèæÂú®Âú∞„Å∏Êàª„Çã„Éú„Çø„É≥
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTanNearMe();
                        },
                        child: const Icon(
                          Icons.near_me,
                          size: 24,
                          color: ColorToken.secondaryDark,
                        ),
                      ),
                    ),
                    // Explore „É™„Çπ„Éà
                    SizedBox(
                      width: 138,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: onExploringStateValue.isExploring
                            ? null
                            : () async {
                                await onTapExplorer();
                              },
                        backgroundColor: onExploringStateValue.isExploring
                            ? ColorPallet.gray800.withValues(alpha: 0.8)
                            : Theme.of(context)
                                .floatingActionButtonTheme
                                .backgroundColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: BorderSide(
                            color: onExploringStateValue.isExploring
                                ? Colors.transparent
                                : ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(left: 4),
                              child: onExploringStateValue.isExploring
                                  ? Transform.translate(
                                      offset: const Offset(4, 0),
                                      child: const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        ),
                                      ),
                                    )
                                  : Image.asset(
                                      Assets.images.explorerIconFig.path,
                                      width: 40,
                                      height: 40,
                                    ),
                            ),
                            const Spacer(),
                            Text(
                              onExploringStateValue.isExploring
                                  ? 'Exploring...'
                                  : 'Explore',
                              style: TextStyle(
                                fontSize: 16,
                                color: onExploringStateValue.isExploring
                                    ? ColorToken.text
                                    : ColorToken.secondaryDark,
                              ),
                            ),
                            const Spacer(),
                          ],
                        ),
                      ),
                    ),
                    // Spot „É™„Çπ„Éà
                    spotListAsyncValue.when(
                      data: (spotList) {
                        // ‰∏ä‰Ωç2„Å§„ÇíÂèñ„ÇäÂá∫„Åó„ÄÅÈ†ÜÂ∫è„ÇíÈÄÜ„Å´„Åô„Çã
                        final displaySpotList =
                            (spotList?.take(2).toList() ?? [])
                                .reversed
                                .toList();
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            backgroundColor: Colors.transparent,
                            shape: const RoundedRectangleBorder(
                              side: BorderSide(
                                color: Colors.transparent,
                              ),
                            ),
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: Transform.translate(
                              offset: const Offset(4, 4),
                              child: Stack(
                                clipBehavior: Clip.none,
                                alignment: Alignment.bottomRight,
                                children: [
                                  for (var i = 0; i &lt; 2; i++)
                                    if (i &lt; displaySpotList.length)
                                      Positioned(
                                        left: i * -4.0,
                                        top: i * -4.0,
                                        child: SizedBox(
                                          width: 44,
                                          height: 44,
                                          child: DecoratedBox(
                                            decoration: BoxDecoration(
                                              border: Border.all(
                                                color: ColorToken.bgWhite,
                                                width: 2,
                                              ),
                                              borderRadius:
                                                  BorderRadius.circular(4),
                                            ),
                                            child: Padding(
                                              padding: const EdgeInsets.all(2),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: SquareImage(
                                                  imageUrl: displaySpotList[i]
                                                      .photoUrl,
                                                  size: 44,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                      loading: () {
                        return const SizedBox.shrink();
                      },
                      error: (error, _) {
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            heroTag: 'ErrorShowSpotListButton',
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: const Icon(
                              Icons.photo,
                              size: 24,
                              color: ColorToken.secondaryDark,
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Center(
            child: ElevatedButton(
              onPressed: () async {
                await openAppSettings();
              },
              child: const Text(
                'Please enable location access in the Settings App',
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## üîß „ÉÑ„Éº„É´
*2025/2/2 16:20:35*

**Mapping zoom level**

I'm exploring how to ensure a circle with a specific radius on Google Maps in Flutter is fully visible by adjusting the camera's zoom level. The aim is to make the bounding box of the circle completely visible, possibly using LatLngBounds and CameraUpdate.newLatLngBounds.

**Crafting a bounding box**

I‚Äôm digging into computing a bounding box around a circle's center and radius, translating these into latitude and longitude degrees, and using CameraUpdate.newLatLngBounds for visibility.

**Ensuring visibility**

I'm verifying that the LatLngBounds constructor utilizes either the southwestern or northeastern corners to ensure the circle's complete visibility on the screen.

**Adjusting my approach**

I'm refining the function to ensure accurate zooming for circles near poles by separately calculating latitude and longitude deltas, particularly when dealing with radii meters.

**Tweaking calculations**

I'm adjusting for latitude and longitude differences near the poles by refining delta calculations for radii in meters, ensuring visibility and addressing issues like "Bounds too small."

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2025/2/2 16:20:35*

GoogleMap „ÅßÂÜÜ„ÇíË°®Á§∫„Åô„Çã„Å®ÂêåÊôÇ„Å´„ÄÅ„Åù„ÅÆÂÜÜ„ÅåÁîªÈù¢ÂÜÖ„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´ zoom „ÇíËá™ÂãïË™øÊï¥„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´ **`LatLngBounds` „Çí‰Ωø„Å£„Åü `CameraUpdate.newLatLngBounds(bounds, padding)`** „ÇíÂà©Áî®„Åô„Çã„Å®Á∞°Âçò„Å´ÂÆüÁèæ„Åß„Åç„Åæ„Åô„ÄÇ  

---

## „ÇÑ„Çä„Åü„ÅÑ„Åì„Å®

- `explorer?.range` („É°„Éº„Éà„É´) „Åã„ÇâÂçäÂæÑ„ÇíÊåÅ„Å§ÂÜÜ„ÇíÊèèÁîª„Åô„Çã
- „Åù„ÅÆÂÜÜ„ÅåÁîªÈù¢„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´ GoogleMap „ÅÆ„Ç´„É°„É©‰ΩçÁΩÆÔºÜ„Ç∫„Éº„É†„ÇíËá™ÂãïË™øÊï¥„Åó„Åü„ÅÑ

---

## ÂÆüË£Ö„ÅÆ„Éù„Ç§„É≥„Éà

1. **ÂÜÜ„ÅÆ‰∏≠ÂøÉÁÇπ**Ôºà= „É¶„Éº„Ç∂„Éº„ÅÆÁèæÂú®Âú∞„Å™„Å©Ôºâ
2. **ÂçäÂæÑÔºà„É°„Éº„Éà„É´Ôºâ**
   
„Åì„ÅÆ2„Å§„ÅÆÊÉÖÂ†±„Åã„Çâ„ÄÅ  
- ÂçóË•øÔºàsouthwestÔºâÁ´Ø
- ÂåóÊù±ÔºànortheastÔºâÁ´Ø  

„ÅÆÂ∫ßÊ®ô„ÇíË®àÁÆó„Åó„ÄÅ `LatLngBounds` „ÇíÁîüÊàê„Åó„Å¶„ÄÅ `animateCamera(CameraUpdate.newLatLngBounds(bounds, padding))` „ÇíÂëº„Å≥Âá∫„Åó„Åæ„Åô„ÄÇ

---

## „Çµ„É≥„Éó„É´ÂÆüË£Ö

‰ª•‰∏ã„ÅÆ‰æã„Åß„ÅØ„ÄÅ `onExploringState` „ÅåÂ§âÊõ¥„Åï„Çå„Åü„Çø„Ç§„Éü„É≥„Ç∞Ôºà= ÂÜÜ„ÇíË°®Á§∫„Åô„Çã„Çø„Ç§„Éü„É≥„Ç∞Ôºâ„Åß„ÄÅ  
`circlesState.value = {circle};` „ÅÆ„ÅÇ„Å®„Å´ **„ÄåÂÜÜ„ÅåÁîªÈù¢„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´„Ç´„É°„É©„ÇíÂãï„Åã„Åô„Äç** „Åü„ÇÅ„ÅÆÂá¶ÁêÜ„ÇíÂÖ•„Çå„Åü‰æã„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ

```dart
ref.listen<OnExploringState>(
  onExploringNotifierProvider,
  (previous, next) async {
    if (next.isExploring) {
      try {
        final currentLocation = await ref
            .watch(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();

        // range „ÅØ„Äåkm„Äç„Åß„ÅØ„Å™„Åè„Äå„É°„Éº„Éà„É´„ÄçÊÉ≥ÂÆö„Å™„Çâ„ÄÅ„Åì„ÅÆ„Åæ„Åæ‰Ωø„ÅÜ„ÄÇ 
        // km „ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„Å™„Çâ (range * 1000) „Åó„Å¶„É°„Éº„Éà„É´„Å´ÊèõÁÆó„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
        final rangeInMeters = next.explorer?.range ?? 0;

        // ÂÜÜ„ÇíË°®Á§∫
        final circle = Circle(
          circleId: const CircleId('explorerCircle'),
          center: currentLocation,
          radius: rangeInMeters,
          strokeColor: const Color(0xFF004DFF),
          strokeWidth: 1,
          fillColor: const Color(0x40004DFF), // ÂçäÈÄèÊòé„Éñ„É´„Éº
        );
        circlesState.value = {circle};

        // ---- „Åì„Åì„Åß„Ç∫„Éº„É†„ÇíÂÜÜ„Å´Âêà„Çè„Åõ„ÇãÂá¶ÁêÜ„ÇíËøΩÂä†„Åô„Çã ----
        await _zoomToFitCircle(
          googleMapController: googleMapControllerState.value,
          center: currentLocation,
          radiusInMeters: rangeInMeters,
        );

      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    } else {
      // ÂÜÜ„ÇíÊ∂à„Åô„Å™„Å©„ÅÆÂá¶ÁêÜ ...
      circlesState.value = {};
      // ...
    }
  },
);
```

### `_zoomToFitCircle` „ÅÆÂÆüË£Ö‰æã

```dart
/// ÊåáÂÆö„Åó„Åü [center] „Å® [radiusInMeters] „ÅÆÂÜÜ„ÅåÁîªÈù¢ÂÜÖ„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´„Ç´„É°„É©„ÇíÂãï„Åã„Åô
Future<void> _zoomToFitCircle({
  required GoogleMapController? googleMapController,
  required LatLng center,
  required double radiusInMeters,
}) async {
  if (googleMapController == null) {
    return;
  }

  // Á∑ØÂ∫¶„ÉªÁµåÂ∫¶„ÇíÂ∫¶Êï∞„Å´ÊèõÁÆó„Åô„Çã„Åü„ÇÅ„ÅÆ‰øÇÊï∞„ÇíÊ±Ç„ÇÅ„Çã
  // („Åñ„Å£„Åè„Çä„Å®„Åó„ÅüÂú∞ÁêÉÂçäÂæÑ„Åã„ÇâÁÆóÂá∫„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅÂé≥ÂØÜ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅ
  //  ‰∏ÄËà¨ÁöÑ„Å™„Ç±„Éº„Çπ„Åß„ÅØÂçÅÂàÜÂÆüÁî®ÁöÑ„Åß„Åô)
  const double earthCircumferencePerDegree = 111320; // m/degree (Á∑ØÂ∫¶)
  final double latRadians = center.latitude * (math.pi / 180);

  // Á∑ØÂ∫¶ÊñπÂêë(1Â∫¶„ÅÇ„Åü„ÇäÁ¥Ñ111.32km)
  final double deltaLat = radiusInMeters / earthCircumferencePerDegree;
  // ÁµåÂ∫¶ÊñπÂêë(Á∑ØÂ∫¶„Å´„Çà„Å£„Å¶Â§âÂåñ„Åô„Çã„ÄÇËµ§ÈÅì‰ªòËøë ~111.32km/Â∫¶„ÄÅÊ•µÂú∞‰ªòËøë ~0km/Â∫¶)
  final double deltaLng =
      radiusInMeters / (earthCircumferencePerDegree * math.cos(latRadians));

  // ÂçóË•øÁ´Ø(southwest)„Å®ÂåóÊù±Á´Ø(northeast)„ÇíË®àÁÆó
  final southwest = LatLng(
    center.latitude - deltaLat,
    center.longitude - deltaLng,
  );
  final northeast = LatLng(
    center.latitude + deltaLat,
    center.longitude + deltaLng,
  );

  // Bounds „ÅåÂ∞è„Åï„Åô„Åé„Çã (‰æã: range=0) Â†¥Âêà„ÅÆ„Åü„ÇÅ„ÅÆ„Ç¨„Éº„Éâ
  if (southwest == northeast) {
    // „ÅÇ„ÇãÁ®ãÂ∫¶Âõ∫ÂÆö„Ç∫„Éº„É†„Å´È£õ„Å∞„Åô„Å™„Å©„ÅÆÂá¶ÁêÜ
    await googleMapController.animateCamera(
      CameraUpdate.newLatLngZoom(center, 17),
    );
    return;
  }

  // LatLngBounds „ÅØÂºïÊï∞„Åå southWest < northEast „Å´„Å™„Çã„Çà„ÅÜ„Å´ÊåáÂÆö„Åô„Çã
  final bounds = LatLngBounds(
    southwest: LatLng(
      math.min(southwest.latitude, northeast.latitude),
      math.min(southwest.longitude, northeast.longitude),
    ),
    northeast: LatLng(
      math.max(southwest.latitude, northeast.latitude),
      math.max(southwest.longitude, northeast.longitude),
    ),
  );

  // Â∞ë„Åó‰ΩôÁôΩ„Çí„Å®„Å£„Å¶„Ç∫„Éº„É†
  final cameraUpdate = CameraUpdate.newLatLngBounds(bounds, 80);
  await googleMapController.animateCamera(cameraUpdate);
}
```

---

## „Çà„Åè„ÅÇ„Çã„Éè„Éû„Çä„Å©„Åì„Çç

1. `LatLngBounds` „ÅØ `southwest` „Å® `northeast` „ÇíÊ≠£„Åó„ÅÑÈ†ÜÂ∫è„Åß‰∏é„Åà„Å™„ÅÑ„Å®„Ç®„É©„Éº„Å´„Å™„Çã  
   - Á∑ØÂ∫¶ (latitude) „Å™„Çâ„ÄåÂ∞è„Åï„ÅÑÊñπ„Åå south„ÄÅÂ§ß„Åç„ÅÑÊñπ„Åå north„Äç  
   - ÁµåÂ∫¶ (longitude) „Å™„Çâ„ÄåÂ∞è„Åï„ÅÑÊñπ„Åå west„ÄÅÂ§ß„Åç„ÅÑÊñπ„Åå east„Äç

2. ÂÜÜ„ÅÆÂçäÂæÑ„Åå 0„ÄúÊï∞ÂçÅ„É°„Éº„Éà„É´„Å™„Å©Ê•µÁ´Ø„Å´Â∞è„Åï„ÅÑÂ†¥Âêà„ÅØ„ÄÅ `newLatLngBounds` „Åå„ÄåBounds „ÅåÂ∞è„Åï„Åô„Åé„Çã„Äç„Å®„ÅÑ„ÅÜÁêÜÁî±„ÅßÂ§±Êïó„Åó„Åü„Çä„ÄÅÊÉ≥ÂÆö„Åó„Å™„ÅÑ„Ç∫„Éº„É†„Å´„Å™„Å£„Åü„Çä„Åô„Çã  
   - „Åù„ÅÆÂ†¥Âêà„ÅØ fallback Âá¶ÁêÜ„Å®„Åó„Å¶„ÄÅ `newLatLngZoom(center, 17)` „Å™„Å©„Äå„Å®„Çä„ÅÇ„Åà„ÅöÂõ∫ÂÆöÂÄçÁéá„Äç„ÅßÊò†„Åô„Çà„ÅÜ„Å´„Åô„Çã„Å®ÂÆâÂÆö„Åó„Åæ„Åô„ÄÇ

3. ÁµåÂ∫¶Â∑Æ„ÅÆË®àÁÆó„Å´„ÅØ„ÄÅÂ∫ßÊ®ô„ÅÆÁ∑ØÂ∫¶„Å´Âøú„Åò„Å¶ `cos(latitude)` „ÇíÊéõ„Åë„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã  
   - „Åì„Çå„Çí„Åó„Å™„ÅÑ„Å®„ÄÅÈ´òÁ∑ØÂ∫¶Âú∞Âüü (Êó•Êú¨„Åß„ÇÇÂåóÊµ∑ÈÅìÊù±ÈÉ®„Å™„Å©) „Åß„ÅØË™§Â∑Æ„ÅåÂ§ß„Åç„Åè„Å™„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô  
   - ‰∏äË®ò„Çµ„É≥„Éó„É´„Åß„ÅØÁ∞°ÊòìË®àÁÆó„Å´„Å®„Å©„ÇÅ„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅÊôÆÈÄö„ÅÆÂà©Áî®„Ç±„Éº„Çπ„Åß„ÅÇ„Çå„Å∞ÂïèÈ°å„Å™„ÅèÊ©üËÉΩ„Åó„Åæ„Åô„ÄÇ

4. Âú∞Âõ≥„Åå‰ΩúÊàê„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Çø„Ç§„Éü„É≥„Ç∞ (`onMapCreated` „ÅåÊú™ÂÆå‰∫Ü) „Åß `animateCamera` „ÇíÂëº„Å∂„Å®‰Ωï„ÇÇËµ∑„Åì„Çâ„Å™„ÅÑÂ†¥Âêà„Åå„ÅÇ„Çã  
   - „Äå„Éû„ÉÉ„Éó„Åå‰Ωú„Çâ„Çå„Åü„ÅÇ„Å®„Å´„Ç∫„Éº„É†„Åô„Çã„Äç„Éï„É≠„Éº„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åã„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

---

## „Åæ„Å®„ÇÅ

- ÂÜÜ„ÇíÊèèÁîª„Åó„Åü„ÅÇ„Å®„Å´„ÄÅ `LatLngBounds` „ÅßËá™Âãï„Ç∫„Éº„É†„Åô„Çå„Å∞„ÄÅÊåáÂÆö„Åó„ÅüÂçäÂæÑ„ÅÆÂÜÜ„ÇíÁîªÈù¢ÂÜÖ„Å´Âèé„ÇÅ„Çâ„Çå„Åæ„Åô„ÄÇ  
- Ë∑ùÈõ¢„Çí„ÄåÁ∑ØÂ∫¶„ÉªÁµåÂ∫¶„ÅÆÂ∫¶Êï∞„Äç„Å´ÊèõÁÆó„Åó„ÄÅÂçóË•øÁ´Ø„ÉªÂåóÊù±Á´Ø„ÇíË®àÁÆó„Åó„Å¶ `CameraUpdate.newLatLngBounds(bounds, padding)` „ÇíÂëº„Å≥Âá∫„Åô„Å†„Åë„Åß„Åô„ÄÇ  

„Åì„Çå„Åß `explorer?.range` „É°„Éº„Éà„É´„ÅÆÂÜÜ„Åå„Åó„Å£„Åã„ÇäË¶ã„Åà„Çã„Çà„ÅÜ„Å´Ëá™Âãï„ÅßÂú∞Âõ≥„Åå„Ç∫„Éº„É†ÔºÜÁßªÂãï„Åô„Çã„Çà„ÅÜ„Å´„Å™„Çã„ÅØ„Åö„Åß„Åô„ÄÇ

---

## üë§ „É¶„Éº„Ç∂„Éº
*2025/2/2 16:23:12*

1km„Åã„Çâ10km„ÅÆÂÜÜ„Åó„ÅãÊèè„Åã„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„ÇÇ„Å£„Å®Á∞°ÊòìÁöÑ„Å™Âá¶ÁêÜ„Åß„ÅÑ„ÅÑ„Çà„ÄÇ
„ÅÇ„Çì„Åæ„ÇäË§áÈõë„Å™Âá¶ÁêÜ„Çí„Åó„Å¶„Åª„Åó„Åè„Å™„ÅÑ„ÄÇÂèØË™≠ÊÄßÈáçË¶ñ„Åß„ÄÇ

---

## üîß „ÉÑ„Éº„É´
*2025/2/2 16:23:31*

**Mapping the approach**

I‚Äôm thinking of defining a small function to calculate the bounding box in degrees, allowing for quick and easy adjustment of zoom levels for circles ranging from 1km to 10km.

**Mapping bounding box**

I‚Äôm detailing steps to define the bounding box for circles from 1km to 10km, using simpler latitude and longitude adjustments without considering latitude's cosine influence.

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2025/2/2 16:23:31*

„Äå**1km „Äú 10km „ÅÆÂÜÜ** „Åó„ÅãÊèè„Åã„Å™„ÅÑ„Äç„Å®„ÅÑ„ÅÜÂâçÊèê„Åß„ÅÇ„Çå„Å∞„ÄÅ  
**„Äå1km ‚âà 0.009Â∫¶„Äç** „Å®„ÅÑ„ÅÜÂçòÁ¥îÊèõÁÆó„ÅßÂçÅÂàÜÂÆüÁî®ÁöÑ„Åß„Åô„ÄÇ  
Á∑ØÂ∫¶„ÉªÁµåÂ∫¶„Å®„ÇÇ„Åì„ÅÆÂÄ§„Çí‰Ωø„Å£„Å¶„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ„Çí‰Ωú„Çã„Å®ÂèØË™≠ÊÄß„ÅåÈ´ò„Åè„ÄÅÂÆüË£Ö„ÇÇ„Ç∑„É≥„Éó„É´„Å´„Åß„Åç„Åæ„Åô„ÄÇ

‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´ **`zoomToFitCircle`** Èñ¢Êï∞„Çí‰Ωú„Å£„Å¶Âëº„Å≥Âá∫„Åô„Ç§„É°„Éº„Ç∏„Åß„Åô„ÄÇ

---

## „Çµ„É≥„Éó„É´ÂÆüË£Ö‰æã

```dart
/// ÂçäÂæÑ [radiusMeters] „ÅÆÂÜÜ„Åå„Å°„Çá„ÅÜ„Å©Âèé„Åæ„Çã„Çà„ÅÜ„Å´„Ç∫„Éº„É†„Åô„ÇãÁ∞°ÊòìÁâà
/// ‚Äª 1km „Äú 10km Á®ãÂ∫¶„ÅÆÁØÑÂõ≤„Åß„ÅÇ„Çå„Å∞Ë™§Â∑ÆÊ∞ó„Å´„Åõ„Åö 1km ‚âà 0.009Â∫¶ „ÅßOK„ÄÇ
Future<void> _zoomToFitCircle({
  required GoogleMapController? googleMapController,
  required LatLng center,
  required double radiusMeters,
}) async {
  if (googleMapController == null) return;

  // 1km ‚âà 0.009Â∫¶ (Âé≥ÂØÜ„Åß„Å™„Åè„Å¶OK)
  // ‰ªäÂõû„ÅØ 1~10km Á®ãÂ∫¶„Å™„ÅÆ„Åß„Åì„Çå„ÅßÂçÅÂàÜ
  final radiusKm = radiusMeters / 1000.0;
  final delta = 0.009 * radiusKm;

  // ÂçóË•øÁ´Ø„Å®ÂåóÊù±Á´Ø„Çí„Åñ„Å£„Åè„ÇäÊ±∫„ÇÅ„Çã
  final sw = LatLng(center.latitude - delta, center.longitude - delta);
  final ne = LatLng(center.latitude + delta, center.longitude + delta);

  // LatLngBounds „Çí‰ΩúÊàê
  final bounds = LatLngBounds(southwest: sw, northeast: ne);

  // Â∞ë„Åó‰ΩôÁôΩ„Çí„ÅÇ„Åë„Åü„ÅÑÂ†¥Âêà„ÅØ padding „ÇíË®≠ÂÆö
  const padding = 50.0; // ÁîªÈù¢ÂõõÈöÖ„Å®„ÅÆ‰ΩôÁôΩ
  final cameraUpdate = CameraUpdate.newLatLngBounds(bounds, padding);

  // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Åß„Ç∫„Éº„É†
  await googleMapController.animateCamera(cameraUpdate);
}
```

### Âëº„Å≥Âá∫„Åó„Ç§„É°„Éº„Ç∏

```dart
if (next.isExploring) {
  // ... ÂÜÜ„ÅÆÊèèÁîª ...

  // 1„Äú10km Á®ãÂ∫¶„ÅÆÊÉ≥ÂÆö„Å™„ÅÆ„ÅßÂçòÁ¥îÊèõÁÆó„Åß OK
  final rangeInMeters = next.explorer?.range ?? 0;

  circlesState.value = {
    Circle(
      circleId: const CircleId('explorerCircle'),
      center: currentLocation,
      radius: rangeInMeters,
      strokeColor: const Color(0xFF004DFF),
      strokeWidth: 1,
      fillColor: const Color(0x40004DFF),
    )
  };

  // ÂÜÜ„ÅåÁîªÈù¢ÂÜÖ„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´„Ç´„É°„É©„Çí„Ç∫„Éº„É†
  await _zoomToFitCircle(
    googleMapController: googleMapControllerState.value,
    center: currentLocation,
    radiusMeters: rangeInMeters,
  );
}
```

---

## „Éù„Ç§„É≥„Éà

- **1km ‚âà 0.009Â∫¶** „Å®„ÅÑ„ÅÜÁ∞°ÊòìÁöÑ„Å™‰øÇÊï∞„Çí‰Ωø„ÅÜ„Å†„Åë„Åß„ÄÅ1„Äú10kmÁ®ãÂ∫¶„ÅÆ„Ç∫„É¨„Åß„ÅÇ„Çå„Å∞„Åª„ÅºÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ  
- ÂçóË•øÁ´Ø (`southwest`) „Å®ÂåóÊù±Á´Ø (`northeast`) „ÇíÂçòÁ¥îË®àÁÆó„ÅßÂá∫„Åó„Å¶ `LatLngBounds` „Å´Á™Å„Å£Ëæº„ÇÄ„Å†„Åë„Å™„ÅÆ„Åß„ÄÅ„Å®„Å¶„ÇÇË™≠„Åø„ÇÑ„Åô„ÅÑ„Åß„Åô„ÄÇ  
- Ë™§Â∑Æ„ÇíÂé≥ÂØÜ„Å´Ë®àÁÆó„Åó„Åü„ÅÑÂ†¥Âêà„ÇÑ 100km ‰ª•‰∏ä„ÅÆÂ§ß„Åç„Å™ÁØÑÂõ≤„ÅßÊâ±„ÅÑ„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅÁ∑ØÂ∫¶„Å´„Çà„Å£„Å¶ÁµåÂ∫¶„ÅÆË∑ùÈõ¢‰øÇÊï∞„ÅåÂ§â„Çè„ÇãË®àÁÆó (`cos(latitude)`) „ÅåÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„Åå„ÄÅ‰ªäÂõû„ÅØ„Åù„Åì„Åæ„Åß‰∏çË¶Å„Å™„ÅÆ„ÅßÁúÅÁï•„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ  

„Åì„Çå„Å†„Åë„Åß„ÄÅ**1„Äú10km „ÅÆÂÜÜ„Åå„Åó„Å£„Åã„ÇäÁîªÈù¢ÂÜÖ„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´Ëá™ÂãïË™øÊï¥**„Åß„Åç„Åæ„Åô„ÄÇ

---
