# 非同期エラー対応

日付: 2023-06-20

---

## 👤 ユーザー
*2023/6/20 19:10:44*

いかのようなエラーが出ているので対応してほしい

Cannot pass function of type '(GazeTrackEvent) async -&gt; Void' to parameter expecting synchronous function type

public final class GazeTrackCalibrationInteractor: GazeTrackCalibrationInteractorProtocol {
    private let calibrationNextPointSubject = PassthroughSubject&lt;(x: Double, y: Double), Never&gt;()
    private let progressSubject = PassthroughSubject&lt;Double, Never&gt;()
    private let completedCalibrationSubject = PassthroughSubject&lt;\[Double\], Never&gt;()
    private let errorSubject = PassthroughSubject&lt;Error, Never&gt;()
    private let gazeTrackManager: GazeTrackManagerProtocol
    private var cancellableSet = Set&lt;AnyCancellable&gt;()

    public var calibrationNextPointPublisher: AnyPublisher&lt;(x: Double, y: Double), Never&gt; {
        calibrationNextPointSubject.eraseToAnyPublisher()
    }

    public var progressPublisher: AnyPublisher&lt;Double, Never&gt; {
        progressSubject.eraseToAnyPublisher()
    }
    
    public var completedCalibrationPublisher: AnyPublisher&lt;\[Double\], Never&gt; {
        completedCalibrationSubject.eraseToAnyPublisher()
    }

    public var errorPublisher: AnyPublisher&lt;Error, Never&gt; {
        errorSubject.eraseToAnyPublisher()
    }

    public init(gazeTrackManager: GazeTrackManagerProtocol = SeeSoGazeTrackManager()) {
        self.gazeTrackManager = gazeTrackManager

        gazeTrackManager
            .gazeTrackEventPublisher
            .sink { \[weak self\] event in
                guard let self else { return }

                switch event {
                case .initialized(let trackerVoid, let error):
                    AppLogger.debugLog("Event: \\(event), TrackerVoid: \\(String(describing: trackerVoid)), Error: \\(error)")

                    guard error != .none else {
                        // エラーではないです
                        return
                    }
                    self.errorSubject.send(error)
                    
                case .started:
                    AppLogger.debugLog("Event: \\(event)")

                case .stopped(let error):
                    AppLogger.debugLog("Event: \\(event), Error: \\(error)", level: .error)

                    self.errorSubject.send(error)

                case .gaze(let gazeInformation):
                    AppLogger.debugLog("Event: \\(event), Gaze Information: \\(gazeInformation)")

                case .calibrationNextPoint(let x, let y):
                    AppLogger.debugLog("Event: \\(event), X: \\(x), Y: \\(y)")

                    do {
                        try await self.gazeTrackManager.startCalibrationCollectSamples()
                    } catch {
                        self.errorSubject.send(error)
                    }

                case .calibrationProgress(let progress):
                    AppLogger.debugLog("Event: \\(event), Progress: \\(progress)")
                    
                    self.progressSubject.send(progress)

                case .calibrationFinished(let calibrationData):
                    AppLogger.debugLog("Event: \\(event), Calibration Data: \\(calibrationData)")
                    
                    self.completedCalibrationSubject.send(calibrationData)

                case .image(let timestamp, let image):
                    AppLogger.debugLog("Event: \\(event), Timestamp: \\(timestamp), Image: \\(image)")

                case .attention(let timestampBegin, let timestampEnd, let score):
                    AppLogger.debugLog("Event: \\(event), Timestamp Begin: \\(timestampBegin), Timestamp End: \\(timestampEnd), Score: \\(score)")

                case .blink(let timestamp, let isBlinkLeft, let isBlinkRight, let isBlink, let eyeOpenness):
                    AppLogger.debugLog("Event: \\(event), Timestamp: \\(timestamp), Is Blink Left: \\(isBlinkLeft), Is Blink Right: \\(isBlinkRight), Is Blink: \\(isBlink), Eye Openness: \\(eyeOpenness)")

                case .drowsiness(let timestamp, let isDrowsiness):
                    AppLogger.debugLog("Event: \\(event), Timestamp: \\(timestamp), Is Drowsiness: \\(isDrowsiness)")
                }
            }
            .store(in: &cancellableSet)
        
        self.gazeTrackManager.initializationGazeTracker()
    }

    public func startCalibration() async throws {
        try await gazeTrackManager.startCalibration()
    }
}

---

## 🤖 アシスタント
*2023/6/20 19:11:18*

Swift 5.5から導入された非同期処理と既存の同期処理を混在させることはできません。そのため、`sink`メソッド内で非同期の`startCalibrationCollectSamples`メソッドを呼び出すことができません。

この問題を解決するために、非同期タスクを`Task.init{}`ブロック内で生成し、そのブロック内で非同期関数を呼び出します。こうすることで非同期タスクが完了するまで待機できます。

以下に修正後のコードの一部を示します：

```swift
gazeTrackManager
    .gazeTrackEventPublisher
    .sink { [weak self] event in
        guard let self = self else { return }

        switch event {
        case .calibrationNextPoint(let x, let y):
            AppLogger.debugLog("Event: \(event), X: \(x), Y: \(y)")

            Task.init {
                do {
                    try await self.gazeTrackManager.startCalibrationCollectSamples()
                } catch {
                    self.errorSubject.send(error)
                }
            }

        // Other cases...
        }
    }
    .store(in: &cancellableSet)
```

この修正により、非同期関数`startCalibrationCollectSamples`は`Task.init {}`ブロック内で実行され、`sink`メソッドの同期コードとの間で競合することがなくなります。

---
