# 関数Aで関数Bを実行する

Date: 2023-06-20

---

## 👤 User
*2023-06-20 21:46:14*

Swiftで関数Aでは関数Bをコールしている。条件Cがあるが、関数Aを実行したタイミングで、条件Cがtrueならすぐに関数Bを実行して、falseの場合はtrueになるまで待って、関数Bを実行したい。その場合どうすればいいか教えて欲しい

---

## 🤖 Assistant
*2023-06-20 21:47:32*

ここでの主な考え方は、「条件C」が真になるまで待つという処理をどのように実装するかです。Swiftでは、非同期処理を扱うためのいくつかの方法があります。その中で、Swift 5.5から導入された新機能 `async/await` を利用した方法を以下に示します。

ここでは、条件Cが`Bool`型の変数`conditionC`であると仮定します。

```swift
import Foundation

// 全体を非同期タスクとして定義します
@available(iOS 15, *)
func functionA() async {
    // 条件Cが真になるまでループします
    while !conditionC {
        // 短い待機時間を設けてCPUの無駄遣いを防ぎます
        await Task.sleep(1_000_000_000) // 1 second
    }
    // 条件Cが真になったら関数Bを実行します
    functionB()
}

func functionB() {
    // functionBの処理
}

var conditionC = false

// 非同期処理を呼び出す際には、非同期タスクを使います
@available(iOS 15, *)
func test() {
    Task {
        await functionA()
    }
}

test()

// conditionCの値を変更する処理
DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
    conditionC = true
}
```

この例では、`functionA`の中で無限ループを作り、その中で`Task.sleep(1_000_000_000)`を使って1秒待機することで、条件Cが真になるまで待っています。この待機時間はCPUの無駄遣いを防ぐために設けています。

そして、この非同期処理を呼び出すために、新たな非同期タスクを作成する`Task {}`を使っています。この中に`await functionA()`と書くことで非同期関数を呼び出しています。

なお、上記コードはSwift 5.5以降、およびiOS 15以降で動作します。それより古いバージョンでは動作しないので、使用するバージョンに注意してください。

また、`conditionC`の値が別のスレッドで変更される可能性がある場合は、スレッドセーフな操作を考慮する必要があります。上記のコードはシンプルな例であり、実際のアプリケーションではより複雑な非同期処理やエラーハンドリングが必要になるかもしれません。

最後に、無限ループを作るという処理は一般的には推奨されません。実

---

## 👤 User
*2023-06-20 21:47:36*

conditionCはAnyPublisher&lt;Bool, Never&gt;の場合はどうすればいい？

---

## 🤖 Assistant
*2023-06-20 21:48:37*

あなたの質問はSwiftUIとCombineを使って非同期処理を行う際のケースに関連しているようです。Combineフレームワークでは、データの変化を監視するためにPublisherとSubscriberの概念を使用します。

あなたが述べたように、条件Cが`AnyPublisher<Bool, Never>`型である場合、そのPublisherが新しい値を発行するたびに関数Bを呼び出したいと思います。それは、特に`filter`オペレータを使って値がtrueであるときだけ関数Bを呼び出すことができます。

以下に具体的なコードを示します：

```swift
import Combine
import Foundation

func functionA(conditionC: AnyPublisher<Bool, Never>) -> AnyCancellable {
    return conditionC
        .filter { $0 == true } // 条件Cが真であるときだけ通過させる
        .sink { _ in functionB() } // 条件Cが真のときに関数Bを実行
}

func functionB() {
    // functionBの処理
    print("Function B is called")
}

let conditionC = PassthroughSubject<Bool, Never>()
let cancellable = functionA(conditionC: conditionC.eraseToAnyPublisher())

// どこかでconditionCが更新されると、関数Bが呼ばれます
conditionC.send(true)
```

ここで、`functionA`は`AnyPublisher<Bool, Never>`を引数に取り、`.filter`でtrueだけを通過させ、`.sink`で関数Bを呼び出しています。そして`functionA`は`AnyCancellable`を返すので、外部から購読をキャンセルできます。そのため、`functionA`の呼び出し結果を変数`cancellable`に保持しています。

また、`PassthroughSubject<Bool, Never>`のインスタンス`conditionC`は、必要に応じてtrueまたはfalseを送信します。送信するたびに、その値が購読者（ここでは`functionA`）に送られ、条件がtrueのときだけ関数Bが呼び出されます。

なお、CombineはiOS 13.0以降で使用可能です。

---
