# スクロール検知と読み込み

Date: 2024-09-26

---

## 👤 User
*2024-09-26 15:13:09*

SwiftUIで何度bottomに到達した際にmoreLoadするようにしたい。

extension ConversationLogView {
    struct ConversationListView: View {
        let threads: [MessageThread]
        let isFetchingMessageThreads: Bool
        let onTapped: (MessageThread) -&gt; Void
        let onScrollToEnd: () -&gt; Void

        var body: some View {
            // 本来は List を使用したいが ScrollView 内部のため LazyVStack を採用している
            LazyVStack(spacing: 0) {
                ForEach(threads) { thread in
                    if let finishedAt = thread.finishedAt {
                        Button {
                            onTapped(thread)
                        } label: {
                            HStack(spacing: 16) {
                                Text(finishedAt.toString(.yyyyMMddSlash))
                                    .foregroundColor(Color.gritGray70)
                                    .font(.regular12)
                                Text(thread.title)
                                    .foregroundColor(Color.gritGray110)
                                    .font(.bold14)
                                    .multilineTextAlignment(.leading)
                                    .lineSpacing(4)
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.vertical, 20)
                            .padding(.horizontal, 16)
                        }
                        .background(Color.gritWhite) // Button 内にいれるとタップした時の色の変化が不自然なため外側で指定している
                        // 以下の .clipShape は ProgressView を bottom に埋め込んでいるため LazyVStack 全体を .clipShape しても bottom が適応されないための対応
                        .clipShape(.rect(
                            topLeadingRadius: thread.id == threads.first?.id ? 12 : 0,
                            bottomLeadingRadius: thread.id == threads.last?.id ? 12 : 0,
                            bottomTrailingRadius: thread.id == threads.last?.id ? 12 : 0,
                            topTrailingRadius: thread.id == threads.first?.id ? 12 : 0
                        ))

                        Divider().background(Color.gritGray30)
                            .isVisible(thread.id != threads.last?.id)
                    }
                }

                if threads.isNotEmpty {
                    ProgressView()
                        .padding(.vertical, 8)
                        .isVisible(isFetchingMessageThreads, shouldRemove: true)
                    
                    // LazyVStack が最後まで到達したことを検知する目的
                    GeometryReader { geometry in
                        Color.clear
                            .onAppear {
                                if geometry.frame(in: .global).maxY &lt; UIScreen.main.bounds.height {
                                    onScrollToEnd()
                                }
                            }
                    }
                    .frame(height: 1)
                }
            }
            .animation(.default, value: isFetchingMessageThreads)
        }
    }
}

---

## 🤖 Assistant
*2024-09-26 15:13:37*

このコードでは、`GeometryReader` を使用してリストがスクロールの最後に到達したかどうかを検知し、そこで `onScrollToEnd()` を呼び出してさらに読み込む処理を実行しています。いくつかの調整を加えることで、よりスムーズな動作やパフォーマンス向上が期待できます。

次のように、改善点や詳細説明を補足します。

### 改善点:
1. **最下部の検出におけるしきい値の追加**:
   現在のコードでは、`maxY` が `UIScreen.main.bounds.height` より小さい場合に即座に `onScrollToEnd()` が呼び出されますが、しきい値を追加することでスクロールの最下部付近でのみ呼び出されるようにします。
   
2. **オフスクリーン検知の最適化**:
   `GeometryReader` の使用は動作しますが、頻繁な再計算が発生することがあるため、オフスクリーンでの検知を最適化することも検討できます。

以下は、上記の改善を含めたコード例です：

```swift
extension ConversationLogView {
    struct ConversationListView: View {
        let threads: [MessageThread]
        let isFetchingMessageThreads: Bool
        let onTapped: (MessageThread) -> Void
        let onScrollToEnd: () -> Void

        var body: some View {
            LazyVStack(spacing: 0) {
                ForEach(threads) { thread in
                    if let finishedAt = thread.finishedAt {
                        Button {
                            onTapped(thread)
                        } label: {
                            HStack(spacing: 16) {
                                Text(finishedAt.toString(.yyyyMMddSlash))
                                    .foregroundColor(Color.gritGray70)
                                    .font(.regular12)
                                Text(thread.title)
                                    .foregroundColor(Color.gritGray110)
                                    .font(.bold14)
                                    .multilineTextAlignment(.leading)
                                    .lineSpacing(4)
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.vertical, 20)
                            .padding(.horizontal, 16)
                        }
                        .background(Color.gritWhite)
                        .clipShape(.rect(
                            topLeadingRadius: thread.id == threads.first?.id ? 12 : 0,
                            bottomLeadingRadius: thread.id == threads.last?.id ? 12 : 0,
                            bottomTrailingRadius: thread.id == threads.last?.id ? 12 : 0,
                            topTrailingRadius: thread.id == threads.first?.id ? 12 : 0
                        ))

                        Divider().background(Color.gritGray30)
                            .isVisible(thread.id != threads.last?.id)
                    }
                }

                if threads.isNotEmpty {
                    ProgressView()
                        .padding(.vertical, 8)
                        .isVisible(isFetchingMessageThreads, shouldRemove: true)
                    
                    // LazyVStack が最後まで到達したことを検知する目的
                    GeometryReader { geometry in
                        Color.clear
                            .onAppear {
                                let scrollPosition = geometry.frame(in: .global).maxY
                                let screenHeight = UIScreen.main.bounds.height
                                
                                // しきい値を設定して、画面下部の一定範囲に入ったときにロードを開始
                                if scrollPosition < screenHeight - 50 {
                                    onScrollToEnd()
                                }
                            }
                    }
                    .frame(height: 1)
                }
            }
            .animation(.default, value: isFetchingMessageThreads)
        }
    }
}
```

### 改善のポイント:
1. `scrollPosition < screenHeight - 50` というようにしきい値を設定し、スクロールが完全に最下部に到達しなくても、近づいたら次のデータを読み込むようにしています。この値は `50` ですが、調整可能です。
2. `onScrollToEnd()` は画面下部に近づくと呼び出されるため、過剰なロード呼び出しを防ぐことができます。

### 説明:
- `GeometryReader` を使用して、スクロール位置を取得し、画面の高さと比較します。スクロール位置が画面下部に達するか、しきい値内に収まったときに追加の読み込み処理を開始します。
- `.animation(.default)` を使用して、読み込み時の進行状況インジケーターがスムーズに表示されるようにしています。

このアプローチで、リストがスクロールの最後に到達したときに、新しいメッセージスレッドを読み込むことができます。

---
