# SwiftUI メールログイン

日付: 2023-06-01

---

## 👤 ユーザー
*2023/6/1 15:23:39*

SwiftUIでメールアドレスとパスワードを入力してログインするような画面を作成しようとしている。メールアドレスとパスワードを同じstructに含めて、validation を行うような処理をいれたい。

---

## 🤖 アシスタント
*2023/6/1 15:24:22*

それについてはSwiftUIとCombineを使って簡単に実装できます。以下に一例を示します。

まずは、メールアドレスとパスワードを保持するためのstructとそのバリデーションを含むViewModelを作成します：

```swift
import Combine

struct UserInput {
    var email = ""
    var password = ""
}

class LoginViewModel: ObservableObject {
    @Published var userInput = UserInput()
    @Published var isValid = false

    private var cancellables = Set<AnyCancellable>()

    init() {
        isFormValidPublisher
            .receive(on: RunLoop.main)
            .assign(to: \.isValid, on: self)
            .store(in: &cancellables)
    }

    private var isFormValidPublisher: AnyPublisher<Bool, Never> {
        Publishers.CombineLatest($userInput.email, $userInput.password)
            .map { email, password in
                self.isValidEmail(email) && self.isValidPassword(password)
            }
            .eraseToAnyPublisher()
    }

    private func isValidEmail(_ email: String) -> Bool {
        // Add your own email validation logic here
        return email.count > 5
    }

    private func isValidPassword(_ password: String) -> Bool {
        // Add your own password validation logic here
        return password.count > 5
    }
}
```

次に、このViewModelを使ってログイン画面を作ります：

```swift
import SwiftUI

struct LoginView: View {
    @StateObject private var viewModel = LoginViewModel()

    var body: some View {
        VStack {
            TextField("Email", text: $viewModel.userInput.email)
                .autocapitalization(.none)
                .keyboardType(.emailAddress)

            SecureField("Password", text: $viewModel.userInput.password)

            Button(action: {
                // Handle login action here
            }) {
                Text("Log In")
            }
            .disabled(!viewModel.isValid)
        }
        .padding()
    }
}
```

この例では、`TextField`と`SecureField`を使ってユーザーからの入力を受け付け、その値をViewModelにbindしています。ViewModelの中にはバリデーションロジックが含まれており、フォームが有効な場合にのみ"Log In"ボタンが有効になります。

メールアドレスとパスワードのバリデーションロジックは適宜調整してください。

---

## 👤 ユーザー
*2023/6/1 15:25:51*

email と password をただのStringにするのではなくて、Email 型と Password 型にして、そこにisValid を生やすのはどうなの？

---

## 🤖 アシスタント
*2023/6/1 15:26:28*

それは非常に良いアイデアです。型安全にすることで、コードの間違いを早期に防ぎ、明確な意図を表現することができます。以下に`Email`と`Password`型を導入し、それぞれに`isValid`プロパティを含めた例を示します。

```swift
import Combine

struct Email {
    var value: String = ""
    
    var isValid: Bool {
        // Add your own email validation logic here
        return value.count > 5
    }
}

struct Password {
    var value: String = ""
    
    var isValid: Bool {
        // Add your own password validation logic here
        return value.count > 5
    }
}

struct UserInput {
    var email = Email()
    var password = Password()
}

class LoginViewModel: ObservableObject {
    @Published var userInput = UserInput()
    
    var isValid: Bool {
        userInput.email.isValid && userInput.password.isValid
    }
}
```

そして、UI側を以下のように更新します：

```swift
import SwiftUI

struct LoginView: View {
    @StateObject private var viewModel = LoginViewModel()

    var body: some View {
        VStack {
            TextField("Email", text: $viewModel.userInput.email.value)
                .autocapitalization(.none)
                .keyboardType(.emailAddress)

            SecureField("Password", text: $viewModel.userInput.password.value)

            Button(action: {
                // Handle login action here
            }) {
                Text("Log In")
            }
            .disabled(!viewModel.isValid)
        }
        .padding()
    }
}
```

ここで、`Email`と`Password`型が自身のバリデーションを管理するようになり、それぞれのバリデーションロジックが明確に分離されました。これはコードの読みやすさとメンテナンス性を向上させます。

ただし、`Email`と`Password`型が自己バリデーションを含むという事実は、それらの型がUIとビジネスロジックの両方に関与することを意味します。これが許容できるかどうかはプロジェクトのアーキテクチャと設計目標によります。

---

## 👤 ユーザー
*2023/6/1 15:27:25*

UserInput ではなくて、ログインフォームに命名を変えて欲しい

---

## 🤖 アシスタント
*2023/6/1 15:27:53*

了解しました。それに応じて`UserInput`を`LoginForm`に変更し、それぞれのコードを次のように修正します：

```swift
import Combine

struct Email {
    var value: String = ""
    
    var isValid: Bool {
        // Add your own email validation logic here
        return value.count > 5
    }
}

struct Password {
    var value: String = ""
    
    var isValid: Bool {
        // Add your own password validation logic here
        return value.count > 5
    }
}

struct LoginForm {
    var email = Email()
    var password = Password()
}

class LoginViewModel: ObservableObject {
    @Published var loginForm = LoginForm()
    
    var isValid: Bool {
        loginForm.email.isValid && loginForm.password.isValid
    }
}
```

そして、UI側は以下のように更新します：

```swift
import SwiftUI

struct LoginView: View {
    @StateObject private var viewModel = LoginViewModel()

    var body: some View {
        VStack {
            TextField("Email", text: $viewModel.loginForm.email.value)
                .autocapitalization(.none)
                .keyboardType(.emailAddress)

            SecureField("Password", text: $viewModel.loginForm.password.value)

            Button(action: {
                // Handle login action here
            }) {
                Text("Log In")
            }
            .disabled(!viewModel.isValid)
        }
        .padding()
    }
}
```

この変更により、`LoginForm`という名前はより明確にこの構造体がログインフォームのデータを管理する役割を担っていることを示しています。

---
