# 型安全なエラーハンドリング

日付: 2025-06-04

---

## 👤 ユーザー
*2025/06/04 22:30:08*

TypeScriptでは関数でエラーを返却するときはどう表現して、それを呼ぶ側はどうハンドリングするのがよいのか？
なるべく型安全な実装で行いたい。たとえばAPIの呼び出し時にどうするかを考えたい。成功は画面に表示して、失敗はapiのエラーレスポンスコードによってハンドリングして場合分けの処理をしたいとする。

---

## 🤖 アシスタント
*2025/06/04 22:30:09*

以下では **「例外を投げる」** と **「値として返す」** の 2 通りを比較したうえで、画面側で *HTTP ステータスごとに場合分け* しやすく、しかも **型安全** を維持できる実装パターンを例示します。結論だけ先に言うと――

&gt; **アプリ境界（API ラッパ）では “結果オブジェクト” を返し、UI 層では discriminated union で exhaustiveness-check する**  

が最も安全で保守しやすいです。  

---

## 1. ふたつの戦略と型安全性

| 戦略 | 使い方 | メリット | デメリット |
| --- | --- | --- | --- |
| 例外 `throw` | `try { await api() } catch(e) { … }` | *早期脱出* が楽／深い階層でも一括ハンドリング可 | **型情報が流れない**（`catch` は基本 `unknown`）&lt;br&gt;ハンドリング漏れを TS が検知できない |
| 結果オブジェクトを返す | `const res = await api(); if (res.ok) …` | **戻り値に型を付けられる**&lt;br&gt;switch 文で **exhaustive** にチェック可 | 呼び出し側で if/switch が必須（ただし UI 層では分岐したいので欠点になりにくい） |

&gt; **「必ず状況を分けたい UI」＋「HTTP ステータスごとに処理が変わる」** という要件では 2 番目が圧倒的に扱いやすいです。

---

## 2. 型定義 ―― Result と Error を discriminated union で表現

```ts
// ---- 汎用 Result 型 ----
export type Result<T, E> =
  | { ok: true;  data: T }
  | { ok: false; error: E };

// ---- API 固有のエラー型 (ステータスで弁別) ----
export type ApiError =
  | { status: 400; type: "BadRequest";    message: string }
  | { status: 401; type: "Unauthorized";  message: string }
  | { status: 404; type: "NotFound";      message: string }
  | { status: 500; type: "ServerError";   message: string }
  | { status: -1;  type: "NetworkError";  reason: string }; // fetch が投げた場合など
```

*`status` が discriminant になっているので `switch(error.status)` だけで絞り込み可能。  
新ケースを追加したら **コンパイルエラー** で教えてくれます。*

---

## 3. API ラッパ関数

```ts
export async function fetchUser(id: string): Promise<Result<User, ApiError>> {
  try {
    const resp = await fetch(`/api/users/${id}`);

    if (resp.ok) {
      // 200 系 → Zod などでパースすると安心
      const json = await resp.json();
      return { ok: true, data: userSchema.parse(json) };
    }

    // 4xx / 5xx → ステータスごとに変換
    const message = await resp.text();
    switch (resp.status) {
      case 400:
        return { ok: false, error: { status: 400, type: "BadRequest",   message } };
      case 401:
        return { ok: false, error: { status: 401, type: "Unauthorized", message } };
      case 404:
        return { ok: false, error: { status: 404, type: "NotFound",     message } };
      default:
        return { ok: false, error: { status: 500, type: "ServerError",  message } };
    }
  } catch (err) {
    // ネットワーク層の例外を握りつぶして型付きで返す
    return {
      ok: false,
      error: { status: -1, type: "NetworkError", reason: (err as Error).message },
    };
  }
}
```

ポイント 🔑  

1. **API から “例外を漏らさない”**：どんな障害でも Result に畳み込む  
2. **成功レスポンスはランタイム検証**（Zod 等）で “安全な data” に  
3. **エラーステータスは switch で網羅**（default で 500 系に寄せると拡張しやすい）

---

## 4. 呼び出し側（React の例）

```tsx
const handleLoad = async () => {
  const res = await fetchUser(userId);

  if (res.ok) {
    setUser(res.data);
    toast.success("ユーザーを読み込みました");
    return;
  }

  // エラーごとに UI を分岐
  switch (res.error.status) {
    case 400:
      toast.error("入力が不正です");
      break;
    case 401:
      toast.warning("再ログインしてください");
      navigate("/login");
      break;
    case 404:
      navigate("/404");
      break;
    case -1:
      toast.error("ネットワークに接続できません");
      break;
    default:          // 500 系
      toast.error("サーバーで問題が発生しました");
  }
};
```

*`switch(res.error.status)` は **exhaustive** なので、新しいステータスを追加すると **“最後の default に never が来てエラー”** でハンドリング漏れに気付けます。*

---

## 5. ボイラープレートを減らす方法

| アプローチ | 概要 |
| --- | --- |
| **neverthrow** | `Result<T, E>` & 補助メソッド (`map/andThen`) 付き。自前で定義するより API が豊富。 |
| **fp-ts / Effect** | `Either`, `TaskEither`, `Effect` など関数型スタイル。大規模で一貫したエラーハンドリングが必要なときに。 |
| **openapi-zod-client** | OpenAPI 上の `responses` をコード生成し **成功/失敗が型に反映** される。ランタイム検証も自動。今回の手巻き Result と思想は同じ。 |

&gt; *生成系を使うなら「`200` 以外は全て `ApiError`」のような schema を書くと、上記と同じハンドリング方法がそのまま得られます。*

---

## 6. まとめ & ガイドライン

1. **ライブラリ境界で “例外 → Result” に変換**  
   UI まで throw を透過させない。
2. **`status` か `type` を discriminant にして union を作る**  
   → `switch` で **網羅** をコンパイル時に保証。
3. **成功レスポンスは Zod などで parse**  
   → *ランタイム* の安全性も担保。
4. **ボイラープレートが気になるなら neverthrow などを採用**  
   → `map`, `mapErr`, `asyncResult` で compose が楽。

これで「成功は画面表示、失敗はエラーコードで場合分け」という UI 要件を **100 % 型安全** に満たせます。

---

## 👤 ユーザー
*2025/06/04 22:32:47*

ifハンドリングが一般的なのか？ try-catchはあまりしないのか？

---

## 🤖 アシスタント
*2025/06/04 22:32:48*

### 「if/switch で分岐」か「try … catch」で捕まえるかは “粒度” と “責務” で決める

| 層 | 目的 | 典型的なスタイル |
| --- | --- | --- |
| **ライブラリ内・フレームワーク内部** | 予期しないプログラミングエラーを即座に伝搬したい | `throw new Error()` → 呼び出し側が `try … catch` |
| **API ラッパ（I/O 境界）** | **I/O 失敗をドメインエラーに正規化**したい | `try … catch` でネットワーク例外を捕捉し、&lt;br&gt;成功/失敗の **Result 型** を返す |
| **ドメイン／アプリケーション層** | ビジネスロジックの分岐を **型安全に強制**したい | `if (result.ok)` / `switch (result.error.kind)` で&lt;br&gt;**exhaustive-check** |
| **UI 層（React など）** | 画面遷移・トースト表示などユーザ通知 | `switch / if` でステータス別に処理 or&lt;br&gt;エラー境界でまとめてレンダリング |

&gt; - **プログラミングエラー（バグや null 参照）**: _throw_ → `try … catch`  
&gt; - **ユースケース想定済みの失敗（404, Validation Error …）**: _戻り値 Result_ → `if` / `switch`

### なぜ「try … catch だと型安全が落ちる」のか？

```ts
try {
  await fetchUser(id);
} catch (e) {
  // e の型は基本 unknown
  // instanceOf やカスタムガードで絞れば可読性・網羅性が下がる
}
```

*コンパイラは「捕まえたあとにハンドリング漏れがあるか」までは検知できません*。  
一方 **discriminated union** を返す設計なら――

```ts
const res = await fetchUser(id);
if (!res.ok) {
  // res.error は { status: 400 | 401 | 404 | 500 | -1, … }
  switch (res.error.status) {
    case 400: …   // 👍 ここを書かないと TS がエラー
    // …
  }
}
```

「書き忘れるとビルドが落ちる」ので **網羅性がコンパイルで保証** されます。

### 現場ではどちらが “一般的” か？

| 項目 | 実態 |
| --- | --- |
| OSS/SDK | ほぼ **例外を投げる**（Axios, Prisma, AWS SDK…） |
| **Web / モバイルアプリ**のフロント | **API ラッパを自前で巻いて Result 型** に変換するチーム増加&lt;br&gt;（neverthrow / zod-client / TanStack Query の `throwOnError:false` など） |
| 関数型指向プロジェクト | `fp-ts`, `Effect` の `TaskEither` を多用（完全値返却型） |
| 小規模スクリプト | `try … catch` が手軽なのでそのまま |

つまり **「try … catch＝悪」ではなく、階層ごとに役割が違う** という整理が主流です。

### ハイブリッド実装例（Axios + neverthrow）

```ts
import axios from "axios";
import { err, ok, Result } from "neverthrow";

export async function fetchUser(id: string): ResultAsync<User, ApiError> {
  return ResultAsync.fromPromise(
    axios.get<User>(`/api/users/${id}`),
    // Axios が投げるエラーを型付きに
    (e) => toApiError(e),
  ).map((res) => res.data); // 成功時だけ map
}
```

*UI は `const res = await fetchUser(id); if (res.isOk()) …` と書けて、  
`switch(res.error.status)` で exhaustiveness が働きます。*

### まとめルール

1. **ライブラリ境界** … _throw_ して呼び出し側に委ねる。  
2. **アプリ境界（I/O → ドメイン）** … _Result 型へ変換_ して “想定内の失敗” を列挙する。  
3. **UI/ドメイン** … `if` / `switch` で **分岐を強制**、新ケース追加時にビルドエラーで気付く。  
4. **プログラミングエラー** は例外のままにしておき、Error Boundary や最上位で握りつぶす。

この住み分けを徹底すれば「型安全」と「記述量」のバランスを崩さず、  
**try … catch も if/switch も “然るべき場所” で活かす** ことができます。

---

## 👤 ユーザー
*2025/06/04 22:34:22*

openapi-zod-client を使うとどんな実装になるのか？

---

## 🤖 アシスタント
*2025/06/04 22:35:10*

### ざっくり流れ ─ “OpenAPI → 型付き Zod + Zodios クライアント” を丸ごと自動生成

| 手順 | コマンド／ファイル | 補足 |
| --- | --- | --- |
| ① **依存追加** | `pnpm add @zodios/core`&lt;br&gt;`pnpm add -D openapi-zod-client` | Zod は @zodios/core に同梱 |
| ② **OpenAPI 定義を書く** | `openapi.yaml` | 200／4xx／5xx など **レスポンスを網羅**しておく |
| ③ **スクリプト追加** | ```jsonc
"scripts": {
  "codegen:api":
    "openapi-zod-client ./openapi.yaml \
     -o src/api.gen.ts \
     --base-url /api   \
     -a               /* axios を同梱 */
}
``` | `-a` フラグで axios 依存込みの Zodios クライアントが生成される citeturn1search0 |
| ④ **生成** | `pnpm run codegen:api` | 1 ファイルに **Zod スキーマ + Endpoints + Client factory** が出力される citeturn1search1 |

---

### 生成物（抜粋）

```ts
// src/api.gen.ts   ※自動生成
import { z } from "zod";
import { makeApi, Zodios, type ZodiosOptions } from "@zodios/core";

// --- schemas -------------------------------------------------
const User = z.object({
  id: z.string(),
  name: z.string(),
});
const Error404 = z.object({
  status: z.literal(404),
  message: z.string(),
});

// --- endpoints ----------------------------------------------
const endpoints = makeApi([
  {
    method: "get",
    path: "/users/:id",
    alias: "getUser",
    parameters: [{ name: "id", type: "Path", schema: z.string() }],
    response: User,               // 200
    errors: [{ status: 404, schema: Error404 }], // ← 4xx も型に載る
  },
]);

// --- client factory -----------------------------------------
export function createApiClient(
  baseUrl = "/api",
  opts?: ZodiosOptions,
) {
  return new Zodios(baseUrl, endpoints, opts);
}
```

ポイント 📝  

* **成功レスポンスも失敗レスポンスも Zod スキーマで生成**  
  → 実行時は `axios → Zod` でパースされるので *不正 JSON が来ても throw*  
* `alias` がそのままメソッド名になるので **IDE 補完が効く**。

---

### 呼び出し側の実装パターン

#### 1️⃣ そのまま `try‒catch`（最短）

```ts
import { createApiClient } from "@/api.gen";
import { ZodiosError } from "@zodios/core";

const api = createApiClient();

try {
  const user = await api.getUser({ params: { id: "123" } }); // ← User 型
  toast.success(`${user.name} を取得しました`);
} catch (e) {
  if (e instanceof ZodiosError) {
    switch (e.response?.status) {
      case 404:
        toast.error("ユーザーが存在しません");
        break;
      default:
        toast.error("サーバーエラーが発生しました");
    }
  }
}
```

*`ZodiosError` には `response?.status` と **Zod でパース済みの `e.response?.data`** が入るので、  
JSON→TS 型変換を自分で書く必要がありません。*

---

#### 2️⃣ “Result 型” ラッパーで UI 層を if/switch に統一

```ts
import { Result } from "@/shared/result";
import { createApiClient } from "@/api.gen";
import { ZodiosError } from "@zodios/core";

const api = createApiClient();

export async function fetchUser(
  id: string,
): Promise<Result<User, Error404>> {
  try {
    const data = await api.getUser({ params: { id } });
    return { ok: true, data };
  } catch (e) {
    if (
      e instanceof ZodiosError &&
      e.response?.status === 404
    ) {
      return { ok: false, error: e.response.data }; // ← Error404 型
    }
    throw e; // 想定外は従来どおり throw
  }
}
```

→ UI 側は **前回示した `if (res.ok)` / `switch (res.error.status)` パターン**で統一できる。

---

### 生成ファイルをフレームワークに組み込む

| 目的 | やり方 |
| --- | --- |
| **TanStack Query** | ```ts
const api = createApiClient();
const { data } = useQuery({
  queryKey: ["user", id],
  queryFn: () => api.getUser({ params: { id } }),
});
``` |
| **複数環境の baseURL 切替** | `createApiClient(process.env.API_BASE_URL)` |
| **共通ヘッダー / リトライ** | `api.interceptors.request.use(/* ... */)` &lt;br&gt; `api.interceptors.response.use(/* ... */)` （axios API と同じ） |

---

### openapi-zod-client で得られるもの

* **OpenAPI ➜ 型 ➜ 実行時検証 ➜ クライアントまで一本化**  
  → 定義と実装のズレがゼロ。  
* **非 2xx レスポンスも型付きで捕捉**  
  → 「404 ならこの UI」という分岐を *コンパイル時に強制*。  
* **出力はただの `.ts`**  
  → PR diff が読みやすく、カスタムテンプレートで軽量化も可能 citeturn1search2  

&gt; まとめると、*「OpenAPI を真の単一情報源にしつつ Zod の実行時安全も享受」*  
&gt; そんな実装になるのが **openapi-zod-client** です。

---

## 👤 ユーザー
*2025/06/04 22:39:22*

@hey-api/client-fetch を使った場合と openapi-zod-client を使った場合の違いを教えて欲しい

import { createClient, createConfig } from "@hey-api/client-fetch";

export const api = createClient(
  createConfig({
    baseUrl: "http://localhost:3000",
    throwOnError: true,         // ここを false にすれば Result 型へ
  }),
);

---

## 🤖 アシスタント
*2025/06/04 22:40:35*

### TL;DR  
| 項目 | **@hey-api/client-fetch** | **openapi-zod-client** |
| --- | --- | --- |
| 生成ツール | `openapi-ts`（Hey API公式） | 単体 CLI |
| 生成物 | **Fetch** ラッパ + 型／SDK 一式 | **Axios＋Zodios** ラッパ 1 ファイル |
| ランタイム検証 | ✅ *任意*（`sdk.validator: "zod" | "ajv"` で生成） citeturn9search4 | ✅ *常時*（Zod で request / response を `parse`） citeturn6search0 |
| エラーハンドリング | `throwOnError` フラグで **throw** か **Result 型** を選択 citeturn9search1 | 失敗時は `ZodiosError`（Axios error）を **throw** |
| HTTP 実装 | ネイティブ Fetch（polyfill 不要） | Axios（Edge/Deno で使う場合は polyfill 要） |
| カスタマイズ | プラグイン・バンドル設定が豊富（ヘッダ注入・再試行・バリデータ追加） citeturn9search2 | 生成テンプレを上書き可／出力はただの TS |
| リポジトリ規模 | Hey API 本体が活発（複数クライアントを同日リリース） citeturn9search1 | OSS 1人開発・更新は緩やか（週次 DL は数千） citeturn6search0 |
| 典型ユースケース | **BFF や Next.js/Remix** など Fetch 文化のプロジェクト | **型安全 + 実行時安全を最優先** する SPA / Node バッチ |

---

## 1. 生成ステップのイメージ

```bash
# hey-api 版
npx @hey-api/openapi-ts -i openapi.yaml -o src/api -c @hey-api/client-fetch

# zod 版
pnpx openapi-zod-client openapi.yaml -o src/api.gen.ts
```

*hey-api* は複数フォルダ（schemas, operations, client など）が生成され、  
*zod-client* は 1 ファイルに **Zod schema + Endpoints + Client factory** がまとまります。

---

## 2. 呼び出しコード比較

### @hey-api/client-fetch

```ts
import { createClient, createConfig } from "@hey-api/client-fetch";
import type { paths } from "./api"; // openapi-ts が吐く型

const api = createClient(
  createConfig({ baseUrl: "/api", throwOnError: false })  // false ⟹ Result 型
);

// Result パターン
const res = await api["/users/{id}"].get({ params: { path: { id } } });

if (res.ok) {
  console.log(res.data.name);        // 型安全
} else {
  switch (res.error.status) {        // 4xx/5xx も列挙されている
    case 404:
      /* ... */
  }
}
```

* `throwOnError: true` にすると `FetchError` を **throw**。  
* `sdk.validator: "zod"` を付けてビルドすると **Zod で response を検証**（失敗時は throw）。 citeturn9search4  

---

### openapi-zod-client（Zodios）

```ts
import { createApiClient } from "./api.gen";       // 1 ファイル
import { ZodiosError } from "@zodios/core";

const api = createApiClient("/api");

try {
  const user = await api.getUser({ params: { id } });  // User 型
  console.log(user.name);
} catch (e) {
  if (e instanceof ZodiosError) {
    switch (e.response?.status) {          // ここも型推論が効く
      case 404:
        /* ... */
    }
  }
}
```

* **リクエストもレスポンスも Zod で `parse`** されるため、  
  サーバーが仕様とズレた JSON を返すと実行時に即 catch。 citeturn6search0  

---

## 3. どちらを選ぶ？判断ポイント

| 判断軸 | こんな場合は **@hey-api/client-fetch** | こんな場合は **openapi-zod-client** |
| --- | --- | --- |
| **実行環境** | Deno / Cloudflare Workers / Edge runtime で Axios を避けたい | Node / Browser で Axios OK、または interceptors が欲しい |
| **型だけで十分？** | 「リクエストもレスポンスもバックエンドと同リポジトリだから **型ズレは稀**」 | 「別チーム API なので **ランタイム検証必須**」 |
| **生成の粒度** | フォルダ分割して **ツリ―シェイク** ＆パス単位 import したい | 1 ファイル完結で依存が少ない方が嬉しい |
| **メンテナンス体制** | プラグインや多言語 SDK を含めて **公式サポート重視** | OSS でシンプルに完結したワークフローを好む |
| **エラー API** | Result パターン or throw を**フラグ一発で切替**したい | Zodios のデフォルト throw で十分／自前 Result ラッパを被せたい |

---

## 4. 併用もできる

大規模モノレポで **社内 API** は “hey-api + Fetch”、  
**外部サービス** は “zod-client + Axios” と分ける例もあります。

```text
packages/
├─ api-internal/   # openapi-ts + client-fetch
└─ api-stripe/     # openapi-zod-client  (runtime validation重視)
```

---

### まとめ

* **Fetch 派 & コード生成を細かく制御したい → Hey API（client-fetch）**  
* **Zod でガッチリ実行時保証を取りたい → openapi-zod-client**  

どちらも **Result 型 or 例外** の二択でハンドリングできるため、  
プロジェクトの *運用方針（Fetch vs Axios / 型だけ vs ランタイム検証）* に合わせて選ぶのがベストです。

---

## 👤 ユーザー
*2025/06/04 22:45:00*

@hey-api/client-fetchで、throw式にした実装例は？

---

## 🤖 アシスタント
*2025/06/04 22:46:40*

## `@hey-api/client-fetch` を **“throw 式”** で使う最小構成

&gt; ポイントは **① `throwOnError: true` を渡す (ランタイム)** と  
&gt; **② メソッドの 1st ジェネリックを `true` にする (コンパイル)** です。  

```ts
// apiClient.ts ------------------------------------------------------------
import { createClient, createConfig, type FetchError } from "@hey-api/client-fetch";
import type { paths } from "./openapi.gen";   // openapi-ts が吐いた型

export const api = createClient(
  createConfig({
    baseUrl: "http://localhost:3000",
    throwOnError: true,              // ← ① ここで “失敗なら throw” を有効化
    headers: { "X-Requested-With": "frontend" },
  }),
);
```

*`createConfig().throwOnError` が **ランタイムの挙動** を決める。  
0.11 系以降は **型側** でも “投げる” ことを明示するために、  
各メソッドの **1 番目のジェネリック** が `ThrowOnError extends boolean` になりました* citeturn7search3

---

### 呼び出し例 : `GET /users/{id}`

```ts
import { api } from "@/apiClient";
import type { components } from "./openapi.gen";

// --- 成功時 200 の型（openapi.yaml → TS 型） -----------------------------
type User = components["schemas"]["User"];

// --- 失敗時 404 の型 ------------------------------------------------------
type NotFound = components["schemas"]["Error404"];

// ---------- UI / React Hook 側 --------------------------------------------
export async function loadUser(id: string) {
  try {
    //           ▼ ThrowOnError を true に
    const user = await api["/users/{id}"].get<true, User, NotFound>({
      params: { path: { id } },
    });

    return user;                // user は User 型
  } catch (e) {
    // e は FetchError<NotFound> 型（ジェネリックで推論が効く）
    const err = e as FetchError<NotFound>;

    switch (err.status) {       // 404, 400, 500 … が列挙型で補完
      case 404:
        console.info("ユーザーが見つかりません", err.data);
        break;
      default:
        console.error("想定外のエラー", err);
    }
    throw err;                  // さらに上位で ErrorBoundary に流すなど
  }
}
```

* `FetchError<D>` には  
  * **`status`** ― HTTP ステータス  
  * **`data`** ― OpenAPI で宣言したエラーボディ型  
  が入る。  
* catch の網羅性はコンパイラが保証（`switch(err.status)` に exhaustive-check が効く）。  

---

## よくある FAQ

| 疑問 | 回答 |
| --- | --- |
| **「ジェネリックを省略すると？」** | `ThrowOnError` の既定は `false`。&lt;br&gt;コンパイルは通りますが、失敗時は `Promise<{ error: … }>` **返却式** になり throw しません。 |
| **Result 型に戻せる？** | `throwOnError: false` にして `const res = await …` で取る。&lt;br&gt;必要なら `api["/users/{id}"].get<false, User, NotFound>()` と `false` を入れても OK。 |
| **TanStack Query で使う** | `queryFn: () => api["/users/{id}"].get<true, User, NotFound>({ … })`&lt;br&gt;→ 失敗は onError に `FetchError` が飛びます。 |
| **Axios で書きたい** | Hey API 公式の `@hey-api/client-axios` も同じパターンで `throwOnError` 対応しています。 |

---

## まとめ

1. **`createConfig({ throwOnError: true })`** で “ランタイム: throw” を有効化。  
2. **メソッド呼び出しを `<true, Success, Error>`** で型付けすれば  
   * 成功時は **純粋なデータ型**  
   * 失敗時は **`FetchError<ErrorBody>`** が `catch` に来る。  
3. `switch(err.status)` で **HTTP ステータスごとに型安全に分岐**。  

以上で *@hey-api/client-fetch* でも **例外スタイル** のハンドリングが  
簡潔＆型安全に実装できます。

---

## 👤 ユーザー
*2025/06/04 22:47:51*

さらに Zod を適応させた場合は？

https://heyapi.dev/openapi-ts/plugins/zod

---

## 🤖 アシスタント
*2025/06/04 22:49:18*

以下は **「@hey-api/client-fetch × throwOnError:true ＋ Zod プラグイン（sdk.validator:true）」** を組み合わせたときの、コード生成〜ハンドリング例までを一気通貫で示したものです。  

---

## 1. openapi-ts 設定ファイル

```ts
// openapi-ts.config.ts  (プロジェクト直下)
import { defaultPlugins } from "@hey-api/openapi-ts";

export default {
  input : "./openapi.yaml",      // <- あなたの OpenAPI
  output: "./src/__generated__", // 生成物の置き場
  plugins: [
    ...defaultPlugins,           // 型定義など既定プラグイン
    "@hey-api/client-fetch",     // Fetch ベースの SDK
    "zod",                       // ★ Zod スキーマを生成
    {
      /* SDK へ Zod バリデータを注入 */
      name: "@hey-api/sdk",
      validator: true,           // ★ レスポンスを z.parse で検証
    },
  ],
} as const;
```

*`validator:true` を付けるだけで、生成 SDK が **自動で request / response を Zod で検証** してくれるようになります citeturn4search0。*

---

## 2. コード生成

```bash
pnpm dlx @hey-api/openapi-ts            # 1回目は npx でも OK
```

生成ディレクトリには主に 3 つのアーティファクトが入ります：

| ファイル | 主な役割 |
| --- | --- |
| **schemas/*.ts** | OpenAPI の各 `schema` → `z.object()` / `z.union()` など |
| **sdk/client-fetch.ts** | `createClient()` を輸出する Fetch SDK |
| **types.ts** | OpenAPI → 型定義 (`components["schemas"]["User"]` など) |

---

## 3. クライアントの初期化（throw 式）

```ts
// api.ts
import { createClient, FetchError } from "@/__generated__/sdk/client-fetch";

export const api = createClient({
  baseUrl: "/api",
  throwOnError: true,     // ★ HTTP 4xx/5xx は FetchError として throw
});
```

---

## 4. 呼び出し例とハンドリング

```ts
import { api } from "@/api";
import { ZodError } from "zod";

/** User スキーマの型をそのまま再利用 */
import { zUser } from "@/__generated__/schemas";
type User = typeof zUser._type;  // = z.infer<typeof zUser>

export async function loadUser(id: string) {
  try {
    // ThrowOnError=true → 戻り値は「成功時 200 のみ」
    const user = await api["/users/{id}"].get<true, 200>({   // ①
      params: { path: { id } },
    });
    console.log("取得成功", user);      // user は完全に Zod 検証済みの User 型

  } catch (e) {
    /* ----------- ② Zod 検証エラー ----------- */
    if (e instanceof ZodError) {
      // サーバーのレスポンスが仕様と食い違っていた
      console.error("スキーマ不整合", e.issues);
      return;
    }

    /* ----------- ③ HTTP エラー (FetchError) ----------- */
    if (e instanceof FetchError) {
      switch (e.status) {                // 400/401/404/500... が補完される
        case 404:
          console.warn("ユーザーは存在しません");
          return;
        case 401:
          console.warn("再ログインしてください");
          return;
        default:
          console.error("想定外の HTTP エラー", e);
      }
    }

    /* ----------- ④ 予期しない例外 ----------- */
    throw e;   // ErrorBoundary などへ
  }
}
```

### 流れを整理

1. **①** 呼び出し時に **パラメータ** が Zod で `parse` される  
   → 不正な `id` を渡すと *リクエスト前* に `ZodError`.
2. **②** レスポンス JSON がスキーマに合わなければ `ZodError` が throw。  
   → バックエンドのバグを即座に検知。
3. **③** HTTP ステータスが 4xx/5xx なら `FetchError` が throw。  
   → `e.status` と **OpenAPI で宣言したエラースキーマ** (`e.data`) が型付き。  
4. **④** それ以外はプログラミングエラーとして上位へ伝搬。

---

## 5. 他ライブラリとの統合例（TanStack Query）

```ts
import { useQuery } from "@tanstack/react-query";
import { api } from "@/api";

export const useUser = (id: string) =>
  useQuery({
    queryKey: ["user", id],
    queryFn : () => api["/users/{id}"].get<true, 200>({ params: { path: { id } } }),
    retry   : false,                         // ZodError も catch されて onError へ
  });
```

onError では `error instanceof ZodError` / `FetchError` で分岐できます。

---

## 6. openapi-zod-client との違い（おさらい）

| 軸 | **@hey-api/client-fetch＋Zod** | **openapi-zod-client** |
| --- | --- | --- |
| HTTP 実装 | **Fetch** (ポリフィル無し) | Axios＋Zodios |
| 生成物 | *フォルダ分割*（types / schemas / sdk） | ほぼ 1 ファイル |
| バリデーション | `sdk.validator:true` で自動 (`ZodError` を throw) | 常時 z.parse |
| エラー型 | `FetchError` (HTTP) / `ZodError` (検証) | `ZodiosError` |
| Edge/Deno 互換 | ◎（Fetch） | △（Axios ポリフィル要） |

---

### まとめ

* **設定は `plugins: ['zod']` ＋ `sdk.validator:true` だけ**。  
* 生成 SDK が *リクエスト前後で Zod 検証* を自動実行。  
* UI では **`ZodError` と `FetchError` を型安全にハンドリング**。  
* Axios が不要で Edge Runtime でも動かしたい場合に特に有効です。

---

## 👤 ユーザー
*2025/06/04 22:51:13*

@hey-api/client-fetch＋Zod のほうが openapi-zod-client よりもよくないか？

---

## 🤖 アシスタント
*2025/06/04 22:51:57*

### “どちらが **良い** か？”はユースケース次第  
両者とも **OpenAPI → 型 → Zod 実行時検証 → SDK** を自動生成できますが、  
設計哲学も生成物の形も異なります。優先したい軸をはっきり決めると答えが出ます。

| 判断軸 | **@hey-api/client-fetch ＋ Zod**&lt;br&gt;(*openapi-ts + client-fetch plugin + `validator:true`*) | **openapi-zod-client** |
|---|---|---|
| **HTTP 実装** | ネイティブ `fetch` （ポリフィル不要） | Axios ＋ Zodios |
| **生成物の構造** | `types/`, `schemas/`, `sdk/` の **3 階層**&lt;br&gt;ファイル分割＝**ツリーシェイクしやすい** | **1 ファイル完結**（スキーマ＋クライアント） |
| **ランタイム検証** | `validator:true` を付けたときだけ&lt;br&gt;→ `ZodError` or `FetchError` が **throw** citeturn0search5 | 常時 `z.parse` 実行。失敗時は `ZodiosError` を **throw** citeturn0search0 |
| **エラー API** | `throwOnError` フラグで&lt;br&gt;  ☑︎ **throw 式**&lt;br&gt;  ☐ Result 型（`{ ok, data | error }`）を選択可 | 常に throw。Result に変えたい場合は自前ラッパ |
| **Edge / Deno 互換** | ◎（Fetch なのでそのまま動く） | △（Axios を polyfill するか別 fetcher を実装） |
| **ビルド & 補完速度** | 分割構造のおかげで **速い**（tsc 4 秒程度の事例） citeturn2search0 | 大規模 spec では 1 ファイルが肥大 → 補完遅延・tsc 15 秒超の報告あり citeturn2search0 |
| **メンテ体制** | ◎ Hey API 社の本体リポジトリで**複数メンテナ**。Zod plugin は**β**表記だが毎月コミットあり citeturn1search1turn0search5 | ○ 個人メンテ（@astahmer）だが **月1 リリース**ペースで継続中 citeturn0search2 |
| **npm DL (週)** | 約 19 万件 citeturn3search1 | 約 8 万件 citeturn3search0 |

---

## どちらが **向いている** シチュエーション？

### @hey-api/client-fetch ＋ Zod が優位
1. **Edge / Cloudflare Workers / Deno** など Fetch ネイティブ環境。
2. 「**リポジトリ同居**で API チーム＝フロントチーム」  
   → 型ズレは CI で検知できるので、開発中は *throw* と *Result* を切り替えたい。
3. SDK を **分割インポート**してバンドルサイズを最小化したい。
4. **CI で自動再生成 → PR diff を細かくレビュー**したい  
   （フォルダ分割のほうが差分が読みやすい）。

### openapi-zod-client が優位
1. **バックエンドが完全に別チーム／別言語**で „契約違反” が起きがち。  
   → 生成クライアントが **常時 Zod 検証**してくれる安心感を重視。
2. **設定ゼロで 1 ファイル完結**にしたいプロトタイピングや小規模 SPA。
3. Axios しか使っておらず、**インターセプタでリトライ／認証ヘッダ挿入**など  
   Axios のエコシステムを活用したい。
4. **neverthrow / fp-ts** など関数型ライブラリで Result ラッパを自前で被せる前提。

---

## 結論（実務の落とし所）

- **フルスタック or BFF 型のモノレポ**なら  
  → ***@hey-api + Zod***：分割ファイルで差分が追いやすく、Edge 環境も楽。
- **異なるリポジトリ／社外 API を叩くフロント**なら  
  → ***openapi-zod-client***：常時ランタイム検証で“API 契約ズレ”を即検知。
- **混在も可**：社内 API は Hey API、外部 Stripe などは zod-client にする例もある。

要するに  
&gt; **「Fetch vs Axios」「分割 vs 単一ファイル」「βでも活動的 vs 実績ある個人 OSS」**  
&gt; どれを重視するかでベストは変わる、というのが答えです。

---
