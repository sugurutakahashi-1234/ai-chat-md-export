# Èå≤Èü≥ÈñãÂßã„Å®ÂÅúÊ≠¢„ÅÆÈü≥

Êó•‰ªò: 2024-05-09

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/05/09 20:27:06*

Èå≤Èü≥ÈñãÂßãÊôÇ„Å®ÂÅúÊ≠¢ÊôÇ„Å´Èü≥„ÇíÈ≥¥„Çâ„Åó„Åü„ÅÑ

import SwiftUI

// MARK: - View

@MainActor
struct RecordingView: View {
    @StateObject private var presenter: RecordingPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            Section("Recording Config") {
                RecordingConfigPickerView(selection: $presenter.audioFormat)
                RecordingConfigPickerView(selection: $presenter.audioSampleRate)
                RecordingConfigPickerView(selection: $presenter.audioChannel)
                RecordingConfigPickerView(selection: $presenter.audioEncodeQuality)
            }
            .textCase(nil)
            
            Section("Session Config") {
                Toggle(isOn: $presenter.isEnabledAudioSession) {
                    Text("Audio Session")
                }
                
                Group {
                    RecordingConfigPickerView(selection: $presenter.audioSessionCategory)
                    RecordingConfigPickerView(selection: $presenter.audioSessionMode)
                }
                .disabled(!presenter.isEnabledAudioSession)
               
            }
            .textCase(nil)
            
            Section("Recording Action") {
                Button {
                    presenter.onTapStartRecording()
                } label: {
                    Text("Start Recording")
                }
                .disabled(presenter.isRecording)

                Button {
                    presenter.onTapStopRecording()
                } label: {
                    Text("Stop Recording")
                }
                .disabled(!presenter.isRecording)
                
                HStack {
                    Text("Recording Time")
                    Spacer()
                    Text(TimeInterval(presenter.recordingTime).mmss)
                }
            }
            .textCase(nil)
            
            Section("Audio List") {
                NavigationLink {
                    AudioListView()
                } label: {
                    Text("Audio List")
                }
            }
            .textCase(nil)
        }
        .navigationTitle("Recording")
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: false)
        .appErrorAlert(isPresented: $presenter.showAlert, appError: presenter.appError)
        .onAppear {
            presenter.onAppear()
        }
    }
}

// MARK: - Preview

#Preview {
    RecordingView()
        .navigationStacked()
}

import Foundation
import Combine

@MainActor
final class RecordingPresenter: ObservableObject {
    @Published var audioFormat: AudioFormat = .mpeg4aac_aac
    @Published var audioSampleRate: AudioSampleRate = .voiceLow
    @Published var audioChannel: AudioChannel = .stereo
    @Published var audioEncodeQuality: AudioEncodeQuality = .low
    
    @Published var isEnabledAudioSession: Bool = false
    @Published var audioSessionCategory: AudioSessionCategory = .record
    @Published var audioSessionMode: AudioSessionMode = .default

    @Published var isRecording: Bool = false
    @Published var recordingTime: Int = 0

    @Published var isLoading: Bool = false
    @Published var appError: AppError?
    @Published var showAlert: Bool = false

    private let deviceAccessDriver: DeviceAccessDriver = DeviceAccessDriver()
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let recordingDriver: RecordingDriver = RecordingDriver()

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        recordingDriver.isRecordingPublisher
            .assign(to: &$isRecording)
    }

    func onAppear() {
        Task {
            await deviceAccessDriver.requestRecording()
        }
    }

    func onTapStartRecording() {
        let recordingConfig = RecordingConfig(audioFormat: audioFormat, audioSampleRate: audioSampleRate, audioChannel: audioChannel, audioEncodeQuality: audioEncodeQuality, isEnabledAudioSession: isEnabledAudioSession, audioSessionCategory: audioSessionCategory, audioSessionMode: audioSessionMode)
        do {
            try recordingDriver.startRecording(recordingConfig: recordingConfig)
            startTimer()
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapStopRecording() {
        do {
            stopTimer()
            try recordingDriver.stopRecording()
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    private func startTimer() {
        recordingTime = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTime += 1
            }
            .store(in: &cancellables)
    }

    private func stopTimer() {
        cancellables.forEach { $0.cancel() }
    }
}

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/05/09 20:27:40*

To play a sound when starting and stopping recording in your SwiftUI application, you can utilize the `AVAudioPlayer` from the `AVFoundation` framework to play an audio file. Here's how you can modify your `RecordingPresenter` to include functionality for playing sounds at the start and stop of a recording session.

First, make sure to import `AVFoundation` in your Swift file:

```swift
import AVFoundation
```

Next, you'll need to add functionality to your `RecordingPresenter` to handle the audio playback. Here are the steps to follow:

1. **Add an AVAudioPlayer property** to your class to manage the audio playback.
2. **Initialize the audio player** with a sound file.
3. **Play the sound** at appropriate times (when recording starts and stops).

Here is how you could integrate this into your `RecordingPresenter`:

```swift
@MainActor
final class RecordingPresenter: ObservableObject {
    ...
    private var audioPlayer: AVAudioPlayer?

    init() {
        recordingDriver.isRecordingPublisher
            .assign(to: &$isRecording)
        setupAudioPlayer()
    }

    private func setupAudioPlayer() {
        guard let soundURL = Bundle.main.url(forResource: "startStopSound", withExtension: "mp3") else {
            OSLogger.errorLog("Failed to load the sound file.")
            return
        }
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: soundURL)
            audioPlayer?.prepareToPlay()
        } catch {
            OSLogger.errorLog("Could not create audio player: \(error)")
        }
    }

    func onTapStartRecording() {
        audioPlayer?.play()  // Play sound on start
        let recordingConfig = RecordingConfig(audioFormat: audioFormat, audioSampleRate: audioSampleRate, audioChannel: audioChannel, audioEncodeQuality: audioEncodeQuality, isEnabledAudioSession: isEnabledAudioSession, audioSessionCategory: audioSessionCategory, audioSessionMode: audioSessionMode)
        do {
            try recordingDriver.startRecording(recordingConfig: recordingConfig)
            startTimer()
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapStopRecording() {
        audioPlayer?.play()  // Play sound on stop
        do {
            stopTimer()
            try recordingDriver.stopRecording()
        } catch {
            OSLogger.errorLog("Could not stop recording: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    ...
}
```

**Note:** Make sure to add your sound file (in this case, `"startStopSound.mp3"`) to your Xcode project's resources, so it can be loaded by `Bundle.main.url`. Adjust the sound file name and extension according to your actual file.

This modification plays a sound whenever you start or stop recording, providing a clear auditory signal to the user.

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/05/09 20:27:54*

Apple Ê®ôÊ∫ñ„ÅÆ„ÇÑ„Å§„ÅÆÈü≥„Å™„Çì„Å†„ÄÇ

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/05/09 20:28:25*

If you're looking to use Apple's standard system sounds for starting and stopping a recording in your app, you can utilize the `AudioToolbox` framework to play predefined system sounds. Here‚Äôs how you can integrate this into your `RecordingPresenter`.

First, import the `AudioToolbox` framework in your Swift file:

```swift
import AudioToolbox
```

Then, you can modify your `RecordingPresenter` class to play a system sound at the start and stop of recording. Apple provides various system sound IDs that you can use. For example, you might use the sound ID for a typical "Tock" sound, which is commonly used in iOS for keyboard clicks and other UI feedback.

Here's how you could modify your class:

```swift
@MainActor
final class RecordingPresenter: ObservableObject {
    ...
    private let startSoundID: SystemSoundID = 1104  // Example sound ID for "Tock"
    private let stopSoundID: SystemSoundID = 1104   // Same sound ID for simplicity, you can choose another

    init() {
        recordingDriver.isRecordingPublisher
            .assign(to: &$isRecording)
    }

    func onTapStartRecording() {
        AudioServicesPlaySystemSound(startSoundID)  // Play system sound on start
        let recordingConfig = RecordingConfig(audioFormat: audioFormat, audioSampleRate: audioSampleRate, audioChannel: audioChannel, audioEncodeQuality: audioEncodeQuality, isEnabledAudioSession: isEnabledAudioSession, audioSessionCategory: audioSessionCategory, audioSessionMode: audioSessionMode)
        do {
            try recordingDriver.startRecording(recordingConfig: recordingConfig)
            startTimer()
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    func onTapStopRecording() {
        AudioServicesPlaySystemSound(stopSoundID)  // Play system sound on stop
        do {
            stopTimer()
            try recordingDriver.stopRecording()
        } catch {
            OSLogger.errorLog("Could not stop recording: \(error)")
            appError = error.toAppError
            showAlert = true
        }
    }

    ...
}
```

In this example, I used system sound ID `1104`, which is one of the common sounds for simple clicks or "Tock" sounds in iOS. You can experiment with different system sound IDs to find the one that best suits your needs. Remember, the use of these system sounds should comply with the user interface guidelines provided by Apple, ensuring they are not disruptive or misleading in the context of your app.

Also, it's important to note that system sounds are subject to the system's mute settings‚Äîthus, if the device is muted, these sounds will not play.

---

## üë§ „É¶„Éº„Ç∂„Éº
*2024/05/09 20:34:06*

Ê®ôÊ∫ñ„Ç¢„Éó„É™„ÅÆÂãïÁîª„ÅÆÈñãÂßãÈü≥„Å®ÂÅúÊ≠¢Èü≥„Å®Âêå„Åò„Å´„Åó„Åü„ÅÑ

---

## ü§ñ „Ç¢„Ç∑„Çπ„Çø„É≥„Éà
*2024/05/09 20:34:48*

To replicate the sound effects used in Apple‚Äôs standard Camera app for video recording start and stop, you would typically look for a way to access those specific system sounds. However, these particular sounds are not publicly available through the `AudioToolbox` framework or any other public API provided by Apple. Apple does not provide direct access to the sounds used in their Camera app for starting and stopping video recordings.

Here are a few alternative approaches you can consider:

1. **Custom Sound Effects**: The most common approach is to use or create custom sound effects that are similar to those you‚Äôre interested in. You can either create these sounds yourself, work with a sound designer, or find royalty-free sounds that are available for use. Once you have the sound files, you can use `AVAudioPlayer` from the `AVFoundation` framework to play these sounds at the appropriate times.

2. **User Feedback via Vibration**: If you prefer not to use custom sounds, another approach could be to provide haptic feedback using the `UIImpactFeedbackGenerator` when recording starts or stops. This would give a physical feedback which is less intrusive than sound.

3. **Third-Party Libraries**: Sometimes third-party libraries or resources might have recreated similar sounds based on Apple‚Äôs design. This isn‚Äôt the official sound, but it could be close enough for your purposes.

Here's how you could implement the first approach, using custom sound files:

### Implementing Custom Sound Effects

First, ensure your sound files (e.g., `startRecording.mp3` and `stopRecording.mp3`) are added to your project‚Äôs resources. Then, modify your `RecordingPresenter` to include an `AVAudioPlayer` for playing these sounds.

```swift
import AVFoundation

@MainActor
final class RecordingPresenter: ObservableObject {
    ...
    private var startAudioPlayer: AVAudioPlayer?
    private var stopAudioPlayer: AVAudioPlayer?

    init() {
        recordingDriver.isRecordingPublisher
            .assign(to: &$isRecording)
        setupAudioPlayers()
    }

    private func setupAudioPlayers() {
        let bundle = Bundle.main
        if let startURL = bundle.url(forResource: "startRecording", withExtension: "mp3"),
           let stopURL = bundle.url(forResource: "stopRecording", withExtension: "mp3") {
            do {
                startAudioPlayer = try AVAudioPlayer(contentsOf: startURL)
                stopAudioPlayer = try AVAudioPlayer(contentsOf: stopURL)
                startAudioPlayer?.prepareToPlay()
                stopAudioPlayer?.prepareToPlay()
            } catch {
                OSLogger.errorLog("Error loading sound files: \(error)")
            }
        }
    }

    func onTapStartRecording() {
        startAudioPlayer?.play()
        // Continue with your existing start recording logic
    }

    func onTapStopRecording() {
        stopAudioPlayer?.play()
        // Continue with your existing stop recording logic
    }

    ...
}
```

### Using Haptic Feedback

If you opt for a less intrusive form of feedback like haptics, here‚Äôs how you might implement it using `UIImpactFeedbackGenerator`:

```swift
import UIKit

func onTapStartRecording() {
    let feedbackGenerator = UIImpactFeedbackGenerator(style: .medium)
    feedbackGenerator.impactOccurred()
    // Continue with your existing start recording logic
}

func onTapStopRecording() {
    let feedbackGenerator = UIImpactFeedbackGenerator

---
