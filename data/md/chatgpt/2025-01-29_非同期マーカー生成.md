# 非同期マーカー生成

日付: 2025-01-29

---

## 👤 ユーザー
*2025/1/29 16:54:55*

buildAllMarkers が同期処理だと、多くのマーカーを生成する際にすごい時間がかかることが判明した。
こちらの処理を非同期的に行い、markersStateをできたものから順に更新していきたい。

import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

enum SpotType {
  noneGuild, // spotGuildId == null
  myGuild, // spotGuildId == myGuildId
  enemyGuild // spotGuildId != myGuildId
}

/// 逆三角形を描画するシンプルな Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // 左上
      ..lineTo(size.width, 0) // 右上
      ..lineTo(size.width / 2, size.height) // 底辺の中央
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isMarkersBuildingState = useState(false);

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);
      final photoUrl = spot.photoUrl;
      Widget content;

      switch (spotType) {
        case SpotType.noneGuild:
          content = DecoratedBox(
            decoration: BoxDecoration(
              border: Border.all(
                color: ColorPallet.white,
                width: 4,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: ColoredBox(
                color: ColorToken.bgWhite,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: (photoUrl != null && photoUrl.isNotEmpty)
                      ? CachedNetworkImage(
                          imageUrl: photoUrl,
                          fit: BoxFit.cover,
                          width: 64,
                          height: 64,
                          errorWidget: (context, url, error) {
                            return Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.broken_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            );
                          },
                        )
                      : Container(
                          width: 64,
                          height: 64,
                          color: ColorToken.bgDark,
                          child: const Icon(
                            Icons.hide_image_outlined,
                            size: 48,
                            color: ColorToken.text,
                          ),
                        ),
                ),
              ),
            ),
          );

        case SpotType.myGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorPallet.green500,
              child: Icon(
                Icons.flag,
                color: ColorPallet.green100,
                size: 24,
              ),
            ),
          );

        case SpotType.enemyGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorToken.bgEnemy,
              child: Icon(
                Icons.flag,
                color: ColorToken.enemy,
                size: 24,
              ),
            ),
          );
      }

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              content,
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final photoUrl = itemBox.itemBoxImage;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: (photoUrl != null && photoUrl.isNotEmpty)
                          ? CachedNetworkImage(
                              imageUrl: photoUrl,
                              fit: BoxFit.cover,
                              width: 64,
                              height: 64,
                              errorWidget: (context, url, error) {
                                return Container(
                                  width: 64,
                                  height: 64,
                                  color: ColorToken.bgDark,
                                  child: const Icon(
                                    Icons.broken_image_outlined,
                                    size: 48,
                                    color: ColorToken.text,
                                  ),
                                );
                              },
                            )
                          : Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.hide_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Set&lt;Marker&gt;&gt; buildAllMarkers({
      required List&lt;GuildSpotDTO&gt; spotList,
      required List&lt;ItemBoxDTO&gt; itemBoxList,
      required String? myGuildId,
    }) async {
      final markerSet = &lt;Marker&gt;{};

      // ---- Spot マーカー生成 ----
      for (final spot in spotList) {
        final lat = spot.spotLatitude?.toDouble() ?? 0;
        final lng = spot.spotLongitude?.toDouble() ?? 0;
        final spotId = spot.spotId ?? '';
        final spotType = getSpotType(spot.guildId, myGuildId);
        final widget = buildSpotMarkerWidget(spot, myGuildId);

        // widget_to_marker で変換
        final iconDescriptor = await widget.toBitmapDescriptor(
          logicalSize: const Size(88, 100),
          imageSize: spotType == SpotType.noneGuild
              ? const Size(198, 225)
              : const Size(242, 275),
          waitToRender: const Duration(milliseconds: 1000),
        );

        markerSet.add(
          Marker(
            markerId: MarkerId('spot_$spotId'),
            position: LatLng(lat, lng),
            icon: iconDescriptor,
            onTap: () async {
              await onTapSpotMarker(spotId, spotType);
            },
          ),
        );
      }

      // ---- ItemBox マーカー生成 ----
      for (final itemBox in itemBoxList) {
        final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
        final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
        final itemBoxId = itemBox.itemBoxId ?? '';
        final widget = buildItemBoxMarkerWidget(itemBox);

        // widget_to_marker で変換
        final iconDescriptor = await widget.toBitmapDescriptor(
          logicalSize: const Size(88, 100),
          imageSize: const Size(198, 225),
          waitToRender: const Duration(milliseconds: 1000),
        );

        markerSet.add(
          Marker(
            markerId: MarkerId('itemBox_$itemBoxId'),
            position: LatLng(lat, lng),
            icon: iconDescriptor,
            onTap: () async {
              await onTapItemBoxMarker(itemBox);
            },
          ),
        );
      }

      return markerSet;
    }

    Future&lt;void&gt; refreshMarkers(
      List&lt;GuildSpotDTO&gt; spotList,
      List&lt;ItemBoxDTO&gt; itemBoxList,
    ) async {
      try {
        final newMarkers = await buildAllMarkers(
          spotList: spotList,
          itemBoxList: itemBoxList,
          myGuildId: myGuildIdState.value,
        );
        markersState.value = newMarkers;
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTanNearMe() async {
      try {
        final refreshedLocation = await ref
            .read(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();
        final controller = googleMapControllerState.value;
        if (controller != null) {
          await controller.animateCamera(
            CameraUpdate.newLatLng(refreshedLocation),
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; initializeMarkers() async {
      try {
        isMarkersBuildingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshMarkers(spotList, itemBoxList);
        }
      } on Exception catch (error) {
        debugPrint('Error: $error');
      } finally {
        isMarkersBuildingState.value = false;
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await initializeMarkers();
        });
        // フォアグラウンド復帰で位置情報再取得
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // マーカーの更新中はスキップ
        if (!isMarkersBuildingState.value) {
          // マーカーの更新
          await initializeMarkers();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          try {
            final currentLocation = await ref
                .watch(currentLocationNotifierProvider.notifier)
                .getCurrentLocation();

            // range は km 単位なので、メートルに換算（×1000）
            final explorerRangeKm = next.explorer?.range ?? 0;
            final rangeInMeters = explorerRangeKm * 1000.0;

            final circle = Circle(
              circleId: const CircleId('explorerCircle'),
              center: currentLocation,
              radius: rangeInMeters,
              strokeColor: const Color(0xFF004DFF), // ブルー
              strokeWidth: 1,
              fillColor: const Color(0x40004DFF), // 25%ぐらい透過のブルー
            );

            circlesState.value = {circle};

            await googleMapControllerState.value?.animateCamera(
              CameraUpdate.newLatLng(currentLocation),
            );
          } on Exception catch (error) {
            if (context.mounted) {
              showErrorSnackBar(context, error);
            }
          }
        } else {
          circlesState.value = {};
          final explodedSpotList = ref.read(explodedSpotListNotifierProvider);

          final spotPhotoItems = explodedSpotList
                  ?.where((spot) =&gt; spot.photoUrl != null)
                  .map(
                    (spot) =&gt; SpotPhotoItem(
                      photoId: spot.photoId ?? '',
                      spotPhotoUrl: spot.photoUrl ?? '',
                      spotOwnership: spot.guildId == null
                          ? SpotOwnership.neutral
                          : spot.guildId == myGuildIdState.value
                              ? SpotOwnership.owner
                              : SpotOwnership.enemy,
                    ),
                  )
                  .toList() ??
              [];

          ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

          await showDialog&lt;void&gt;(
            context: context,
            builder: (_) =&gt; ExploredResultDialog(
              spotPhotoItemList: spotPhotoItems,
            ),
          );

          ref.read(explodedSpotListNotifierProvider.notifier).clear();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapControllerState.value = controller;
              },
              markers: markersState.value,
              circles: circlesState.value,
            ),
            if (isMarkersBuildingState.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // 現在地へ戻るボタン
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTanNearMe();
                        },
                        child: const Icon(
                          Icons.near_me,
                          size: 24,
                          color: ColorToken.secondaryDark,
                        ),
                      ),
                    ),
                    // Explore リスト
                    SizedBox(
                      width: 138,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: onExploringStateValue.isExploring
                            ? null
                            : () async {
                                await onTapExplorer();
                              },
                        backgroundColor: onExploringStateValue.isExploring
                            ? ColorPallet.gray800.withValues(alpha: 0.8)
                            : Theme.of(context)
                                .floatingActionButtonTheme
                                .backgroundColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: BorderSide(
                            color: onExploringStateValue.isExploring
                                ? Colors.transparent
                                : ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(left: 4),
                              child: onExploringStateValue.isExploring
                                  ? Transform.translate(
                                      offset: const Offset(4, 0),
                                      child: const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        ),
                                      ),
                                    )
                                  : Image.asset(
                                      Assets.images.explorerIconFig.path,
                                      width: 40,
                                      height: 40,
                                    ),
                            ),
                            const Spacer(),
                            Text(
                              onExploringStateValue.isExploring
                                  ? 'Exploring...'
                                  : 'Explore',
                              style: TextStyle(
                                fontSize: 16,
                                color: onExploringStateValue.isExploring
                                    ? ColorToken.text
                                    : ColorToken.secondaryDark,
                              ),
                            ),
                            const Spacer(),
                          ],
                        ),
                      ),
                    ),
                    // Spot リスト
                    spotListAsyncValue.when(
                      data: (spotList) {
                        // 上位2つを取り出し、順序を逆にする
                        final displaySpotList =
                            (spotList?.take(2).toList() ?? [])
                                .reversed
                                .toList();
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            backgroundColor: Colors.transparent,
                            shape: const RoundedRectangleBorder(
                              side: BorderSide(
                                color: Colors.transparent,
                              ),
                            ),
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: Transform.translate(
                              offset: const Offset(4, 4),
                              child: Stack(
                                clipBehavior: Clip.none,
                                alignment: Alignment.bottomRight,
                                children: [
                                  for (var i = 0; i &lt; 2; i++)
                                    if (i &lt; displaySpotList.length)
                                      Positioned(
                                        left: i * -4.0,
                                        top: i * -4.0,
                                        child: SizedBox(
                                          width: 44,
                                          height: 44,
                                          child: DecoratedBox(
                                            decoration: BoxDecoration(
                                              border: Border.all(
                                                color: ColorToken.bgWhite,
                                                width: 2,
                                              ),
                                              borderRadius:
                                                  BorderRadius.circular(4),
                                            ),
                                            child: Padding(
                                              padding: const EdgeInsets.all(2),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: SquareImage(
                                                  imageUrl: displaySpotList[i]
                                                      .photoUrl,
                                                  size: 44,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                      loading: () {
                        return const SizedBox.shrink();
                      },
                      error: (error, _) {
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            heroTag: 'ErrorShowSpotListButton',
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: const Icon(
                              Icons.photo,
                              size: 24,
                              color: ColorToken.secondaryDark,
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Center(
            child: ElevatedButton(
              onPressed: () async {
                await openAppSettings();
              },
              child: const Text(
                'Please enable location access in the Settings App',
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## 🔧 ツール
*2025/1/29 16:55:59*

**Converting to asynchronous**

I’m mapping out how to transition from synchronous to asynchronous map marker generation in Flutter, aiming to avoid UI blocking by leveraging background isolates or concurrency.

**Implementing iterative updates**

I’m exploring an approach where markers are updated iteratively, each iteration yielding control back to the UI, possibly using a Stream in Flutter to progressively update the marker state.

**Refining the strategy**

I’m refining the approach by considering asynchronous marker generation functions and managing concurrency with mechanisms like Future.wait or controlled counters to prevent UI blocking.

**Evaluating sequential vs. concurrent** 

I'm weighing the pros and cons of sequentially generating markers while yielding control to the UI after each change or using concurrency to update markers more progressively and efficiently.

---

## 🤖 アシスタント
*2025/1/29 16:55:59*

`widget_to_marker` を使ったマーカー生成は、内部で WidgetsBinding を利用して実際にウィジェットをレンダリングするため、  
**多数のマーカーを一度に同期的に生成すると UI スレッドを長時間ブロックし、結果としてアプリが固まったように見える**  
といった問題が発生しやすくなります。

このような場合、**マーカーを一括生成せず「1 つ生成するたびに即座に反映」** することで、  
ユーザの目に見える形で徐々にマーカーが追加されていくようにし、UI のフリーズを回避できます。

以下のように、ループ内で順次マーカー生成（`widget_to_marker`）を行いながら `markersState` を更新すれば OK です。

```dart
/// --- 1つのスポットから Marker を生成する例
Future<Marker> _buildSpotMarker({
  required GuildSpotDTO spot,
  required String? myGuildId,
  required void Function(String spotId, SpotType spotType) onTapSpotMarker,
}) async {
  final lat = spot.spotLatitude?.toDouble() ?? 0;
  final lng = spot.spotLongitude?.toDouble() ?? 0;
  final spotId = spot.spotId ?? '';
  final spotType = getSpotType(spot.guildId, myGuildId);

  // 生成したいウィジェットを作る
  final widget = buildSpotMarkerWidget(spot, myGuildId);

  // widget_to_marker を使って BitmapDescriptor を非同期生成
  final iconDescriptor = await widget.toBitmapDescriptor(
    logicalSize: const Size(88, 100),
    imageSize: spotType == SpotType.noneGuild
        ? const Size(198, 225)
        : const Size(242, 275),
    waitToRender: const Duration(milliseconds: 1000),
  );

  return Marker(
    markerId: MarkerId('spot_$spotId'),
    position: LatLng(lat, lng),
    icon: iconDescriptor,
    onTap: () => onTapSpotMarker(spotId, spotType),
  );
}

/// --- 1つのアイテムボックスから Marker を生成する例
Future<Marker> _buildItemBoxMarker({
  required ItemBoxDTO itemBox,
  required Future<void> Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
}) async {
  final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
  final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
  final itemBoxId = itemBox.itemBoxId ?? '';

  final widget = buildItemBoxMarkerWidget(itemBox);

  // widget_to_marker を使って BitmapDescriptor を非同期生成
  final iconDescriptor = await widget.toBitmapDescriptor(
    logicalSize: const Size(88, 100),
    imageSize: const Size(198, 225),
    waitToRender: const Duration(milliseconds: 1000),
  );

  return Marker(
    markerId: MarkerId('itemBox_$itemBoxId'),
    position: LatLng(lat, lng),
    icon: iconDescriptor,
    onTap: () => onTapItemBoxMarker(itemBox),
  );
}

/// --- 上記を利用して、全マーカーを「順次」生成していく例
Future<void> buildAllMarkersAsync({
  required WidgetRef ref,
  required ValueNotifier<Set<Marker>> markersState,
  required ValueNotifier<bool> isMarkersBuildingState,
  required List<GuildSpotDTO> spotList,
  required List<ItemBoxDTO> itemBoxList,
  required String? myGuildId,
}) async {
  isMarkersBuildingState.value = true;
  // いったん空にするならここ
  markersState.value = {};

  // Spot マーカーを順次生成して反映
  for (final spot in spotList) {
    final spotMarker = await _buildSpotMarker(
      spot: spot,
      myGuildId: myGuildId,
      onTapSpotMarker: (spotId, spotType) async {
        await onTapSpotMarker(spotId, spotType);
      },
    );

    // 既存のマーカー + 1つ追加して更新
    markersState.value = {
      ...markersState.value,
      spotMarker,
    };

    // 毎回少しだけ待機するとより UI が滑らかに更新される
    await Future.delayed(Duration.zero);
  }

  // ItemBox マーカーを順次生成して反映
  for (final itemBox in itemBoxList) {
    final itemBoxMarker = await _buildItemBoxMarker(
      itemBox: itemBox,
      onTapItemBoxMarker: (itemBox) async {
        await onTapItemBoxMarker(itemBox);
      },
    );

    markersState.value = {
      ...markersState.value,
      itemBoxMarker,
    };

    await Future.delayed(Duration.zero);
  }

  isMarkersBuildingState.value = false;
}
```

## ポイント

1. **1つ生成するごとに `markersState` に追加し、State を更新**  
   大量のマーカーをまとめて生成してからまとめて `markersState` を更新すると、  
   生成にかかるあいだ UI スレッドがブロックされて待ってしまいます。  
   そこで、1つずつ生成が終わるたびに `markersState` に追加して再ビルドさせることで、  
   「1個ずつマップにマーカーが増えていく」ような挙動になり、ユーザが待ちやすくなります。

2. **マーカー生成中にプログレスを示す**  
   もし時間がかかるようであれば、生成中であることを示すプログレスやインジケータを表示すると良いです。  
   すでに `isMarkersBuildingState` を持っているので、それを `true` にしている間  
   「Loading...」 や「しばらくお待ちください」などを表示してあげるとユーザフレンドリーです。

3. **連続生成時に小さなウェイトを挟む**  
   `widget_to_marker` はウィジェットをレンダリングする際にメインスレッド（UI スレッド）を使うため、  
   大量ループで一気に実行するとフレームが詰まってしまう場合があります。  
   各ループ後に `await Future.delayed(Duration.zero);` のように**わずかに待機**を入れることで、  
   次フレームへの制御を明け渡し、アニメーションやユーザインタラクションをブロックしにくくできます。

4. **もしマップ外のマーカーが多すぎるなら、クラスタリングや必要範囲だけ生成を検討**  
   本当に数百・数千のマーカーがある場合、そもそも全て表示しようとするとマップが見づらくなったり  
   アプリパフォーマンスが低下したりするので、「現在のズームレベルや表示範囲に応じてクラスター表示」  
   などのアプローチも検討するとより快適になります。

---

上記のように、「**ループ内で非同期処理 -> ステートを追加更新**」という形にするだけで  
マーカーが多い場合でもフリーズが大幅に軽減され、ユーザ体験が改善します。

---

## 👤 ユーザー
*2025/1/29 17:17:58*

少し修正して以下になった。
リフレッシュもする処理なのでmarkersState.value = {};と最初に全部リセットにするのではなく、MarkerIdを使って、上書き更新、追加、削除をうまく制御したい。      Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: spotType == SpotType.noneGuild
            ? const Size(198, 225)
            : const Size(242, 275),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    /// --- 上記を利用して、全マーカーを「順次」生成していく例
    Future&lt;void&gt; buildAllMarkersAsync({
      required List&lt;GuildSpotDTO&gt; spotList,
      required List&lt;ItemBoxDTO&gt; itemBoxList,
      required String? myGuildId,
    }) async {
      markersState.value = {};

      // Spot マーカーを順次生成して反映
      for (final spot in spotList) {
        final spotMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // 既存のマーカー + 1つ追加して更新
        markersState.value = {
          ...markersState.value,
          spotMarker,
        };

        // 毎回少しだけ待機するとより UI が滑らかに更新される
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox マーカーを順次生成して反映
      for (final itemBox in itemBoxList) {
        final itemBoxMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (itemBox) async {
            await onTapItemBoxMarker(itemBox);
          },
        );

        markersState.value = {
          ...markersState.value,
          itemBoxMarker,
        };

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

---

## 🔧 ツール
*2025/1/29 17:18:40*

**Crafting the strategy**

I'm piecing together a strategy to boost efficiency by managing MarkerId updates. This involves swapping markers with same IDs, adding new spots, and removing old ones.

**Enhancing marker management**

I’m refining marker management by adding, updating, and removing markers. Using a ValueNotifier&lt;Set&lt;Marker&gt;&gt;, I ensure only the necessary ones are present for the new list.

**Evaluating marker updates**

I'm a bit unsure about whether to re-generate markers only for changed data or all markers. The goal is to merge without replacing all markers, leveraging the current approach.

**Refining marker updates**

Checking if markers exist, if not, I create new ones or update them. This ensures only necessary markers are included, streamlining the process.

**Managing marker updates**

I'm thinking through updating existing markers or creating new ones if they don't exist. This approach ensures only relevant markers are part of the final setup.

**Updating markers smartly**

I’m creating a final example for incremental marker updates, using MarkerId. Considering forced re-generation only for data changes, since widget_to_marker can be costly.

**Refining marker management**

This snippet is about adding, removing, or updating markers based on new data. It uses MarkerId to ensure only relevant markers are included, resulting in an efficient update process.

**Outlining the code snippet**

It's worth noting the code snippet efficiently manages new spot and item box markers, ensuring the marker set stays current by adding new ones or updating existing ones.

---

## 🤖 アシスタント
*2025/1/29 17:18:40*

`markersState.value = {}` でまるごと置き換えるのではなく、  
**各マーカーに対応する `MarkerId` をキーとして「追加・更新・削除」をきちんと制御** すると、  
「すでに描画済みのマーカーは残しつつ、新規のマーカーだけ追加、不要なマーカーだけ削除」という更新が可能になります。  

たとえば以下のように、

1. **いま必要なマーカーID** の集合を作る（`spotList` + `itemBoxList` に基づく）  
2. 既存の `markersState.value` から、不要になったマーカー（= マーカーID が新しい集合に存在しないもの）を削除  
3. 新たに必要なマーカーID がまだ存在しない場合のみ `buildSpotMarker` や `buildItemBoxMarker` で生成して追加  
4. すでに同じマーカーID がある場合は必要に応じて再生成 or 使い回し（データ変化によって見た目が変わる場合など）

という流れで進めると良いでしょう。  
また、一気に生成すると重い場合は、**1つ生成するたびに `await Future.delayed(Duration.zero)` を挟んで** UI が固まるのを和らげられます。

以下は、イメージ例です（Spot / ItemBox をまとめて `updateMarkers` で更新する想定）。  
すでに存在する `buildSpotMarker` / `buildItemBoxMarker` / `getSpotType` / `onTapSpotMarker` / `onTapItemBoxMarker` などは  
そのまま使ってください。

```dart
Future<void> updateMarkers({
  required List<GuildSpotDTO> newSpotList,
  required List<ItemBoxDTO> newItemBoxList,
  required String? myGuildId,
}) async {
  // 現在の markers を一旦コピーして扱いやすくする
  final currentMarkers = markersState.value.toSet();

  // 1. 新たに必要な MarkerId の集合を作る
  //    spot は 'spot_～'、itemBox は 'itemBox_～' など
  final neededMarkerIds = <String>{};
  for (final spot in newSpotList) {
    neededMarkerIds.add('spot_${spot.spotId}');
  }
  for (final itemBox in newItemBoxList) {
    neededMarkerIds.add('itemBox_${itemBox.itemBoxId}');
  }

  // 2. 既存のマーカーから「今回いらないもの」を削除
  //    (MarkerId が neededMarkerIds に含まれていないものを消す)
  currentMarkers.removeWhere(
    (marker) => !neededMarkerIds.contains(marker.markerId.value),
  );

  // 3. Spot のマーカーを更新
  for (final spot in newSpotList) {
    final markerId = MarkerId('spot_${spot.spotId}');
    // 既に同じIDのマーカーが存在するか調べる
    final existing = currentMarkers.firstWhere(
      (m) => m.markerId == markerId,
      orElse: () => null as Marker, // Dart 3 なら `orElse: () => null` は不可なので仮
    );

    if (existing == null) {
      // まだ無いマーカーだけ生成
      final spotMarker = await buildSpotMarker(
        spot: spot,
        myGuildId: myGuildId,
        onTapSpotMarker: (spotId, spotType) async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
      currentMarkers.add(spotMarker);

      // 生成直後に少し待機して UI フリーズを緩和
      await Future.delayed(Duration.zero);
    } else {
      // すでにあるマーカーを再描画したい場合はここで再生成する
      // ただし widget_to_marker は重いので、基本的には
      // 「見た目に変化がなければ再生成しない」ほうがパフォーマンス的に安全
    }
  }

  // 4. ItemBox のマーカーを更新
  for (final itemBox in newItemBoxList) {
    final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
    final existing = currentMarkers.firstWhere(
      (m) => m.markerId == markerId,
      orElse: () => null as Marker,
    );

    if (existing == null) {
      final itemBoxMarker = await buildItemBoxMarker(
        itemBox: itemBox,
        onTapItemBoxMarker: (box) async {
          await onTapItemBoxMarker(box);
        },
      );
      currentMarkers.add(itemBoxMarker);

      await Future.delayed(Duration.zero);
    } else {
      // 同上。必要なら再生成
    }
  }

  // 5. 完成したマーカー集合を state に反映
  markersState.value = currentMarkers;
}
```

### ポイント

- **同じ `MarkerId` のマーカーを重複して追加すると、後から追加されたものが上書きされる** 形になります。  
  そのため「まったく同じ ID を持つマーカーがすでにあれば再生成しない」ことで性能を保ちつつ、  
  「新しく必要になったマーカーだけ追加」「必要なくなったマーカーだけ削除」できます。
- `widget_to_marker` の呼び出しは**マーカーが大量になると非常に重い**ので、  
  変更のないデータに対しては**再生成をスキップ**する設計が理想です。  
  （たとえば「Spot のギルドID が変わった / 画像URL が変わった / など見た目が変わる場合のみ再生成する」など）

こうして「必要なマーカーの `MarkerId` リストをベースに取捨選択しながら順次生成する」実装にすることで、  
**フルリフレッシュせずに済む** & **マーカーが多いときの負荷を軽減** & **UI をブロックしにくい** といったメリットが得られます。

---

## 👤 ユーザー
*2025/1/29 17:22:14*

すでにあるマーカーについても再描画したいのと、markersState.value = currentMarkers;で一気に更新するのではなく、順次更新していきたい。
つまり、buildSpotMarkerとupdateMarkersは分けずに、同じ処理で、初期描画もするし更新もさせたい。

---

## 🔧 ツール
*2025/1/29 17:23:07*

**Enhancing spot continuity**

I’m synthesizing a function to iterate through spotList, efficiently update the marker set by adding new markers and removing old ones, ensuring a seamless redrawing process.

**Refining spot marker updates**

I’m combining functionality to streamline updating spot markers by utilizing a `renderSpotMarker` function. It seamlessly builds, updates, and ensures real-time synchronization of markers on the map.

**Refining marker updates**

I’m pulling together a method to refresh spot markers by removing unneeded ones, rebuilding each marker for spotList, updating the map state, and introducing a short delay for visibility.

**Integrating marker updates**

I’m pulling together a comprehensive `refreshAllMarkers` function to streamline updating spot markers. It assembles necessary IDs, removes obsolete markers, and rebuilds each spot and item box marker, fostering real-time synchronization.

---

## 🤖 アシスタント
*2025/1/29 17:23:07*

以下のように実装すると、**初回描画**でも**更新**（再描画）でも同じ処理で対応しつつ、  
「すでにあるマーカーは必ず再描画し、不要になったマーカーは消去、新しいマーカーは追加」を  
**1 個ずつ順次マップに反映**できます。

ポイントは以下のとおりです。

1. **必要なマーカー ID の集合**をあらかじめ作る (`spot` なら `spot_XXX` など)  
2. **既存のマーカーから不要なものを削除** (ID の集合に含まれないものを除去)  
3. **Spot / ItemBox のリストをループし、1つずつ「新しく Marker を生成 → 既存 Marker を削除 → 追加 → State 反映 → わずかに待機」**  
   - 「既存のものを再利用する・しない」は要件次第ですが、**「常に再生成」**してしまえば  
     見た目や情報が更新されているか否かに関わらず、常に最新の状態で描画されます  
   - 生成した直後に `markersState` を都度更新することで、マップに「1 個ずつ追加される」演出になる  
4. **`await Future.delayed(Duration.zero)` を挟む**ことでメインスレッドをブロックしすぎないようにする

以下はサンプルコードです。  
`buildSpotMarker`, `buildItemBoxMarker`, `getSpotType` などはお手元の実装をそのまま利用してください。

```dart
Future<void> refreshAllMarkers({
  required List<GuildSpotDTO> newSpotList,
  required List<ItemBoxDTO> newItemBoxList,
  required String? myGuildId,
}) async {
  // 1. まず現在のマーカーをコピーして作業しやすくする
  final currentMarkers = markersState.value.toSet();

  // 2. 今回必要な MarkerId 一覧を作る
  //    spot は 'spot_～'、itemBox は 'itemBox_～' とする
  final neededMarkerIds = <String>{};
  for (final spot in newSpotList) {
    final spotId = spot.spotId ?? '';
    neededMarkerIds.add('spot_$spotId');
  }
  for (final box in newItemBoxList) {
    final boxId = box.itemBoxId ?? '';
    neededMarkerIds.add('itemBox_$boxId');
  }

  // 3. 既存マーカーから「不要になったもの」を削除する
  //    (neededMarkerIds に存在しない MarkerId を持つマーカーは消す)
  currentMarkers.removeWhere(
    (marker) => !neededMarkerIds.contains(marker.markerId.value),
  );

  // いったん削除結果を反映(不要マーカーが消える)
  markersState.value = {...currentMarkers};

  // 4. Spot のリストを順に処理し、1つずつ再描画して反映
  for (final spot in newSpotList) {
    final markerId = MarkerId('spot_${spot.spotId}');
    // buildSpotMarker (必ず再生成して再描画する想定)
    final newMarker = await buildSpotMarker(
      spot: spot,
      myGuildId: myGuildId,
      onTapSpotMarker: (spotId, spotType) async {
        await onTapSpotMarker(spotId, spotType);
      },
    );

    // 既存に同じ ID のマーカーがあれば削除してから追加
    currentMarkers.removeWhere((m) => m.markerId == markerId);
    currentMarkers.add(newMarker);

    // 新たに追加される or 更新されたマーカーをすぐ反映
    markersState.value = {...currentMarkers};

    // UI をブロックしにくくするために少し待機
    await Future.delayed(Duration.zero);
  }

  // 5. ItemBox も同様に処理
  for (final itemBox in newItemBoxList) {
    final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
    final newMarker = await buildItemBoxMarker(
      itemBox: itemBox,
      onTapItemBoxMarker: (box) async {
        await onTapItemBoxMarker(box);
      },
    );

    currentMarkers.removeWhere((m) => m.markerId == markerId);
    currentMarkers.add(newMarker);

    markersState.value = {...currentMarkers};

    await Future.delayed(Duration.zero);
  }
}
```

## 処理の流れ

1. **不要マーカー削除**  
   `neededMarkerIds` に含まれないマーカーは最初に削除して `markersState` に反映するので、  
   たとえば「サーバーサイドから削除されたスポット」などはすぐに消える

2. **Spot / ItemBox のマーカーを全て再生成**  
   （もしくは「見た目に変更があったものだけ再生成」でも良い）  
   - 既存の同じ ID のマーカーを `removeWhere` でいったん取り除く  
   - 新しく生成したマーカーを `add`  
   - `markersState.value = {...currentMarkers}` で更新  
   - `await Future.delayed(Duration.zero)` で UI 更新のチャンスを与える

こうすることで、「初回描画時」「更新時」の両方に対応でき、  
**1個ずつマーカーが再描画・追加されていく**のをユーザが視覚的に確認できるようになります。  

### 必要に応じて最適化も

- すべてのマーカーを毎回再生成すると**`widget_to_marker` の負荷が大きい**ので、  
  「Spot に変更があったものだけ再生成し、変わっていないものは使い回す」などの最適化も検討してください。  
- 数百〜数千レベルのマーカーを扱うなら、クラスタリングやズームレベルに応じた表示数の制限も検討するとさらに快適になります。

---
