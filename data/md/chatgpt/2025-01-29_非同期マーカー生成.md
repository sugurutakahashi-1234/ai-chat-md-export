# éåŒæœŸãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ

æ—¥ä»˜: 2025-01-29

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/1/29 16:54:55*

buildAllMarkers ãŒåŒæœŸå‡¦ç†ã ã¨ã€å¤šãã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹éš›ã«ã™ã”ã„æ™‚é–“ãŒã‹ã‹ã‚‹ã“ã¨ãŒåˆ¤æ˜ã—ãŸã€‚
ã“ã¡ã‚‰ã®å‡¦ç†ã‚’éåŒæœŸçš„ã«è¡Œã„ã€markersStateã‚’ã§ããŸã‚‚ã®ã‹ã‚‰é †ã«æ›´æ–°ã—ã¦ã„ããŸã„ã€‚

import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:snpit_guild_app/domain/design/color_pallet.dart';
import 'package:snpit_guild_app/domain/design/color_token.dart';
import 'package:snpit_guild_app/gen/assets.gen.dart';
import 'package:snpit_guild_app/infrastructure/snapit_guild_api/snapit_guild_api.openapi.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/get_guild.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/guilds/spots/get_guild_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/item_boxes/get_item_box_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/spots/get_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/api_client/users/get_user.dart';
import 'package:snpit_guild_app/presentation/providers/current_location.dart';
import 'package:snpit_guild_app/presentation/providers/exploded_spot_list.dart';
import 'package:snpit_guild_app/presentation/providers/on_exploring.dart';
import 'package:snpit_guild_app/presentation/providers/should_refresh_map_spot.dart';
import 'package:snpit_guild_app/presentation/providers/show_explorer_list.dart';
import 'package:snpit_guild_app/presentation/providers/show_our_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_shootable_spot_detail.dart';
import 'package:snpit_guild_app/presentation/providers/show_spot_list.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/explored_result_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/dialogs/item_box_dialog.dart';
import 'package:snpit_guild_app/presentation/widgets/spot_photo_carousel.dart';
import 'package:snpit_guild_app/presentation/widgets/square_image.dart';
import 'package:snpit_guild_app/utils/snack_bar_utils.dart';
import 'package:widget_to_marker/widget_to_marker.dart';

enum SpotType {
  noneGuild, // spotGuildId == null
  myGuild, // spotGuildId == myGuildId
  enemyGuild // spotGuildId != myGuildId
}

/// é€†ä¸‰è§’å½¢ã‚’æç”»ã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãª Painter
class TrianglePainter extends CustomPainter {
  TrianglePainter({required this.color});
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;
    final path = Path()
      ..moveTo(0, 0) // å·¦ä¸Š
      ..lineTo(size.width, 0) // å³ä¸Š
      ..lineTo(size.width / 2, size.height) // åº•è¾ºã®ä¸­å¤®
      ..close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(TrianglePainter oldDelegate) =&gt; false;
}

class MapPage extends HookConsumerWidget {
  const MapPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentLocationAsyncValue =
        ref.watch(currentLocationNotifierProvider);
    final spotListAsyncValue = ref.watch(getSpotListNotifierProvider);
    final onExploringStateValue = ref.watch(onExploringNotifierProvider);
    final googleMapControllerState = useState&lt;GoogleMapController?&gt;(null);
    final myGuildIdState = useState&lt;String?&gt;(null);
    final markersState = useState&lt;Set&lt;Marker&gt;&gt;({});
    final circlesState = useState&lt;Set&lt;Circle&gt;&gt;({});
    final isMarkersBuildingState = useState(false);

    Future&lt;void&gt; onTapSpotMarker(String spotId, SpotType spotType) async {
      switch (spotType) {
        case SpotType.noneGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);

        case SpotType.myGuild:
          ref.read(showOurSpotDetailNotifierProvider.notifier).show(spotId);

        case SpotType.enemyGuild:
          ref
              .read(showShootableSpotDetailNotifierProvider.notifier)
              .show(spotId);
      }
    }

    Future&lt;void&gt; onTapItemBoxMarker(ItemBoxDTO itemBox) async {
      await showDialog&lt;void&gt;(
        context: context,
        builder: (_) {
          return ItemBoxDialog(itemBox: itemBox);
        },
      );
    }

    SpotType getSpotType(String? spotGuildId, String? myGuildId) {
      if (spotGuildId == null) {
        return SpotType.noneGuild;
      } else if (spotGuildId == myGuildId) {
        return SpotType.myGuild;
      } else {
        return SpotType.enemyGuild;
      }
    }

    // Widget buildSpotMarkerWidget(SpotType spotType, String? photoUrl) {
    Widget buildSpotMarkerWidget(GuildSpotDTO spot, String? myGuildId) {
      final spotType = getSpotType(spot.guildId, myGuildId);
      final photoUrl = spot.photoUrl;
      Widget content;

      switch (spotType) {
        case SpotType.noneGuild:
          content = DecoratedBox(
            decoration: BoxDecoration(
              border: Border.all(
                color: ColorPallet.white,
                width: 4,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: ColoredBox(
                color: ColorToken.bgWhite,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: (photoUrl != null && photoUrl.isNotEmpty)
                      ? CachedNetworkImage(
                          imageUrl: photoUrl,
                          fit: BoxFit.cover,
                          width: 64,
                          height: 64,
                          errorWidget: (context, url, error) {
                            return Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.broken_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            );
                          },
                        )
                      : Container(
                          width: 64,
                          height: 64,
                          color: ColorToken.bgDark,
                          child: const Icon(
                            Icons.hide_image_outlined,
                            size: 48,
                            color: ColorToken.text,
                          ),
                        ),
                ),
              ),
            ),
          );

        case SpotType.myGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorPallet.green500,
              child: Icon(
                Icons.flag,
                color: ColorPallet.green100,
                size: 24,
              ),
            ),
          );

        case SpotType.enemyGuild:
          content = const CircleAvatar(
            radius: 32,
            backgroundColor: ColorToken.bgWhite,
            child: CircleAvatar(
              radius: 28,
              backgroundColor: ColorToken.bgEnemy,
              child: Icon(
                Icons.flag,
                color: ColorToken.enemy,
                size: 24,
              ),
            ),
          );
      }

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              content,
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Widget buildItemBoxMarkerWidget(ItemBoxDTO itemBox) {
      final photoUrl = itemBox.itemBoxImage;

      return Padding(
        padding: const EdgeInsets.all(8),
        child: DecoratedBox(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                blurRadius: 8,
                color: ColorToken.bgBlack.withAlpha(50),
                spreadRadius: 2,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: ColorPallet.white,
                    width: 4,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(4),
                  child: ColoredBox(
                    color: ColorToken.bgWhite,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: (photoUrl != null && photoUrl.isNotEmpty)
                          ? CachedNetworkImage(
                              imageUrl: photoUrl,
                              fit: BoxFit.cover,
                              width: 64,
                              height: 64,
                              errorWidget: (context, url, error) {
                                return Container(
                                  width: 64,
                                  height: 64,
                                  color: ColorToken.bgDark,
                                  child: const Icon(
                                    Icons.broken_image_outlined,
                                    size: 48,
                                    color: ColorToken.text,
                                  ),
                                );
                              },
                            )
                          : Container(
                              width: 64,
                              height: 64,
                              color: ColorToken.bgDark,
                              child: const Icon(
                                Icons.hide_image_outlined,
                                size: 48,
                                color: ColorToken.text,
                              ),
                            ),
                    ),
                  ),
                ),
              ),
              Transform.translate(
                offset: const Offset(0, -4),
                child: CustomPaint(
                  size: const Size(12, 12),
                  painter: TrianglePainter(color: ColorToken.bgWhite),
                ),
              ),
            ],
          ),
        ),
      );
    }

    Future&lt;Set&lt;Marker&gt;&gt; buildAllMarkers({
      required List&lt;GuildSpotDTO&gt; spotList,
      required List&lt;ItemBoxDTO&gt; itemBoxList,
      required String? myGuildId,
    }) async {
      final markerSet = &lt;Marker&gt;{};

      // ---- Spot ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ ----
      for (final spot in spotList) {
        final lat = spot.spotLatitude?.toDouble() ?? 0;
        final lng = spot.spotLongitude?.toDouble() ?? 0;
        final spotId = spot.spotId ?? '';
        final spotType = getSpotType(spot.guildId, myGuildId);
        final widget = buildSpotMarkerWidget(spot, myGuildId);

        // widget_to_marker ã§å¤‰æ›
        final iconDescriptor = await widget.toBitmapDescriptor(
          logicalSize: const Size(88, 100),
          imageSize: spotType == SpotType.noneGuild
              ? const Size(198, 225)
              : const Size(242, 275),
          waitToRender: const Duration(milliseconds: 1000),
        );

        markerSet.add(
          Marker(
            markerId: MarkerId('spot_$spotId'),
            position: LatLng(lat, lng),
            icon: iconDescriptor,
            onTap: () async {
              await onTapSpotMarker(spotId, spotType);
            },
          ),
        );
      }

      // ---- ItemBox ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆ ----
      for (final itemBox in itemBoxList) {
        final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
        final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
        final itemBoxId = itemBox.itemBoxId ?? '';
        final widget = buildItemBoxMarkerWidget(itemBox);

        // widget_to_marker ã§å¤‰æ›
        final iconDescriptor = await widget.toBitmapDescriptor(
          logicalSize: const Size(88, 100),
          imageSize: const Size(198, 225),
          waitToRender: const Duration(milliseconds: 1000),
        );

        markerSet.add(
          Marker(
            markerId: MarkerId('itemBox_$itemBoxId'),
            position: LatLng(lat, lng),
            icon: iconDescriptor,
            onTap: () async {
              await onTapItemBoxMarker(itemBox);
            },
          ),
        );
      }

      return markerSet;
    }

    Future&lt;void&gt; refreshMarkers(
      List&lt;GuildSpotDTO&gt; spotList,
      List&lt;ItemBoxDTO&gt; itemBoxList,
    ) async {
      try {
        final newMarkers = await buildAllMarkers(
          spotList: spotList,
          itemBoxList: itemBoxList,
          myGuildId: myGuildIdState.value,
        );
        markersState.value = newMarkers;
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTanNearMe() async {
      try {
        final refreshedLocation = await ref
            .read(currentLocationNotifierProvider.notifier)
            .getCurrentLocation();
        final controller = googleMapControllerState.value;
        if (controller != null) {
          await controller.animateCamera(
            CameraUpdate.newLatLng(refreshedLocation),
          );
        }
      } on Exception catch (error) {
        if (context.mounted) {
          showErrorSnackBar(context, error);
        }
      }
    }

    Future&lt;void&gt; onTapExplorer() async {
      ref.read(showExplorerListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; onTapSpotList() async {
      ref.read(showSpotListNotifierProvider.notifier).show();
    }

    Future&lt;void&gt; initializeMarkers() async {
      try {
        isMarkersBuildingState.value = true;

        await ref.read(getSpotListNotifierProvider.notifier).getAllSpotList();

        await ref.read(getMyGuildNotifierProvider.notifier).getMyGuild();

        final myUser =
            await ref.read(getMyUserNotifierProvider.notifier).getMyUser();

        myGuildIdState.value = myUser.guildId;

        final itemBoxList = await ref
            .read(getItemBoxListNotifierProvider.notifier)
            .getItemBoxList();

        final myGuildId = myGuildIdState.value;
        if (myGuildId != null) {
          final spotList = await ref
              .read(getGuildSpotListNotifierProvider.notifier)
              .getGuildSpotList(myGuildId);

          await refreshMarkers(spotList, itemBoxList);
        }
      } on Exception catch (error) {
        debugPrint('Error: $error');
      } finally {
        isMarkersBuildingState.value = false;
      }
    }

    useEffect(
      () {
        Future.microtask(() async {
          await initializeMarkers();
        });
        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¾©å¸°ã§ä½ç½®æƒ…å ±å†å–å¾—
        final observer = _LifecycleObserver(
          onResume: () async {
            final refreshedLocation =
                ref.refresh(currentLocationNotifierProvider);
            debugPrint('Location refreshed: $refreshedLocation');
          },
        );
        WidgetsBinding.instance.addObserver(observer);
        return () =&gt; WidgetsBinding.instance.removeObserver(observer);
      },
      [],
    );

    ref
      ..listen&lt;int&gt;(shouldRefreshMapSpotNotifierProvider,
          (previous, next) async {
        // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!isMarkersBuildingState.value) {
          // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°
          await initializeMarkers();
        }
      })
      ..listen&lt;OnExploringState&gt;(onExploringNotifierProvider,
          (previous, next) async {
        if (next.isExploring) {
          try {
            final currentLocation = await ref
                .watch(currentLocationNotifierProvider.notifier)
                .getCurrentLocation();

            // range ã¯ km å˜ä½ãªã®ã§ã€ãƒ¡ãƒ¼ãƒˆãƒ«ã«æ›ç®—ï¼ˆÃ—1000ï¼‰
            final explorerRangeKm = next.explorer?.range ?? 0;
            final rangeInMeters = explorerRangeKm * 1000.0;

            final circle = Circle(
              circleId: const CircleId('explorerCircle'),
              center: currentLocation,
              radius: rangeInMeters,
              strokeColor: const Color(0xFF004DFF), // ãƒ–ãƒ«ãƒ¼
              strokeWidth: 1,
              fillColor: const Color(0x40004DFF), // 25%ãã‚‰ã„é€éã®ãƒ–ãƒ«ãƒ¼
            );

            circlesState.value = {circle};

            await googleMapControllerState.value?.animateCamera(
              CameraUpdate.newLatLng(currentLocation),
            );
          } on Exception catch (error) {
            if (context.mounted) {
              showErrorSnackBar(context, error);
            }
          }
        } else {
          circlesState.value = {};
          final explodedSpotList = ref.read(explodedSpotListNotifierProvider);

          final spotPhotoItems = explodedSpotList
                  ?.where((spot) =&gt; spot.photoUrl != null)
                  .map(
                    (spot) =&gt; SpotPhotoItem(
                      photoId: spot.photoId ?? '',
                      spotPhotoUrl: spot.photoUrl ?? '',
                      spotOwnership: spot.guildId == null
                          ? SpotOwnership.neutral
                          : spot.guildId == myGuildIdState.value
                              ? SpotOwnership.owner
                              : SpotOwnership.enemy,
                    ),
                  )
                  .toList() ??
              [];

          ref.read(shouldRefreshMapSpotNotifierProvider.notifier).trigger();

          await showDialog&lt;void&gt;(
            context: context,
            builder: (_) =&gt; ExploredResultDialog(
              spotPhotoItemList: spotPhotoItems,
            ),
          );

          ref.read(explodedSpotListNotifierProvider.notifier).clear();
        }
      });

    return Scaffold(
      body: currentLocationAsyncValue.when(
        data: (currentLocation) =&gt; Stack(
          children: [
            GoogleMap(
              initialCameraPosition: CameraPosition(
                target: currentLocation,
                zoom: 17,
              ),
              myLocationEnabled: true,
              myLocationButtonEnabled: false,
              onMapCreated: (controller) {
                googleMapControllerState.value = controller;
              },
              markers: markersState.value,
              circles: circlesState.value,
            ),
            if (isMarkersBuildingState.value)
              const Center(child: CircularProgressIndicator()),
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // ç¾åœ¨åœ°ã¸æˆ»ã‚‹ãƒœã‚¿ãƒ³
                    SizedBox(
                      width: 48,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'CurrentLocationButton',
                        onPressed: () async {
                          await onTanNearMe();
                        },
                        child: const Icon(
                          Icons.near_me,
                          size: 24,
                          color: ColorToken.secondaryDark,
                        ),
                      ),
                    ),
                    // Explore ãƒªã‚¹ãƒˆ
                    SizedBox(
                      width: 138,
                      height: 48,
                      child: FloatingActionButton(
                        heroTag: 'ShowExploreListButton',
                        onPressed: onExploringStateValue.isExploring
                            ? null
                            : () async {
                                await onTapExplorer();
                              },
                        backgroundColor: onExploringStateValue.isExploring
                            ? ColorPallet.gray800.withValues(alpha: 0.8)
                            : Theme.of(context)
                                .floatingActionButtonTheme
                                .backgroundColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(40),
                          side: BorderSide(
                            color: onExploringStateValue.isExploring
                                ? Colors.transparent
                                : ColorToken.secondaryLight,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(left: 4),
                              child: onExploringStateValue.isExploring
                                  ? Transform.translate(
                                      offset: const Offset(4, 0),
                                      child: const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        ),
                                      ),
                                    )
                                  : Image.asset(
                                      Assets.images.explorerIconFig.path,
                                      width: 40,
                                      height: 40,
                                    ),
                            ),
                            const Spacer(),
                            Text(
                              onExploringStateValue.isExploring
                                  ? 'Exploring...'
                                  : 'Explore',
                              style: TextStyle(
                                fontSize: 16,
                                color: onExploringStateValue.isExploring
                                    ? ColorToken.text
                                    : ColorToken.secondaryDark,
                              ),
                            ),
                            const Spacer(),
                          ],
                        ),
                      ),
                    ),
                    // Spot ãƒªã‚¹ãƒˆ
                    spotListAsyncValue.when(
                      data: (spotList) {
                        // ä¸Šä½2ã¤ã‚’å–ã‚Šå‡ºã—ã€é †åºã‚’é€†ã«ã™ã‚‹
                        final displaySpotList =
                            (spotList?.take(2).toList() ?? [])
                                .reversed
                                .toList();
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            backgroundColor: Colors.transparent,
                            shape: const RoundedRectangleBorder(
                              side: BorderSide(
                                color: Colors.transparent,
                              ),
                            ),
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: Transform.translate(
                              offset: const Offset(4, 4),
                              child: Stack(
                                clipBehavior: Clip.none,
                                alignment: Alignment.bottomRight,
                                children: [
                                  for (var i = 0; i &lt; 2; i++)
                                    if (i &lt; displaySpotList.length)
                                      Positioned(
                                        left: i * -4.0,
                                        top: i * -4.0,
                                        child: SizedBox(
                                          width: 44,
                                          height: 44,
                                          child: DecoratedBox(
                                            decoration: BoxDecoration(
                                              border: Border.all(
                                                color: ColorToken.bgWhite,
                                                width: 2,
                                              ),
                                              borderRadius:
                                                  BorderRadius.circular(4),
                                            ),
                                            child: Padding(
                                              padding: const EdgeInsets.all(2),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: SquareImage(
                                                  imageUrl: displaySpotList[i]
                                                      .photoUrl,
                                                  size: 44,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                      loading: () {
                        return const SizedBox.shrink();
                      },
                      error: (error, _) {
                        return SizedBox(
                          width: 48,
                          height: 48,
                          child: FloatingActionButton(
                            heroTag: 'ErrorShowSpotListButton',
                            onPressed: () async {
                              await onTapSpotList();
                            },
                            child: const Icon(
                              Icons.photo,
                              size: 24,
                              color: ColorToken.secondaryDark,
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        loading: () {
          return const Center(child: CircularProgressIndicator());
        },
        error: (error, _) {
          return Center(
            child: ElevatedButton(
              onPressed: () async {
                await openAppSettings();
              },
              child: const Text(
                'Please enable location access in the Settings App',
              ),
            ),
          );
        },
      ),
    );
  }
}

class _LifecycleObserver extends WidgetsBindingObserver {
  _LifecycleObserver({this.onResume});
  final VoidCallback? onResume;

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      onResume?.call();
    }
  }
}

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/1/29 16:55:59*

**Converting to asynchronous**

Iâ€™m mapping out how to transition from synchronous to asynchronous map marker generation in Flutter, aiming to avoid UI blocking by leveraging background isolates or concurrency.

**Implementing iterative updates**

Iâ€™m exploring an approach where markers are updated iteratively, each iteration yielding control back to the UI, possibly using a Stream in Flutter to progressively update the marker state.

**Refining the strategy**

Iâ€™m refining the approach by considering asynchronous marker generation functions and managing concurrency with mechanisms like Future.wait or controlled counters to prevent UI blocking.

**Evaluating sequential vs. concurrent** 

I'm weighing the pros and cons of sequentially generating markers while yielding control to the UI after each change or using concurrency to update markers more progressively and efficiently.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/1/29 16:55:59*

`widget_to_marker` ã‚’ä½¿ã£ãŸãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆã¯ã€å†…éƒ¨ã§ WidgetsBinding ã‚’åˆ©ç”¨ã—ã¦å®Ÿéš›ã«ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹ãŸã‚ã€  
**å¤šæ•°ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ä¸€åº¦ã«åŒæœŸçš„ã«ç”Ÿæˆã™ã‚‹ã¨ UI ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é•·æ™‚é–“ãƒ–ãƒ­ãƒƒã‚¯ã—ã€çµæœã¨ã—ã¦ã‚¢ãƒ—ãƒªãŒå›ºã¾ã£ãŸã‚ˆã†ã«è¦‹ãˆã‚‹**  
ã¨ã„ã£ãŸå•é¡ŒãŒç™ºç”Ÿã—ã‚„ã™ããªã‚Šã¾ã™ã€‚

ã“ã®ã‚ˆã†ãªå ´åˆã€**ãƒãƒ¼ã‚«ãƒ¼ã‚’ä¸€æ‹¬ç”Ÿæˆã›ãšã€Œ1 ã¤ç”Ÿæˆã™ã‚‹ãŸã³ã«å³åº§ã«åæ˜ ã€** ã™ã‚‹ã“ã¨ã§ã€  
ãƒ¦ãƒ¼ã‚¶ã®ç›®ã«è¦‹ãˆã‚‹å½¢ã§å¾ã€…ã«ãƒãƒ¼ã‚«ãƒ¼ãŒè¿½åŠ ã•ã‚Œã¦ã„ãã‚ˆã†ã«ã—ã€UI ã®ãƒ•ãƒªãƒ¼ã‚ºã‚’å›é¿ã§ãã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚ˆã†ã«ã€ãƒ«ãƒ¼ãƒ—å†…ã§é †æ¬¡ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆï¼ˆ`widget_to_marker`ï¼‰ã‚’è¡Œã„ãªãŒã‚‰ `markersState` ã‚’æ›´æ–°ã™ã‚Œã° OK ã§ã™ã€‚

```dart
/// --- 1ã¤ã®ã‚¹ãƒãƒƒãƒˆã‹ã‚‰ Marker ã‚’ç”Ÿæˆã™ã‚‹ä¾‹
Future<Marker> _buildSpotMarker({
  required GuildSpotDTO spot,
  required String? myGuildId,
  required void Function(String spotId, SpotType spotType) onTapSpotMarker,
}) async {
  final lat = spot.spotLatitude?.toDouble() ?? 0;
  final lng = spot.spotLongitude?.toDouble() ?? 0;
  final spotId = spot.spotId ?? '';
  final spotType = getSpotType(spot.guildId, myGuildId);

  // ç”Ÿæˆã—ãŸã„ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’ä½œã‚‹
  final widget = buildSpotMarkerWidget(spot, myGuildId);

  // widget_to_marker ã‚’ä½¿ã£ã¦ BitmapDescriptor ã‚’éåŒæœŸç”Ÿæˆ
  final iconDescriptor = await widget.toBitmapDescriptor(
    logicalSize: const Size(88, 100),
    imageSize: spotType == SpotType.noneGuild
        ? const Size(198, 225)
        : const Size(242, 275),
    waitToRender: const Duration(milliseconds: 1000),
  );

  return Marker(
    markerId: MarkerId('spot_$spotId'),
    position: LatLng(lat, lng),
    icon: iconDescriptor,
    onTap: () => onTapSpotMarker(spotId, spotType),
  );
}

/// --- 1ã¤ã®ã‚¢ã‚¤ãƒ†ãƒ ãƒœãƒƒã‚¯ã‚¹ã‹ã‚‰ Marker ã‚’ç”Ÿæˆã™ã‚‹ä¾‹
Future<Marker> _buildItemBoxMarker({
  required ItemBoxDTO itemBox,
  required Future<void> Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
}) async {
  final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
  final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
  final itemBoxId = itemBox.itemBoxId ?? '';

  final widget = buildItemBoxMarkerWidget(itemBox);

  // widget_to_marker ã‚’ä½¿ã£ã¦ BitmapDescriptor ã‚’éåŒæœŸç”Ÿæˆ
  final iconDescriptor = await widget.toBitmapDescriptor(
    logicalSize: const Size(88, 100),
    imageSize: const Size(198, 225),
    waitToRender: const Duration(milliseconds: 1000),
  );

  return Marker(
    markerId: MarkerId('itemBox_$itemBoxId'),
    position: LatLng(lat, lng),
    icon: iconDescriptor,
    onTap: () => onTapItemBoxMarker(itemBox),
  );
}

/// --- ä¸Šè¨˜ã‚’åˆ©ç”¨ã—ã¦ã€å…¨ãƒãƒ¼ã‚«ãƒ¼ã‚’ã€Œé †æ¬¡ã€ç”Ÿæˆã—ã¦ã„ãä¾‹
Future<void> buildAllMarkersAsync({
  required WidgetRef ref,
  required ValueNotifier<Set<Marker>> markersState,
  required ValueNotifier<bool> isMarkersBuildingState,
  required List<GuildSpotDTO> spotList,
  required List<ItemBoxDTO> itemBoxList,
  required String? myGuildId,
}) async {
  isMarkersBuildingState.value = true;
  // ã„ã£ãŸã‚“ç©ºã«ã™ã‚‹ãªã‚‰ã“ã“
  markersState.value = {};

  // Spot ãƒãƒ¼ã‚«ãƒ¼ã‚’é †æ¬¡ç”Ÿæˆã—ã¦åæ˜ 
  for (final spot in spotList) {
    final spotMarker = await _buildSpotMarker(
      spot: spot,
      myGuildId: myGuildId,
      onTapSpotMarker: (spotId, spotType) async {
        await onTapSpotMarker(spotId, spotType);
      },
    );

    // æ—¢å­˜ã®ãƒãƒ¼ã‚«ãƒ¼ + 1ã¤è¿½åŠ ã—ã¦æ›´æ–°
    markersState.value = {
      ...markersState.value,
      spotMarker,
    };

    // æ¯å›å°‘ã—ã ã‘å¾…æ©Ÿã™ã‚‹ã¨ã‚ˆã‚Š UI ãŒæ»‘ã‚‰ã‹ã«æ›´æ–°ã•ã‚Œã‚‹
    await Future.delayed(Duration.zero);
  }

  // ItemBox ãƒãƒ¼ã‚«ãƒ¼ã‚’é †æ¬¡ç”Ÿæˆã—ã¦åæ˜ 
  for (final itemBox in itemBoxList) {
    final itemBoxMarker = await _buildItemBoxMarker(
      itemBox: itemBox,
      onTapItemBoxMarker: (itemBox) async {
        await onTapItemBoxMarker(itemBox);
      },
    );

    markersState.value = {
      ...markersState.value,
      itemBoxMarker,
    };

    await Future.delayed(Duration.zero);
  }

  isMarkersBuildingState.value = false;
}
```

## ãƒã‚¤ãƒ³ãƒˆ

1. **1ã¤ç”Ÿæˆã™ã‚‹ã”ã¨ã« `markersState` ã«è¿½åŠ ã—ã€State ã‚’æ›´æ–°**  
   å¤§é‡ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ã¾ã¨ã‚ã¦ç”Ÿæˆã—ã¦ã‹ã‚‰ã¾ã¨ã‚ã¦ `markersState` ã‚’æ›´æ–°ã™ã‚‹ã¨ã€  
   ç”Ÿæˆã«ã‹ã‹ã‚‹ã‚ã„ã  UI ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦å¾…ã£ã¦ã—ã¾ã„ã¾ã™ã€‚  
   ãã“ã§ã€1ã¤ãšã¤ç”ŸæˆãŒçµ‚ã‚ã‚‹ãŸã³ã« `markersState` ã«è¿½åŠ ã—ã¦å†ãƒ“ãƒ«ãƒ‰ã•ã›ã‚‹ã“ã¨ã§ã€  
   ã€Œ1å€‹ãšã¤ãƒãƒƒãƒ—ã«ãƒãƒ¼ã‚«ãƒ¼ãŒå¢—ãˆã¦ã„ãã€ã‚ˆã†ãªæŒ™å‹•ã«ãªã‚Šã€ãƒ¦ãƒ¼ã‚¶ãŒå¾…ã¡ã‚„ã™ããªã‚Šã¾ã™ã€‚

2. **ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆä¸­ã«ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã‚’ç¤ºã™**  
   ã‚‚ã—æ™‚é–“ãŒã‹ã‹ã‚‹ã‚ˆã†ã§ã‚ã‚Œã°ã€ç”Ÿæˆä¸­ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã‚„ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã™ã‚‹ã¨è‰¯ã„ã§ã™ã€‚  
   ã™ã§ã« `isMarkersBuildingState` ã‚’æŒã£ã¦ã„ã‚‹ã®ã§ã€ãã‚Œã‚’ `true` ã«ã—ã¦ã„ã‚‹é–“  
   ã€ŒLoading...ã€ ã‚„ã€Œã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€ãªã©ã‚’è¡¨ç¤ºã—ã¦ã‚ã’ã‚‹ã¨ãƒ¦ãƒ¼ã‚¶ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ã§ã™ã€‚

3. **é€£ç¶šç”Ÿæˆæ™‚ã«å°ã•ãªã‚¦ã‚§ã‚¤ãƒˆã‚’æŒŸã‚€**  
   `widget_to_marker` ã¯ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹éš›ã«ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ï¼ˆUI ã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰ã‚’ä½¿ã†ãŸã‚ã€  
   å¤§é‡ãƒ«ãƒ¼ãƒ—ã§ä¸€æ°—ã«å®Ÿè¡Œã™ã‚‹ã¨ãƒ•ãƒ¬ãƒ¼ãƒ ãŒè©°ã¾ã£ã¦ã—ã¾ã†å ´åˆãŒã‚ã‚Šã¾ã™ã€‚  
   å„ãƒ«ãƒ¼ãƒ—å¾Œã« `await Future.delayed(Duration.zero);` ã®ã‚ˆã†ã«**ã‚ãšã‹ã«å¾…æ©Ÿ**ã‚’å…¥ã‚Œã‚‹ã“ã¨ã§ã€  
   æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã¸ã®åˆ¶å¾¡ã‚’æ˜ã‘æ¸¡ã—ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚„ãƒ¦ãƒ¼ã‚¶ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã«ããã§ãã¾ã™ã€‚

4. **ã‚‚ã—ãƒãƒƒãƒ—å¤–ã®ãƒãƒ¼ã‚«ãƒ¼ãŒå¤šã™ãã‚‹ãªã‚‰ã€ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã‚„å¿…è¦ç¯„å›²ã ã‘ç”Ÿæˆã‚’æ¤œè¨**  
   æœ¬å½“ã«æ•°ç™¾ãƒ»æ•°åƒã®ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚‹å ´åˆã€ãã‚‚ãã‚‚å…¨ã¦è¡¨ç¤ºã—ã‚ˆã†ã¨ã™ã‚‹ã¨ãƒãƒƒãƒ—ãŒè¦‹ã¥ã‚‰ããªã£ãŸã‚Š  
   ã‚¢ãƒ—ãƒªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒä½ä¸‹ã—ãŸã‚Šã™ã‚‹ã®ã§ã€ã€Œç¾åœ¨ã®ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚„è¡¨ç¤ºç¯„å›²ã«å¿œã˜ã¦ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼è¡¨ç¤ºã€  
   ãªã©ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚‚æ¤œè¨ã™ã‚‹ã¨ã‚ˆã‚Šå¿«é©ã«ãªã‚Šã¾ã™ã€‚

---

ä¸Šè¨˜ã®ã‚ˆã†ã«ã€ã€Œ**ãƒ«ãƒ¼ãƒ—å†…ã§éåŒæœŸå‡¦ç† -> ã‚¹ãƒ†ãƒ¼ãƒˆã‚’è¿½åŠ æ›´æ–°**ã€ã¨ã„ã†å½¢ã«ã™ã‚‹ã ã‘ã§  
ãƒãƒ¼ã‚«ãƒ¼ãŒå¤šã„å ´åˆã§ã‚‚ãƒ•ãƒªãƒ¼ã‚ºãŒå¤§å¹…ã«è»½æ¸›ã•ã‚Œã€ãƒ¦ãƒ¼ã‚¶ä½“é¨“ãŒæ”¹å–„ã—ã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/1/29 17:17:58*

å°‘ã—ä¿®æ­£ã—ã¦ä»¥ä¸‹ã«ãªã£ãŸã€‚
ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚‚ã™ã‚‹å‡¦ç†ãªã®ã§markersState.value = {};ã¨æœ€åˆã«å…¨éƒ¨ãƒªã‚»ãƒƒãƒˆã«ã™ã‚‹ã®ã§ã¯ãªãã€MarkerIdã‚’ä½¿ã£ã¦ã€ä¸Šæ›¸ãæ›´æ–°ã€è¿½åŠ ã€å‰Šé™¤ã‚’ã†ã¾ãåˆ¶å¾¡ã—ãŸã„ã€‚â€¨â€¨    Future&lt;Marker&gt; buildSpotMarker({
      required GuildSpotDTO spot,
      required String? myGuildId,
      required Future&lt;void&gt; Function(String spotId, SpotType spotType)
          onTapSpotMarker,
    }) async {
      final lat = spot.spotLatitude?.toDouble() ?? 0;
      final lng = spot.spotLongitude?.toDouble() ?? 0;
      final spotId = spot.spotId ?? '';
      final spotType = getSpotType(spot.guildId, myGuildId);
      final widget = buildSpotMarkerWidget(spot, myGuildId);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: spotType == SpotType.noneGuild
            ? const Size(198, 225)
            : const Size(242, 275),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('spot_$spotId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
    }

    Future&lt;Marker&gt; buildItemBoxMarker({
      required ItemBoxDTO itemBox,
      required Future&lt;void&gt; Function(ItemBoxDTO itemBox) onTapItemBoxMarker,
    }) async {
      final lat = itemBox.itemBoxLatitude?.toDouble() ?? 0;
      final lng = itemBox.itemBoxLongitude?.toDouble() ?? 0;
      final itemBoxId = itemBox.itemBoxId ?? '';
      final widget = buildItemBoxMarkerWidget(itemBox);

      final iconDescriptor = await widget.toBitmapDescriptor(
        logicalSize: const Size(88, 100),
        imageSize: const Size(198, 225),
        waitToRender: const Duration(milliseconds: 100),
      );

      return Marker(
        markerId: MarkerId('itemBox_$itemBoxId'),
        position: LatLng(lat, lng),
        icon: iconDescriptor,
        onTap: () async {
          await onTapItemBoxMarker(itemBox);
        },
      );
    }

    /// --- ä¸Šè¨˜ã‚’åˆ©ç”¨ã—ã¦ã€å…¨ãƒãƒ¼ã‚«ãƒ¼ã‚’ã€Œé †æ¬¡ã€ç”Ÿæˆã—ã¦ã„ãä¾‹
    Future&lt;void&gt; buildAllMarkersAsync({
      required List&lt;GuildSpotDTO&gt; spotList,
      required List&lt;ItemBoxDTO&gt; itemBoxList,
      required String? myGuildId,
    }) async {
      markersState.value = {};

      // Spot ãƒãƒ¼ã‚«ãƒ¼ã‚’é †æ¬¡ç”Ÿæˆã—ã¦åæ˜ 
      for (final spot in spotList) {
        final spotMarker = await buildSpotMarker(
          spot: spot,
          myGuildId: myGuildId,
          onTapSpotMarker: (spotId, spotType) async {
            await onTapSpotMarker(spotId, spotType);
          },
        );

        // æ—¢å­˜ã®ãƒãƒ¼ã‚«ãƒ¼ + 1ã¤è¿½åŠ ã—ã¦æ›´æ–°
        markersState.value = {
          ...markersState.value,
          spotMarker,
        };

        // æ¯å›å°‘ã—ã ã‘å¾…æ©Ÿã™ã‚‹ã¨ã‚ˆã‚Š UI ãŒæ»‘ã‚‰ã‹ã«æ›´æ–°ã•ã‚Œã‚‹
        await Future&lt;void&gt;.delayed(Duration.zero);
      }

      // ItemBox ãƒãƒ¼ã‚«ãƒ¼ã‚’é †æ¬¡ç”Ÿæˆã—ã¦åæ˜ 
      for (final itemBox in itemBoxList) {
        final itemBoxMarker = await buildItemBoxMarker(
          itemBox: itemBox,
          onTapItemBoxMarker: (itemBox) async {
            await onTapItemBoxMarker(itemBox);
          },
        );

        markersState.value = {
          ...markersState.value,
          itemBoxMarker,
        };

        await Future&lt;void&gt;.delayed(Duration.zero);
      }
    }

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/1/29 17:18:40*

**Crafting the strategy**

I'm piecing together a strategy to boost efficiency by managing MarkerId updates. This involves swapping markers with same IDs, adding new spots, and removing old ones.

**Enhancing marker management**

Iâ€™m refining marker management by adding, updating, and removing markers. Using a ValueNotifier&lt;Set&lt;Marker&gt;&gt;, I ensure only the necessary ones are present for the new list.

**Evaluating marker updates**

I'm a bit unsure about whether to re-generate markers only for changed data or all markers. The goal is to merge without replacing all markers, leveraging the current approach.

**Refining marker updates**

Checking if markers exist, if not, I create new ones or update them. This ensures only necessary markers are included, streamlining the process.

**Managing marker updates**

I'm thinking through updating existing markers or creating new ones if they don't exist. This approach ensures only relevant markers are part of the final setup.

**Updating markers smartly**

Iâ€™m creating a final example for incremental marker updates, using MarkerId. Considering forced re-generation only for data changes, since widget_to_marker can be costly.

**Refining marker management**

This snippet is about adding, removing, or updating markers based on new data. It uses MarkerId to ensure only relevant markers are included, resulting in an efficient update process.

**Outlining the code snippet**

It's worth noting the code snippet efficiently manages new spot and item box markers, ensuring the marker set stays current by adding new ones or updating existing ones.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/1/29 17:18:40*

`markersState.value = {}` ã§ã¾ã‚‹ã”ã¨ç½®ãæ›ãˆã‚‹ã®ã§ã¯ãªãã€  
**å„ãƒãƒ¼ã‚«ãƒ¼ã«å¯¾å¿œã™ã‚‹ `MarkerId` ã‚’ã‚­ãƒ¼ã¨ã—ã¦ã€Œè¿½åŠ ãƒ»æ›´æ–°ãƒ»å‰Šé™¤ã€ã‚’ãã¡ã‚“ã¨åˆ¶å¾¡** ã™ã‚‹ã¨ã€  
ã€Œã™ã§ã«æç”»æ¸ˆã¿ã®ãƒãƒ¼ã‚«ãƒ¼ã¯æ®‹ã—ã¤ã¤ã€æ–°è¦ã®ãƒãƒ¼ã‚«ãƒ¼ã ã‘è¿½åŠ ã€ä¸è¦ãªãƒãƒ¼ã‚«ãƒ¼ã ã‘å‰Šé™¤ã€ã¨ã„ã†æ›´æ–°ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚  

ãŸã¨ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã€

1. **ã„ã¾å¿…è¦ãªãƒãƒ¼ã‚«ãƒ¼ID** ã®é›†åˆã‚’ä½œã‚‹ï¼ˆ`spotList` + `itemBoxList` ã«åŸºã¥ãï¼‰  
2. æ—¢å­˜ã® `markersState.value` ã‹ã‚‰ã€ä¸è¦ã«ãªã£ãŸãƒãƒ¼ã‚«ãƒ¼ï¼ˆ= ãƒãƒ¼ã‚«ãƒ¼ID ãŒæ–°ã—ã„é›†åˆã«å­˜åœ¨ã—ãªã„ã‚‚ã®ï¼‰ã‚’å‰Šé™¤  
3. æ–°ãŸã«å¿…è¦ãªãƒãƒ¼ã‚«ãƒ¼ID ãŒã¾ã å­˜åœ¨ã—ãªã„å ´åˆã®ã¿ `buildSpotMarker` ã‚„ `buildItemBoxMarker` ã§ç”Ÿæˆã—ã¦è¿½åŠ   
4. ã™ã§ã«åŒã˜ãƒãƒ¼ã‚«ãƒ¼ID ãŒã‚ã‚‹å ´åˆã¯å¿…è¦ã«å¿œã˜ã¦å†ç”Ÿæˆ or ä½¿ã„å›ã—ï¼ˆãƒ‡ãƒ¼ã‚¿å¤‰åŒ–ã«ã‚ˆã£ã¦è¦‹ãŸç›®ãŒå¤‰ã‚ã‚‹å ´åˆãªã©ï¼‰

ã¨ã„ã†æµã‚Œã§é€²ã‚ã‚‹ã¨è‰¯ã„ã§ã—ã‚‡ã†ã€‚  
ã¾ãŸã€ä¸€æ°—ã«ç”Ÿæˆã™ã‚‹ã¨é‡ã„å ´åˆã¯ã€**1ã¤ç”Ÿæˆã™ã‚‹ãŸã³ã« `await Future.delayed(Duration.zero)` ã‚’æŒŸã‚“ã§** UI ãŒå›ºã¾ã‚‹ã®ã‚’å’Œã‚‰ã’ã‚‰ã‚Œã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€ã‚¤ãƒ¡ãƒ¼ã‚¸ä¾‹ã§ã™ï¼ˆSpot / ItemBox ã‚’ã¾ã¨ã‚ã¦ `updateMarkers` ã§æ›´æ–°ã™ã‚‹æƒ³å®šï¼‰ã€‚  
ã™ã§ã«å­˜åœ¨ã™ã‚‹ `buildSpotMarker` / `buildItemBoxMarker` / `getSpotType` / `onTapSpotMarker` / `onTapItemBoxMarker` ãªã©ã¯  
ãã®ã¾ã¾ä½¿ã£ã¦ãã ã•ã„ã€‚

```dart
Future<void> updateMarkers({
  required List<GuildSpotDTO> newSpotList,
  required List<ItemBoxDTO> newItemBoxList,
  required String? myGuildId,
}) async {
  // ç¾åœ¨ã® markers ã‚’ä¸€æ—¦ã‚³ãƒ”ãƒ¼ã—ã¦æ‰±ã„ã‚„ã™ãã™ã‚‹
  final currentMarkers = markersState.value.toSet();

  // 1. æ–°ãŸã«å¿…è¦ãª MarkerId ã®é›†åˆã‚’ä½œã‚‹
  //    spot ã¯ 'spot_ï½'ã€itemBox ã¯ 'itemBox_ï½' ãªã©
  final neededMarkerIds = <String>{};
  for (final spot in newSpotList) {
    neededMarkerIds.add('spot_${spot.spotId}');
  }
  for (final itemBox in newItemBoxList) {
    neededMarkerIds.add('itemBox_${itemBox.itemBoxId}');
  }

  // 2. æ—¢å­˜ã®ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ã€Œä»Šå›ã„ã‚‰ãªã„ã‚‚ã®ã€ã‚’å‰Šé™¤
  //    (MarkerId ãŒ neededMarkerIds ã«å«ã¾ã‚Œã¦ã„ãªã„ã‚‚ã®ã‚’æ¶ˆã™)
  currentMarkers.removeWhere(
    (marker) => !neededMarkerIds.contains(marker.markerId.value),
  );

  // 3. Spot ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’æ›´æ–°
  for (final spot in newSpotList) {
    final markerId = MarkerId('spot_${spot.spotId}');
    // æ—¢ã«åŒã˜IDã®ãƒãƒ¼ã‚«ãƒ¼ãŒå­˜åœ¨ã™ã‚‹ã‹èª¿ã¹ã‚‹
    final existing = currentMarkers.firstWhere(
      (m) => m.markerId == markerId,
      orElse: () => null as Marker, // Dart 3 ãªã‚‰ `orElse: () => null` ã¯ä¸å¯ãªã®ã§ä»®
    );

    if (existing == null) {
      // ã¾ã ç„¡ã„ãƒãƒ¼ã‚«ãƒ¼ã ã‘ç”Ÿæˆ
      final spotMarker = await buildSpotMarker(
        spot: spot,
        myGuildId: myGuildId,
        onTapSpotMarker: (spotId, spotType) async {
          await onTapSpotMarker(spotId, spotType);
        },
      );
      currentMarkers.add(spotMarker);

      // ç”Ÿæˆç›´å¾Œã«å°‘ã—å¾…æ©Ÿã—ã¦ UI ãƒ•ãƒªãƒ¼ã‚ºã‚’ç·©å’Œ
      await Future.delayed(Duration.zero);
    } else {
      // ã™ã§ã«ã‚ã‚‹ãƒãƒ¼ã‚«ãƒ¼ã‚’å†æç”»ã—ãŸã„å ´åˆã¯ã“ã“ã§å†ç”Ÿæˆã™ã‚‹
      // ãŸã ã— widget_to_marker ã¯é‡ã„ã®ã§ã€åŸºæœ¬çš„ã«ã¯
      // ã€Œè¦‹ãŸç›®ã«å¤‰åŒ–ãŒãªã‘ã‚Œã°å†ç”Ÿæˆã—ãªã„ã€ã»ã†ãŒãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çš„ã«å®‰å…¨
    }
  }

  // 4. ItemBox ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’æ›´æ–°
  for (final itemBox in newItemBoxList) {
    final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
    final existing = currentMarkers.firstWhere(
      (m) => m.markerId == markerId,
      orElse: () => null as Marker,
    );

    if (existing == null) {
      final itemBoxMarker = await buildItemBoxMarker(
        itemBox: itemBox,
        onTapItemBoxMarker: (box) async {
          await onTapItemBoxMarker(box);
        },
      );
      currentMarkers.add(itemBoxMarker);

      await Future.delayed(Duration.zero);
    } else {
      // åŒä¸Šã€‚å¿…è¦ãªã‚‰å†ç”Ÿæˆ
    }
  }

  // 5. å®Œæˆã—ãŸãƒãƒ¼ã‚«ãƒ¼é›†åˆã‚’ state ã«åæ˜ 
  markersState.value = currentMarkers;
}
```

### ãƒã‚¤ãƒ³ãƒˆ

- **åŒã˜ `MarkerId` ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’é‡è¤‡ã—ã¦è¿½åŠ ã™ã‚‹ã¨ã€å¾Œã‹ã‚‰è¿½åŠ ã•ã‚ŒãŸã‚‚ã®ãŒä¸Šæ›¸ãã•ã‚Œã‚‹** å½¢ã«ãªã‚Šã¾ã™ã€‚  
  ãã®ãŸã‚ã€Œã¾ã£ãŸãåŒã˜ ID ã‚’æŒã¤ãƒãƒ¼ã‚«ãƒ¼ãŒã™ã§ã«ã‚ã‚Œã°å†ç”Ÿæˆã—ãªã„ã€ã“ã¨ã§æ€§èƒ½ã‚’ä¿ã¡ã¤ã¤ã€  
  ã€Œæ–°ã—ãå¿…è¦ã«ãªã£ãŸãƒãƒ¼ã‚«ãƒ¼ã ã‘è¿½åŠ ã€ã€Œå¿…è¦ãªããªã£ãŸãƒãƒ¼ã‚«ãƒ¼ã ã‘å‰Šé™¤ã€ã§ãã¾ã™ã€‚
- `widget_to_marker` ã®å‘¼ã³å‡ºã—ã¯**ãƒãƒ¼ã‚«ãƒ¼ãŒå¤§é‡ã«ãªã‚‹ã¨éå¸¸ã«é‡ã„**ã®ã§ã€  
  å¤‰æ›´ã®ãªã„ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã¯**å†ç”Ÿæˆã‚’ã‚¹ã‚­ãƒƒãƒ—**ã™ã‚‹è¨­è¨ˆãŒç†æƒ³ã§ã™ã€‚  
  ï¼ˆãŸã¨ãˆã°ã€ŒSpot ã®ã‚®ãƒ«ãƒ‰ID ãŒå¤‰ã‚ã£ãŸ / ç”»åƒURL ãŒå¤‰ã‚ã£ãŸ / ãªã©è¦‹ãŸç›®ãŒå¤‰ã‚ã‚‹å ´åˆã®ã¿å†ç”Ÿæˆã™ã‚‹ã€ãªã©ï¼‰

ã“ã†ã—ã¦ã€Œå¿…è¦ãªãƒãƒ¼ã‚«ãƒ¼ã® `MarkerId` ãƒªã‚¹ãƒˆã‚’ãƒ™ãƒ¼ã‚¹ã«å–æ¨é¸æŠã—ãªãŒã‚‰é †æ¬¡ç”Ÿæˆã™ã‚‹ã€å®Ÿè£…ã«ã™ã‚‹ã“ã¨ã§ã€  
**ãƒ•ãƒ«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã›ãšã«æ¸ˆã‚€** & **ãƒãƒ¼ã‚«ãƒ¼ãŒå¤šã„ã¨ãã®è² è·ã‚’è»½æ¸›** & **UI ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã«ãã„** ã¨ã„ã£ãŸãƒ¡ãƒªãƒƒãƒˆãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2025/1/29 17:22:14*

ã™ã§ã«ã‚ã‚‹ãƒãƒ¼ã‚«ãƒ¼ã«ã¤ã„ã¦ã‚‚å†æç”»ã—ãŸã„ã®ã¨ã€markersState.value = currentMarkers;ã§ä¸€æ°—ã«æ›´æ–°ã™ã‚‹ã®ã§ã¯ãªãã€é †æ¬¡æ›´æ–°ã—ã¦ã„ããŸã„ã€‚
ã¤ã¾ã‚Šã€buildSpotMarkerã¨updateMarkersã¯åˆ†ã‘ãšã«ã€åŒã˜å‡¦ç†ã§ã€åˆæœŸæç”»ã‚‚ã™ã‚‹ã—æ›´æ–°ã‚‚ã•ã›ãŸã„ã€‚

---

## ğŸ”§ ãƒ„ãƒ¼ãƒ«
*2025/1/29 17:23:07*

**Enhancing spot continuity**

Iâ€™m synthesizing a function to iterate through spotList, efficiently update the marker set by adding new markers and removing old ones, ensuring a seamless redrawing process.

**Refining spot marker updates**

Iâ€™m combining functionality to streamline updating spot markers by utilizing a `renderSpotMarker` function. It seamlessly builds, updates, and ensures real-time synchronization of markers on the map.

**Refining marker updates**

Iâ€™m pulling together a method to refresh spot markers by removing unneeded ones, rebuilding each marker for spotList, updating the map state, and introducing a short delay for visibility.

**Integrating marker updates**

Iâ€™m pulling together a comprehensive `refreshAllMarkers` function to streamline updating spot markers. It assembles necessary IDs, removes obsolete markers, and rebuilds each spot and item box marker, fostering real-time synchronization.

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2025/1/29 17:23:07*

ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã¨ã€**åˆå›æç”»**ã§ã‚‚**æ›´æ–°**ï¼ˆå†æç”»ï¼‰ã§ã‚‚åŒã˜å‡¦ç†ã§å¯¾å¿œã—ã¤ã¤ã€  
ã€Œã™ã§ã«ã‚ã‚‹ãƒãƒ¼ã‚«ãƒ¼ã¯å¿…ãšå†æç”»ã—ã€ä¸è¦ã«ãªã£ãŸãƒãƒ¼ã‚«ãƒ¼ã¯æ¶ˆå»ã€æ–°ã—ã„ãƒãƒ¼ã‚«ãƒ¼ã¯è¿½åŠ ã€ã‚’  
**1 å€‹ãšã¤é †æ¬¡ãƒãƒƒãƒ—ã«åæ˜ **ã§ãã¾ã™ã€‚

ãƒã‚¤ãƒ³ãƒˆã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã™ã€‚

1. **å¿…è¦ãªãƒãƒ¼ã‚«ãƒ¼ ID ã®é›†åˆ**ã‚’ã‚ã‚‰ã‹ã˜ã‚ä½œã‚‹ (`spot` ãªã‚‰ `spot_XXX` ãªã©)  
2. **æ—¢å­˜ã®ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ä¸è¦ãªã‚‚ã®ã‚’å‰Šé™¤** (ID ã®é›†åˆã«å«ã¾ã‚Œãªã„ã‚‚ã®ã‚’é™¤å»)  
3. **Spot / ItemBox ã®ãƒªã‚¹ãƒˆã‚’ãƒ«ãƒ¼ãƒ—ã—ã€1ã¤ãšã¤ã€Œæ–°ã—ã Marker ã‚’ç”Ÿæˆ â†’ æ—¢å­˜ Marker ã‚’å‰Šé™¤ â†’ è¿½åŠ  â†’ State åæ˜  â†’ ã‚ãšã‹ã«å¾…æ©Ÿã€**  
   - ã€Œæ—¢å­˜ã®ã‚‚ã®ã‚’å†åˆ©ç”¨ã™ã‚‹ãƒ»ã—ãªã„ã€ã¯è¦ä»¶æ¬¡ç¬¬ã§ã™ãŒã€**ã€Œå¸¸ã«å†ç”Ÿæˆã€**ã—ã¦ã—ã¾ãˆã°  
     è¦‹ãŸç›®ã‚„æƒ…å ±ãŒæ›´æ–°ã•ã‚Œã¦ã„ã‚‹ã‹å¦ã‹ã«é–¢ã‚ã‚‰ãšã€å¸¸ã«æœ€æ–°ã®çŠ¶æ…‹ã§æç”»ã•ã‚Œã¾ã™  
   - ç”Ÿæˆã—ãŸç›´å¾Œã« `markersState` ã‚’éƒ½åº¦æ›´æ–°ã™ã‚‹ã“ã¨ã§ã€ãƒãƒƒãƒ—ã«ã€Œ1 å€‹ãšã¤è¿½åŠ ã•ã‚Œã‚‹ã€æ¼”å‡ºã«ãªã‚‹  
4. **`await Future.delayed(Duration.zero)` ã‚’æŒŸã‚€**ã“ã¨ã§ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã™ããªã„ã‚ˆã†ã«ã™ã‚‹

ä»¥ä¸‹ã¯ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚  
`buildSpotMarker`, `buildItemBoxMarker`, `getSpotType` ãªã©ã¯ãŠæ‰‹å…ƒã®å®Ÿè£…ã‚’ãã®ã¾ã¾åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚

```dart
Future<void> refreshAllMarkers({
  required List<GuildSpotDTO> newSpotList,
  required List<ItemBoxDTO> newItemBoxList,
  required String? myGuildId,
}) async {
  // 1. ã¾ãšç¾åœ¨ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ä½œæ¥­ã—ã‚„ã™ãã™ã‚‹
  final currentMarkers = markersState.value.toSet();

  // 2. ä»Šå›å¿…è¦ãª MarkerId ä¸€è¦§ã‚’ä½œã‚‹
  //    spot ã¯ 'spot_ï½'ã€itemBox ã¯ 'itemBox_ï½' ã¨ã™ã‚‹
  final neededMarkerIds = <String>{};
  for (final spot in newSpotList) {
    final spotId = spot.spotId ?? '';
    neededMarkerIds.add('spot_$spotId');
  }
  for (final box in newItemBoxList) {
    final boxId = box.itemBoxId ?? '';
    neededMarkerIds.add('itemBox_$boxId');
  }

  // 3. æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ã€Œä¸è¦ã«ãªã£ãŸã‚‚ã®ã€ã‚’å‰Šé™¤ã™ã‚‹
  //    (neededMarkerIds ã«å­˜åœ¨ã—ãªã„ MarkerId ã‚’æŒã¤ãƒãƒ¼ã‚«ãƒ¼ã¯æ¶ˆã™)
  currentMarkers.removeWhere(
    (marker) => !neededMarkerIds.contains(marker.markerId.value),
  );

  // ã„ã£ãŸã‚“å‰Šé™¤çµæœã‚’åæ˜ (ä¸è¦ãƒãƒ¼ã‚«ãƒ¼ãŒæ¶ˆãˆã‚‹)
  markersState.value = {...currentMarkers};

  // 4. Spot ã®ãƒªã‚¹ãƒˆã‚’é †ã«å‡¦ç†ã—ã€1ã¤ãšã¤å†æç”»ã—ã¦åæ˜ 
  for (final spot in newSpotList) {
    final markerId = MarkerId('spot_${spot.spotId}');
    // buildSpotMarker (å¿…ãšå†ç”Ÿæˆã—ã¦å†æç”»ã™ã‚‹æƒ³å®š)
    final newMarker = await buildSpotMarker(
      spot: spot,
      myGuildId: myGuildId,
      onTapSpotMarker: (spotId, spotType) async {
        await onTapSpotMarker(spotId, spotType);
      },
    );

    // æ—¢å­˜ã«åŒã˜ ID ã®ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
    currentMarkers.removeWhere((m) => m.markerId == markerId);
    currentMarkers.add(newMarker);

    // æ–°ãŸã«è¿½åŠ ã•ã‚Œã‚‹ or æ›´æ–°ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼ã‚’ã™ãåæ˜ 
    markersState.value = {...currentMarkers};

    // UI ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã«ããã™ã‚‹ãŸã‚ã«å°‘ã—å¾…æ©Ÿ
    await Future.delayed(Duration.zero);
  }

  // 5. ItemBox ã‚‚åŒæ§˜ã«å‡¦ç†
  for (final itemBox in newItemBoxList) {
    final markerId = MarkerId('itemBox_${itemBox.itemBoxId}');
    final newMarker = await buildItemBoxMarker(
      itemBox: itemBox,
      onTapItemBoxMarker: (box) async {
        await onTapItemBoxMarker(box);
      },
    );

    currentMarkers.removeWhere((m) => m.markerId == markerId);
    currentMarkers.add(newMarker);

    markersState.value = {...currentMarkers};

    await Future.delayed(Duration.zero);
  }
}
```

## å‡¦ç†ã®æµã‚Œ

1. **ä¸è¦ãƒãƒ¼ã‚«ãƒ¼å‰Šé™¤**  
   `neededMarkerIds` ã«å«ã¾ã‚Œãªã„ãƒãƒ¼ã‚«ãƒ¼ã¯æœ€åˆã«å‰Šé™¤ã—ã¦ `markersState` ã«åæ˜ ã™ã‚‹ã®ã§ã€  
   ãŸã¨ãˆã°ã€Œã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‹ã‚‰å‰Šé™¤ã•ã‚ŒãŸã‚¹ãƒãƒƒãƒˆã€ãªã©ã¯ã™ãã«æ¶ˆãˆã‚‹

2. **Spot / ItemBox ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’å…¨ã¦å†ç”Ÿæˆ**  
   ï¼ˆã‚‚ã—ãã¯ã€Œè¦‹ãŸç›®ã«å¤‰æ›´ãŒã‚ã£ãŸã‚‚ã®ã ã‘å†ç”Ÿæˆã€ã§ã‚‚è‰¯ã„ï¼‰  
   - æ—¢å­˜ã®åŒã˜ ID ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ `removeWhere` ã§ã„ã£ãŸã‚“å–ã‚Šé™¤ã  
   - æ–°ã—ãç”Ÿæˆã—ãŸãƒãƒ¼ã‚«ãƒ¼ã‚’ `add`  
   - `markersState.value = {...currentMarkers}` ã§æ›´æ–°  
   - `await Future.delayed(Duration.zero)` ã§ UI æ›´æ–°ã®ãƒãƒ£ãƒ³ã‚¹ã‚’ä¸ãˆã‚‹

ã“ã†ã™ã‚‹ã“ã¨ã§ã€ã€Œåˆå›æç”»æ™‚ã€ã€Œæ›´æ–°æ™‚ã€ã®ä¸¡æ–¹ã«å¯¾å¿œã§ãã€  
**1å€‹ãšã¤ãƒãƒ¼ã‚«ãƒ¼ãŒå†æç”»ãƒ»è¿½åŠ ã•ã‚Œã¦ã„ã**ã®ã‚’ãƒ¦ãƒ¼ã‚¶ãŒè¦–è¦šçš„ã«ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚  

### å¿…è¦ã«å¿œã˜ã¦æœ€é©åŒ–ã‚‚

- ã™ã¹ã¦ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¯å›å†ç”Ÿæˆã™ã‚‹ã¨**`widget_to_marker` ã®è² è·ãŒå¤§ãã„**ã®ã§ã€  
  ã€ŒSpot ã«å¤‰æ›´ãŒã‚ã£ãŸã‚‚ã®ã ã‘å†ç”Ÿæˆã—ã€å¤‰ã‚ã£ã¦ã„ãªã„ã‚‚ã®ã¯ä½¿ã„å›ã™ã€ãªã©ã®æœ€é©åŒ–ã‚‚æ¤œè¨ã—ã¦ãã ã•ã„ã€‚  
- æ•°ç™¾ã€œæ•°åƒãƒ¬ãƒ™ãƒ«ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’æ‰±ã†ãªã‚‰ã€ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã‚„ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸè¡¨ç¤ºæ•°ã®åˆ¶é™ã‚‚æ¤œè¨ã™ã‚‹ã¨ã•ã‚‰ã«å¿«é©ã«ãªã‚Šã¾ã™ã€‚

---
