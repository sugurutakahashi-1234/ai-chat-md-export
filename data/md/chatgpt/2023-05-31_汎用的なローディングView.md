# 汎用的なローディングView

日付: 2023-05-31

---

## 👤 ユーザー
*2023/5/31 21:18:35*

SwiftUIで全ての画面で使えるような汎用的なローディングViewを作りたい

---

## 🤖 アシスタント
*2023/5/31 21:19:41*

SwiftUIを使って汎用的なローディングViewを作成するために、まずはシンプルなローディングインジケーターを作成してみましょう。このローディングインジケーターは、`ProgressView`を使用して作成します。

```swift
import SwiftUI

struct LoadingView: View {
    var body: some View {
        ProgressView()
            .progressViewStyle(CircularProgressViewStyle(tint: .blue))
            .scaleEffect(2)
    }
}
```

上記の`LoadingView`は非常にシンプルで、ビジュアルに対するカスタマイズ可能性は少ないですが、非常に素早く簡単に作成できるローディングインジケーターとしては非常に便利です。

さらにカスタマイズしたい場合、自分でローディングインジケーターを作成することも可能です。以下に、回転するローダーを作成する例を示します：

```swift
import SwiftUI

struct LoadingView: View {
    @State private var isAnimating: Bool = false

    var body: some View {
        GeometryReader { (geometry: GeometryProxy) in
            ForEach(0..<5) { index in
                Group {
                    Circle()
                        .frame(width: geometry.size.width / 5, height: geometry.size.height / 5)
                        .scaleEffect(!self.isAnimating ? 1 - CGFloat(index) / 5 : 0.2 + CGFloat(index) / 5)
                        .offset(y: geometry.size.width / 10 - CGFloat(index) * geometry.size.height / 5)
                }.frame(width: geometry.size.width, height: geometry.size.height)
            }
        }
        .aspectRatio(1, contentMode: .fit)
        .rotationEffect(!self.isAnimating ? .degrees(0) : .degrees(360))
        .animation(Animation.timingOut(withDuration: 2.0, curve: .linear).repeatForever(autoreverses: false))
        .onAppear {
            self.isAnimating = true
        }
    }
}
```

上記の`LoadingView`では、5つの円を時間差で拡大縮小させ、全体を回転させることでローディングインジケーターとしてのビジュアルを実現しています。

これらのViewは、アプリケーション内のどの画面からでも表示できます。例えば、何かの処理を行っている間ローディングを表示したい場合、以下のようにして`LoadingView`を表示できます：

```swift
import SwiftUI

struct ContentView: View {
    @State private var isLoading: Bool = false

    var body: some View {
        ZStack {
            // Main content
            // ...

            // Loading indicator
            if isLoading {
                LoadingView()
            }
        }
        .onAppear {
            startLoading()
        }
    }

    private func startLoading() {
        isLoading = true

        // Simulate a long running task
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
            isLoading = false

---

## 👤 ユーザー
*2023/5/31 21:19:45*

つづき

---

## 🤖 アシスタント
*2023/5/31 21:20:00*

```swift
        }
    }
}
```

上記の`ContentView`では、`isLoading`という`@State`変数を使用してローディングの表示・非表示を制御しています。何かの処理を開始する前に`isLoading`を`true`にセットし、処理が終わったら`false`にセットすることで、処理中のみローディングが表示されるようになります。

このように、SwiftUIを使用してカスタムローディングViewを作成することは非常に簡単で、非常に効率的にアプリケーションのユーザ体験を向上させることができます。

---

## 👤 ユーザー
*2023/5/31 21:20:30*

ある画面のViewでAPIリクストをViewModel経由で行った場合にローディングさせたい場合はどうやって書くの？

---

## 🤖 アシスタント
*2023/5/31 21:21:17*

ViewModelを使ってAPIリクエストを行い、その間にローディングを表示する場合、まずViewModel内でリクエストの状態を管理するためのプロパティを追加します。そのプロパティの変化に応じてローディングの表示を切り替えることができます。

以下にその一例を示します：

```swift
import SwiftUI
import Combine

// ViewModel
class ExampleViewModel: ObservableObject {
    @Published var isLoading: Bool = false
    var cancellables = Set<AnyCancellable>()
    
    func loadData() {
        isLoading = true
        // simulate API request
        Just("Data")
            .delay(for: .seconds(2), scheduler: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { _ in
                    self.isLoading = false
            })
            .store(in: &cancellables)
    }
}

// Loading View
struct LoadingView: View {
    var body: some View {
        ProgressView()
            .progressViewStyle(CircularProgressViewStyle(tint: .blue))
            .scaleEffect(2)
    }
}

// Content View
struct ContentView: View {
    @ObservedObject var viewModel = ExampleViewModel()

    var body: some View {
        ZStack {
            // Main content
            VStack {
                Button("Load Data") {
                    viewModel.loadData()
                }
            }
            
            // Loading indicator
            if viewModel.isLoading {
                LoadingView()
            }
        }
    }
}
```

この例では、`ExampleViewModel`に`isLoading`という`@Published`プロパティを追加しています。`loadData`メソッドが呼ばれた時に`isLoading`を`true`にセットし、データのロードが完了したら`false`にセットしています。

また、`ContentView`では、この`viewModel`を`@ObservedObject`として監視し、`isLoading`の値に応じて`LoadingView`を表示または非表示にしています。

---

## 👤 ユーザー
*2023/5/31 21:22:29*

複数の画面で、使いたい場合はどうすれば良いか？ 各画面でisLoadingするのは大変だと思う

---

## 🤖 アシスタント
*2023/5/31 21:23:21*

そのような場合、`EnvironmentObject`を使用すると便利です。`EnvironmentObject`を使うと、アプリケーション全体で共有することができる共有データを作成できます。

ここでは`LoadingState`という新たなクラスを作成し、アプリケーション全体でローディングの状態を共有することを考えます：

```swift
import SwiftUI
import Combine

// Loading State
class LoadingState: ObservableObject {
    @Published var isLoading: Bool = false
}

// ViewModel
class ExampleViewModel: ObservableObject {
    @EnvironmentObject var loadingState: LoadingState
    var cancellables = Set<AnyCancellable>()
    
    func loadData() {
        loadingState.isLoading = true
        // simulate API request
        Just("Data")
            .delay(for: .seconds(2), scheduler: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { _ in
                    self.loadingState.isLoading = false
            })
            .store(in: &cancellables)
    }
}

// Loading View
struct LoadingView: View {
    @EnvironmentObject var loadingState: LoadingState

    var body: some View {
        if loadingState.isLoading {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: .blue))
                .scaleEffect(2)
        }
    }
}

// Content View
struct ContentView: View {
    @ObservedObject var viewModel = ExampleViewModel()

    var body: some View {
        ZStack {
            // Main content
            VStack {
                Button("Load Data") {
                    viewModel.loadData()
                }
            }
            
            // Loading indicator
            LoadingView()
        }
    }
}
```

そして、アプリケーションの起動時に`LoadingState`を`EnvironmentObject`として注入します：

```swift
@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(LoadingState())
        }
    }
}
```

これで、`LoadingState`はアプリケーション全体で共有され、どの画面でもローディングの状態を参照することができます。なお、`@EnvironmentObject`はビューの階層のどこからでもアクセスできるため、深くネストされたビューや異なる画面でもローディングの状態を簡単に参照できます。

---

## 👤 ユーザー
*2023/5/31 21:23:25*

ObservableObject で @EnvironmentObject は使えないでしょう

---

## 🤖 アシスタント
*2023/5/31 21:24:08*

おっしゃるとおりで、`ObservableObject`は`@EnvironmentObject`プロパティラッパーを直接サポートしていません。すみません、私の説明で混乱を招いてしまったかもしれません。それを補正するために、ViewModelがローディング状態を操作するために、`LoadingState`インスタンスを明示的に注入する必要があります。

そのため、`ExampleViewModel`と`ContentView`を以下のように修正します：

```swift
// ViewModel
class ExampleViewModel: ObservableObject {
    var loadingState: LoadingState
    var cancellables = Set<AnyCancellable>()

    init(loadingState: LoadingState) {
        self.loadingState = loadingState
    }
    
    func loadData() {
        loadingState.isLoading = true
        // simulate API request
        Just("Data")
            .delay(for: .seconds(2), scheduler: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { _ in
                    self.loadingState.isLoading = false
            })
            .store(in: &cancellables)
    }
}

// Content View
struct ContentView: View {
    @EnvironmentObject var loadingState: LoadingState
    @ObservedObject var viewModel: ExampleViewModel

    init(loadingState: LoadingState) {
        self.loadingState = loadingState
        self.viewModel = ExampleViewModel(loadingState: loadingState)
    }

    var body: some View {
        ZStack {
            // Main content
            VStack {
                Button("Load Data") {
                    viewModel.loadData()
                }
            }
            
            // Loading indicator
            LoadingView()
        }
    }
}
```

このように、ViewModelの初期化時に`LoadingState`を注入します。そして、ボタンをタップすると`viewModel.loadData()`を呼び出し、それが`LoadingState`の`isLoading`を変更します。これにより、全ての画面でローディングの状態を一貫して管理できます。

---

## 👤 ユーザー
*2023/5/31 21:24:28*

ContentView の initにloadingStateを持ってこないといけないの？

---

## 🤖 アシスタント
*2023/5/31 21:25:33*

ご指摘の通り、ContentViewの`init`メソッドで`loadingState`を受け取ることは必要ありません。`@EnvironmentObject`プロパティラッパーを使うと、ビューが表示されるときに自動的にその環境オブジェクトが注入されます。ただし、`ExampleViewModel`に`LoadingState`を注入するためには、明示的にインスタンスを渡す必要があります。

以下のように修正できます：

```swift
// ViewModel
class ExampleViewModel: ObservableObject {
    var loadingState: LoadingState
    var cancellables = Set<AnyCancellable>()

    init(loadingState: LoadingState) {
        self.loadingState = loadingState
    }
    
    func loadData() {
        loadingState.isLoading = true
        // simulate API request
        Just("Data")
            .delay(for: .seconds(2), scheduler: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { _ in
                    self.loadingState.isLoading = false
            })
            .store(in: &cancellables)
    }
}

// Content View
struct ContentView: View {
    @EnvironmentObject var loadingState: LoadingState
    @ObservedObject var viewModel: ExampleViewModel

    var body: some View {
        ZStack {
            // Main content
            VStack {
                Button("Load Data") {
                    viewModel.loadData()
                }
            }
            
            // Loading indicator
            LoadingView()
        }
    }
    
    init() {
        self.viewModel = ExampleViewModel(loadingState: LoadingState())
    }
}
```

しかし、この方法では新しい`LoadingState`のインスタンスが作成されるため、他のビューと共有されません。そのため、`ContentView`の`init`メソッドでは新しい`LoadingState`を作成せず、代わりに`EnvironmentObject`から注入されるインスタンスを使用します：

```swift
// ViewModel
class ExampleViewModel: ObservableObject {
    var loadingState: LoadingState
    var cancellables = Set<AnyCancellable>()

    init(loadingState: LoadingState) {
        self.loadingState = loadingState
    }
    
    func loadData() {
        loadingState.isLoading = true
        // simulate API request
        Just("Data")
            .delay(for: .seconds(2), scheduler: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { _ in
                    self.loadingState.isLoading = false
            })
            .store(in: &cancellables)
    }
}

// Content View
struct ContentView: View {
    @EnvironmentObject var loadingState: LoadingState
    @ObservedObject var viewModel: ExampleViewModel

    var body: some View {
        ZStack {
            // Main content
            VStack {
                Button("Load Data") {
                    viewModel.loadData()
                }
            }
            
            // Loading indicator
            LoadingView()
        }
        .onAppear {
            viewModel = ExampleViewModel(loadingState: loadingState)
        }
    }
}
```

これで、`ContentView`とそのViewModelは同じ`LoadingState`インスタンスを共有し、全てのビューでローディングの状態を一貫して管理できます。

---
