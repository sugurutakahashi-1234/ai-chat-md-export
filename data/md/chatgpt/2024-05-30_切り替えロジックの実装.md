# 切り替えロジックの実装

日付: 2024-05-30

---

## 👤 ユーザー
*2024/5/30 14:16:07*

このViewについてselectedApiによってResponseViewやPropertyViewのobjectsの引数に使う値を入れ替えたい

import SwiftUI
import OpenAPIURLSession
import SimpleToast
import Shimmer

enum ApiType: CaseIterable {
    case getUsers
    case getUser
}

enum ApiError: LocalizedError {
    case notFound
    case undocumented
    
    // alert title
    var errorDescription: String? {
        "\\(self)"
    }
}

public struct ContentView: View {
    @State var showToast: Bool = false
    @State var getUsersResponse: \[Components.Schemas.User\] = \[\]
    @State var getUserByIdResponse: \[Components.Schemas.User\] = \[\]
    @State var userId: Int = 1
    @State var selectedApi: ApiType = .getUser
    @State var isLoading: Bool = false
    @State var showAlert: Bool = false
    @State var apiError: ApiError?
    let client: Client

    public init() {
        self.client = Client(
            serverURL: try! Servers.server1(),
            transport: URLSessionTransport()
        )
    }

    public var body: some View {
        NavigationStack {
            List {
                Picker("API", selection: $selectedApi) {
                    Text("getUsers")
                        .tag(ApiType.getUsers)
                    Text("getUser").tag(ApiType.getUser)
                }
                .pickerStyle(.navigationLink)

                if selectedApi == .getUser {
                    TextField("User id", value: $userId, format: .number)
                }

                Button {
                    Task {
                        await executeSelectedAPI()
                    }
                } label: {
                    Text("Execute")
                }
    
                ResponseView(objects: getUserByIdResponse)
                    .redacted(reason: isLoading ? .placeholder : \[\])
                    .shimmering(active: isLoading)

                PropertyView(showToast: $showToast, objects: getUserByIdResponse)
                    .redacted(reason: isLoading ? .placeholder : \[\])
                    .shimmering(active: isLoading)
            }
            .simpleToast(isPresented: $showToast, options: SimpleToastOptions(
                alignment: .bottom,
                hideAfter: 1
            )) {
                Label {
                    Text("Copy")
                } icon: {
                    Image(systemName: "checkmark.circle")
                }
                .padding()
                .background(Color.green.opacity(0.8))
                .foregroundColor(Color.white)
                .cornerRadius(12)
                .padding(.top)
            }
        }
        .alert(isPresented: $showAlert, error: apiError) { 
            Button("OK") {}
        }
    }
    
    func executeSelectedAPI() async {
        switch selectedApi {
        case .getUsers:
            await getUsers()
        case .getUser:
            await getUserById(id: userId)
        }
    }

    private func getUsers() async {
        isLoading = true
        defer {
            isLoading = false
        }
        
        let response = try! await client.getUsers()
        
        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let users):
                self.getUsersResponse = users
            }
        case .notFound(let notFoundResponse):
            switch notFoundResponse.body {
            case .json(let error):
                print("\\(error)")
                apiError = .notFound
                showAlert = true
            }
        case .undocumented(statusCode: let statusCode, \_):
            print("\\(statusCode)")
            apiError = .undocumented
            showAlert = true
        }
    }

    private func getUserById(id: Int) async {
        isLoading = true
        defer {
            isLoading = false
        }

        let response = try! await client.getUserById(path: .init(id: id))

        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let user):
                self.getUserByIdResponse = \[user\]
            }
        case .notFound(let notFoundResponse):
            switch notFoundResponse.body {
            case .json(let error):
                print("\\(error)")
                apiError = .notFound
                showAlert = true
            }
        case .undocumented(statusCode: let statusCode, \_):
            print("\\(statusCode)")
            apiError = .undocumented
            showAlert = true
        }
    }
}

#Preview {
    ContentView()
}

---

## 🤖 アシスタント
*2024/5/30 14:16:31*

`ResponseView`と`PropertyView`の`objects`引数に使用する値を`selectedApi`によって切り替えるために、`selectedApi`の状態に応じて適切な値を渡すロジックを実装できます。以下のように修正することで、それぞれのビューに渡すデータを切り替えることができます。

```swift
import SwiftUI
import OpenAPIURLSession
import SimpleToast
import Shimmer

enum ApiType: CaseIterable {
    case getUsers
    case getUser
}

enum ApiError: LocalizedError {
    case notFound
    case undocumented
    
    // alert title
    var errorDescription: String? {
        "\(self)"
    }
}

public struct ContentView: View {
    @State var showToast: Bool = false
    @State var getUsersResponse: [Components.Schemas.User] = []
    @State var getUserByIdResponse: [Components.Schemas.User] = []
    @State var userId: Int = 1
    @State var selectedApi: ApiType = .getUser
    @State var isLoading: Bool = false
    @State var showAlert: Bool = false
    @State var apiError: ApiError?
    let client: Client

    public init() {
        self.client = Client(
            serverURL: try! Servers.server1(),
            transport: URLSessionTransport()
        )
    }

    public var body: some View {
        NavigationStack {
            List {
                Picker("API", selection: $selectedApi) {
                    Text("getUsers").tag(ApiType.getUsers)
                    Text("getUser").tag(ApiType.getUser)
                }
                .pickerStyle(.navigationLink)

                if selectedApi == .getUser {
                    TextField("User id", value: $userId, format: .number)
                }

                Button {
                    Task {
                        await executeSelectedAPI()
                    }
                } label: {
                    Text("Execute")
                }

                let responseObjects: [Components.Schemas.User] = selectedApi == .getUsers ? getUsersResponse : getUserByIdResponse
                
                ResponseView(objects: responseObjects)
                    .redacted(reason: isLoading ? .placeholder : [])
                    .shimmering(active: isLoading)

                PropertyView(showToast: $showToast, objects: responseObjects)
                    .redacted(reason: isLoading ? .placeholder : [])
                    .shimmering(active: isLoading)
            }
            .simpleToast(isPresented: $showToast, options: SimpleToastOptions(
                alignment: .bottom,
                hideAfter: 1
            )) {
                Label {
                    Text("Copy")
                } icon: {
                    Image(systemName: "checkmark.circle")
                }
                .padding()
                .background(Color.green.opacity(0.8))
                .foregroundColor(Color.white)
                .cornerRadius(12)
                .padding(.top)
            }
        }
        .alert(isPresented: $showAlert, error: apiError) { 
            Button("OK") {}
        }
    }

    func executeSelectedAPI() async {
        switch selectedApi {
        case .getUsers:
            await getUsers()
        case .getUser:
            await getUserById(id: userId)
        }
    }

    private func getUsers() async {
        isLoading = true
        defer {
            isLoading = false
        }
        
        let response = try! await client.getUsers()
        
        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let users):
                self.getUsersResponse = users
            }
        case .notFound(let notFoundResponse):
            switch notFoundResponse.body {
            case .json(let error):
                print("\(error)")
                apiError = .notFound
                showAlert = true
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
            apiError = .undocumented
            showAlert = true
        }
    }

    private func getUserById(id: Int) async {
        isLoading = true
        defer {
            isLoading = false
        }

        let response = try! await client.getUserById(path: .init(id: id))

        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let user):
                self.getUserByIdResponse = [user]
            }
        case .notFound(let notFoundResponse):
            switch notFoundResponse.body {
            case .json(let error):
                print("\(error)")
                apiError = .notFound
                showAlert = true
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
            apiError = .undocumented
            showAlert = true
        }
    }
}

#Preview {
    ContentView()
}
```

この修正では、`selectedApi`に基づいて`responseObjects`を決定し、それを`ResponseView`と`PropertyView`に渡しています。これにより、APIの選択に応じて適切なデータを表示することができます。

---

## 👤 ユーザー
*2024/5/30 14:17:18*

もっとAPIが増える可能性があるのでswitch文で記述してほしい

---

## 🤖 アシスタント
*2024/5/30 14:17:49*

将来的にAPIが増える可能性を考慮し、`switch`文を使用して`ResponseView`と`PropertyView`の`objects`引数に渡すデータを切り替える実装に変更します。

```swift
import SwiftUI
import OpenAPIURLSession
import SimpleToast
import Shimmer

enum ApiType: CaseIterable {
    case getUsers
    case getUser
}

enum ApiError: LocalizedError {
    case notFound
    case undocumented
    
    // alert title
    var errorDescription: String? {
        "\(self)"
    }
}

public struct ContentView: View {
    @State var showToast: Bool = false
    @State var getUsersResponse: [Components.Schemas.User] = []
    @State var getUserByIdResponse: [Components.Schemas.User] = []
    @State var userId: Int = 1
    @State var selectedApi: ApiType = .getUser
    @State var isLoading: Bool = false
    @State var showAlert: Bool = false
    @State var apiError: ApiError?
    let client: Client

    public init() {
        self.client = Client(
            serverURL: try! Servers.server1(),
            transport: URLSessionTransport()
        )
    }

    public var body: some View {
        NavigationStack {
            List {
                Picker("API", selection: $selectedApi) {
                    Text("getUsers").tag(ApiType.getUsers)
                    Text("getUser").tag(ApiType.getUser)
                }
                .pickerStyle(.navigationLink)

                if selectedApi == .getUser {
                    TextField("User id", value: $userId, format: .number)
                }

                Button {
                    Task {
                        await executeSelectedAPI()
                    }
                } label: {
                    Text("Execute")
                }

                let responseObjects: [Components.Schemas.User]
                switch selectedApi {
                case .getUsers:
                    responseObjects = getUsersResponse
                case .getUser:
                    responseObjects = getUserByIdResponse
                }

                ResponseView(objects: responseObjects)
                    .redacted(reason: isLoading ? .placeholder : [])
                    .shimmering(active: isLoading)

                PropertyView(showToast: $showToast, objects: responseObjects)
                    .redacted(reason: isLoading ? .placeholder : [])
                    .shimmering(active: isLoading)
            }
            .simpleToast(isPresented: $showToast, options: SimpleToastOptions(
                alignment: .bottom,
                hideAfter: 1
            )) {
                Label {
                    Text("Copy")
                } icon: {
                    Image(systemName: "checkmark.circle")
                }
                .padding()
                .background(Color.green.opacity(0.8))
                .foregroundColor(Color.white)
                .cornerRadius(12)
                .padding(.top)
            }
        }
        .alert(isPresented: $showAlert, error: apiError) { 
            Button("OK") {}
        }
    }

    func executeSelectedAPI() async {
        switch selectedApi {
        case .getUsers:
            await getUsers()
        case .getUser:
            await getUserById(id: userId)
        }
    }

    private func getUsers() async {
        isLoading = true
        defer {
            isLoading = false
        }
        
        let response = try! await client.getUsers()
        
        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let users):
                self.getUsersResponse = users
            }
        case .notFound(let notFoundResponse):
            switch notFoundResponse.body {
            case .json(let error):
                print("\(error)")
                apiError = .notFound
                showAlert = true
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
            apiError = .undocumented
            showAlert = true
        }
    }

    private func getUserById(id: Int) async {
        isLoading = true
        defer {
            isLoading = false
        }

        let response = try! await client.getUserById(path: .init(id: id))

        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let user):
                self.getUserByIdResponse = [user]
            }
        case .notFound(let notFoundResponse):
            switch notFoundResponse.body {
            case .json(let error):
                print("\(error)")
                apiError = .notFound
                showAlert = true
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
            apiError = .undocumented
            showAlert = true
        }
    }
}

#Preview {
    ContentView()
}
```

この修正により、`selectedApi`の値に基づいて`switch`文を使用して適切な`responseObjects`を選択し、それを`ResponseView`および`PropertyView`に渡すようにしました。これにより、将来的にAPIが増えても、同様の方法で簡単に対応できます。

---

## 👤 ユーザー
*2024/5/30 14:39:13*

View内のコードにビジネスロジックを含めたくない

                let responseObjects: \[Components.Schemas.User\]
                switch selectedApi {
                case .getUsers:
                    responseObjects = getUsersResponse
                case .getUser:
                    responseObjects = getUserByIdResponse
                }

---

## 🤖 アシスタント
*2024/5/30 14:39:47*

ビジネスロジックをViewから分離するために、ViewModelを使用してロジックを管理する方法を実装します。ViewModelを導入し、APIの選択に応じて適切なデータを返すメソッドを追加します。

以下はその実装例です。

```swift
import SwiftUI
import OpenAPIURLSession
import SimpleToast
import Shimmer

enum ApiType: CaseIterable {
    case getUsers
    case getUser
}

enum ApiError: LocalizedError {
    case notFound
    case undocumented
    
    // alert title
    var errorDescription: String? {
        "\(self)"
    }
}

class ContentViewModel: ObservableObject {
    @Published var showToast: Bool = false
    @Published var getUsersResponse: [Components.Schemas.User] = []
    @Published var getUserByIdResponse: [Components.Schemas.User] = []
    @Published var userId: Int = 1
    @Published var selectedApi: ApiType = .getUser
    @Published var isLoading: Bool = false
    @Published var showAlert: Bool = false
    @Published var apiError: ApiError?
    
    let client: Client

    init() {
        self.client = Client(
            serverURL: try! Servers.server1(),
            transport: URLSessionTransport()
        )
    }
    
    var responseObjects: [Components.Schemas.User] {
        switch selectedApi {
        case .getUsers:
            return getUsersResponse
        case .getUser:
            return getUserByIdResponse
        }
    }

    func executeSelectedAPI() async {
        switch selectedApi {
        case .getUsers:
            await getUsers()
        case .getUser:
            await getUserById(id: userId)
        }
    }

    private func getUsers() async {
        isLoading = true
        defer {
            isLoading = false
        }
        
        let response = try! await client.getUsers()
        
        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let users):
                self.getUsersResponse = users
            }
        case .notFound(let notFoundResponse):
            switch notFoundResponse.body {
            case .json(let error):
                print("\(error)")
                apiError = .notFound
                showAlert = true
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
            apiError = .undocumented
            showAlert = true
        }
    }

    private func getUserById(id: Int) async {
        isLoading = true
        defer {
            isLoading = false
        }

        let response = try! await client.getUserById(path: .init(id: id))

        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let user):
                self.getUserByIdResponse = [user]
            }
        case .notFound(let notFoundResponse):
            switch notFoundResponse.body {
            case .json(let error):
                print("\(error)")
                apiError = .notFound
                showAlert = true
            }
        case .undocumented(statusCode: let statusCode, _):
            print("\(statusCode)")
            apiError = .undocumented
            showAlert = true
        }
    }
}

public struct ContentView: View {
    @StateObject private var viewModel = ContentViewModel()

    public var body: some View {
        NavigationStack {
            List {
                Picker("API", selection: $viewModel.selectedApi) {
                    Text("getUsers").tag(ApiType.getUsers)
                    Text("getUser").tag(ApiType.getUser)
                }
                .pickerStyle(.navigationLink)

                if viewModel.selectedApi == .getUser {
                    TextField("User id", value: $viewModel.userId, format: .number)
                }

                Button {
                    Task {
                        await viewModel.executeSelectedAPI()
                    }
                } label: {
                    Text("Execute")
                }

                ResponseView(objects: viewModel.responseObjects)
                    .redacted(reason: viewModel.isLoading ? .placeholder : [])
                    .shimmering(active: viewModel.isLoading)

                PropertyView(showToast: $viewModel.showToast, objects: viewModel.responseObjects)
                    .redacted(reason: viewModel.isLoading ? .placeholder : [])
                    .shimmering(active: viewModel.isLoading)
            }
            .simpleToast(isPresented: $viewModel.showToast, options: SimpleToastOptions(
                alignment: .bottom,
                hideAfter: 1
            )) {
                Label {
                    Text("Copy")
                } icon: {
                    Image(systemName: "checkmark.circle")
                }
                .padding()
                .background(Color.green.opacity(0.8))
                .foregroundColor(Color.white)
                .cornerRadius(12)
                .padding(.top)
            }
        }
        .alert(isPresented: $viewModel.showAlert, error: viewModel.apiError) { 
            Button("OK") {}
        }
    }
}

#Preview {
    ContentView()
}
```

この実装では、`ContentViewModel`を導入し、すべてのビジネスロジックをViewModel内に移動しました。View側ではViewModelを使用して状態を管理し、UIを更新するだけにしています。これにより、コードの責任範囲が明確になり、テストやメンテナンスが容易になります。

---
