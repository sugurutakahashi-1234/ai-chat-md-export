# スネークケースの辞書キー変換

日付: 2023-06-08

---

## 👤 ユーザー
*2023/06/08 19:13:19*

Swiftで辞書型のキーを文字列で設定しているのですが、エンコーダブルに対応して、スネークケースとかにしたいだどうすればいい。

---

## 🤖 アシスタント
*2023/06/08 19:14:04*

Swiftでは、`Encodable` および `Decodable` プロトコルを使用してJSONをエンコード/デコードすることができます。これを利用してキーをスネークケースに変換することも可能です。

具体的には、`JSONEncoder` や `JSONDecoder` の `keyDecodingStrategy` や `keyEncodingStrategy` を `.convertFromSnakeCase` や `.convertToSnakeCase` に設定することで、キーの変換を行うことができます。

例えば、次のような構造体があるとします:

```swift
struct MyStruct: Codable {
    let someKey: String
}
```

この構造体をエンコードするときに、キーをスネークケースに変換するには以下のようにします:

```swift
let myStruct = MyStruct(someKey: "some value")

let encoder = JSONEncoder()
encoder.keyEncodingStrategy = .convertToSnakeCase

do {
    let jsonData = try encoder.encode(myStruct)
    if let jsonString = String(data: jsonData, encoding: .utf8) {
        print(jsonString)
        // prints: {"some_key":"some value"}
    }
} catch {
    print("Error encoding: \(error)")
}
```

また、JSONデータをデコードするときに、キーをスネークケースからキャメルケースに変換するには以下のようにします:

```swift
let jsonString = "{\"some_key\":\"some value\"}"
if let jsonData = jsonString.data(using: .utf8) {
    let decoder = JSONDecoder()
    decoder.keyDecodingStrategy = .convertFromSnakeCase

    do {
        let myStruct = try decoder.decode(MyStruct.self, from: jsonData)
        print(myStruct.someKey)
        // prints: "some value"
    } catch {
        print("Error decoding: \(error)")
    }
}
```

以上のように、`keyEncodingStrategy` と `keyDecodingStrategy` を設定することで、エンコード/デコード時のキーのケースを変換することができます。

---

## 👤 ユーザー
*2023/06/08 19:14:26*

こうゆうのをエンコーダブルのstructを別に作って欲しかった

fileprivate extension CGSize {
    var dict: [String: Double] {
        [
            "width": width,
            "height": height
        ]
    }
}

---

## 🤖 アシスタント
*2023/06/08 19:15:05*

指定された `CGSize` の拡張に対する `Codable` サポートを提供するために、カスタム `Encodable` および `Decodable` の実装を追加できます。スネークケースのキーを使用したい場合、`CodingKeys` を使用してキーを定義します。

```swift
import CoreGraphics

extension CGSize: Encodable {
    enum CodingKeys: String, CodingKey {
        case width
        case height
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(width, forKey: .width)
        try container.encode(height, forKey: .height)
    }
}

extension CGSize: Decodable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.init()
        width = try container.decode(CGFloat.self, forKey: .width)
        height = try container.decode(CGFloat.self, forKey: .height)
    }
}
```

こうすることで `CGSize` が直接 `Encodable` と `Decodable` を満たすため、スネークケースのキーを使用して `CGSize` をエンコードおよびデコードできます。

なお、`Encoder` や `Decoder` の `keyEncodingStrategy` または `keyDecodingStrategy` を `.convertToSnakeCase` または `.convertFromSnakeCase` に設定することで、キーを自動的にスネークケースに変換することができます。

この方法では `CGSize` のプロパティが `Double` ではなく `CGFloat` であるため、直接 `Double` をデコードしようとするとエラーが発生します。そのため、上記のコードでは `CGFloat` を直接エンコードおよびデコードしています。

---

## 👤 ユーザー
*2023/06/08 19:16:34*

別にstruct Size: Encodable みたいな定義を作ってそれに変換するのはどう❓

---

## 🤖 アシスタント
*2023/06/08 19:17:14*

要望に合わせて `CGSize` の代わりに使用する別のエンコード可能な `Size` 構造体を作成することも可能です。

```swift
import CoreGraphics

struct Size: Encodable {
    let width: Double
    let height: Double
    
    // イニシャライザで CGSize を受け取り、width と height を変換します
    init(from size: CGSize) {
        self.width = Double(size.width)
        self.height = Double(size.height)
    }
    
    enum CodingKeys: String, CodingKey {
        case width
        case height
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(width, forKey: .width)
        try container.encode(height, forKey: .height)
    }
}
```

これにより、あなたの `CGSize` を `Size` に変換し、それをエンコードすることができます。

```swift
let cgSize = CGSize(width: 10, height: 20)
let size = Size(from: cgSize)

let encoder = JSONEncoder()
encoder.keyEncodingStrategy = .convertToSnakeCase

do {
    let jsonData = try encoder.encode(size)
    if let jsonString = String(data: jsonData, encoding: .utf8) {
        print(jsonString)
        // prints: {"width":10,"height":20}
    }
} catch {
    print("Error encoding: \(error)")
}
```

この例では `CGSize` の `width` と `height` を `Double` に変換してから `Size` オブジェクトに保存しています。そして、その `Size` オブジェクトをエンコードしています。この方法であれば、キーをスネークケースに変換するために `keyEncodingStrategy` を設定することも可能です。

---

## 👤 ユーザー
*2023/06/08 19:17:29*

func encode(to encoder: Encoder) throws {} の記述って省略できないの？

---

## 🤖 アシスタント
*2023/06/08 19:18:11*

Swiftの `Encodable` プロトコルに準拠する場合、 `encode(to encoder: Encoder) throws` というメソッドを提供する必要があります。しかし、プロパティがすべて自分自身で `Encodable` を満たしている場合（つまり、プロパティがすべて `Encodable` プロトコルに準拠している型である場合）には、このメソッドの実装を省略することが可能です。

例えば次のように書けます：

```swift
import CoreGraphics

struct Size: Encodable {
    let width: Double
    let height: Double
    
    init(from size: CGSize) {
        self.width = Double(size.width)
        self.height = Double(size.height)
    }
}
```

このコードでは `Size` は `Encodable` プロトコルに準拠していますが、 `encode(to:)` メソッドは明示的に実装していません。これは、 `width` と `height` プロパティがどちらも `Encodable` プロトコルに準拠している `Double` 型であるため、Swiftが自動的にこれらのプロパティをエンコードする方法を理解しているからです。

したがって、カスタムのエンコードロジック（特殊な条件でプロパティをエンコードする、一部のプロパティを無視するなど）が必要ない限り、 `encode(to:)` メソッドの実装を省略することができます。

---
