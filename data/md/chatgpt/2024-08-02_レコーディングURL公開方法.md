# ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°URLå…¬é–‹æ–¹æ³•

æ—¥ä»˜: 2024-08-02

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/8/2 15:29:48*

ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®urlã‚’ã†ã¾ãDriverå¤–ã§ã‚‚æ‰±ãˆã‚‹ã‚ˆã†ã«ã—ãŸã„ã€‚

public final class RecordingDriver: RecordingDriverProtocol {
    private nonisolated(unsafe) var audioRecorder: AVAudioRecorder?

    private nonisolated(unsafe) let isRecordingSubject = PassthroughSubject&lt;Bool, Never&gt;()
    public var isRecordingPublisher: AnyPublisher&lt;Bool, Never&gt; {
        isRecordingSubject.eraseToAnyPublisher()
    }

    /// second (s)
    private nonisolated(unsafe) let recordingTimeSubject = CurrentValueSubject&lt;Int, Never&gt;(0)
    public var recordingTimePublisher: AnyPublisher&lt;Int, Never&gt; {
        recordingTimeSubject.eraseToAnyPublisher()
    }

    /// Audio Power (0.0 - 1.0)
    private nonisolated(unsafe) var audioVolumeLevelSubject = CurrentValueSubject&lt;Double, Never&gt;(0.0)
    public var audioVolumeLevelPublisher: AnyPublisher&lt;Double, Never&gt; {
        audioVolumeLevelSubject.eraseToAnyPublisher()
    }

    // TODO: ã“ã®å®Ÿè£…ã¯ã‚ˆããªã„ãŒæ¤œè¨¼ã‚³ãƒ¼ãƒ‰ãªã®ã§ãã†ã—ã¦ã„ã‚‹ã ã‘ã§ã‚ã‚Šã€ã„ã¤ã‹å‰Šé™¤ã™ã‚‹
    private nonisolated(unsafe) var isEnabledAudioSessionCache: Bool = false

    private nonisolated(unsafe) var recordingTimer = Set&lt;AnyCancellable&gt;()
    private nonisolated(unsafe) var meteringTimer = Set&lt;AnyCancellable&gt;()

    private nonisolated(unsafe) var meteringTimerInterval: TimeInterval = 0.05

    public init() {}

    public func setMeteringTimerInterval(interval: TimeInterval) {
        meteringTimerInterval = interval
    }

    public func startRecording(recordingConfig: RecordingConfig) async throws {
        let audioFilename = Constants.FilePath.audioDirectory
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue,
        ]

        await SystemSoundStaticDriver.play(systemSoundType: .startRecording)

        isEnabledAudioSessionCache = recordingConfig.isEnabledAudioSession
        if recordingConfig.isEnabledAudioSession {
            try AVAudioSession.sharedInstance().setCategory(
                recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
                mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
                options: []
            )
            OSLogger.debugLog("Start: session active")
            try AVAudioSession.sharedInstance().setActive(true)
            OSLogger.debugLog("Completed: session active")
        }

        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()

        // ä¸Šè¨˜ã¾ã§ã®å‡¦ç†ã¯ã‚¤ãƒ‹ã‚·ãƒ£ãƒ©ã‚¤ã‚¶ã§è¡Œã£ã¦ã‚‚è‰¯ã„ã‹ã‚‚ã—ã‚Œãªã„
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")

        startRecordingTimer()
        startMeteringTimer()
    }

    public func stopRecording() async throws {
        guard let audioRecorder, audioRecorder.isRecording else {
            return
        }

        stopRecordingTimer()
        stopMeteringTimer()

        OSLogger.debugLog("Start: stop recording")
        audioRecorder.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        if isEnabledAudioSessionCache {
            OSLogger.debugLog("Start: session unactive")
            try AVAudioSession.sharedInstance().setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        }

        await SystemSoundStaticDriver.play(systemSoundType: .stopRecording)
    }

    private func startRecordingTimer() {
        recordingTimeSubject.value = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTimeSubject.value += 1
            }
            .store(in: &recordingTimer)
    }

    private func stopRecordingTimer() {
        recordingTimer.forEach { $0.cancel() }
    }

    private func startMeteringTimer() {
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { [weak self] _ in
                guard let self else {
                    return nil
                }
                audioRecorder?.updateMeters()
                return AudioHelpStaticDriver.normalized(decibel: Double(audioRecorder?.averagePower(forChannel: 0) ?? -80))
            }
            .assign(to: \.value, on: audioVolumeLevelSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/8/2 15:29:58*

ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®URLã‚’Driverå¤–ã§ã‚‚æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€æ¬¡ã®å¤‰æ›´ã‚’è¡Œã„ã¾ã™ã€‚

1. URLã‚’å…¬é–‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦æä¾›ã™ã‚‹ã€‚
2. ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹æ™‚ã«ã“ã®URLã‚’è¨­å®šã™ã‚‹ã€‚

ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã‚’æ›´æ–°ã—ã¾ã™ï¼š

```swift
public final class RecordingDriver: RecordingDriverProtocol {
    private nonisolated(unsafe) var audioRecorder: AVAudioRecorder?

    private nonisolated(unsafe) let isRecordingSubject = PassthroughSubject<Bool, Never>()
    public var isRecordingPublisher: AnyPublisher<Bool, Never> {
        isRecordingSubject.eraseToAnyPublisher()
    }

    /// second (s)
    private nonisolated(unsafe) let recordingTimeSubject = CurrentValueSubject<Int, Never>(0)
    public var recordingTimePublisher: AnyPublisher<Int, Never> {
        recordingTimeSubject.eraseToAnyPublisher()
    }

    /// Audio Power (0.0 - 1.0)
    private nonisolated(unsafe) var audioVolumeLevelSubject = CurrentValueSubject<Double, Never>(0.0)
    public var audioVolumeLevelPublisher: AnyPublisher<Double, Never> {
        audioVolumeLevelSubject.eraseToAnyPublisher()
    }

    // TODO: ã“ã®å®Ÿè£…ã¯ã‚ˆããªã„ãŒæ¤œè¨¼ã‚³ãƒ¼ãƒ‰ãªã®ã§ãã†ã—ã¦ã„ã‚‹ã ã‘ã§ã‚ã‚Šã€ã„ã¤ã‹å‰Šé™¤ã™ã‚‹
    private nonisolated(unsafe) var isEnabledAudioSessionCache: Bool = false

    private nonisolated(unsafe) var recordingTimer = Set<AnyCancellable>()
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()

    private nonisolated(unsafe) var meteringTimerInterval: TimeInterval = 0.05
    
    public private(set) var recordingURL: URL?

    public init() {}

    public func setMeteringTimerInterval(interval: TimeInterval) {
        meteringTimerInterval = interval
    }

    public func startRecording(recordingConfig: RecordingConfig) async throws {
        recordingURL = Constants.FilePath.audioDirectory
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue,
        ]

        await SystemSoundStaticDriver.play(systemSoundType: .startRecording)

        isEnabledAudioSessionCache = recordingConfig.isEnabledAudioSession
        if recordingConfig.isEnabledAudioSession {
            try AVAudioSession.sharedInstance().setCategory(
                recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
                mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
                options: []
            )
            OSLogger.debugLog("Start: session active")
            try AVAudioSession.sharedInstance().setActive(true)
            OSLogger.debugLog("Completed: session active")
        }

        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: recordingURL!, settings: settings)
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()

        // ä¸Šè¨˜ã¾ã§ã®å‡¦ç†ã¯ã‚¤ãƒ‹ã‚·ãƒ£ãƒ©ã‚¤ã‚¶ã§è¡Œã£ã¦ã‚‚è‰¯ã„ã‹ã‚‚ã—ã‚Œãªã„
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")

        startRecordingTimer()
        startMeteringTimer()
    }

    public func stopRecording() async throws {
        guard let audioRecorder, audioRecorder.isRecording else {
            return
        }

        stopRecordingTimer()
        stopMeteringTimer()

        OSLogger.debugLog("Start: stop recording")
        audioRecorder.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        if isEnabledAudioSessionCache {
            OSLogger.debugLog("Start: session unactive")
            try AVAudioSession.sharedInstance().setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        }

        await SystemSoundStaticDriver.play(systemSoundType: .stopRecording)
    }

    private func startRecordingTimer() {
        recordingTimeSubject.value = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTimeSubject.value += 1
            }
            .store(in: &recordingTimer)
    }

    private func stopRecordingTimer() {
        recordingTimer.forEach { $0.cancel() }
    }

    private func startMeteringTimer() {
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { [weak self] _ in
                guard let self else {
                    return nil
                }
                audioRecorder?.updateMeters()
                return AudioHelpStaticDriver.normalized(decibel: Double(audioRecorder?.averagePower(forChannel: 0) ?? -80))
            }
            .assign(to: \.value, on: audioVolumeLevelSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}
```

ã“ã®å¤‰æ›´ã«ã‚ˆã‚Šã€`RecordingDriver`ã‚¯ãƒ©ã‚¹å¤–ã‹ã‚‰ã‚‚éŒ²éŸ³ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®URLã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚`recordingURL`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯å…¬é–‹ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€å¤–éƒ¨ã‹ã‚‰ç°¡å˜ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã§ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/8/2 15:30:36*

startRecording ã®ã¨ãã®å¼•æ•°ã«æ¸¡ã™ã®ã¯ã©ã†ï¼Ÿ

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/8/2 15:31:08*

`startRecording`ãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã¨ã—ã¦URLã‚’æ¸¡ã™ã“ã¨ã§ã€å¤–éƒ¨ã‹ã‚‰URLã‚’æŒ‡å®šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚ãã®æ–¹æ³•ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚

ã¾ãšã€`RecordingConfig`ã«`URL`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ ã—ã€URLã‚’æŒ‡å®šã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

```swift
public struct RecordingConfig {
    // ä»–ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
    var url: URL?
    // åˆæœŸåŒ–
    public init(
        // ä»–ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        url: URL? = nil
    ) {
        // ä»–ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®åˆæœŸåŒ–
        self.url = url
    }
}
```

æ¬¡ã«ã€`startRecording`ãƒ¡ã‚½ãƒƒãƒ‰ã§ã“ã®URLã‚’åˆ©ç”¨ã—ã¾ã™ã€‚æ¸¡ã•ã‚ŒãŸURLãŒnilã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®URLã‚’ç”Ÿæˆã—ã¾ã™ã€‚

```swift
public final class RecordingDriver: RecordingDriverProtocol {
    private nonisolated(unsafe) var audioRecorder: AVAudioRecorder?

    private nonisolated(unsafe) let isRecordingSubject = PassthroughSubject<Bool, Never>()
    public var isRecordingPublisher: AnyPublisher<Bool, Never> {
        isRecordingSubject.eraseToAnyPublisher()
    }

    /// second (s)
    private nonisolated(unsafe) let recordingTimeSubject = CurrentValueSubject<Int, Never>(0)
    public var recordingTimePublisher: AnyPublisher<Int, Never> {
        recordingTimeSubject.eraseToAnyPublisher()
    }

    /// Audio Power (0.0 - 1.0)
    private nonisolated(unsafe) var audioVolumeLevelSubject = CurrentValueSubject<Double, Never>(0.0)
    public var audioVolumeLevelPublisher: AnyPublisher<Double, Never> {
        audioVolumeLevelSubject.eraseToAnyPublisher()
    }

    // TODO: ã“ã®å®Ÿè£…ã¯ã‚ˆããªã„ãŒæ¤œè¨¼ã‚³ãƒ¼ãƒ‰ãªã®ã§ãã†ã—ã¦ã„ã‚‹ã ã‘ã§ã‚ã‚Šã€ã„ã¤ã‹å‰Šé™¤ã™ã‚‹
    private nonisolated(unsafe) var isEnabledAudioSessionCache: Bool = false

    private nonisolated(unsafe) var recordingTimer = Set<AnyCancellable>()
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()

    private nonisolated(unsafe) var meteringTimerInterval: TimeInterval = 0.05
    
    public private(set) var recordingURL: URL?

    public init() {}

    public func setMeteringTimerInterval(interval: TimeInterval) {
        meteringTimerInterval = interval
    }

    public func startRecording(recordingConfig: RecordingConfig) async throws {
        recordingURL = recordingConfig.url ?? Constants.FilePath.audioDirectory
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue,
        ]

        await SystemSoundStaticDriver.play(systemSoundType: .startRecording)

        isEnabledAudioSessionCache = recordingConfig.isEnabledAudioSession
        if recordingConfig.isEnabledAudioSession {
            try AVAudioSession.sharedInstance().setCategory(
                recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
                mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
                options: []
            )
            OSLogger.debugLog("Start: session active")
            try AVAudioSession.sharedInstance().setActive(true)
            OSLogger.debugLog("Completed: session active")
        }

        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: recordingURL!, settings: settings)
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()

        // ä¸Šè¨˜ã¾ã§ã®å‡¦ç†ã¯ã‚¤ãƒ‹ã‚·ãƒ£ãƒ©ã‚¤ã‚¶ã§è¡Œã£ã¦ã‚‚è‰¯ã„ã‹ã‚‚ã—ã‚Œãªã„
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")

        startRecordingTimer()
        startMeteringTimer()
    }

    public func stopRecording() async throws {
        guard let audioRecorder, audioRecorder.isRecording else {
            return
        }

        stopRecordingTimer()
        stopMeteringTimer()

        OSLogger.debugLog("Start: stop recording")
        audioRecorder.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        if isEnabledAudioSessionCache {
            OSLogger.debugLog("Start: session unactive")
            try AVAudioSession.sharedInstance().setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        }

        await SystemSoundStaticDriver.play(systemSoundType: .stopRecording)
    }

    private func startRecordingTimer() {
        recordingTimeSubject.value = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTimeSubject.value += 1
            }
            .store(in: &recordingTimer)
    }

    private func stopRecordingTimer() {
        recordingTimer.forEach { $0.cancel() }
    }

    private func startMeteringTimer() {
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { [weak self] _ in
                guard let self else {
                    return nil
                }
                audioRecorder?.updateMeters()
                return AudioHelpStaticDriver.normalized(decibel: Double(audioRecorder?.averagePower(forChannel: 0) ?? -80))
            }
            .assign(to: \.value, on: audioVolumeLevelSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}
```

ã“ã®å¤‰æ›´ã«ã‚ˆã‚Šã€`startRecording`ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚ŒãŸ`RecordingConfig`ã«URLãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®URLã‚’ä½¿ç”¨ã—ã¦éŒ²éŸ³ã‚’é–‹å§‹ã—ã¾ã™ã€‚URLãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®URLã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å¤–éƒ¨ã‹ã‚‰URLã‚’æŒ‡å®šã—ã¦éŒ²éŸ³ã‚’é–‹å§‹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/8/2 15:41:56*

stopRecording() ã§URLã‚’è¿”ã™ã“ã¨ã¯ã§ããªã„ã®ã‹ï¼Ÿã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ä½¿ã‚ãªã„æ–¹æ³•ãŒãƒ™ã‚¹ãƒˆã§ã‚ã‚‹

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/8/2 15:42:25*

`stopRecording`ãƒ¡ã‚½ãƒƒãƒ‰ã§éŒ²éŸ³ã®åœæ­¢ã¨ã¨ã‚‚ã«éŒ²éŸ³ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‚’è¿”ã™ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ã¨ã—ã¦URLã‚’è¿”ã™ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚éåŒæœŸãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦æˆ»ã‚Šå€¤ã‚’URLã«ã™ã‚‹ã“ã¨ã§ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ä½¿ã‚ãšã«URLã‚’æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸‹ã¯ãã®å®Ÿè£…ä¾‹ã§ã™ï¼š

```swift
public final class RecordingDriver: RecordingDriverProtocol {
    private nonisolated(unsafe) var audioRecorder: AVAudioRecorder?

    private nonisolated(unsafe) let isRecordingSubject = PassthroughSubject<Bool, Never>()
    public var isRecordingPublisher: AnyPublisher<Bool, Never> {
        isRecordingSubject.eraseToAnyPublisher()
    }

    /// second (s)
    private nonisolated(unsafe) let recordingTimeSubject = CurrentValueSubject<Int, Never>(0)
    public var recordingTimePublisher: AnyPublisher<Int, Never> {
        recordingTimeSubject.eraseToAnyPublisher()
    }

    /// Audio Power (0.0 - 1.0)
    private nonisolated(unsafe) var audioVolumeLevelSubject = CurrentValueSubject<Double, Never>(0.0)
    public var audioVolumeLevelPublisher: AnyPublisher<Double, Never> {
        audioVolumeLevelSubject.eraseToAnyPublisher()
    }

    // TODO: ã“ã®å®Ÿè£…ã¯ã‚ˆããªã„ãŒæ¤œè¨¼ã‚³ãƒ¼ãƒ‰ãªã®ã§ãã†ã—ã¦ã„ã‚‹ã ã‘ã§ã‚ã‚Šã€ã„ã¤ã‹å‰Šé™¤ã™ã‚‹
    private nonisolated(unsafe) var isEnabledAudioSessionCache: Bool = false

    private nonisolated(unsafe) var recordingTimer = Set<AnyCancellable>()
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()

    private nonisolated(unsafe) var meteringTimerInterval: TimeInterval = 0.05

    public init() {}

    public func setMeteringTimerInterval(interval: TimeInterval) {
        meteringTimerInterval = interval
    }

    public func startRecording(recordingConfig: RecordingConfig) async throws {
        let recordingURL = recordingConfig.url ?? Constants.FilePath.audioDirectory
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue,
        ]

        await SystemSoundStaticDriver.play(systemSoundType: .startRecording)

        isEnabledAudioSessionCache = recordingConfig.isEnabledAudioSession
        if recordingConfig.isEnabledAudioSession {
            try AVAudioSession.sharedInstance().setCategory(
                recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
                mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
                options: []
            )
            OSLogger.debugLog("Start: session active")
            try AVAudioSession.sharedInstance().setActive(true)
            OSLogger.debugLog("Completed: session active")
        }

        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: recordingURL, settings: settings)
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()

        // ä¸Šè¨˜ã¾ã§ã®å‡¦ç†ã¯ã‚¤ãƒ‹ã‚·ãƒ£ãƒ©ã‚¤ã‚¶ã§è¡Œã£ã¦ã‚‚è‰¯ã„ã‹ã‚‚ã—ã‚Œãªã„
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")

        startRecordingTimer()
        startMeteringTimer()
    }

    public func stopRecording() async throws -> URL? {
        guard let audioRecorder, audioRecorder.isRecording else {
            return nil
        }

        stopRecordingTimer()
        stopMeteringTimer()

        OSLogger.debugLog("Start: stop recording")
        audioRecorder.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        if isEnabledAudioSessionCache {
            OSLogger.debugLog("Start: session unactive")
            try AVAudioSession.sharedInstance().setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        }

        await SystemSoundStaticDriver.play(systemSoundType: .stopRecording)
        
        return audioRecorder.url
    }

    private func startRecordingTimer() {
        recordingTimeSubject.value = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTimeSubject.value += 1
            }
            .store(in: &recordingTimer)
    }

    private func stopRecordingTimer() {
        recordingTimer.forEach { $0.cancel() }
    }

    private func startMeteringTimer() {
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { [weak self] _ in
                guard let self else {
                    return nil
                }
                audioRecorder?.updateMeters()
                return AudioHelpStaticDriver.normalized(decibel: Double(audioRecorder?.averagePower(forChannel: 0) ?? -80))
            }
            .assign(to: \.value, on: audioVolumeLevelSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}
```

ã“ã®å¤‰æ›´ã«ã‚ˆã‚Šã€`stopRecording`ãƒ¡ã‚½ãƒƒãƒ‰ãŒéŒ²éŸ³ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã§ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ä½¿ç”¨ã›ãšã«ã€éŒ²éŸ³ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---
