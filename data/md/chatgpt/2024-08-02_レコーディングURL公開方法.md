# レコーディングURL公開方法

日付: 2024-08-02

---

## 👤 ユーザー
*2024/8/2 15:29:48*

レコーディングのurlをうまくDriver外でも扱えるようにしたい。

public final class RecordingDriver: RecordingDriverProtocol {
    private nonisolated(unsafe) var audioRecorder: AVAudioRecorder?

    private nonisolated(unsafe) let isRecordingSubject = PassthroughSubject&lt;Bool, Never&gt;()
    public var isRecordingPublisher: AnyPublisher&lt;Bool, Never&gt; {
        isRecordingSubject.eraseToAnyPublisher()
    }

    /// second (s)
    private nonisolated(unsafe) let recordingTimeSubject = CurrentValueSubject&lt;Int, Never&gt;(0)
    public var recordingTimePublisher: AnyPublisher&lt;Int, Never&gt; {
        recordingTimeSubject.eraseToAnyPublisher()
    }

    /// Audio Power (0.0 - 1.0)
    private nonisolated(unsafe) var audioVolumeLevelSubject = CurrentValueSubject&lt;Double, Never&gt;(0.0)
    public var audioVolumeLevelPublisher: AnyPublisher&lt;Double, Never&gt; {
        audioVolumeLevelSubject.eraseToAnyPublisher()
    }

    // TODO: この実装はよくないが検証コードなのでそうしているだけであり、いつか削除する
    private nonisolated(unsafe) var isEnabledAudioSessionCache: Bool = false

    private nonisolated(unsafe) var recordingTimer = Set&lt;AnyCancellable&gt;()
    private nonisolated(unsafe) var meteringTimer = Set&lt;AnyCancellable&gt;()

    private nonisolated(unsafe) var meteringTimerInterval: TimeInterval = 0.05

    public init() {}

    public func setMeteringTimerInterval(interval: TimeInterval) {
        meteringTimerInterval = interval
    }

    public func startRecording(recordingConfig: RecordingConfig) async throws {
        let audioFilename = Constants.FilePath.audioDirectory
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue,
        ]

        await SystemSoundStaticDriver.play(systemSoundType: .startRecording)

        isEnabledAudioSessionCache = recordingConfig.isEnabledAudioSession
        if recordingConfig.isEnabledAudioSession {
            try AVAudioSession.sharedInstance().setCategory(
                recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
                mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
                options: []
            )
            OSLogger.debugLog("Start: session active")
            try AVAudioSession.sharedInstance().setActive(true)
            OSLogger.debugLog("Completed: session active")
        }

        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()

        // 上記までの処理はイニシャライザで行っても良いかもしれない
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")

        startRecordingTimer()
        startMeteringTimer()
    }

    public func stopRecording() async throws {
        guard let audioRecorder, audioRecorder.isRecording else {
            return
        }

        stopRecordingTimer()
        stopMeteringTimer()

        OSLogger.debugLog("Start: stop recording")
        audioRecorder.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        if isEnabledAudioSessionCache {
            OSLogger.debugLog("Start: session unactive")
            try AVAudioSession.sharedInstance().setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        }

        await SystemSoundStaticDriver.play(systemSoundType: .stopRecording)
    }

    private func startRecordingTimer() {
        recordingTimeSubject.value = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTimeSubject.value += 1
            }
            .store(in: &recordingTimer)
    }

    private func stopRecordingTimer() {
        recordingTimer.forEach { $0.cancel() }
    }

    private func startMeteringTimer() {
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { [weak self] _ in
                guard let self else {
                    return nil
                }
                audioRecorder?.updateMeters()
                return AudioHelpStaticDriver.normalized(decibel: Double(audioRecorder?.averagePower(forChannel: 0) ?? -80))
            }
            .assign(to: \.value, on: audioVolumeLevelSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}

---

## 🤖 アシスタント
*2024/8/2 15:29:58*

レコーディングのURLをDriver外でも扱えるようにするために、次の変更を行います。

1. URLを公開プロパティとして提供する。
2. レコーディング開始時にこのURLを設定する。

以下のように実装を更新します：

```swift
public final class RecordingDriver: RecordingDriverProtocol {
    private nonisolated(unsafe) var audioRecorder: AVAudioRecorder?

    private nonisolated(unsafe) let isRecordingSubject = PassthroughSubject<Bool, Never>()
    public var isRecordingPublisher: AnyPublisher<Bool, Never> {
        isRecordingSubject.eraseToAnyPublisher()
    }

    /// second (s)
    private nonisolated(unsafe) let recordingTimeSubject = CurrentValueSubject<Int, Never>(0)
    public var recordingTimePublisher: AnyPublisher<Int, Never> {
        recordingTimeSubject.eraseToAnyPublisher()
    }

    /// Audio Power (0.0 - 1.0)
    private nonisolated(unsafe) var audioVolumeLevelSubject = CurrentValueSubject<Double, Never>(0.0)
    public var audioVolumeLevelPublisher: AnyPublisher<Double, Never> {
        audioVolumeLevelSubject.eraseToAnyPublisher()
    }

    // TODO: この実装はよくないが検証コードなのでそうしているだけであり、いつか削除する
    private nonisolated(unsafe) var isEnabledAudioSessionCache: Bool = false

    private nonisolated(unsafe) var recordingTimer = Set<AnyCancellable>()
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()

    private nonisolated(unsafe) var meteringTimerInterval: TimeInterval = 0.05
    
    public private(set) var recordingURL: URL?

    public init() {}

    public func setMeteringTimerInterval(interval: TimeInterval) {
        meteringTimerInterval = interval
    }

    public func startRecording(recordingConfig: RecordingConfig) async throws {
        recordingURL = Constants.FilePath.audioDirectory
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue,
        ]

        await SystemSoundStaticDriver.play(systemSoundType: .startRecording)

        isEnabledAudioSessionCache = recordingConfig.isEnabledAudioSession
        if recordingConfig.isEnabledAudioSession {
            try AVAudioSession.sharedInstance().setCategory(
                recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
                mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
                options: []
            )
            OSLogger.debugLog("Start: session active")
            try AVAudioSession.sharedInstance().setActive(true)
            OSLogger.debugLog("Completed: session active")
        }

        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: recordingURL!, settings: settings)
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()

        // 上記までの処理はイニシャライザで行っても良いかもしれない
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")

        startRecordingTimer()
        startMeteringTimer()
    }

    public func stopRecording() async throws {
        guard let audioRecorder, audioRecorder.isRecording else {
            return
        }

        stopRecordingTimer()
        stopMeteringTimer()

        OSLogger.debugLog("Start: stop recording")
        audioRecorder.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        if isEnabledAudioSessionCache {
            OSLogger.debugLog("Start: session unactive")
            try AVAudioSession.sharedInstance().setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        }

        await SystemSoundStaticDriver.play(systemSoundType: .stopRecording)
    }

    private func startRecordingTimer() {
        recordingTimeSubject.value = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTimeSubject.value += 1
            }
            .store(in: &recordingTimer)
    }

    private func stopRecordingTimer() {
        recordingTimer.forEach { $0.cancel() }
    }

    private func startMeteringTimer() {
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { [weak self] _ in
                guard let self else {
                    return nil
                }
                audioRecorder?.updateMeters()
                return AudioHelpStaticDriver.normalized(decibel: Double(audioRecorder?.averagePower(forChannel: 0) ?? -80))
            }
            .assign(to: \.value, on: audioVolumeLevelSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}
```

この変更により、`RecordingDriver`クラス外からも録音されたファイルのURLにアクセスできるようになります。`recordingURL`プロパティは公開されているため、外部から簡単にアクセス可能です。

---

## 👤 ユーザー
*2024/8/2 15:30:36*

startRecording のときの引数に渡すのはどう？

---

## 🤖 アシスタント
*2024/8/2 15:31:08*

`startRecording`メソッドの引数としてURLを渡すことで、外部からURLを指定できるようにすることも可能です。その方法を以下に示します。

まず、`RecordingConfig`に`URL`プロパティを追加し、URLを指定できるようにします。

```swift
public struct RecordingConfig {
    // 他のプロパティ
    var url: URL?
    // 初期化
    public init(
        // 他のパラメータ
        url: URL? = nil
    ) {
        // 他のプロパティの初期化
        self.url = url
    }
}
```

次に、`startRecording`メソッドでこのURLを利用します。渡されたURLがnilの場合はデフォルトのURLを生成します。

```swift
public final class RecordingDriver: RecordingDriverProtocol {
    private nonisolated(unsafe) var audioRecorder: AVAudioRecorder?

    private nonisolated(unsafe) let isRecordingSubject = PassthroughSubject<Bool, Never>()
    public var isRecordingPublisher: AnyPublisher<Bool, Never> {
        isRecordingSubject.eraseToAnyPublisher()
    }

    /// second (s)
    private nonisolated(unsafe) let recordingTimeSubject = CurrentValueSubject<Int, Never>(0)
    public var recordingTimePublisher: AnyPublisher<Int, Never> {
        recordingTimeSubject.eraseToAnyPublisher()
    }

    /// Audio Power (0.0 - 1.0)
    private nonisolated(unsafe) var audioVolumeLevelSubject = CurrentValueSubject<Double, Never>(0.0)
    public var audioVolumeLevelPublisher: AnyPublisher<Double, Never> {
        audioVolumeLevelSubject.eraseToAnyPublisher()
    }

    // TODO: この実装はよくないが検証コードなのでそうしているだけであり、いつか削除する
    private nonisolated(unsafe) var isEnabledAudioSessionCache: Bool = false

    private nonisolated(unsafe) var recordingTimer = Set<AnyCancellable>()
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()

    private nonisolated(unsafe) var meteringTimerInterval: TimeInterval = 0.05
    
    public private(set) var recordingURL: URL?

    public init() {}

    public func setMeteringTimerInterval(interval: TimeInterval) {
        meteringTimerInterval = interval
    }

    public func startRecording(recordingConfig: RecordingConfig) async throws {
        recordingURL = recordingConfig.url ?? Constants.FilePath.audioDirectory
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue,
        ]

        await SystemSoundStaticDriver.play(systemSoundType: .startRecording)

        isEnabledAudioSessionCache = recordingConfig.isEnabledAudioSession
        if recordingConfig.isEnabledAudioSession {
            try AVAudioSession.sharedInstance().setCategory(
                recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
                mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
                options: []
            )
            OSLogger.debugLog("Start: session active")
            try AVAudioSession.sharedInstance().setActive(true)
            OSLogger.debugLog("Completed: session active")
        }

        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: recordingURL!, settings: settings)
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()

        // 上記までの処理はイニシャライザで行っても良いかもしれない
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")

        startRecordingTimer()
        startMeteringTimer()
    }

    public func stopRecording() async throws {
        guard let audioRecorder, audioRecorder.isRecording else {
            return
        }

        stopRecordingTimer()
        stopMeteringTimer()

        OSLogger.debugLog("Start: stop recording")
        audioRecorder.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        if isEnabledAudioSessionCache {
            OSLogger.debugLog("Start: session unactive")
            try AVAudioSession.sharedInstance().setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        }

        await SystemSoundStaticDriver.play(systemSoundType: .stopRecording)
    }

    private func startRecordingTimer() {
        recordingTimeSubject.value = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTimeSubject.value += 1
            }
            .store(in: &recordingTimer)
    }

    private func stopRecordingTimer() {
        recordingTimer.forEach { $0.cancel() }
    }

    private func startMeteringTimer() {
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { [weak self] _ in
                guard let self else {
                    return nil
                }
                audioRecorder?.updateMeters()
                return AudioHelpStaticDriver.normalized(decibel: Double(audioRecorder?.averagePower(forChannel: 0) ?? -80))
            }
            .assign(to: \.value, on: audioVolumeLevelSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}
```

この変更により、`startRecording`メソッドに渡された`RecordingConfig`にURLが含まれている場合、そのURLを使用して録音を開始します。URLが指定されていない場合は、デフォルトのURLを生成します。これにより、外部からURLを指定して録音を開始できるようになります。

---

## 👤 ユーザー
*2024/8/2 15:41:56*

stopRecording() でURLを返すことはできないのか？グローバル変数を使わない方法がベストである

---

## 🤖 アシスタント
*2024/8/2 15:42:25*

`stopRecording`メソッドで録音の停止とともに録音されたファイルのURLを返すようにするためには、メソッドの戻り値としてURLを返すように変更します。非同期メソッドとして戻り値をURLにすることで、グローバル変数を使わずにURLを扱うことができます。

以下はその実装例です：

```swift
public final class RecordingDriver: RecordingDriverProtocol {
    private nonisolated(unsafe) var audioRecorder: AVAudioRecorder?

    private nonisolated(unsafe) let isRecordingSubject = PassthroughSubject<Bool, Never>()
    public var isRecordingPublisher: AnyPublisher<Bool, Never> {
        isRecordingSubject.eraseToAnyPublisher()
    }

    /// second (s)
    private nonisolated(unsafe) let recordingTimeSubject = CurrentValueSubject<Int, Never>(0)
    public var recordingTimePublisher: AnyPublisher<Int, Never> {
        recordingTimeSubject.eraseToAnyPublisher()
    }

    /// Audio Power (0.0 - 1.0)
    private nonisolated(unsafe) var audioVolumeLevelSubject = CurrentValueSubject<Double, Never>(0.0)
    public var audioVolumeLevelPublisher: AnyPublisher<Double, Never> {
        audioVolumeLevelSubject.eraseToAnyPublisher()
    }

    // TODO: この実装はよくないが検証コードなのでそうしているだけであり、いつか削除する
    private nonisolated(unsafe) var isEnabledAudioSessionCache: Bool = false

    private nonisolated(unsafe) var recordingTimer = Set<AnyCancellable>()
    private nonisolated(unsafe) var meteringTimer = Set<AnyCancellable>()

    private nonisolated(unsafe) var meteringTimerInterval: TimeInterval = 0.05

    public init() {}

    public func setMeteringTimerInterval(interval: TimeInterval) {
        meteringTimerInterval = interval
    }

    public func startRecording(recordingConfig: RecordingConfig) async throws {
        let recordingURL = recordingConfig.url ?? Constants.FilePath.audioDirectory
            .appendingPathComponent("\(Date.ios8601)")
            .appendingPathExtension(recordingConfig.audioFormat.fileExtension.rawValue)

        let settings = [
            AVFormatIDKey: Int(recordingConfig.audioFormat.audioFormatID),
            AVSampleRateKey: recordingConfig.audioSampleRate.rawValue,
            AVNumberOfChannelsKey: recordingConfig.audioChannel.rawValue,
            AVEncoderAudioQualityKey: recordingConfig.audioEncodeQuality.toAVAudioQuality.rawValue,
        ]

        await SystemSoundStaticDriver.play(systemSoundType: .startRecording)

        isEnabledAudioSessionCache = recordingConfig.isEnabledAudioSession
        if recordingConfig.isEnabledAudioSession {
            try AVAudioSession.sharedInstance().setCategory(
                recordingConfig.audioSessionCategory.toAVAudioSessionCategory,
                mode: recordingConfig.audioSessionMode.toAVAudioSessionMode,
                options: []
            )
            OSLogger.debugLog("Start: session active")
            try AVAudioSession.sharedInstance().setActive(true)
            OSLogger.debugLog("Completed: session active")
        }

        OSLogger.debugLog("Start: start recording")
        audioRecorder = try AVAudioRecorder(url: recordingURL, settings: settings)
        audioRecorder?.isMeteringEnabled = true
        audioRecorder?.prepareToRecord()

        // 上記までの処理はイニシャライザで行っても良いかもしれない
        audioRecorder?.record()
        isRecordingSubject.send(true)
        OSLogger.debugLog("Start: start recording")

        startRecordingTimer()
        startMeteringTimer()
    }

    public func stopRecording() async throws -> URL? {
        guard let audioRecorder, audioRecorder.isRecording else {
            return nil
        }

        stopRecordingTimer()
        stopMeteringTimer()

        OSLogger.debugLog("Start: stop recording")
        audioRecorder.stop()
        isRecordingSubject.send(false)
        OSLogger.debugLog("Completed: stop recording")

        if isEnabledAudioSessionCache {
            OSLogger.debugLog("Start: session unactive")
            try AVAudioSession.sharedInstance().setActive(false)
            OSLogger.debugLog("Completed: session unactive")
        }

        await SystemSoundStaticDriver.play(systemSoundType: .stopRecording)
        
        return audioRecorder.url
    }

    private func startRecordingTimer() {
        recordingTimeSubject.value = 0

        Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                self?.recordingTimeSubject.value += 1
            }
            .store(in: &recordingTimer)
    }

    private func stopRecordingTimer() {
        recordingTimer.forEach { $0.cancel() }
    }

    private func startMeteringTimer() {
        Timer.publish(every: meteringTimerInterval, on: .main, in: .common).autoconnect()
            .compactMap { [weak self] _ in
                guard let self else {
                    return nil
                }
                audioRecorder?.updateMeters()
                return AudioHelpStaticDriver.normalized(decibel: Double(audioRecorder?.averagePower(forChannel: 0) ?? -80))
            }
            .assign(to: \.value, on: audioVolumeLevelSubject)
            .store(in: &meteringTimer)
    }

    private func stopMeteringTimer() {
        meteringTimer.forEach { $0.cancel() }
    }
}
```

この変更により、`stopRecording`メソッドが録音されたファイルのURLを返すようになります。これでグローバル変数を使用せずに、録音されたファイルのURLを取得することができます。

---
