# Flutter ナビゲーション テキスト編集

日付: 2025-01-06

---

## 👤 ユーザー
*2025/1/6 18:24:35*

{
  "content_type": "image_asset_pointer",
  "asset_pointer": "file-service://file-L21pobaUmhvmaP99vWMQ5B",
  "size_bytes": 69080,
  "width": 629,
  "height": 579,
  "fovea": null,
  "metadata": {
    "dalle": null,
    "gizmo": null,
    "generation": null,
    "container_pixel_height": null,
    "container_pixel_width": null,
    "emu_omit_glimpse_image": null,
    "emu_patches_override": null,
    "sanitized": true,
    "asset_pointer_link": null,
    "watermarked_asset_pointer": null
  }
}
このような画面でFlutterにてナビゲーション遷移させてテキスト編集するような画面を実装するにはどんなコンポーネントを使うのが簡単か？

---

## 🤖 アシスタント
*2025/1/6 18:25:15*

Flutterでこのような画面を実装する場合、ナビゲーション遷移やテキスト編集のために以下のコンポーネントや設計を使用すると簡単に実現できます：

---

### **ナビゲーション遷移**
1. **`Navigator`**:
   - Flutterの標準的なナビゲーション機能を使用します。  
   - 遷移する際には`Navigator.push`で新しい画面を表示します。
   - 例:
     ```dart
     Navigator.push(
       context,
       MaterialPageRoute(builder: (context) => EditNameScreen(name: currentName)),
     );
     ```

2. **`GoRouter` (推奨)**:
   - 大規模アプリの場合、`go_router`を使用するとルート管理が簡単になります。
   - 例:
     ```dart
     GoRouter(
       routes: [
         GoRoute(
           path: '/edit-name',
           builder: (context, state) {
             final name = state.queryParameters['name'] ?? '';
             return EditNameScreen(name: name);
           },
         ),
       ],
     );
     ```

---

### **テキスト編集画面**
1. **`TextField`**:
   - ユーザー入力用に`TextField`を使用します。
   - プレースホルダーは`decoration`で設定可能。
   - 例:
     ```dart
     TextField(
       controller: _controller,
       decoration: InputDecoration(
         labelText: 'Name',
         border: UnderlineInputBorder(),
       ),
     );
     ```

2. **`TextEditingController`**:
   - 入力内容を管理するために利用します。
   - 例:
     ```dart
     final TextEditingController _controller = TextEditingController(text: initialName);
     ```

3. **`ElevatedButton`**:
   - 「保存」ボタンには`ElevatedButton`を使用します。
   - 例:
     ```dart
     ElevatedButton(
       onPressed: () {
         // 保存処理
         Navigator.pop(context, _controller.text);
       },
       child: Text('Save'),
     );
     ```

---

### **全体構成の例**
以下は、ナビゲーションとテキスト編集を統合した例です。

```dart
import 'package:flutter/material.dart';

class GuildManagementScreen extends StatelessWidget {
  final String guildName = "SNPT Guild";

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Guild Management')),
      body: ListTile(
        title: Text(guildName),
        trailing: Icon(Icons.chevron_right),
        onTap: () async {
          final newName = await Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => EditNameScreen(name: guildName),
            ),
          );
          if (newName != null) {
            // 新しい名前を保存する処理
            print('New Name: $newName');
          }
        },
      ),
    );
  }
}

class EditNameScreen extends StatelessWidget {
  final String name;

  EditNameScreen({required this.name});

  @override
  Widget build(BuildContext context) {
    final TextEditingController _controller = TextEditingController(text: name);

    return Scaffold(
      appBar: AppBar(
        title: Text('Edit Name'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context, _controller.text);
            },
            child: Text('Save', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TextField(
          controller: _controller,
          decoration: InputDecoration(
            labelText: 'Name',
            border: UnderlineInputBorder(),
          ),
        ),
      ),
    );
  }
}

void main() => runApp(MaterialApp(home: GuildManagementScreen()));
```

---

### **解説**
1. **ナビゲーション**:
   - `GuildManagementScreen`でタップすると`EditNameScreen`に遷移します。
2. **名前編集**:
   - `TextField`を使って名前を編集し、「保存」で結果を`Navigator.pop`で返します。
3. **使いやすさ**:
   - この実装では最小限のコードでシンプルに目的を達成できます。

他に質問があればお気軽にどうぞ！

---

## 👤 ユーザー
*2025/1/6 18:25:43*

HooksやRiverpod annotationを使って実装してほしい。ライブラリは導入済みである

---

## 🤖 アシスタント
*2025/1/6 18:26:17*

以下は、**Hooks**と**Riverpodのannotation**を使用して実装する例です。  
`flutter_hooks`と`riverpod_annotation`を活用することで、状態管理や依存性注入を簡潔に行えます。

---

### **フルコード例**
以下は`Hooks`と`Riverpod annotation`を使用した実装です。

#### **RiverpodのState管理**
`guild_provider.dart`
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'guild_provider.g.dart';

// ギルド名の状態管理
@riverpod
class GuildName extends _$GuildName {
  @override
  String build() => "SNPT Guild";

  void update(String newName) {
    state = newName;
  }
}
```

---

#### **Guild Management Screen**
ギルド名を表示し、編集画面に遷移する画面です。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'guild_provider.dart';

class GuildManagementScreen extends HookConsumerWidget {
  const GuildManagementScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final guildName = ref.watch(guildNameProvider); // ギルド名を取得

    return Scaffold(
      appBar: AppBar(title: const Text('Guild Management')),
      body: ListTile(
        title: Text(guildName),
        trailing: const Icon(Icons.chevron_right),
        onTap: () async {
          // 名前編集画面に遷移し、新しい名前を取得
          final newName = await Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => const EditNameScreen(),
            ),
          );
          if (newName != null && newName is String) {
            // Riverpodで状態を更新
            ref.read(guildNameProvider.notifier).update(newName);
          }
        },
      ),
    );
  }
}
```

---

#### **Edit Name Screen**
名前を編集するための画面です。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';

class EditNameScreen extends HookWidget {
  const EditNameScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final textController = useTextEditingController(); // Hookでコントローラーを管理

    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Name'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context, textController.text); // 入力値を返す
            },
            child: const Text(
              'Save',
              style: TextStyle(color: Colors.white),
            ),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TextField(
          controller: textController,
          decoration: const InputDecoration(
            labelText: 'Name',
            border: UnderlineInputBorder(),
          ),
        ),
      ),
    );
  }
}
```

---

### **主要ポイント**
1. **Riverpod AnnotationでState管理**:
   - `GuildName`クラスを`@riverpod`でラップして自動的にプロバイダを生成しています。
   - `guildNameProvider`を通じて、`GuildName`を参照・更新可能。

2. **Flutter HooksでWidgetの状態を管理**:
   - `useTextEditingController`を使用して、`TextField`の状態管理を簡潔に実装。
   - Hookを活用することで、`StatefulWidget`を使わずに状態を管理できます。

3. **簡潔なリビルド管理**:
   - `ref.watch()`で状態を監視し、自動的にリビルドします。
   - 更新は`ref.read().update()`で行います。

---

### **必要な依存関係**
`pubspec.yaml`に以下を追加します。

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_hooks: ^0.18.0
  hooks_riverpod: ^2.0.3

dev_dependencies:
  riverpod_annotation: ^2.0.0
  build_runner: ^2.4.0
```

---

### **まとめ**
この実装では、Riverpodのannotationを使った状態管理と、Hooksによる簡潔なUI状態管理が可能です。これにより、冗長なコードを減らし、メンテナンス性の高いアーキテクチャを実現できます。

---

## 👤 ユーザー
*2025/1/6 18:27:31*

他の画面でも使いたいため一般的なテキスト編集画面としたい。
タイトルとタップ時の処理を外側で設定できるようにしたい。（apiをコールしたりしたいため）

---

## 🤖 アシスタント
*2025/1/6 18:28:15*

一般的なテキスト編集画面として再利用できるようにするには、**タイトル**や**タップ時の処理（コールバック）**を外側で設定できるように設計します。このような仕組みを導入すれば、APIコールや状態管理のロジックを柔軟に外部で管理できます。

以下のように設計・実装します。

---

### **Reusable Text Editing Screen**

汎用的なテキスト編集画面を実装します。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';

class TextEditingScreen extends HookWidget {
  final String title; // 画面タイトル
  final String initialText; // 初期テキスト
  final void Function(String updatedText) onSave; // 保存時のコールバック

  const TextEditingScreen({
    Key? key,
    required this.title,
    required this.initialText,
    required this.onSave,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final textController = useTextEditingController(text: initialText);

    return Scaffold(
      appBar: AppBar(
        title: Text(title),
        actions: [
          TextButton(
            onPressed: () {
              final updatedText = textController.text;
              onSave(updatedText); // 保存処理を外部で実行
              Navigator.pop(context); // 画面を閉じる
            },
            child: const Text(
              'Save',
              style: TextStyle(color: Colors.white),
            ),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TextField(
          controller: textController,
          decoration: const InputDecoration(
            labelText: 'Edit Text',
            border: UnderlineInputBorder(),
          ),
        ),
      ),
    );
  }
}
```

---

### **画面での利用例**

以下の例では、ギルド名を編集するために汎用的な`TextEditingScreen`を利用します。  
**APIコール**や**状態の更新**は外部で定義できます。

#### **Guild Management Screen**

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'guild_provider.dart';
import 'text_editing_screen.dart';

class GuildManagementScreen extends ConsumerWidget {
  const GuildManagementScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final guildName = ref.watch(guildNameProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('Guild Management')),
      body: ListTile(
        title: Text(guildName),
        trailing: const Icon(Icons.chevron_right),
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => TextEditingScreen(
                title: 'Edit Guild Name',
                initialText: guildName,
                onSave: (updatedText) {
                  // 状態の更新処理
                  ref.read(guildNameProvider.notifier).update(updatedText);

                  // APIコール例
                  _updateGuildNameApi(updatedText);
                },
              ),
            ),
          );
        },
      ),
    );
  }

  // APIコール例
  Future<void> _updateGuildNameApi(String newName) async {
    // ここでAPIリクエストを送信
    print('API call to update guild name: $newName');
  }
}
```

---

### **他の画面での利用例**

#### **プロフィール名編集画面**

`ProfileScreen`で別のデータを編集する例です。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'text_editing_screen.dart';

final profileNameProvider = StateProvider<String>((ref) => 'John Doe');

class ProfileScreen extends ConsumerWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final profileName = ref.watch(profileNameProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: ListTile(
        title: Text(profileName),
        trailing: const Icon(Icons.chevron_right),
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => TextEditingScreen(
                title: 'Edit Profile Name',
                initialText: profileName,
                onSave: (updatedText) {
                  // 状態の更新
                  ref.read(profileNameProvider.notifier).state = updatedText;

                  // APIコール例
                  _updateProfileNameApi(updatedText);
                },
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _updateProfileNameApi(String newName) async {
    // ここでAPIリクエストを送信
    print('API call to update profile name: $newName');
  }
}
```

---

### **メリット**

1. **汎用性**:
   - `TextEditingScreen`は、タイトルや初期値、保存時の処理を引数で指定できるため、複数の画面で再利用可能。

2. **外部での状態管理・APIコール**:
   - `onSave`を通じて外部で状態やAPIコールの処理を柔軟に定義可能。

3. **シンプルな実装**:
   - `TextEditingScreen`のロジックはシンプルで、状態管理は外部で行うため、再利用性が高い。

---

### **依存関係**
- `flutter_hooks` (状態管理用)
- `riverpod_annotation` (状態管理用)

`pubspec.yaml`:
```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_hooks: ^0.18.0
  hooks_riverpod: ^2.0.3

dev_dependencies:
  riverpod_annotation: ^2.0.0
  build_runner: ^2.4.0
```

---

この設計で他の画面でも柔軟に利用できるようになります。他に質問があれば教えてください！

---
