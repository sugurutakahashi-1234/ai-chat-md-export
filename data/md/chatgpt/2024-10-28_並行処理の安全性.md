# 並行処理の安全性

Date: 2024-10-28

---

## 👤 User
*2024-10-28 14:03:30*

エラーを日本語で

Reference to static property 'updateJWTTokenError' is not concurrency-safe because it involves shared mutable state

class ContentDebugViewModel: ObservableObject {
    init() {
        Notification.Name.updateJWTTokenError.addObserver(self, selector: #selector(handleUpdateJWTTokenError))
    }

    @objc func handleUpdateJWTTokenError() {
        print("handleUpdateJWTTokenError...")
    }
}

---

## 🤖 Assistant
*2024-10-28 14:03:43*

エラーメッセージは、静的プロパティ `'updateJWTTokenError'` にアクセスする際に、共有の可変状態に関与しているため、並行処理に安全ではないことを示しています。このため、並行処理に対応する形でのコードの修正が必要です。

以下は、並行処理に対応するための修正案です：

1. **`@MainActor` を使う**:  
   `ContentDebugViewModel` を `@MainActor` に指定することで、メインスレッドでの実行を保証し、並行処理の安全性を確保します。

```swift
@MainActor
class ContentDebugViewModel: ObservableObject {
    init() {
        Notification.Name.updateJWTTokenError.addObserver(self, selector: #selector(handleUpdateJWTTokenError))
    }

    @objc func handleUpdateJWTTokenError() {
        print("handleUpdateJWTTokenError...")
    }
}
```

2. **Swift Concurrencyを使用する**:  
   `NotificationCenter` の `addObserver` メソッドを非同期対応の `AsyncStream` や `async/await` を使って監視するように変更する方法もあります。

例えば：

```swift
import Combine

@MainActor
class ContentDebugViewModel: ObservableObject {
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        NotificationCenter.default.publisher(for: .updateJWTTokenError)
            .sink { [weak self] _ in
                self?.handleUpdateJWTTokenError()
            }
            .store(in: &cancellables)
    }

    private func handleUpdateJWTTokenError() {
        print("handleUpdateJWTTokenError...")
    }
}
```

このようにして、並行処理環境においても安全な形で通知を監視できます。

---
