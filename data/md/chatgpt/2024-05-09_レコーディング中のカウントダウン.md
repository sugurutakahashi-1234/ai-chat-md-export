# ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã®ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³

æ—¥ä»˜: 2024-05-09

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/9 18:39:31*

ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã®æ™‚é–“ã‚’ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã—ãŸã„ã€‚

//
//  Created by sugurutakahashi on 2024/05/02
//  Copyright Â© 2024 crage Inc. All rights reserved.
//

import SwiftUI

// MARK: - View

@MainActor
struct RecordingView: View {
    @StateObject private var presenter: RecordingPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            Section("Recording Config") {
                RecordingConfigPickerView(selection: $presenter.audioFormat)
                RecordingConfigPickerView(selection: $presenter.audioSampleRate)
                RecordingConfigPickerView(selection: $presenter.audioChannel)
                RecordingConfigPickerView(selection: $presenter.audioEncodeQuality)
            }
            .textCase(nil)
            
            Section("Session Config") {
                RecordingConfigPickerView(selection: $presenter.audioSessionCategory)
                RecordingConfigPickerView(selection: $presenter.audioSessionMode)
            }
            .textCase(nil)
            
            Section("Recording Action") {
                Button {
                    presenter.onTapStartRecording()
                } label: {
                    Text("Start Recording")
                }
                .disabled(presenter.isRecording)

                Button {
                    presenter.onTapStopRecording()
                } label: {
                    Text("Stop Recording")
                }
                .disabled(!presenter.isRecording)
            }
            .textCase(nil)
            
            Section("Audio List") {
                NavigationLink {
                    AudioListView()
                } label: {
                    Text("Audio List")
                }
            }
            .textCase(nil)
        }
        .navigationTitle("Recording")
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: false)
        .onAppear {
            presenter.onAppear()
        }
    }
}

// MARK: - Preview

#Preview {
    RecordingView()
        .navigationStacked()
}



import Foundation

@MainActor
final class RecordingPresenter: ObservableObject {
    @Published var audioFormat: AudioFormat = .mpeg4aac_acc
    @Published var audioSampleRate: AudioSampleRate = .voiceLow
    @Published var audioChannel: AudioChannel = .stereo
    @Published var audioEncodeQuality: AudioEncodeQuality = .low
    @Published var audioSessionCategory: AudioSessionCategory = .record
    @Published var audioSessionMode: AudioSessionMode = .default
    
    @Published var isRecording: Bool = false

    @Published var isLoading: Bool = false
    @Published var showAlert: Bool = false
    
    private let deviceAccessDriver: DeviceAccessDriver = DeviceAccessDriver()
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let recordingDriver: RecordingDriver = RecordingDriver()

    init() {
        recordingDriver.isRecordingPublisher
            .assign(to: &$isRecording)
    }

    func onAppear() {
        Task {
            await deviceAccessDriver.requestRecording()
        }
    }

    func onTapStartRecording() {
        let recordingConfig = RecordingConfig(audioFormat: audioFormat, audioSampleRate: audioSampleRate, audioChannel: audioChannel, audioEncodeQuality: audioEncodeQuality, audioSessionCategory: audioSessionCategory, audioSessionMode: audioSessionMode)
        do {
            try recordingDriver.startRecording(recordingConfig: recordingConfig)
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
             showAlert = true
        }
    }

    func onTapStopRecording() {
        do {
            try recordingDriver.stopRecording()
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            showAlert = true
        }
    }
}

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/9 18:40:42*

To add a countdown timer to your recording feature in the `RecordingView`, you can enhance your SwiftUI and ViewModel classes to manage and display the time remaining. Here is how you can do it:

1. **Add Timer Functionality to `RecordingPresenter`:** First, add properties to keep track of the recording duration and a timer to decrement this duration.

2. **Update UI to Display Countdown Timer:** Modify the `RecordingView` to show the remaining recording time.

### Step 1: Modify `RecordingPresenter`

```swift
import Combine
import Foundation

@MainActor
final class RecordingPresenter: ObservableObject {
    @Published var audioFormat: AudioFormat = .mpeg4aac_acc
    @Published var audioSampleRate: AudioSampleRate = .voiceLow
    @Published var audioChannel: AudioChannel = .stereo
    @Published var audioEncodeQuality: AudioEncodeQuality = .low
    @Published var audioSessionCategory: AudioSessionCategory = .record
    @Published var audioSessionMode: AudioSessionMode = .default
    
    @Published var isRecording: Bool = false
    @Published var countdownTime: Int = 0  // Remaining time in seconds
    @Published var isLoading: Bool = false
    @Published var showAlert: Bool = false
    
    private let deviceAccessDriver: DeviceAccessDriver = DeviceAccessDriver()
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let recordingDriver: RecordingDriver = RecordingDriver()
    private var recordingTimer: AnyCancellable?
    
    init() {
        recordingDriver.isRecordingPublisher
            .assign(to: &$isRecording)
    }
    
    func onAppear() {
        Task {
            await deviceAccessDriver.requestRecording()
        }
    }

    func onTapStartRecording() {
        let recordingConfig = RecordingConfig(audioFormat: audioFormat, audioSampleRate: audioSampleRate, audioChannel: audioChannel, audioEncodeQuality: audioEncodeQuality, audioSessionCategory: audioSessionCategory, audioSessionMode: audioSessionMode)
        do {
            try recordingDriver.startRecording(recordingConfig: recordingConfig)
            startTimer(duration: 60)  // Set desired countdown duration
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            showAlert = true
        }
    }

    func onTapStopRecording() {
        do {
            try recordingDriver.stopRecording()
            stopTimer()
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            showAlert = true
        }
    }
    
    private func startTimer(duration: Int) {
        countdownTime = duration
        recordingTimer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                guard let self = self else { return }
                if self.countdownTime > 0 {
                    self.countdownTime -= 1
                } else {
                    self.onTapStopRecording()
                }
            }
    }
    
    private func stopTimer() {
        recordingTimer?.cancel()
    }
}
```

### Step 2: Update `RecordingView`

```swift
import SwiftUI

@MainActor
struct RecordingView: View {
    @StateObject private var presenter: RecordingPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            Section("Recording Config") {
                RecordingConfigPickerView(selection: $presenter.audioFormat)
                RecordingConfigPickerView(selection: $presenter.audioSampleRate)
                RecordingConfigPickerView(selection: $presenter.audioChannel)
                RecordingConfigPickerView(selection: $presenter.audioEncodeQuality)
            }
            
            Section("Session Config") {
                RecordingConfigPickerView(selection: $presenter.audioSessionCategory)
                RecordingConfigPickerView(selection: $presenter.audioSessionMode)
            }
            
            Section("Recording Action") {
                Button {
                    presenter.onTapStartRecording()
                } label: {
                    Text("Start Recording")
                }
                .disabled(presenter.isRecording)

                Button {
                    presenter.onTapStopRecording()
                } label: {
                    Text("Stop Recording")
                }
                .disabled(!presenter.isRecording)
                
                if presenter.isRecording {
                    Text("Time Remaining: \(presenter.countdownTime)s")
                }
            }
            
            Section("Audio List") {
                NavigationLink {
                    AudioListView()
                } label: {
                    Text("Audio List")
                }
            }
        }
        .navigationTitle("Recording")
        .overlayLoading(isPresented: $presenter.isLoading, isGestureReactable: false)
        .onAppear {
            presenter.onAppear()
        }
    }
}
```

This setup now includes a countdown timer that starts when the recording starts and updates every second. If the timer runs out, the recording automatically stops. Adjust the `startTimer(duration: Int)`

---

## ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼
*2024/5/9 18:43:22*

ç´”ç²‹ã«éŒ²éŸ³æ™‚é–“ã‚’è¨ˆã‚ŠãŸã„ã ã‘ãªã‚“ã 

---

## ğŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ
*2024/5/9 18:44:18*

äº†è§£ã—ã¾ã—ãŸï¼éŒ²éŸ³æ™‚é–“ã‚’è¨ˆæ¸¬ã™ã‚‹ã ã‘ã®æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã«ã¯ã€éŒ²éŸ³ãŒé–‹å§‹ã•ã‚Œã¦ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’è¡¨ç¤ºã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã¡ã‚‰ã®ã‚·ãƒ³ãƒ—ãƒ«ãªå¤‰æ›´ã§å®Ÿç¾ã§ãã¾ã™ã€‚

### `RecordingPresenter` ã«çµŒéæ™‚é–“ã‚’è¿½è·¡ã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’è¿½åŠ 

```swift
import Combine
import Foundation

@MainActor
final class RecordingPresenter: ObservableObject {
    @Published var audioFormat: AudioFormat = .mpeg4aac_acc
    @Published var audioSampleRate: AudioSampleRate = .voiceLow
    @Published var audioChannel: AudioChannel = .stereo
    @Published var audioEncodeQuality: AudioEncodeQuality = .low
    @Published var audioSessionCategory: AudioSessionCategory = .record
    @Published var audioSessionMode: AudioSessionMode = .default
    
    @Published var isRecording: Bool = false
    @Published var recordingTime: Int = 0  // çµŒéæ™‚é–“ï¼ˆç§’ï¼‰
    @Published var isLoading: Bool = false
    @Published var showAlert: Bool = false
    
    private let deviceAccessDriver: DeviceAccessDriver = DeviceAccessDriver()
    private let fileManageDriver: FileManageDriver = FileManageDriver()
    private let recordingDriver: RecordingDriver = RecordingDriver()
    private var recordingTimer: AnyCancellable?
    
    init() {
        recordingDriver.isRecordingPublisher
            .assign(to: &$isRecording)
    }
    
    func onAppear() {
        Task {
            await deviceAccessDriver.requestRecording()
        }
    }

    func onTapStartRecording() {
        let recordingConfig = RecordingConfig(audioFormat: audioFormat, audioSampleRate: audioSampleRate, audioChannel: audioChannel, audioEncodeQuality: audioEncodeQuality, audioSessionCategory: audioSessionCategory, audioSessionMode: audioSessionMode)
        do {
            try recordingDriver.startRecording(recordingConfig: recordingConfig)
            startRecordingTimer()
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            showAlert = true
        }
    }

    func onTapStopRecording() {
        do {
            try recordingDriver.stopRecording()
            stopRecordingTimer()
        } catch {
            OSLogger.errorLog("Could not start recording: \(error)")
            showAlert = true
        }
    }
    
    private func startRecordingTimer() {
        recordingTime = 0
        recordingTimer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
            .sink { [weak self] _ in
                guard let self = self else { return }
                self.recordingTime += 1
            }
    }
    
    private func stopRecordingTimer() {
        recordingTimer?.cancel()
    }
}
```

### `RecordingView` ã«çµŒéæ™‚é–“ã‚’è¡¨ç¤ºã™ã‚‹æ©Ÿèƒ½ã‚’è¿½åŠ 

```swift
import SwiftUI

@MainActor
struct RecordingView: View {
    @StateObject private var presenter: RecordingPresenter

    init() {
        _presenter = .init(wrappedValue: .init())
    }

    var body: some View {
        List {
            // Config Sections...
            
            Section("Recording Action") {
                Button {
                    presenter.onTapStartRecording()
                } label: {
                    Text("Start Recording")
                }
                .disabled(presenter.isRecording)

                Button {
                    presenter.onTapStopRecording()
                } label: {
                    Text("Stop Recording")
                }
                .disabled(!presenter.isRecording)

                if presenter.isRecording {
                    Text("Recording Time: \(presenter.recordingTime)s")
                }
            }

            // Audio List Section...
        }
        .navigationTitle("Recording")
        .onAppear {
            presenter.onAppear()
        }
    }
}
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯éŒ²éŸ³ãŒé–‹å§‹ã•ã‚Œã‚‹ã¨ã‚¿ã‚¤ãƒãƒ¼ã‚’èµ·å‹•ã—ã€1ç§’ã”ã¨ã«çµŒéæ™‚é–“ã‚’æ›´æ–°ã—ã¦ç”»é¢ã«è¡¨ç¤ºã—ã¾ã™ã€‚éŒ²éŸ³ãŒåœæ­¢ã•ã‚Œã‚‹ã¨ã€ã‚¿ã‚¤ãƒãƒ¼ã‚‚åœæ­¢ã—ã¾ã™ã€‚

---
